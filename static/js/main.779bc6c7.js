/*! For license information please see main.779bc6c7.js.LICENSE.txt */
(()=>{var e={7291:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=7291,e.exports=t},3803:(e,t,n)=>{"use strict";n.d(t,{A:()=>ae});var r=function(){function e(e){var t=this;this._insertTag=function(e){var n;n=0===t.tags.length?t.insertionPoint?t.insertionPoint.nextSibling:t.prepend?t.container.firstChild:t.before:t.tags[t.tags.length-1].nextSibling,t.container.insertBefore(e,n),t.tags.push(e)},this.isSpeedy=void 0===e.speedy||e.speedy,this.tags=[],this.ctr=0,this.nonce=e.nonce,this.key=e.key,this.container=e.container,this.prepend=e.prepend,this.insertionPoint=e.insertionPoint,this.before=null}var t=e.prototype;return t.hydrate=function(e){e.forEach(this._insertTag)},t.insert=function(e){this.ctr%(this.isSpeedy?65e3:1)===0&&this._insertTag(function(e){var t=document.createElement("style");return t.setAttribute("data-emotion",e.key),void 0!==e.nonce&&t.setAttribute("nonce",e.nonce),t.appendChild(document.createTextNode("")),t.setAttribute("data-s",""),t}(this));var t=this.tags[this.tags.length-1];if(this.isSpeedy){var n=function(e){if(e.sheet)return e.sheet;for(var t=0;t<document.styleSheets.length;t++)if(document.styleSheets[t].ownerNode===e)return document.styleSheets[t]}(t);try{n.insertRule(e,n.cssRules.length)}catch(r){}}else t.appendChild(document.createTextNode(e));this.ctr++},t.flush=function(){this.tags.forEach((function(e){var t;return null==(t=e.parentNode)?void 0:t.removeChild(e)})),this.tags=[],this.ctr=0},e}(),a=Math.abs,s=String.fromCharCode,i=Object.assign;function o(e){return e.trim()}function l(e,t,n){return e.replace(t,n)}function u(e,t){return e.indexOf(t)}function c(e,t){return 0|e.charCodeAt(t)}function d(e,t,n){return e.slice(t,n)}function h(e){return e.length}function p(e){return e.length}function f(e,t){return t.push(e),e}var m=1,g=1,y=0,b=0,v=0,x="";function w(e,t,n,r,a,s,i){return{value:e,root:t,parent:n,type:r,props:a,children:s,line:m,column:g,length:i,return:""}}function k(e,t){return i(w("",null,null,"",null,null,0),e,{length:-e.length},t)}function S(){return v=b>0?c(x,--b):0,g--,10===v&&(g=1,m--),v}function I(){return v=b<y?c(x,b++):0,g++,10===v&&(g=1,m++),v}function C(){return c(x,b)}function N(){return b}function T(e,t){return d(x,e,t)}function E(e){switch(e){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function A(e){return m=g=1,y=h(x=e),b=0,[]}function _(e){return x="",e}function $(e){return o(T(b-1,M(91===e?e+2:40===e?e+1:e)))}function R(e){for(;(v=C())&&v<33;)I();return E(e)>2||E(v)>3?"":" "}function D(e,t){for(;--t&&I()&&!(v<48||v>102||v>57&&v<65||v>70&&v<97););return T(e,N()+(t<6&&32==C()&&32==I()))}function M(e){for(;I();)switch(v){case e:return b;case 34:case 39:34!==e&&39!==e&&M(v);break;case 40:41===e&&M(e);break;case 92:I()}return b}function F(e,t){for(;I()&&e+v!==57&&(e+v!==84||47!==C()););return"/*"+T(t,b-1)+"*"+s(47===e?e:I())}function O(e){for(;!E(C());)I();return T(e,b)}var P="-ms-",L="-moz-",z="-webkit-",B="comm",W="rule",V="decl",U="@keyframes";function j(e,t){for(var n="",r=p(e),a=0;a<r;a++)n+=t(e[a],a,e,t)||"";return n}function G(e,t,n,r){switch(e.type){case"@layer":if(e.children.length)break;case"@import":case V:return e.return=e.return||e.value;case B:return"";case U:return e.return=e.value+"{"+j(e.children,r)+"}";case W:e.value=e.props.join(",")}return h(n=j(e.children,r))?e.return=e.value+"{"+n+"}":""}function H(e){return _(q("",null,null,null,[""],e=A(e),0,[0],e))}function q(e,t,n,r,a,i,o,d,p){for(var m=0,g=0,y=o,b=0,v=0,x=0,w=1,k=1,T=1,E=0,A="",_=a,M=i,P=r,L=A;k;)switch(x=E,E=I()){case 40:if(108!=x&&58==c(L,y-1)){-1!=u(L+=l($(E),"&","&\f"),"&\f")&&(T=-1);break}case 34:case 39:case 91:L+=$(E);break;case 9:case 10:case 13:case 32:L+=R(x);break;case 92:L+=D(N()-1,7);continue;case 47:switch(C()){case 42:case 47:f(X(F(I(),N()),t,n),p);break;default:L+="/"}break;case 123*w:d[m++]=h(L)*T;case 125*w:case 59:case 0:switch(E){case 0:case 125:k=0;case 59+g:-1==T&&(L=l(L,/\f/g,"")),v>0&&h(L)-y&&f(v>32?Y(L+";",r,n,y-1):Y(l(L," ","")+";",r,n,y-2),p);break;case 59:L+=";";default:if(f(P=K(L,t,n,m,g,a,d,A,_=[],M=[],y),i),123===E)if(0===g)q(L,t,P,P,_,i,y,d,M);else switch(99===b&&110===c(L,3)?100:b){case 100:case 108:case 109:case 115:q(e,P,P,r&&f(K(e,P,P,0,0,a,d,A,a,_=[],y),M),a,M,y,d,r?_:M);break;default:q(L,P,P,P,[""],M,0,d,M)}}m=g=v=0,w=T=1,A=L="",y=o;break;case 58:y=1+h(L),v=x;default:if(w<1)if(123==E)--w;else if(125==E&&0==w++&&125==S())continue;switch(L+=s(E),E*w){case 38:T=g>0?1:(L+="\f",-1);break;case 44:d[m++]=(h(L)-1)*T,T=1;break;case 64:45===C()&&(L+=$(I())),b=C(),g=y=h(A=L+=O(N())),E++;break;case 45:45===x&&2==h(L)&&(w=0)}}return i}function K(e,t,n,r,s,i,u,c,h,f,m){for(var g=s-1,y=0===s?i:[""],b=p(y),v=0,x=0,k=0;v<r;++v)for(var S=0,I=d(e,g+1,g=a(x=u[v])),C=e;S<b;++S)(C=o(x>0?y[S]+" "+I:l(I,/&\f/g,y[S])))&&(h[k++]=C);return w(e,t,n,0===s?W:c,h,f,m)}function X(e,t,n){return w(e,t,n,B,s(v),d(e,2,-2),0)}function Y(e,t,n,r){return w(e,t,n,V,d(e,0,r),d(e,r+1,-1),r)}var Q=function(e,t,n){for(var r=0,a=0;r=a,a=C(),38===r&&12===a&&(t[n]=1),!E(a);)I();return T(e,b)},J=function(e,t){return _(function(e,t){var n=-1,r=44;do{switch(E(r)){case 0:38===r&&12===C()&&(t[n]=1),e[n]+=Q(b-1,t,n);break;case 2:e[n]+=$(r);break;case 4:if(44===r){e[++n]=58===C()?"&\f":"",t[n]=e[n].length;break}default:e[n]+=s(r)}}while(r=I());return e}(A(e),t))},Z=new WeakMap,ee=function(e){if("rule"===e.type&&e.parent&&!(e.length<1)){for(var t=e.value,n=e.parent,r=e.column===n.column&&e.line===n.line;"rule"!==n.type;)if(!(n=n.parent))return;if((1!==e.props.length||58===t.charCodeAt(0)||Z.get(n))&&!r){Z.set(e,!0);for(var a=[],s=J(t,a),i=n.props,o=0,l=0;o<s.length;o++)for(var u=0;u<i.length;u++,l++)e.props[l]=a[o]?s[o].replace(/&\f/g,i[u]):i[u]+" "+s[o]}}},te=function(e){if("decl"===e.type){var t=e.value;108===t.charCodeAt(0)&&98===t.charCodeAt(2)&&(e.return="",e.value="")}};function ne(e,t){switch(function(e,t){return 45^c(e,0)?(((t<<2^c(e,0))<<2^c(e,1))<<2^c(e,2))<<2^c(e,3):0}(e,t)){case 5103:return z+"print-"+e+e;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return z+e+e;case 5349:case 4246:case 4810:case 6968:case 2756:return z+e+L+e+P+e+e;case 6828:case 4268:return z+e+P+e+e;case 6165:return z+e+P+"flex-"+e+e;case 5187:return z+e+l(e,/(\w+).+(:[^]+)/,z+"box-$1$2"+P+"flex-$1$2")+e;case 5443:return z+e+P+"flex-item-"+l(e,/flex-|-self/,"")+e;case 4675:return z+e+P+"flex-line-pack"+l(e,/align-content|flex-|-self/,"")+e;case 5548:return z+e+P+l(e,"shrink","negative")+e;case 5292:return z+e+P+l(e,"basis","preferred-size")+e;case 6060:return z+"box-"+l(e,"-grow","")+z+e+P+l(e,"grow","positive")+e;case 4554:return z+l(e,/([^-])(transform)/g,"$1"+z+"$2")+e;case 6187:return l(l(l(e,/(zoom-|grab)/,z+"$1"),/(image-set)/,z+"$1"),e,"")+e;case 5495:case 3959:return l(e,/(image-set\([^]*)/,z+"$1$`$1");case 4968:return l(l(e,/(.+:)(flex-)?(.*)/,z+"box-pack:$3"+P+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+z+e+e;case 4095:case 3583:case 4068:case 2532:return l(e,/(.+)-inline(.+)/,z+"$1$2")+e;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(h(e)-1-t>6)switch(c(e,t+1)){case 109:if(45!==c(e,t+4))break;case 102:return l(e,/(.+:)(.+)-([^]+)/,"$1"+z+"$2-$3$1"+L+(108==c(e,t+3)?"$3":"$2-$3"))+e;case 115:return~u(e,"stretch")?ne(l(e,"stretch","fill-available"),t)+e:e}break;case 4949:if(115!==c(e,t+1))break;case 6444:switch(c(e,h(e)-3-(~u(e,"!important")&&10))){case 107:return l(e,":",":"+z)+e;case 101:return l(e,/(.+:)([^;!]+)(;|!.+)?/,"$1"+z+(45===c(e,14)?"inline-":"")+"box$3$1"+z+"$2$3$1"+P+"$2box$3")+e}break;case 5936:switch(c(e,t+11)){case 114:return z+e+P+l(e,/[svh]\w+-[tblr]{2}/,"tb")+e;case 108:return z+e+P+l(e,/[svh]\w+-[tblr]{2}/,"tb-rl")+e;case 45:return z+e+P+l(e,/[svh]\w+-[tblr]{2}/,"lr")+e}return z+e+P+e+e}return e}var re=[function(e,t,n,r){if(e.length>-1&&!e.return)switch(e.type){case V:e.return=ne(e.value,e.length);break;case U:return j([k(e,{value:l(e.value,"@","@"+z)})],r);case W:if(e.length)return function(e,t){return e.map(t).join("")}(e.props,(function(t){switch(function(e,t){return(e=t.exec(e))?e[0]:e}(t,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return j([k(e,{props:[l(t,/:(read-\w+)/,":-moz-$1")]})],r);case"::placeholder":return j([k(e,{props:[l(t,/:(plac\w+)/,":"+z+"input-$1")]}),k(e,{props:[l(t,/:(plac\w+)/,":-moz-$1")]}),k(e,{props:[l(t,/:(plac\w+)/,P+"input-$1")]})],r)}return""}))}}],ae=function(e){var t=e.key;if("css"===t){var n=document.querySelectorAll("style[data-emotion]:not([data-s])");Array.prototype.forEach.call(n,(function(e){-1!==e.getAttribute("data-emotion").indexOf(" ")&&(document.head.appendChild(e),e.setAttribute("data-s",""))}))}var a,s,i=e.stylisPlugins||re,o={},l=[];a=e.container||document.head,Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="'+t+' "]'),(function(e){for(var t=e.getAttribute("data-emotion").split(" "),n=1;n<t.length;n++)o[t[n]]=!0;l.push(e)}));var u,c,d=[G,(c=function(e){u.insert(e)},function(e){e.root||(e=e.return)&&c(e)})],h=function(e){var t=p(e);return function(n,r,a,s){for(var i="",o=0;o<t;o++)i+=e[o](n,r,a,s)||"";return i}}([ee,te].concat(i,d));s=function(e,t,n,r){u=n,j(H(e?e+"{"+t.styles+"}":t.styles),h),r&&(f.inserted[t.name]=!0)};var f={key:t,sheet:new r({key:t,container:a,nonce:e.nonce,speedy:e.speedy,prepend:e.prepend,insertionPoint:e.insertionPoint}),nonce:e.nonce,inserted:o,registered:{},insert:s};return f.sheet.hydrate(l),f}},918:(e,t,n)=>{"use strict";function r(e){var t=Object.create(null);return function(n){return void 0===t[n]&&(t[n]=e(n)),t[n]}}n.d(t,{A:()=>r})},4575:(e,t,n)=>{"use strict";n.d(t,{T:()=>o,w:()=>i});var r=n(5043),a=n(3803),s=(n(6598),n(9436),r.createContext("undefined"!==typeof HTMLElement?(0,a.A)({key:"css"}):null)),i=(s.Provider,function(e){return(0,r.forwardRef)((function(t,n){var a=(0,r.useContext)(s);return e(t,a,n)}))}),o=r.createContext({})},6598:(e,t,n)=>{"use strict";n.d(t,{J:()=>g});var r={animationIterationCount:1,aspectRatio:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,scale:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},a=n(918),s=!1,i=/[A-Z]|^ms/g,o=/_EMO_([^_]+?)_([^]*?)_EMO_/g,l=function(e){return 45===e.charCodeAt(1)},u=function(e){return null!=e&&"boolean"!==typeof e},c=(0,a.A)((function(e){return l(e)?e:e.replace(i,"-$&").toLowerCase()})),d=function(e,t){switch(e){case"animation":case"animationName":if("string"===typeof t)return t.replace(o,(function(e,t,n){return f={name:t,styles:n,next:f},t}))}return 1===r[e]||l(e)||"number"!==typeof t||0===t?t:t+"px"},h="Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";function p(e,t,n){if(null==n)return"";var r=n;if(void 0!==r.__emotion_styles)return r;switch(typeof n){case"boolean":return"";case"object":var a=n;if(1===a.anim)return f={name:a.name,styles:a.styles,next:f},a.name;var i=n;if(void 0!==i.styles){var o=i.next;if(void 0!==o)for(;void 0!==o;)f={name:o.name,styles:o.styles,next:f},o=o.next;return i.styles+";"}return function(e,t,n){var r="";if(Array.isArray(n))for(var a=0;a<n.length;a++)r+=p(e,t,n[a])+";";else for(var i in n){var o=n[i];if("object"!==typeof o){var l=o;null!=t&&void 0!==t[l]?r+=i+"{"+t[l]+"}":u(l)&&(r+=c(i)+":"+d(i,l)+";")}else{if("NO_COMPONENT_SELECTOR"===i&&s)throw new Error(h);if(!Array.isArray(o)||"string"!==typeof o[0]||null!=t&&void 0!==t[o[0]]){var f=p(e,t,o);switch(i){case"animation":case"animationName":r+=c(i)+":"+f+";";break;default:r+=i+"{"+f+"}"}}else for(var m=0;m<o.length;m++)u(o[m])&&(r+=c(i)+":"+d(i,o[m])+";")}}return r}(e,t,n);case"function":if(void 0!==e){var l=f,m=n(e);return f=l,p(e,t,m)}}var g=n;if(null==t)return g;var y=t[g];return void 0!==y?y:g}var f,m=/label:\s*([^\s;\n{]+)\s*(;|$)/g;function g(e,t,n){if(1===e.length&&"object"===typeof e[0]&&null!==e[0]&&void 0!==e[0].styles)return e[0];var r=!0,a="";f=void 0;var s=e[0];null==s||void 0===s.raw?(r=!1,a+=p(n,t,s)):a+=s[0];for(var i=1;i<e.length;i++){if(a+=p(n,t,e[i]),r)a+=s[i]}m.lastIndex=0;for(var o,l="";null!==(o=m.exec(a));)l+="-"+o[1];var u=function(e){for(var t,n=0,r=0,a=e.length;a>=4;++r,a-=4)t=1540483477*(65535&(t=255&e.charCodeAt(r)|(255&e.charCodeAt(++r))<<8|(255&e.charCodeAt(++r))<<16|(255&e.charCodeAt(++r))<<24))+(59797*(t>>>16)<<16),n=1540483477*(65535&(t^=t>>>24))+(59797*(t>>>16)<<16)^1540483477*(65535&n)+(59797*(n>>>16)<<16);switch(a){case 3:n^=(255&e.charCodeAt(r+2))<<16;case 2:n^=(255&e.charCodeAt(r+1))<<8;case 1:n=1540483477*(65535&(n^=255&e.charCodeAt(r)))+(59797*(n>>>16)<<16)}return(((n=1540483477*(65535&(n^=n>>>13))+(59797*(n>>>16)<<16))^n>>>15)>>>0).toString(36)}(a)+l;return{name:u,styles:a,next:f}}},9436:(e,t,n)=>{"use strict";var r;n.d(t,{i:()=>o,s:()=>i});var a=n(5043),s=!!(r||(r=n.t(a,2))).useInsertionEffect&&(r||(r=n.t(a,2))).useInsertionEffect,i=s||function(e){return e()},o=s||a.useLayoutEffect},1722:(e,t,n)=>{"use strict";n.d(t,{Rk:()=>r,SF:()=>a,sk:()=>s});function r(e,t,n){var r="";return n.split(" ").forEach((function(n){void 0!==e[n]?t.push(e[n]+";"):r+=n+" "})),r}var a=function(e,t,n){var r=e.key+"-"+t.name;!1===n&&void 0===e.registered[r]&&(e.registered[r]=t.styles)},s=function(e,t,n){a(e,t,n);var r=e.key+"-"+t.name;if(void 0===e.inserted[t.name]){var s=t;do{e.insert(t===s?"."+r:"",s,e.sheet,!0),s=s.next}while(void 0!==s)}}},4914:(e,t,n)=>{"use strict";var r=n(4994);t.A=void 0;var a=r(n(39)),s=n(579);t.A=(0,a.default)((0,s.jsx)("path",{d:"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"}),"ContentCopy")},7948:(e,t,n)=>{"use strict";var r=n(4994);t.A=void 0;var a=r(n(39)),s=n(579);t.A=(0,a.default)((0,s.jsx)("path",{d:"M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2M12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"}),"ErrorOutline")},3531:(e,t,n)=>{"use strict";var r=n(4994);t.A=void 0;var a=r(n(39)),s=n(579);t.A=(0,a.default)((0,s.jsx)("path",{d:"M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2m0 12H6V10h12z"}),"LockOpen")},39:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return r.createSvgIcon}});var r=n(4421)},8249:(e,t,n)=>{"use strict";n.d(t,{b:()=>o});var r=n(5043),a=n(3030);n(579);const s=r.createContext(void 0);function i(e){let{props:t,name:n}=e;return function(e){const{theme:t,name:n,props:r}=e;if(!t||!t.components||!t.components[n])return r;const s=t.components[n];return s.defaultProps?(0,a.A)(s.defaultProps,r):s.styleOverrides||s.variants?r:(0,a.A)(s,r)}({props:t,name:n,theme:{components:r.useContext(s)}})}function o(e){return i(e)}},5913:(e,t,n)=>{"use strict";n.d(t,{A:()=>ae});var r=n(7868),a=n(9172),s=n(6596);const i={black:"#000",white:"#fff"},o={50:"#fafafa",100:"#f5f5f5",200:"#eeeeee",300:"#e0e0e0",400:"#bdbdbd",500:"#9e9e9e",600:"#757575",700:"#616161",800:"#424242",900:"#212121",A100:"#f5f5f5",A200:"#eeeeee",A400:"#bdbdbd",A700:"#616161"},l={50:"#f3e5f5",100:"#e1bee7",200:"#ce93d8",300:"#ba68c8",400:"#ab47bc",500:"#9c27b0",600:"#8e24aa",700:"#7b1fa2",800:"#6a1b9a",900:"#4a148c",A100:"#ea80fc",A200:"#e040fb",A400:"#d500f9",A700:"#aa00ff"},u={50:"#ffebee",100:"#ffcdd2",200:"#ef9a9a",300:"#e57373",400:"#ef5350",500:"#f44336",600:"#e53935",700:"#d32f2f",800:"#c62828",900:"#b71c1c",A100:"#ff8a80",A200:"#ff5252",A400:"#ff1744",A700:"#d50000"},c={50:"#fff3e0",100:"#ffe0b2",200:"#ffcc80",300:"#ffb74d",400:"#ffa726",500:"#ff9800",600:"#fb8c00",700:"#f57c00",800:"#ef6c00",900:"#e65100",A100:"#ffd180",A200:"#ffab40",A400:"#ff9100",A700:"#ff6d00"},d={50:"#e3f2fd",100:"#bbdefb",200:"#90caf9",300:"#64b5f6",400:"#42a5f5",500:"#2196f3",600:"#1e88e5",700:"#1976d2",800:"#1565c0",900:"#0d47a1",A100:"#82b1ff",A200:"#448aff",A400:"#2979ff",A700:"#2962ff"},h={50:"#e1f5fe",100:"#b3e5fc",200:"#81d4fa",300:"#4fc3f7",400:"#29b6f6",500:"#03a9f4",600:"#039be5",700:"#0288d1",800:"#0277bd",900:"#01579b",A100:"#80d8ff",A200:"#40c4ff",A400:"#00b0ff",A700:"#0091ea"},p={50:"#e8f5e9",100:"#c8e6c9",200:"#a5d6a7",300:"#81c784",400:"#66bb6a",500:"#4caf50",600:"#43a047",700:"#388e3c",800:"#2e7d32",900:"#1b5e20",A100:"#b9f6ca",A200:"#69f0ae",A400:"#00e676",A700:"#00c853"},f={text:{primary:"rgba(0, 0, 0, 0.87)",secondary:"rgba(0, 0, 0, 0.6)",disabled:"rgba(0, 0, 0, 0.38)"},divider:"rgba(0, 0, 0, 0.12)",background:{paper:i.white,default:i.white},action:{active:"rgba(0, 0, 0, 0.54)",hover:"rgba(0, 0, 0, 0.04)",hoverOpacity:.04,selected:"rgba(0, 0, 0, 0.08)",selectedOpacity:.08,disabled:"rgba(0, 0, 0, 0.26)",disabledBackground:"rgba(0, 0, 0, 0.12)",disabledOpacity:.38,focus:"rgba(0, 0, 0, 0.12)",focusOpacity:.12,activatedOpacity:.12}},m={text:{primary:i.white,secondary:"rgba(255, 255, 255, 0.7)",disabled:"rgba(255, 255, 255, 0.5)",icon:"rgba(255, 255, 255, 0.5)"},divider:"rgba(255, 255, 255, 0.12)",background:{paper:"#121212",default:"#121212"},action:{active:i.white,hover:"rgba(255, 255, 255, 0.08)",hoverOpacity:.08,selected:"rgba(255, 255, 255, 0.16)",selectedOpacity:.16,disabled:"rgba(255, 255, 255, 0.3)",disabledBackground:"rgba(255, 255, 255, 0.12)",disabledOpacity:.38,focus:"rgba(255, 255, 255, 0.12)",focusOpacity:.12,activatedOpacity:.24}};function g(e,t,n,r){const a=r.light||r,i=r.dark||1.5*r;e[t]||(e.hasOwnProperty(n)?e[t]=e[n]:"light"===t?e.light=(0,s.a)(e.main,a):"dark"===t&&(e.dark=(0,s.e$)(e.main,i)))}function y(e){const{mode:t="light",contrastThreshold:n=3,tonalOffset:y=.2,...b}=e,v=e.primary||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:d[200],light:d[50],dark:d[400]}:{main:d[700],light:d[400],dark:d[800]}}(t),x=e.secondary||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:l[200],light:l[50],dark:l[400]}:{main:l[500],light:l[300],dark:l[700]}}(t),w=e.error||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:u[500],light:u[300],dark:u[700]}:{main:u[700],light:u[400],dark:u[800]}}(t),k=e.info||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:h[400],light:h[300],dark:h[700]}:{main:h[700],light:h[500],dark:h[900]}}(t),S=e.success||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:p[400],light:p[300],dark:p[700]}:{main:p[800],light:p[500],dark:p[900]}}(t),I=e.warning||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:c[400],light:c[300],dark:c[700]}:{main:"#ed6c02",light:c[500],dark:c[900]}}(t);function C(e){return(0,s.eM)(e,m.text.primary)>=n?m.text.primary:f.text.primary}const N=e=>{let{color:t,name:n,mainShade:a=500,lightShade:s=300,darkShade:i=700}=e;if(t={...t},!t.main&&t[a]&&(t.main=t[a]),!t.hasOwnProperty("main"))throw new Error((0,r.A)(11,n?` (${n})`:"",a));if("string"!==typeof t.main)throw new Error((0,r.A)(12,n?` (${n})`:"",JSON.stringify(t.main)));return g(t,"light",s,y),g(t,"dark",i,y),t.contrastText||(t.contrastText=C(t.main)),t},T={dark:m,light:f};return(0,a.A)({common:{...i},mode:t,primary:N({color:v,name:"primary"}),secondary:N({color:x,name:"secondary",mainShade:"A400",lightShade:"A200",darkShade:"A700"}),error:N({color:w,name:"error"}),warning:N({color:I,name:"warning"}),info:N({color:k,name:"info"}),success:N({color:S,name:"success"}),grey:o,contrastThreshold:n,getContrastText:C,augmentColor:N,tonalOffset:y,...T[t]},b)}function b(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";function t(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];if(!r.length)return"";const s=r[0];return"string"!==typeof s||s.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)?`, ${s}`:`, var(--${e?`${e}-`:""}${s}${t(...r.slice(1))})`}return function(n){for(var r=arguments.length,a=new Array(r>1?r-1:0),s=1;s<r;s++)a[s-1]=arguments[s];return`var(--${e?`${e}-`:""}${n}${t(...a)})`}}var v=n(6160),x=n(883);function w(e){const t={};return Object.entries(e).forEach((e=>{const[n,r]=e;"object"===typeof r&&(t[n]=`${r.fontStyle?`${r.fontStyle} `:""}${r.fontVariant?`${r.fontVariant} `:""}${r.fontWeight?`${r.fontWeight} `:""}${r.fontStretch?`${r.fontStretch} `:""}${r.fontSize||""}${r.lineHeight?`/${r.lineHeight} `:""}${r.fontFamily||""}`)})),t}const k=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=e;t.forEach(((e,s)=>{s===t.length-1?Array.isArray(a)?a[Number(e)]=n:a&&"object"===typeof a&&(a[e]=n):a&&"object"===typeof a&&(a[e]||(a[e]=r.includes(e)?[]:{}),a=a[e])}))},S=(e,t,n)=>{!function e(r){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];Object.entries(r).forEach((r=>{let[i,o]=r;(!n||n&&!n([...a,i]))&&void 0!==o&&null!==o&&("object"===typeof o&&Object.keys(o).length>0?e(o,[...a,i],Array.isArray(o)?[...s,i]:s):t([...a,i],o,s))}))}(e)},I=(e,t)=>{if("number"===typeof t){if(["lineHeight","fontWeight","opacity","zIndex"].some((t=>e.includes(t))))return t;return e[e.length-1].toLowerCase().indexOf("opacity")>=0?t:`${t}px`}return t};function C(e,t){const{prefix:n,shouldSkipGeneratingVar:r}=t||{},a={},s={},i={};return S(e,((e,t,o)=>{if(("string"===typeof t||"number"===typeof t)&&(!r||!r(e,t))){const r=`--${n?`${n}-`:""}${e.join("-")}`,l=I(e,t);Object.assign(a,{[r]:l}),k(s,e,`var(${r})`,o),k(i,e,`var(${r}, ${l})`,o)}}),(e=>"vars"===e[0])),{css:a,vars:s,varsWithDefaults:i}}const N=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{getSelector:n=y,disableCssColorScheme:r,colorSchemeSelector:s}=t,{colorSchemes:i={},components:o,defaultColorScheme:l="light",...u}=e,{vars:c,css:d,varsWithDefaults:h}=C(u,t);let p=h;const f={},{[l]:m,...g}=i;if(Object.entries(g||{}).forEach((e=>{let[n,r]=e;const{vars:s,css:i,varsWithDefaults:o}=C(r,t);p=(0,a.A)(p,o),f[n]={css:i,vars:s}})),m){const{css:e,vars:n,varsWithDefaults:r}=C(m,t);p=(0,a.A)(p,r),f[l]={css:e,vars:n}}function y(t,n){let r=s;if("class"===s&&(r=".%s"),"data"===s&&(r="[data-%s]"),s?.startsWith("data-")&&!s.includes("%s")&&(r=`[${s}="%s"]`),t){if("media"===r){if(e.defaultColorScheme===t)return":root";const r=i[t]?.palette?.mode||t;return{[`@media (prefers-color-scheme: ${r})`]:{":root":n}}}if(r)return e.defaultColorScheme===t?`:root, ${r.replace("%s",String(t))}`:r.replace("%s",String(t))}return":root"}return{vars:p,generateThemeVars:()=>{let e={...c};return Object.entries(f).forEach((t=>{let[,{vars:n}]=t;e=(0,a.A)(e,n)})),e},generateStyleSheets:()=>{const t=[],a=e.defaultColorScheme||"light";function s(e,n){Object.keys(n).length&&t.push("string"===typeof e?{[e]:{...n}}:e)}s(n(void 0,{...d}),d);const{[a]:o,...l}=f;if(o){const{css:e}=o,t=i[a]?.palette?.mode,l=!r&&t?{colorScheme:t,...e}:{...e};s(n(a,{...l}),l)}return Object.entries(l).forEach((e=>{let[t,{css:a}]=e;const o=i[t]?.palette?.mode,l=!r&&o?{colorScheme:o,...a}:{...a};s(n(t,{...l}),l)})),t}}};var T=n(138),E=n(2768),A=n(2390);const _={textTransform:"uppercase"},$='"Roboto", "Helvetica", "Arial", sans-serif';function R(e,t){const{fontFamily:n=$,fontSize:r=14,fontWeightLight:s=300,fontWeightRegular:i=400,fontWeightMedium:o=500,fontWeightBold:l=700,htmlFontSize:u=16,allVariants:c,pxToRem:d,...h}="function"===typeof t?t(e):t;const p=r/14,f=d||(e=>e/u*p+"rem"),m=(e,t,r,a,s)=>{return{fontFamily:n,fontWeight:e,fontSize:f(t),lineHeight:r,...n===$?{letterSpacing:(i=a/t,Math.round(1e5*i)/1e5)+"em"}:{},...s,...c};var i},g={h1:m(s,96,1.167,-1.5),h2:m(s,60,1.2,-.5),h3:m(i,48,1.167,0),h4:m(i,34,1.235,.25),h5:m(i,24,1.334,0),h6:m(o,20,1.6,.15),subtitle1:m(i,16,1.75,.15),subtitle2:m(o,14,1.57,.1),body1:m(i,16,1.5,.15),body2:m(i,14,1.43,.15),button:m(o,14,1.75,.4,_),caption:m(i,12,1.66,.4),overline:m(i,12,2.66,1,_),inherit:{fontFamily:"inherit",fontWeight:"inherit",fontSize:"inherit",lineHeight:"inherit",letterSpacing:"inherit"}};return(0,a.A)({htmlFontSize:u,pxToRem:f,fontFamily:n,fontSize:r,fontWeightLight:s,fontWeightRegular:i,fontWeightMedium:o,fontWeightBold:l,...g},h,{clone:!1})}function D(){return[`${arguments.length<=0?void 0:arguments[0]}px ${arguments.length<=1?void 0:arguments[1]}px ${arguments.length<=2?void 0:arguments[2]}px ${arguments.length<=3?void 0:arguments[3]}px rgba(0,0,0,0.2)`,`${arguments.length<=4?void 0:arguments[4]}px ${arguments.length<=5?void 0:arguments[5]}px ${arguments.length<=6?void 0:arguments[6]}px ${arguments.length<=7?void 0:arguments[7]}px rgba(0,0,0,0.14)`,`${arguments.length<=8?void 0:arguments[8]}px ${arguments.length<=9?void 0:arguments[9]}px ${arguments.length<=10?void 0:arguments[10]}px ${arguments.length<=11?void 0:arguments[11]}px rgba(0,0,0,0.12)`].join(",")}const M=["none",D(0,2,1,-1,0,1,1,0,0,1,3,0),D(0,3,1,-2,0,2,2,0,0,1,5,0),D(0,3,3,-2,0,3,4,0,0,1,8,0),D(0,2,4,-1,0,4,5,0,0,1,10,0),D(0,3,5,-1,0,5,8,0,0,1,14,0),D(0,3,5,-1,0,6,10,0,0,1,18,0),D(0,4,5,-2,0,7,10,1,0,2,16,1),D(0,5,5,-3,0,8,10,1,0,3,14,2),D(0,5,6,-3,0,9,12,1,0,3,16,2),D(0,6,6,-3,0,10,14,1,0,4,18,3),D(0,6,7,-4,0,11,15,1,0,4,20,3),D(0,7,8,-4,0,12,17,2,0,5,22,4),D(0,7,8,-4,0,13,19,2,0,5,24,4),D(0,7,9,-4,0,14,21,2,0,5,26,4),D(0,8,9,-5,0,15,22,2,0,6,28,5),D(0,8,10,-5,0,16,24,2,0,6,30,5),D(0,8,11,-5,0,17,26,2,0,6,32,5),D(0,9,11,-5,0,18,28,2,0,7,34,6),D(0,9,12,-6,0,19,29,2,0,7,36,6),D(0,10,13,-6,0,20,31,3,0,8,38,7),D(0,10,13,-6,0,21,33,3,0,8,40,7),D(0,10,14,-6,0,22,35,3,0,8,42,7),D(0,11,14,-7,0,23,36,3,0,9,44,8),D(0,11,15,-7,0,24,38,3,0,9,46,8)],F={easeInOut:"cubic-bezier(0.4, 0, 0.2, 1)",easeOut:"cubic-bezier(0.0, 0, 0.2, 1)",easeIn:"cubic-bezier(0.4, 0, 1, 1)",sharp:"cubic-bezier(0.4, 0, 0.6, 1)"},O={shortest:150,shorter:200,short:250,standard:300,complex:375,enteringScreen:225,leavingScreen:195};function P(e){return`${Math.round(e)}ms`}function L(e){if(!e)return 0;const t=e/36;return Math.min(Math.round(10*(4+15*t**.25+t/5)),3e3)}function z(e){const t={...F,...e.easing},n={...O,...e.duration};return{getAutoHeightDuration:L,create:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:["all"],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{duration:a=n.standard,easing:s=t.easeInOut,delay:i=0,...o}=r;return(Array.isArray(e)?e:[e]).map((e=>`${e} ${"string"===typeof a?a:P(a)} ${s} ${"string"===typeof i?i:P(i)}`)).join(",")},...e,easing:t,duration:n}}const B={mobileStepper:1e3,fab:1050,speedDial:1050,appBar:1100,drawer:1200,modal:1300,snackbar:1400,tooltip:1500};function W(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{breakpoints:t,mixins:n={},spacing:s,palette:i={},transitions:o={},typography:l={},shape:u,...c}=e;if(e.vars)throw new Error((0,r.A)(20));const d=y(i),h=(0,A.A)(e);let p=(0,a.A)(h,{mixins:(f=h.breakpoints,m=n,{toolbar:{minHeight:56,[f.up("xs")]:{"@media (orientation: landscape)":{minHeight:48}},[f.up("sm")]:{minHeight:64}},...m}),palette:d,shadows:M.slice(),typography:R(d,l),transitions:z(o),zIndex:{...B}});var f,m;p=(0,a.A)(p,c);for(var g=arguments.length,b=new Array(g>1?g-1:0),v=1;v<g;v++)b[v-1]=arguments[v];return p=b.reduce(((e,t)=>(0,a.A)(e,t)),p),p.unstable_sxConfig={...T.A,...c?.unstable_sxConfig},p.unstable_sx=function(e){return(0,E.A)({sx:e,theme:this})},p}const V=W;var U=n(3582);const j=[...Array(25)].map(((e,t)=>{if(0===t)return;const n=(0,U.A)(t);return`linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`}));function G(e){return{inputPlaceholder:"dark"===e?.5:.42,inputUnderline:"dark"===e?.7:.42,switchTrackDisabled:"dark"===e?.2:.12,switchTrack:"dark"===e?.3:.38}}function H(e){return"dark"===e?j:[]}function q(e){return!!e[0].match(/(cssVarPrefix|colorSchemeSelector|typography|mixins|breakpoints|direction|transitions)/)||!!e[0].match(/sxConfig$/)||"palette"===e[0]&&!!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/)}const K=e=>[...[...Array(24)].map(((t,n)=>`--${e?`${e}-`:""}overlays-${n+1}`)),`--${e?`${e}-`:""}palette-AppBar-darkBg`,`--${e?`${e}-`:""}palette-AppBar-darkColor`],X=e=>(t,n)=>{const r=e.colorSchemeSelector;let a=r;if("class"===r&&(a=".%s"),"data"===r&&(a="[data-%s]"),r?.startsWith("data-")&&!r.includes("%s")&&(a=`[${r}="%s"]`),e.defaultColorScheme===t){if("dark"===t){const r={};return K(e.cssVarPrefix).forEach((e=>{r[e]=n[e],delete n[e]})),"media"===a?{":root":n,"@media (prefers-color-scheme: dark)":{":root":r}}:a?{[a.replace("%s",t)]:r,[`:root, ${a.replace("%s",t)}`]:n}:{":root":{...n,...r}}}if(a&&"media"!==a)return`:root, ${a.replace("%s",String(t))}`}else if(t){if("media"===a)return{[`@media (prefers-color-scheme: ${String(t)})`]:{":root":n}};if(a)return a.replace("%s",String(t))}return":root"};function Y(){const e={...arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}};return function e(t){const n=Object.entries(t);for(let s=0;s<n.length;s++){const[i,o]=n[s];r=o,!(0,a.Q)(r)&&"undefined"!==typeof r&&"string"!==typeof r&&"boolean"!==typeof r&&"number"!==typeof r&&!Array.isArray(r)||i.startsWith("unstable_")?delete t[i]:(0,a.Q)(o)&&(t[i]={...o},e(t[i]))}var r}(e),`import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';\n\nconst theme = ${JSON.stringify(e,null,2)};\n\ntheme.breakpoints = createBreakpoints(theme.breakpoints || {});\ntheme.transitions = createTransitions(theme.transitions || {});\n\nexport default theme;`}function Q(e,t,n){!e[t]&&n&&(e[t]=n)}function J(e){return e&&e.startsWith("hsl")?(0,s.YL)(e):e}function Z(e,t){`${t}Channel`in e||(e[`${t}Channel`]=(0,s.Me)(J(e[t]),`MUI: Can't create \`palette.${t}Channel\` because \`palette.${t}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().\nTo suppress this warning, you need to explicitly provide the \`palette.${t}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`))}const ee=e=>{try{return e()}catch(t){}},te=function(){return b(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"mui")};function ne(e,t,n,r){if(!t)return;t=!0===t?{}:t;const a="dark"===r?"dark":"light";if(!n)return void(e[r]=function(e){const{palette:t={mode:"light"},opacity:n,overlays:r,...a}=e,s=y(t);return{palette:s,opacity:{...G(s.mode),...n},overlays:r||H(s.mode),...a}}({...t,palette:{mode:a,...t?.palette}}));const{palette:s,...i}=V({...n,palette:{mode:a,...t?.palette}});return e[r]={...t,palette:s,opacity:{...G(a),...t?.opacity},overlays:t?.overlays||H(a)},i}function re(e,t,n){e.colorSchemes&&n&&(e.colorSchemes[t]={...!0!==n&&n,palette:y({...!0===n?{}:n.palette,mode:t})})}function ae(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{palette:t,cssVariables:n=!1,colorSchemes:i=(t?void 0:{light:!0}),defaultColorScheme:o=t?.mode,...l}=e,u=o||"light",c=i?.[u],d={...i,...t?{[u]:{..."boolean"!==typeof c&&c,palette:t}}:void 0};for(var h=arguments.length,p=new Array(h>1?h-1:0),f=1;f<h;f++)p[f-1]=arguments[f];if(!1===n){if(!("colorSchemes"in e))return V(e,...p);let n=t;"palette"in e||d[u]&&(!0!==d[u]?n=d[u].palette:"dark"===u&&(n={mode:"dark"}));const r=V({...e,palette:n},...p);return r.defaultColorScheme=u,r.colorSchemes=d,"light"===r.palette.mode&&(r.colorSchemes.light={...!0!==d.light&&d.light,palette:r.palette},re(r,"dark",d.dark)),"dark"===r.palette.mode&&(r.colorSchemes.dark={...!0!==d.dark&&d.dark,palette:r.palette},re(r,"light",d.light)),r}return t||"light"in d||"light"!==u||(d.light=!0),function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{colorSchemes:t={light:!0},defaultColorScheme:n,disableCssColorScheme:i=!1,cssVarPrefix:o="mui",shouldSkipGeneratingVar:l=q,colorSchemeSelector:u=(t.light&&t.dark?"media":void 0),...c}=e,d=Object.keys(t)[0],h=n||(t.light&&"light"!==d?"light":d),p=te(o),{[h]:f,light:m,dark:g,...y}=t,b={...y};let k=f;if(("dark"===h&&!("dark"in t)||"light"===h&&!("light"in t))&&(k=!0),!k)throw new Error((0,r.A)(21,h));const S=ne(b,k,c,h);m&&!b.light&&ne(b,m,void 0,"light"),g&&!b.dark&&ne(b,g,void 0,"dark");let I={defaultColorScheme:h,...S,cssVarPrefix:o,colorSchemeSelector:u,getCssVar:p,colorSchemes:b,font:{...w(S.typography),...S.font},spacing:(C=c.spacing,"number"===typeof C?`${C}px`:"string"===typeof C||"function"===typeof C||Array.isArray(C)?C:"8px")};var C;Object.keys(I.colorSchemes).forEach((e=>{const t=I.colorSchemes[e].palette,n=e=>{const n=e.split("-"),r=n[1],a=n[2];return p(e,t[r][a])};var r;if("light"===t.mode&&(Q(t.common,"background","#fff"),Q(t.common,"onBackground","#000")),"dark"===t.mode&&(Q(t.common,"background","#000"),Q(t.common,"onBackground","#fff")),r=t,["Alert","AppBar","Avatar","Button","Chip","FilledInput","LinearProgress","Skeleton","Slider","SnackbarContent","SpeedDialAction","StepConnector","StepContent","Switch","TableCell","Tooltip"].forEach((e=>{r[e]||(r[e]={})})),"light"===t.mode){Q(t.Alert,"errorColor",(0,s.Nd)(t.error.light,.6)),Q(t.Alert,"infoColor",(0,s.Nd)(t.info.light,.6)),Q(t.Alert,"successColor",(0,s.Nd)(t.success.light,.6)),Q(t.Alert,"warningColor",(0,s.Nd)(t.warning.light,.6)),Q(t.Alert,"errorFilledBg",n("palette-error-main")),Q(t.Alert,"infoFilledBg",n("palette-info-main")),Q(t.Alert,"successFilledBg",n("palette-success-main")),Q(t.Alert,"warningFilledBg",n("palette-warning-main")),Q(t.Alert,"errorFilledColor",ee((()=>t.getContrastText(t.error.main)))),Q(t.Alert,"infoFilledColor",ee((()=>t.getContrastText(t.info.main)))),Q(t.Alert,"successFilledColor",ee((()=>t.getContrastText(t.success.main)))),Q(t.Alert,"warningFilledColor",ee((()=>t.getContrastText(t.warning.main)))),Q(t.Alert,"errorStandardBg",(0,s.j4)(t.error.light,.9)),Q(t.Alert,"infoStandardBg",(0,s.j4)(t.info.light,.9)),Q(t.Alert,"successStandardBg",(0,s.j4)(t.success.light,.9)),Q(t.Alert,"warningStandardBg",(0,s.j4)(t.warning.light,.9)),Q(t.Alert,"errorIconColor",n("palette-error-main")),Q(t.Alert,"infoIconColor",n("palette-info-main")),Q(t.Alert,"successIconColor",n("palette-success-main")),Q(t.Alert,"warningIconColor",n("palette-warning-main")),Q(t.AppBar,"defaultBg",n("palette-grey-100")),Q(t.Avatar,"defaultBg",n("palette-grey-400")),Q(t.Button,"inheritContainedBg",n("palette-grey-300")),Q(t.Button,"inheritContainedHoverBg",n("palette-grey-A100")),Q(t.Chip,"defaultBorder",n("palette-grey-400")),Q(t.Chip,"defaultAvatarColor",n("palette-grey-700")),Q(t.Chip,"defaultIconColor",n("palette-grey-700")),Q(t.FilledInput,"bg","rgba(0, 0, 0, 0.06)"),Q(t.FilledInput,"hoverBg","rgba(0, 0, 0, 0.09)"),Q(t.FilledInput,"disabledBg","rgba(0, 0, 0, 0.12)"),Q(t.LinearProgress,"primaryBg",(0,s.j4)(t.primary.main,.62)),Q(t.LinearProgress,"secondaryBg",(0,s.j4)(t.secondary.main,.62)),Q(t.LinearProgress,"errorBg",(0,s.j4)(t.error.main,.62)),Q(t.LinearProgress,"infoBg",(0,s.j4)(t.info.main,.62)),Q(t.LinearProgress,"successBg",(0,s.j4)(t.success.main,.62)),Q(t.LinearProgress,"warningBg",(0,s.j4)(t.warning.main,.62)),Q(t.Skeleton,"bg",`rgba(${n("palette-text-primaryChannel")} / 0.11)`),Q(t.Slider,"primaryTrack",(0,s.j4)(t.primary.main,.62)),Q(t.Slider,"secondaryTrack",(0,s.j4)(t.secondary.main,.62)),Q(t.Slider,"errorTrack",(0,s.j4)(t.error.main,.62)),Q(t.Slider,"infoTrack",(0,s.j4)(t.info.main,.62)),Q(t.Slider,"successTrack",(0,s.j4)(t.success.main,.62)),Q(t.Slider,"warningTrack",(0,s.j4)(t.warning.main,.62));const e=(0,s.Y9)(t.background.default,.8);Q(t.SnackbarContent,"bg",e),Q(t.SnackbarContent,"color",ee((()=>t.getContrastText(e)))),Q(t.SpeedDialAction,"fabHoverBg",(0,s.Y9)(t.background.paper,.15)),Q(t.StepConnector,"border",n("palette-grey-400")),Q(t.StepContent,"border",n("palette-grey-400")),Q(t.Switch,"defaultColor",n("palette-common-white")),Q(t.Switch,"defaultDisabledColor",n("palette-grey-100")),Q(t.Switch,"primaryDisabledColor",(0,s.j4)(t.primary.main,.62)),Q(t.Switch,"secondaryDisabledColor",(0,s.j4)(t.secondary.main,.62)),Q(t.Switch,"errorDisabledColor",(0,s.j4)(t.error.main,.62)),Q(t.Switch,"infoDisabledColor",(0,s.j4)(t.info.main,.62)),Q(t.Switch,"successDisabledColor",(0,s.j4)(t.success.main,.62)),Q(t.Switch,"warningDisabledColor",(0,s.j4)(t.warning.main,.62)),Q(t.TableCell,"border",(0,s.j4)((0,s.Cg)(t.divider,1),.88)),Q(t.Tooltip,"bg",(0,s.Cg)(t.grey[700],.92))}if("dark"===t.mode){Q(t.Alert,"errorColor",(0,s.j4)(t.error.light,.6)),Q(t.Alert,"infoColor",(0,s.j4)(t.info.light,.6)),Q(t.Alert,"successColor",(0,s.j4)(t.success.light,.6)),Q(t.Alert,"warningColor",(0,s.j4)(t.warning.light,.6)),Q(t.Alert,"errorFilledBg",n("palette-error-dark")),Q(t.Alert,"infoFilledBg",n("palette-info-dark")),Q(t.Alert,"successFilledBg",n("palette-success-dark")),Q(t.Alert,"warningFilledBg",n("palette-warning-dark")),Q(t.Alert,"errorFilledColor",ee((()=>t.getContrastText(t.error.dark)))),Q(t.Alert,"infoFilledColor",ee((()=>t.getContrastText(t.info.dark)))),Q(t.Alert,"successFilledColor",ee((()=>t.getContrastText(t.success.dark)))),Q(t.Alert,"warningFilledColor",ee((()=>t.getContrastText(t.warning.dark)))),Q(t.Alert,"errorStandardBg",(0,s.Nd)(t.error.light,.9)),Q(t.Alert,"infoStandardBg",(0,s.Nd)(t.info.light,.9)),Q(t.Alert,"successStandardBg",(0,s.Nd)(t.success.light,.9)),Q(t.Alert,"warningStandardBg",(0,s.Nd)(t.warning.light,.9)),Q(t.Alert,"errorIconColor",n("palette-error-main")),Q(t.Alert,"infoIconColor",n("palette-info-main")),Q(t.Alert,"successIconColor",n("palette-success-main")),Q(t.Alert,"warningIconColor",n("palette-warning-main")),Q(t.AppBar,"defaultBg",n("palette-grey-900")),Q(t.AppBar,"darkBg",n("palette-background-paper")),Q(t.AppBar,"darkColor",n("palette-text-primary")),Q(t.Avatar,"defaultBg",n("palette-grey-600")),Q(t.Button,"inheritContainedBg",n("palette-grey-800")),Q(t.Button,"inheritContainedHoverBg",n("palette-grey-700")),Q(t.Chip,"defaultBorder",n("palette-grey-700")),Q(t.Chip,"defaultAvatarColor",n("palette-grey-300")),Q(t.Chip,"defaultIconColor",n("palette-grey-300")),Q(t.FilledInput,"bg","rgba(255, 255, 255, 0.09)"),Q(t.FilledInput,"hoverBg","rgba(255, 255, 255, 0.13)"),Q(t.FilledInput,"disabledBg","rgba(255, 255, 255, 0.12)"),Q(t.LinearProgress,"primaryBg",(0,s.Nd)(t.primary.main,.5)),Q(t.LinearProgress,"secondaryBg",(0,s.Nd)(t.secondary.main,.5)),Q(t.LinearProgress,"errorBg",(0,s.Nd)(t.error.main,.5)),Q(t.LinearProgress,"infoBg",(0,s.Nd)(t.info.main,.5)),Q(t.LinearProgress,"successBg",(0,s.Nd)(t.success.main,.5)),Q(t.LinearProgress,"warningBg",(0,s.Nd)(t.warning.main,.5)),Q(t.Skeleton,"bg",`rgba(${n("palette-text-primaryChannel")} / 0.13)`),Q(t.Slider,"primaryTrack",(0,s.Nd)(t.primary.main,.5)),Q(t.Slider,"secondaryTrack",(0,s.Nd)(t.secondary.main,.5)),Q(t.Slider,"errorTrack",(0,s.Nd)(t.error.main,.5)),Q(t.Slider,"infoTrack",(0,s.Nd)(t.info.main,.5)),Q(t.Slider,"successTrack",(0,s.Nd)(t.success.main,.5)),Q(t.Slider,"warningTrack",(0,s.Nd)(t.warning.main,.5));const e=(0,s.Y9)(t.background.default,.98);Q(t.SnackbarContent,"bg",e),Q(t.SnackbarContent,"color",ee((()=>t.getContrastText(e)))),Q(t.SpeedDialAction,"fabHoverBg",(0,s.Y9)(t.background.paper,.15)),Q(t.StepConnector,"border",n("palette-grey-600")),Q(t.StepContent,"border",n("palette-grey-600")),Q(t.Switch,"defaultColor",n("palette-grey-300")),Q(t.Switch,"defaultDisabledColor",n("palette-grey-600")),Q(t.Switch,"primaryDisabledColor",(0,s.Nd)(t.primary.main,.55)),Q(t.Switch,"secondaryDisabledColor",(0,s.Nd)(t.secondary.main,.55)),Q(t.Switch,"errorDisabledColor",(0,s.Nd)(t.error.main,.55)),Q(t.Switch,"infoDisabledColor",(0,s.Nd)(t.info.main,.55)),Q(t.Switch,"successDisabledColor",(0,s.Nd)(t.success.main,.55)),Q(t.Switch,"warningDisabledColor",(0,s.Nd)(t.warning.main,.55)),Q(t.TableCell,"border",(0,s.Nd)((0,s.Cg)(t.divider,1),.68)),Q(t.Tooltip,"bg",(0,s.Cg)(t.grey[700],.92))}Z(t.background,"default"),Z(t.background,"paper"),Z(t.common,"background"),Z(t.common,"onBackground"),Z(t,"divider"),Object.keys(t).forEach((e=>{const n=t[e];n&&"object"===typeof n&&(n.main&&Q(t[e],"mainChannel",(0,s.Me)(J(n.main))),n.light&&Q(t[e],"lightChannel",(0,s.Me)(J(n.light))),n.dark&&Q(t[e],"darkChannel",(0,s.Me)(J(n.dark))),n.contrastText&&Q(t[e],"contrastTextChannel",(0,s.Me)(J(n.contrastText))),"text"===e&&(Z(t[e],"primary"),Z(t[e],"secondary")),"action"===e&&(n.active&&Z(t[e],"active"),n.selected&&Z(t[e],"selected")))}))}));for(var A=arguments.length,_=new Array(A>1?A-1:0),$=1;$<A;$++)_[$-1]=arguments[$];I=_.reduce(((e,t)=>(0,a.A)(e,t)),I);const R={prefix:o,disableCssColorScheme:i,shouldSkipGeneratingVar:l,getSelector:X(I)},{vars:D,generateThemeVars:M,generateStyleSheets:F}=N(I,R);return I.vars=D,Object.entries(I.colorSchemes[I.defaultColorScheme]).forEach((e=>{let[t,n]=e;I[t]=n})),I.generateThemeVars=M,I.generateStyleSheets=F,I.generateSpacing=function(){return(0,v.A)(c.spacing,(0,x.LX)(this))},I.getColorSchemeSelector=function(e){return function(t){return"media"===e?`@media (prefers-color-scheme: ${t})`:e?e.startsWith("data-")&&!e.includes("%s")?`[${e}="${t}"] &`:"class"===e?`.${t} &`:"data"===e?`[data-${t}] &`:`${e.replace("%s",t)} &`:"&"}}(u),I.spacing=I.generateSpacing(),I.shouldSkipGeneratingVar=l,I.unstable_sxConfig={...T.A,...c?.unstable_sxConfig},I.unstable_sx=function(e){return(0,E.A)({sx:e,theme:this})},I.toRuntimeSource=Y,I}({...l,colorSchemes:d,defaultColorScheme:u,..."boolean"!==typeof n&&n},...p)}},5170:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=(0,n(5913).A)()},3582:(e,t,n)=>{"use strict";function r(e){let t;return t=e<1?5.11916*e**2:4.5*Math.log(e+1)+2,Math.round(10*t)/1e3}n.d(t,{A:()=>r})},3375:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r="$$material"},1475:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(7123);const a=e=>(0,r.A)(e)&&"classes"!==e},7123:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=function(e){return"ownerState"!==e&&"theme"!==e&&"sx"!==e&&"as"!==e}},4535:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>o});var r=n(3860),a=n(5170),s=n(3375),i=n(1475);const o=(0,r.Ay)({themeId:s.A,defaultTheme:a.A,rootShouldForwardProp:i.A})},6803:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(7598).A},9662:(e,t,n)=>{"use strict";n.d(t,{A:()=>y});var r=n(5043),a=n(8387),s=n(8610),i=n(6803),o=n(4535),l=n(6870),u=n(8249),c=n(2532),d=n(2372);function h(e){return(0,d.Ay)("MuiSvgIcon",e)}(0,c.A)("MuiSvgIcon",["root","colorPrimary","colorSecondary","colorAction","colorError","colorDisabled","fontSizeInherit","fontSizeSmall","fontSizeMedium","fontSizeLarge"]);var p=n(579);const f=(0,o.Ay)("svg",{name:"MuiSvgIcon",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,"inherit"!==n.color&&t[`color${(0,i.A)(n.color)}`],t[`fontSize${(0,i.A)(n.fontSize)}`]]}})((0,l.A)((e=>{let{theme:t}=e;return{userSelect:"none",width:"1em",height:"1em",display:"inline-block",flexShrink:0,transition:t.transitions?.create?.("fill",{duration:(t.vars??t).transitions?.duration?.shorter}),variants:[{props:e=>!e.hasSvgAsChild,style:{fill:"currentColor"}},{props:{fontSize:"inherit"},style:{fontSize:"inherit"}},{props:{fontSize:"small"},style:{fontSize:t.typography?.pxToRem?.(20)||"1.25rem"}},{props:{fontSize:"medium"},style:{fontSize:t.typography?.pxToRem?.(24)||"1.5rem"}},{props:{fontSize:"large"},style:{fontSize:t.typography?.pxToRem?.(35)||"2.1875rem"}},...Object.entries((t.vars??t).palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars??t).palette?.[n]?.main}}})),{props:{color:"action"},style:{color:(t.vars??t).palette?.action?.active}},{props:{color:"disabled"},style:{color:(t.vars??t).palette?.action?.disabled}},{props:{color:"inherit"},style:{color:void 0}}]}}))),m=r.forwardRef((function(e,t){const n=(0,u.b)({props:e,name:"MuiSvgIcon"}),{children:o,className:l,color:c="inherit",component:d="svg",fontSize:m="medium",htmlColor:g,inheritViewBox:y=!1,titleAccess:b,viewBox:v="0 0 24 24",...x}=n,w=r.isValidElement(o)&&"svg"===o.type,k={...n,color:c,component:d,fontSize:m,instanceFontSize:e.fontSize,inheritViewBox:y,viewBox:v,hasSvgAsChild:w},S={};y||(S.viewBox=v);const I=(e=>{const{color:t,fontSize:n,classes:r}=e,a={root:["root","inherit"!==t&&`color${(0,i.A)(t)}`,`fontSize${(0,i.A)(n)}`]};return(0,s.A)(a,h,r)})(k);return(0,p.jsxs)(f,{as:d,className:(0,a.A)(I.root,l),focusable:"false",color:g,"aria-hidden":!b||void 0,role:b?"img":void 0,ref:t,...S,...x,...w&&o.props,ownerState:k,children:[w?o.props.children:o,b?(0,p.jsx)("title",{children:b}):null]})}));m&&(m.muiName="SvgIcon");const g=m;function y(e,t){function n(n,r){return(0,p.jsx)(g,{"data-testid":`${t}Icon`,ref:r,...n,children:e})}return n.muiName=g.muiName,r.memo(r.forwardRef(n))}},950:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(3468).A},4421:(e,t,n)=>{"use strict";n.r(t),n.d(t,{capitalize:()=>a.A,createChainedFunction:()=>s,createSvgIcon:()=>i.A,debounce:()=>o.A,deprecatedPropType:()=>l,isMuiElement:()=>u.A,ownerDocument:()=>d.A,ownerWindow:()=>h.A,requirePropFactory:()=>p,setRef:()=>f,unstable_ClassNameGenerator:()=>w,unstable_memoTheme:()=>c.A,unstable_useEnhancedEffect:()=>m.A,unstable_useId:()=>g.A,unsupportedProp:()=>y,useControlled:()=>b.A,useEventCallback:()=>v.A,useForkRef:()=>x.A});var r=n(9386),a=n(6803);const s=n(2456).A;var i=n(9662),o=n(950);const l=function(e,t){return()=>null};var u=n(7328),c=n(6870),d=n(2427),h=n(6078);const p=function(e,t){return()=>null};const f=n(6564).A;var m=n(5013),g=n(5879);const y=function(e,t,n,r,a){return null};var b=n(5420),v=n(3319),x=n(5849);const w={configure:e=>{r.A.configure(e)}}},7328:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(5043);const a=function(e,t){return r.isValidElement(e)&&-1!==t.indexOf(e.type.muiName??e.type?._payload?.value?.muiName)}},6870:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});const r={theme:void 0};function a(e){let t,n;return a=>{let s=t;return void 0!==s&&a.theme===n||(r.theme=a.theme,s=e(r),t=s,n=a.theme),s}}},2427:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(1668).A},6078:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(3940).A},5420:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(5043);const a=function(e){let{controlled:t,default:n,name:a,state:s="value"}=e;const{current:i}=r.useRef(void 0!==t),[o,l]=r.useState(n);return[i?t:o,r.useCallback((e=>{i||l(e)}),[])]}},5013:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(4440).A},3319:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(1782).A},5849:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(3462).A},5879:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(5844).A},4984:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>b,q_:()=>v});var r=n(8168),a=n(5043),s=n(918),i=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,o=(0,s.A)((function(e){return i.test(e)||111===e.charCodeAt(0)&&110===e.charCodeAt(1)&&e.charCodeAt(2)<91})),l=n(4575),u=n(1722),c=n(6598),d=n(9436),h=o,p=function(e){return"theme"!==e},f=function(e){return"string"===typeof e&&e.charCodeAt(0)>96?h:p},m=function(e,t,n){var r;if(t){var a=t.shouldForwardProp;r=e.__emotion_forwardProp&&a?function(t){return e.__emotion_forwardProp(t)&&a(t)}:a}return"function"!==typeof r&&n&&(r=e.__emotion_forwardProp),r},g=function(e){var t=e.cache,n=e.serialized,r=e.isStringTag;return(0,u.SF)(t,n,r),(0,d.s)((function(){return(0,u.sk)(t,n,r)})),null},y=function e(t,n){var s,i,o=t.__emotion_real===t,d=o&&t.__emotion_base||t;void 0!==n&&(s=n.label,i=n.target);var h=m(t,n,o),p=h||f(d),y=!p("as");return function(){var b=arguments,v=o&&void 0!==t.__emotion_styles?t.__emotion_styles.slice(0):[];if(void 0!==s&&v.push("label:"+s+";"),null==b[0]||void 0===b[0].raw)v.push.apply(v,b);else{v.push(b[0][0]);for(var x=b.length,w=1;w<x;w++)v.push(b[w],b[0][w])}var k=(0,l.w)((function(e,t,n){var r=y&&e.as||d,s="",o=[],m=e;if(null==e.theme){for(var b in m={},e)m[b]=e[b];m.theme=a.useContext(l.T)}"string"===typeof e.className?s=(0,u.Rk)(t.registered,o,e.className):null!=e.className&&(s=e.className+" ");var x=(0,c.J)(v.concat(o),t.registered,m);s+=t.key+"-"+x.name,void 0!==i&&(s+=" "+i);var w=y&&void 0===h?f(r):p,k={};for(var S in e)y&&"as"===S||w(S)&&(k[S]=e[S]);return k.className=s,n&&(k.ref=n),a.createElement(a.Fragment,null,a.createElement(g,{cache:t,serialized:x,isStringTag:"string"===typeof r}),a.createElement(r,k))}));return k.displayName=void 0!==s?s:"Styled("+("string"===typeof d?d:d.displayName||d.name||"Component")+")",k.defaultProps=t.defaultProps,k.__emotion_real=k,k.__emotion_base=d,k.__emotion_styles=v,k.__emotion_forwardProp=h,Object.defineProperty(k,"toString",{value:function(){return"."+i}}),k.withComponent=function(t,a){return e(t,(0,r.A)({},n,a,{shouldForwardProp:m(k,a,!0)})).apply(void 0,v)},k}}.bind();function b(e,t){return y(e,t)}["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"].forEach((function(e){y[e]=y(e)}));const v=(e,t)=>{Array.isArray(e.__emotion_styles)&&(e.__emotion_styles=t(e.__emotion_styles))}},1136:(e,t,n)=>{"use strict";n.d(t,{EU:()=>l,NI:()=>o,kW:()=>c,vf:()=>u,zu:()=>a});var r=n(3072);const a={xs:0,sm:600,md:900,lg:1200,xl:1536},s={keys:["xs","sm","md","lg","xl"],up:e=>`@media (min-width:${a[e]}px)`},i={containerQueries:e=>({up:t=>{let n="number"===typeof t?t:a[t]||t;return"number"===typeof n&&(n=`${n}px`),e?`@container ${e} (min-width:${n})`:`@container (min-width:${n})`}})};function o(e,t,n){const o=e.theme||{};if(Array.isArray(t)){const e=o.breakpoints||s;return t.reduce(((r,a,s)=>(r[e.up(e.keys[s])]=n(t[s]),r)),{})}if("object"===typeof t){const e=o.breakpoints||s;return Object.keys(t).reduce(((s,l)=>{if((0,r.ob)(e.keys,l)){const e=(0,r.CT)(o.containerQueries?o:i,l);e&&(s[e]=n(t[l],l))}else if(Object.keys(e.values||a).includes(l)){s[e.up(l)]=n(t[l],l)}else{const e=l;s[e]=t[e]}return s}),{})}return n(t)}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=e.keys?.reduce(((t,n)=>(t[e.up(n)]={},t)),{});return t||{}}function u(e,t){return e.reduce(((e,t)=>{const n=e[t];return(!n||0===Object.keys(n).length)&&delete e[t],e}),t)}function c(e){let{values:t,breakpoints:n,base:r}=e;const a=r||function(e,t){if("object"!==typeof e)return{};const n={},r=Object.keys(t);return Array.isArray(e)?r.forEach(((t,r)=>{r<e.length&&(n[t]=!0)})):r.forEach((t=>{null!=e[t]&&(n[t]=!0)})),n}(t,n),s=Object.keys(a);if(0===s.length)return t;let i;return s.reduce(((e,n,r)=>(Array.isArray(t)?(e[n]=null!=t[r]?t[r]:t[i],i=r):"object"===typeof t?(e[n]=null!=t[n]?t[n]:t[i],i=n):e[n]=t,e)),{})}},6596:(e,t,n)=>{"use strict";n.d(t,{X4:()=>h,e$:()=>f,tL:()=>b,eM:()=>d,YL:()=>u,a:()=>g,Cg:()=>p,Me:()=>o,Nd:()=>m,Y9:()=>v,j4:()=>y});var r=n(7868);const a=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MIN_SAFE_INTEGER,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Number.MAX_SAFE_INTEGER;return Math.max(t,Math.min(e,n))};function s(e){return a(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1)}function i(e){if(e.type)return e;if("#"===e.charAt(0))return i(function(e){e=e.slice(1);const t=new RegExp(`.{1,${e.length>=6?2:1}}`,"g");let n=e.match(t);return n&&1===n[0].length&&(n=n.map((e=>e+e))),n?`rgb${4===n.length?"a":""}(${n.map(((e,t)=>t<3?parseInt(e,16):Math.round(parseInt(e,16)/255*1e3)/1e3)).join(", ")})`:""}(e));const t=e.indexOf("("),n=e.substring(0,t);if(!["rgb","rgba","hsl","hsla","color"].includes(n))throw new Error((0,r.A)(9,e));let a,s=e.substring(t+1,e.length-1);if("color"===n){if(s=s.split(" "),a=s.shift(),4===s.length&&"/"===s[3].charAt(0)&&(s[3]=s[3].slice(1)),!["srgb","display-p3","a98-rgb","prophoto-rgb","rec-2020"].includes(a))throw new Error((0,r.A)(10,a))}else s=s.split(",");return s=s.map((e=>parseFloat(e))),{type:n,values:s,colorSpace:a}}const o=(e,t)=>{try{return(e=>{const t=i(e);return t.values.slice(0,3).map(((e,n)=>t.type.includes("hsl")&&0!==n?`${e}%`:e)).join(" ")})(e)}catch(n){return e}};function l(e){const{type:t,colorSpace:n}=e;let{values:r}=e;return t.includes("rgb")?r=r.map(((e,t)=>t<3?parseInt(e,10):e)):t.includes("hsl")&&(r[1]=`${r[1]}%`,r[2]=`${r[2]}%`),r=t.includes("color")?`${n} ${r.join(" ")}`:`${r.join(", ")}`,`${t}(${r})`}function u(e){e=i(e);const{values:t}=e,n=t[0],r=t[1]/100,a=t[2]/100,s=r*Math.min(a,1-a),o=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(e+n/30)%12;return a-s*Math.max(Math.min(t-3,9-t,1),-1)};let u="rgb";const c=[Math.round(255*o(0)),Math.round(255*o(8)),Math.round(255*o(4))];return"hsla"===e.type&&(u+="a",c.push(t[3])),l({type:u,values:c})}function c(e){let t="hsl"===(e=i(e)).type||"hsla"===e.type?i(u(e)).values:e.values;return t=t.map((t=>("color"!==e.type&&(t/=255),t<=.03928?t/12.92:((t+.055)/1.055)**2.4))),Number((.2126*t[0]+.7152*t[1]+.0722*t[2]).toFixed(3))}function d(e,t){const n=c(e),r=c(t);return(Math.max(n,r)+.05)/(Math.min(n,r)+.05)}function h(e,t){return e=i(e),t=s(t),"rgb"!==e.type&&"hsl"!==e.type||(e.type+="a"),"color"===e.type?e.values[3]=`/${t}`:e.values[3]=t,l(e)}function p(e,t,n){try{return h(e,t)}catch(r){return e}}function f(e,t){if(e=i(e),t=s(t),e.type.includes("hsl"))e.values[2]*=1-t;else if(e.type.includes("rgb")||e.type.includes("color"))for(let n=0;n<3;n+=1)e.values[n]*=1-t;return l(e)}function m(e,t,n){try{return f(e,t)}catch(r){return e}}function g(e,t){if(e=i(e),t=s(t),e.type.includes("hsl"))e.values[2]+=(100-e.values[2])*t;else if(e.type.includes("rgb"))for(let n=0;n<3;n+=1)e.values[n]+=(255-e.values[n])*t;else if(e.type.includes("color"))for(let n=0;n<3;n+=1)e.values[n]+=(1-e.values[n])*t;return l(e)}function y(e,t,n){try{return g(e,t)}catch(r){return e}}function b(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.15;return c(e)>.5?f(e,t):g(e,t)}function v(e,t,n){try{return b(e,t)}catch(r){return e}}},3860:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>f,MC:()=>l});var r=n(4984),a=n(9172),s=n(2390),i=n(2768);const o=(0,s.A)();function l(e){return"ownerState"!==e&&"theme"!==e&&"sx"!==e&&"as"!==e}function u(e,t,n){return function(e){for(const t in e)return!1;return!0}(t)?n:t[e]||t}const c=Symbol("mui.processed_props");function d(e,t,n){if(c in e)return e[c];const r={...e,theme:u(t,e.theme,n)};return e[c]=r,r[c]=r,r}function h(e){return e?(t,n)=>n[e]:null}function p(e,t){const n="function"===typeof e?e(t):e;if(Array.isArray(n))return n.flatMap((e=>p(e,t)));if(Array.isArray(n?.variants)){const{variants:e,...r}=n;let a,s=r;e:for(let n=0;n<e.length;n+=1){const r=e[n];if("function"===typeof r.props){if(a??={...t,...t.ownerState,ownerState:t.ownerState},!r.props(a))continue}else for(const e in r.props)if(t[e]!==r.props[e]&&t.ownerState?.[e]!==r.props[e])continue e;Array.isArray(s)||(s=[s]),"function"===typeof r.style?(a??={...t,...t.ownerState,ownerState:t.ownerState},s.push(r.style(a))):s.push(r.style)}return s}return n}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{themeId:t,defaultTheme:n=o,rootShouldForwardProp:s=l,slotShouldForwardProp:c=l}=e,f=e=>(0,i.A)(d(e,t,n));f.__mui_systemSx=!0;return function(e){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,r.q_)(e,(e=>e.filter((e=>!e?.__mui_systemSx))));const{name:o,slot:g,skipVariantsResolver:y,skipSx:b,overridesResolver:v=h(m(g)),...x}=i,w=void 0!==y?y:g&&"Root"!==g&&"root"!==g||!1,k=b||!1;let S=l;"Root"===g||"root"===g?S=s:g?S=c:function(e){return"string"===typeof e&&e.charCodeAt(0)>96}(e)&&(S=void 0);const I=(0,r.Ay)(e,{shouldForwardProp:S,label:undefined,...x}),C=e=>"function"===typeof e&&e.__emotion_real!==e||(0,a.Q)(e)?r=>p(e,d(r,t,n)):e,N=function(r){let a=C(r);for(var s=arguments.length,i=new Array(s>1?s-1:0),l=1;l<s;l++)i[l-1]=arguments[l];const c=i?i.map(C):[];o&&v&&c.push((e=>{const r=u(t,e.theme,n);if(!r.components||!r.components[o]||!r.components[o].styleOverrides)return null;const a=r.components[o].styleOverrides,s={},i=d(e,t,n);for(const t in a)s[t]=p(a[t],i);return v(e,s)})),o&&!w&&c.push((e=>{const r=u(t,e.theme,n),a=r?.components?.[o]?.variants;return a?p({variants:a},d(e,t,n)):null})),k||c.push(f);const h=c.length-i.length;if(Array.isArray(r)&&h>0){const e=new Array(h).fill("");a=[...r,...e],a.raw=[...r.raw,...e]}const m=I(a,...c);return e.muiName&&(m.muiName=e.muiName),m};return I.withConfig&&(N.withConfig=I.withConfig),N}}function m(e){return e?e.charAt(0).toLowerCase()+e.slice(1):e}},6160:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(883);function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:8,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(0,r.LX)({spacing:e});if(e.mui)return e;const n=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return(0===n.length?[1]:n).map((e=>{const n=t(e);return"number"===typeof n?`${n}px`:n})).join(" ")};return n.mui=!0,n}},2390:(e,t,n)=>{"use strict";n.d(t,{A:()=>d});var r=n(9172);const a=e=>{const t=Object.keys(e).map((t=>({key:t,val:e[t]})))||[];return t.sort(((e,t)=>e.val-t.val)),t.reduce(((e,t)=>({...e,[t.key]:t.val})),{})};var s=n(3072);const i={borderRadius:4};var o=n(6160),l=n(2768),u=n(138);function c(e,t){const n=this;if(n.vars){if(!n.colorSchemes?.[e]||"function"!==typeof n.getColorSchemeSelector)return{};let r=n.getColorSchemeSelector(e);return(r.includes("data-")||r.includes("."))&&(r=`*:where(${r.replace(/\s*&$/,"")}) &`),{[r]:t}}return n.palette.mode===e?t:{}}const d=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{breakpoints:t={},palette:n={},spacing:d,shape:h={},...p}=e,f=function(e){const{values:t={xs:0,sm:600,md:900,lg:1200,xl:1536},unit:n="px",step:r=5,...s}=e,i=a(t),o=Object.keys(i);function l(e){return`@media (min-width:${"number"===typeof t[e]?t[e]:e}${n})`}function u(e){return`@media (max-width:${("number"===typeof t[e]?t[e]:e)-r/100}${n})`}function c(e,a){const s=o.indexOf(a);return`@media (min-width:${"number"===typeof t[e]?t[e]:e}${n}) and (max-width:${(-1!==s&&"number"===typeof t[o[s]]?t[o[s]]:a)-r/100}${n})`}return{keys:o,values:i,up:l,down:u,between:c,only:function(e){return o.indexOf(e)+1<o.length?c(e,o[o.indexOf(e)+1]):l(e)},not:function(e){const t=o.indexOf(e);return 0===t?l(o[1]):t===o.length-1?u(o[t]):c(e,o[o.indexOf(e)+1]).replace("@media","@media not all and")},unit:n,...s}}(t),m=(0,o.A)(d);let g=(0,r.A)({breakpoints:f,direction:"ltr",components:{},palette:{mode:"light",...n},spacing:m,shape:{...i,...h}},p);g=(0,s.Ay)(g),g.applyStyles=c;for(var y=arguments.length,b=new Array(y>1?y-1:0),v=1;v<y;v++)b[v-1]=arguments[v];return g=b.reduce(((e,t)=>(0,r.A)(e,t)),g),g.unstable_sxConfig={...u.A,...p?.unstable_sxConfig},g.unstable_sx=function(e){return(0,l.A)({sx:e,theme:this})},g}},3072:(e,t,n)=>{"use strict";function r(e,t){if(!e.containerQueries)return t;const n=Object.keys(t).filter((e=>e.startsWith("@container"))).sort(((e,t)=>{const n=/min-width:\s*([0-9.]+)/;return+(e.match(n)?.[1]||0)-+(t.match(n)?.[1]||0)}));return n.length?n.reduce(((e,n)=>{const r=t[n];return delete e[n],e[n]=r,e}),{...t}):t}function a(e,t){return"@"===t||t.startsWith("@")&&(e.some((e=>t.startsWith(`@${e}`)))||!!t.match(/^@\d/))}function s(e,t){const n=t.match(/^@([^/]+)?\/?(.+)?$/);if(!n)return null;const[,r,a]=n,s=Number.isNaN(+r)?r||0:+r;return e.containerQueries(a).up(s)}function i(e){const t=(e,t)=>e.replace("@media",t?`@container ${t}`:"@container");function n(n,r){n.up=function(){return t(e.breakpoints.up(...arguments),r)},n.down=function(){return t(e.breakpoints.down(...arguments),r)},n.between=function(){return t(e.breakpoints.between(...arguments),r)},n.only=function(){return t(e.breakpoints.only(...arguments),r)},n.not=function(){const n=t(e.breakpoints.not(...arguments),r);return n.includes("not all and")?n.replace("not all and ","").replace("min-width:","width<").replace("max-width:","width>").replace("and","or"):n}}const r={},a=e=>(n(r,e),r);return n(a),{...e,containerQueries:a}}n.d(t,{Ay:()=>i,CT:()=>s,_S:()=>r,ob:()=>a})},5056:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(9172);const a=function(e,t){return t?(0,r.A)(e,t,{clone:!1}):e}},883:(e,t,n)=>{"use strict";n.d(t,{LX:()=>f,MA:()=>p,_W:()=>m,Lc:()=>b,Ms:()=>v});var r=n(1136),a=n(6224),s=n(5056);const i={m:"margin",p:"padding"},o={t:"Top",r:"Right",b:"Bottom",l:"Left",x:["Left","Right"],y:["Top","Bottom"]},l={marginX:"mx",marginY:"my",paddingX:"px",paddingY:"py"},u=function(e){const t={};return n=>(void 0===t[n]&&(t[n]=e(n)),t[n])}((e=>{if(e.length>2){if(!l[e])return[e];e=l[e]}const[t,n]=e.split(""),r=i[t],a=o[n]||"";return Array.isArray(a)?a.map((e=>r+e)):[r+a]})),c=["m","mt","mr","mb","ml","mx","my","margin","marginTop","marginRight","marginBottom","marginLeft","marginX","marginY","marginInline","marginInlineStart","marginInlineEnd","marginBlock","marginBlockStart","marginBlockEnd"],d=["p","pt","pr","pb","pl","px","py","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","paddingX","paddingY","paddingInline","paddingInlineStart","paddingInlineEnd","paddingBlock","paddingBlockStart","paddingBlockEnd"],h=[...c,...d];function p(e,t,n,r){const s=(0,a.Yn)(e,t,!0)??n;return"number"===typeof s||"string"===typeof s?e=>"string"===typeof e?e:"string"===typeof s?`calc(${e} * ${s})`:s*e:Array.isArray(s)?e=>{if("string"===typeof e)return e;const t=Math.abs(e);const n=s[t];return e>=0?n:"number"===typeof n?-n:`-${n}`}:"function"===typeof s?s:()=>{}}function f(e){return p(e,"spacing",8)}function m(e,t){return"string"===typeof t||null==t?t:e(t)}function g(e,t,n,a){if(!t.includes(n))return null;const s=function(e,t){return n=>e.reduce(((e,r)=>(e[r]=m(t,n),e)),{})}(u(n),a),i=e[n];return(0,r.NI)(e,i,s)}function y(e,t){const n=f(e.theme);return Object.keys(e).map((r=>g(e,t,r,n))).reduce(s.A,{})}function b(e){return y(e,c)}function v(e){return y(e,d)}function x(e){return y(e,h)}b.propTypes={},b.filterProps=c,v.propTypes={},v.filterProps=d,x.propTypes={},x.filterProps=h},138:(e,t,n)=>{"use strict";n.d(t,{A:()=>M});var r=n(883),a=n(6224),s=n(5056);const i=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=t.reduce(((e,t)=>(t.filterProps.forEach((n=>{e[n]=t})),e)),{}),a=e=>Object.keys(e).reduce(((t,n)=>r[n]?(0,s.A)(t,r[n](e)):t),{});return a.propTypes={},a.filterProps=t.reduce(((e,t)=>e.concat(t.filterProps)),[]),a};var o=n(1136);function l(e){return"number"!==typeof e?e:`${e}px solid`}function u(e,t){return(0,a.Ay)({prop:e,themeKey:"borders",transform:t})}const c=u("border",l),d=u("borderTop",l),h=u("borderRight",l),p=u("borderBottom",l),f=u("borderLeft",l),m=u("borderColor"),g=u("borderTopColor"),y=u("borderRightColor"),b=u("borderBottomColor"),v=u("borderLeftColor"),x=u("outline",l),w=u("outlineColor"),k=e=>{if(void 0!==e.borderRadius&&null!==e.borderRadius){const t=(0,r.MA)(e.theme,"shape.borderRadius",4,"borderRadius"),n=e=>({borderRadius:(0,r._W)(t,e)});return(0,o.NI)(e,e.borderRadius,n)}return null};k.propTypes={},k.filterProps=["borderRadius"];i(c,d,h,p,f,m,g,y,b,v,k,x,w);const S=e=>{if(void 0!==e.gap&&null!==e.gap){const t=(0,r.MA)(e.theme,"spacing",8,"gap"),n=e=>({gap:(0,r._W)(t,e)});return(0,o.NI)(e,e.gap,n)}return null};S.propTypes={},S.filterProps=["gap"];const I=e=>{if(void 0!==e.columnGap&&null!==e.columnGap){const t=(0,r.MA)(e.theme,"spacing",8,"columnGap"),n=e=>({columnGap:(0,r._W)(t,e)});return(0,o.NI)(e,e.columnGap,n)}return null};I.propTypes={},I.filterProps=["columnGap"];const C=e=>{if(void 0!==e.rowGap&&null!==e.rowGap){const t=(0,r.MA)(e.theme,"spacing",8,"rowGap"),n=e=>({rowGap:(0,r._W)(t,e)});return(0,o.NI)(e,e.rowGap,n)}return null};C.propTypes={},C.filterProps=["rowGap"];i(S,I,C,(0,a.Ay)({prop:"gridColumn"}),(0,a.Ay)({prop:"gridRow"}),(0,a.Ay)({prop:"gridAutoFlow"}),(0,a.Ay)({prop:"gridAutoColumns"}),(0,a.Ay)({prop:"gridAutoRows"}),(0,a.Ay)({prop:"gridTemplateColumns"}),(0,a.Ay)({prop:"gridTemplateRows"}),(0,a.Ay)({prop:"gridTemplateAreas"}),(0,a.Ay)({prop:"gridArea"}));function N(e,t){return"grey"===t?t:e}i((0,a.Ay)({prop:"color",themeKey:"palette",transform:N}),(0,a.Ay)({prop:"bgcolor",cssProperty:"backgroundColor",themeKey:"palette",transform:N}),(0,a.Ay)({prop:"backgroundColor",themeKey:"palette",transform:N}));function T(e){return e<=1&&0!==e?100*e+"%":e}const E=(0,a.Ay)({prop:"width",transform:T}),A=e=>{if(void 0!==e.maxWidth&&null!==e.maxWidth){const t=t=>{const n=e.theme?.breakpoints?.values?.[t]||o.zu[t];return n?"px"!==e.theme?.breakpoints?.unit?{maxWidth:`${n}${e.theme.breakpoints.unit}`}:{maxWidth:n}:{maxWidth:T(t)}};return(0,o.NI)(e,e.maxWidth,t)}return null};A.filterProps=["maxWidth"];const _=(0,a.Ay)({prop:"minWidth",transform:T}),$=(0,a.Ay)({prop:"height",transform:T}),R=(0,a.Ay)({prop:"maxHeight",transform:T}),D=(0,a.Ay)({prop:"minHeight",transform:T}),M=((0,a.Ay)({prop:"size",cssProperty:"width",transform:T}),(0,a.Ay)({prop:"size",cssProperty:"height",transform:T}),i(E,A,_,$,R,D,(0,a.Ay)({prop:"boxSizing"})),{border:{themeKey:"borders",transform:l},borderTop:{themeKey:"borders",transform:l},borderRight:{themeKey:"borders",transform:l},borderBottom:{themeKey:"borders",transform:l},borderLeft:{themeKey:"borders",transform:l},borderColor:{themeKey:"palette"},borderTopColor:{themeKey:"palette"},borderRightColor:{themeKey:"palette"},borderBottomColor:{themeKey:"palette"},borderLeftColor:{themeKey:"palette"},outline:{themeKey:"borders",transform:l},outlineColor:{themeKey:"palette"},borderRadius:{themeKey:"shape.borderRadius",style:k},color:{themeKey:"palette",transform:N},bgcolor:{themeKey:"palette",cssProperty:"backgroundColor",transform:N},backgroundColor:{themeKey:"palette",transform:N},p:{style:r.Ms},pt:{style:r.Ms},pr:{style:r.Ms},pb:{style:r.Ms},pl:{style:r.Ms},px:{style:r.Ms},py:{style:r.Ms},padding:{style:r.Ms},paddingTop:{style:r.Ms},paddingRight:{style:r.Ms},paddingBottom:{style:r.Ms},paddingLeft:{style:r.Ms},paddingX:{style:r.Ms},paddingY:{style:r.Ms},paddingInline:{style:r.Ms},paddingInlineStart:{style:r.Ms},paddingInlineEnd:{style:r.Ms},paddingBlock:{style:r.Ms},paddingBlockStart:{style:r.Ms},paddingBlockEnd:{style:r.Ms},m:{style:r.Lc},mt:{style:r.Lc},mr:{style:r.Lc},mb:{style:r.Lc},ml:{style:r.Lc},mx:{style:r.Lc},my:{style:r.Lc},margin:{style:r.Lc},marginTop:{style:r.Lc},marginRight:{style:r.Lc},marginBottom:{style:r.Lc},marginLeft:{style:r.Lc},marginX:{style:r.Lc},marginY:{style:r.Lc},marginInline:{style:r.Lc},marginInlineStart:{style:r.Lc},marginInlineEnd:{style:r.Lc},marginBlock:{style:r.Lc},marginBlockStart:{style:r.Lc},marginBlockEnd:{style:r.Lc},displayPrint:{cssProperty:!1,transform:e=>({"@media print":{display:e}})},display:{},overflow:{},textOverflow:{},visibility:{},whiteSpace:{},flexBasis:{},flexDirection:{},flexWrap:{},justifyContent:{},alignItems:{},alignContent:{},order:{},flex:{},flexGrow:{},flexShrink:{},alignSelf:{},justifyItems:{},justifySelf:{},gap:{style:S},rowGap:{style:C},columnGap:{style:I},gridColumn:{},gridRow:{},gridAutoFlow:{},gridAutoColumns:{},gridAutoRows:{},gridTemplateColumns:{},gridTemplateRows:{},gridTemplateAreas:{},gridArea:{},position:{},zIndex:{themeKey:"zIndex"},top:{},right:{},bottom:{},left:{},boxShadow:{themeKey:"shadows"},width:{transform:T},maxWidth:{style:A},minWidth:{transform:T},height:{transform:T},maxHeight:{transform:T},minHeight:{transform:T},boxSizing:{},font:{themeKey:"font"},fontFamily:{themeKey:"typography"},fontSize:{themeKey:"typography"},fontStyle:{themeKey:"typography"},fontWeight:{themeKey:"typography"},letterSpacing:{},textTransform:{},lineHeight:{},textAlign:{},typography:{cssProperty:!1,themeKey:"typography"}})},2768:(e,t,n)=>{"use strict";n.d(t,{A:()=>c});var r=n(7598),a=n(5056),s=n(6224),i=n(1136),o=n(3072),l=n(138);const u=function(){function e(e,t,n,a){const o={[e]:t,theme:n},l=a[e];if(!l)return{[e]:t};const{cssProperty:u=e,themeKey:c,transform:d,style:h}=l;if(null==t)return null;if("typography"===c&&"inherit"===t)return{[e]:t};const p=(0,s.Yn)(n,c)||{};if(h)return h(o);return(0,i.NI)(o,t,(t=>{let n=(0,s.BO)(p,d,t);return t===n&&"string"===typeof t&&(n=(0,s.BO)(p,d,`${e}${"default"===t?"":(0,r.A)(t)}`,t)),!1===u?n:{[u]:n}}))}return function t(n){const{sx:r,theme:s={}}=n||{};if(!r)return null;const u=s.unstable_sxConfig??l.A;function c(n){let r=n;if("function"===typeof n)r=n(s);else if("object"!==typeof n)return n;if(!r)return null;const l=(0,i.EU)(s.breakpoints),c=Object.keys(l);let d=l;return Object.keys(r).forEach((n=>{const o=(l=r[n],c=s,"function"===typeof l?l(c):l);var l,c;if(null!==o&&void 0!==o)if("object"===typeof o)if(u[n])d=(0,a.A)(d,e(n,o,s,u));else{const e=(0,i.NI)({theme:s},o,(e=>({[n]:e})));!function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=t.reduce(((e,t)=>e.concat(Object.keys(t))),[]),a=new Set(r);return t.every((e=>a.size===Object.keys(e).length))}(e,o)?d=(0,a.A)(d,e):d[n]=t({sx:o,theme:s})}else d=(0,a.A)(d,e(n,o,s,u))})),(0,o._S)(s,(0,i.vf)(c,d))}return Array.isArray(r)?r.map(c):c(r)}}();u.filterProps=["sx"];const c=u},6224:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>o,BO:()=>i,Yn:()=>s});var r=n(7598),a=n(1136);function s(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(!t||"string"!==typeof t)return null;if(e&&e.vars&&n){const n=`vars.${t}`.split(".").reduce(((e,t)=>e&&e[t]?e[t]:null),e);if(null!=n)return n}return t.split(".").reduce(((e,t)=>e&&null!=e[t]?e[t]:null),e)}function i(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n;return r="function"===typeof e?e(n):Array.isArray(e)?e[n]||a:s(e,n)||a,t&&(r=t(r,a,e)),r}const o=function(e){const{prop:t,cssProperty:n=e.prop,themeKey:o,transform:l}=e,u=e=>{if(null==e[t])return null;const u=e[t],c=s(e.theme,o)||{};return(0,a.NI)(e,u,(e=>{let a=i(c,l,e);return e===a&&"string"===typeof e&&(a=i(c,l,`${t}${"default"===e?"":(0,r.A)(e)}`,e)),!1===n?a:{[n]:a}}))};return u.propTypes={},u.filterProps=[t],u}},9386:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});const r=e=>e,a=(()=>{let e=r;return{configure(t){e=t},generate:t=>e(t),reset(){e=r}}})()},7598:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(7868);function a(e){if("string"!==typeof e)throw new Error((0,r.A)(7));return e.charAt(0).toUpperCase()+e.slice(1)}},8610:(e,t,n)=>{"use strict";function r(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;const r={};for(const a in e){const s=e[a];let i="",o=!0;for(let e=0;e<s.length;e+=1){const r=s[e];r&&(i+=(!0===o?"":" ")+t(r),o=!1,n&&n[r]&&(i+=" "+n[r]))}r[a]=i}return r}n.d(t,{A:()=>r})},2456:(e,t,n)=>{"use strict";function r(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.reduce(((e,t)=>null==t?e:function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];e.apply(this,r),t.apply(this,r)}),(()=>{}))}n.d(t,{A:()=>r})},3468:(e,t,n)=>{"use strict";function r(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:166;function r(){for(var r=arguments.length,a=new Array(r),s=0;s<r;s++)a[s]=arguments[s];clearTimeout(t),t=setTimeout((()=>{e.apply(this,a)}),n)}return r.clear=()=>{clearTimeout(t)},r}n.d(t,{A:()=>r})},9172:(e,t,n)=>{"use strict";function r(e){if("object"!==typeof e||null===e)return!1;const t=Object.getPrototypeOf(e);return(null===t||t===Object.prototype||null===Object.getPrototypeOf(t))&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)}function a(e){if(!r(e))return e;const t={};return Object.keys(e).forEach((n=>{t[n]=a(e[n])})),t}function s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{clone:!0};const i=n.clone?{...e}:e;return r(e)&&r(t)&&Object.keys(t).forEach((o=>{r(t[o])&&Object.prototype.hasOwnProperty.call(e,o)&&r(e[o])?i[o]=s(e[o],t[o],n):n.clone?i[o]=r(t[o])?a(t[o]):t[o]:i[o]=t[o]})),i}n.d(t,{A:()=>s,Q:()=>r})},7868:(e,t,n)=>{"use strict";function r(e){let t="https://mui.com/production-error/?code="+e;for(let n=1;n<arguments.length;n+=1)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified MUI error #"+e+"; visit "+t+" for the full message."}n.d(t,{A:()=>r})},2372:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>s});var r=n(9386);const a={active:"active",checked:"checked",completed:"completed",disabled:"disabled",error:"error",expanded:"expanded",focused:"focused",focusVisible:"focusVisible",open:"open",readOnly:"readOnly",required:"required",selected:"selected"};function s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const s=a[t];return s?`${n}-${s}`:`${r.A.generate(e)}-${t}`}},2532:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(2372);function a(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const a={};return t.forEach((t=>{a[t]=(0,r.Ay)(e,t,n)})),a}},1668:(e,t,n)=>{"use strict";function r(e){return e&&e.ownerDocument||document}n.d(t,{A:()=>r})},3940:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(1668);function a(e){return(0,r.A)(e).defaultView||window}},3030:(e,t,n)=>{"use strict";function r(e,t){const n={...t};for(const a in e)if(Object.prototype.hasOwnProperty.call(e,a)){const s=a;if("components"===s||"slots"===s)n[s]={...e[s],...n[s]};else if("componentsProps"===s||"slotProps"===s){const a=e[s],i=t[s];if(i)if(a){n[s]={...i};for(const e in a)if(Object.prototype.hasOwnProperty.call(a,e)){const t=e;n[s][t]=r(a[t],i[t])}}else n[s]=i;else n[s]=a||{}}else void 0===n[s]&&(n[s]=e[s])}return n}n.d(t,{A:()=>r})},6564:(e,t,n)=>{"use strict";function r(e,t){"function"===typeof e?e(t):e&&(e.current=t)}n.d(t,{A:()=>r})},4440:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(5043);const a="undefined"!==typeof window?r.useLayoutEffect:r.useEffect},1782:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var r=n(5043),a=n(4440);const s=function(e){const t=r.useRef(e);return(0,a.A)((()=>{t.current=e})),r.useRef((function(){return(0,t.current)(...arguments)})).current}},3462:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var r=n(5043),a=n(6564);function s(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return r.useMemo((()=>t.every((e=>null==e))?null:e=>{t.forEach((t=>{(0,a.A)(t,e)}))}),t)}},5844:(e,t,n)=>{"use strict";var r;n.d(t,{A:()=>o});var a=n(5043);let s=0;const i=(r||(r=n.t(a,2)))["useId".toString()];function o(e){if(void 0!==i){const t=i();return e??t}return function(e){const[t,n]=a.useState(e),r=e||t;return a.useEffect((()=>{null==t&&(s+=1,n(`mui-${s}`))}),[t]),r}(e)}},8818:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(C){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},s={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=s[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(s[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=a[e])?r:(n=l(e,e<0?-1:0,!1),i&&(a[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?o(-e,t).neg():l(e%h|0,e/h|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var a=o(u(n,8)),s=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),d=parseInt(e.substring(i,i+l),n);if(l<8){var h=o(u(n,l));s=s.mul(h).add(o(d))}else s=(s=s.mul(a)).add(o(d))}return s.unsigned=t,s}function d(e,t){return"number"===typeof e?o(e,t):"string"===typeof e?c(e,t):l(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var v=i(1,!0);n.UONE=v;var x=i(-1);n.NEG_ONE=x;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=o(u(e,6),this.unsigned),s=this,i="";;){var l=s.div(a),c=(s.sub(l.mul(a)).toInt()>>>0).toString(e);if((s=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},I.neg=I.negate,I.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,h=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,h+=(p+=a+u)>>>16,c+=(h+=n+o)>>>16,c+=t+i,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(h&=65535),this.unsigned)},I.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=d(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,a=65535&this.high,s=this.low>>>16,i=65535&this.low,u=e.high>>>16,c=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,v=0;return b+=(v+=i*p)>>>16,y+=(b+=s*p)>>>16,b&=65535,y+=(b+=i*h)>>>16,f+=(y+=a*p)>>>16,y&=65535,f+=(y+=s*h)>>>16,y&=65535,f+=(y+=i*c)>>>16,f+=n*p+a*h+s*c+i*u,l((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,a,s;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return v;s=y}else{if(this.eq(S))return e.eq(b)||e.eq(x)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:x:(a=this.sub(e.mul(n)),s=n.add(a.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=g}for(a=this;a.gte(e);){n=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),h=o(n),p=h.mul(e);p.isNegative()||p.gt(a);)p=(h=o(n-=c,this.unsigned)).mul(e);h.isZero()&&(h=b),s=s.add(h),a=a.sub(p)}return s},I.div=I.divide,I.modulo=function(e){return r(e)||(e=d(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(e){return r(e)||(e=d(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return r(e)||(e=d(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return r(e)||(e=d(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},7780:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.BlockCipher,r=e.algo,a=[],s=[],i=[],o=[],l=[],u=[],c=[],d=[],h=[],p=[];!function(){for(var e=[],t=0;t<256;t++)e[t]=t<128?t<<1:t<<1^283;var n=0,r=0;for(t=0;t<256;t++){var f=r^r<<1^r<<2^r<<3^r<<4;f=f>>>8^255&f^99,a[n]=f,s[f]=n;var m=e[n],g=e[m],y=e[g],b=257*e[f]^16843008*f;i[n]=b<<24|b>>>8,o[n]=b<<16|b>>>16,l[n]=b<<8|b>>>24,u[n]=b,b=16843009*y^65537*g^257*m^16843008*n,c[f]=b<<24|b>>>8,d[f]=b<<16|b>>>16,h[f]=b<<8|b>>>24,p[f]=b,n?(n=m^e[e[e[y^m]]],r^=e[e[r]]):n=r=1}}();var f=[0,1,2,4,8,16,32,64,128,27,54],m=r.AES=n.extend({_doReset:function(){if(!this._nRounds||this._keyPriorReset!==this._key){for(var e=this._keyPriorReset=this._key,t=e.words,n=e.sigBytes/4,r=4*((this._nRounds=n+6)+1),s=this._keySchedule=[],i=0;i<r;i++)i<n?s[i]=t[i]:(u=s[i-1],i%n?n>6&&i%n==4&&(u=a[u>>>24]<<24|a[u>>>16&255]<<16|a[u>>>8&255]<<8|a[255&u]):(u=a[(u=u<<8|u>>>24)>>>24]<<24|a[u>>>16&255]<<16|a[u>>>8&255]<<8|a[255&u],u^=f[i/n|0]<<24),s[i]=s[i-n]^u);for(var o=this._invKeySchedule=[],l=0;l<r;l++){if(i=r-l,l%4)var u=s[i];else u=s[i-4];o[l]=l<4||i<=4?u:c[a[u>>>24]]^d[a[u>>>16&255]]^h[a[u>>>8&255]]^p[a[255&u]]}}},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._keySchedule,i,o,l,u,a)},decryptBlock:function(e,t){var n=e[t+1];e[t+1]=e[t+3],e[t+3]=n,this._doCryptBlock(e,t,this._invKeySchedule,c,d,h,p,s),n=e[t+1],e[t+1]=e[t+3],e[t+3]=n},_doCryptBlock:function(e,t,n,r,a,s,i,o){for(var l=this._nRounds,u=e[t]^n[0],c=e[t+1]^n[1],d=e[t+2]^n[2],h=e[t+3]^n[3],p=4,f=1;f<l;f++){var m=r[u>>>24]^a[c>>>16&255]^s[d>>>8&255]^i[255&h]^n[p++],g=r[c>>>24]^a[d>>>16&255]^s[h>>>8&255]^i[255&u]^n[p++],y=r[d>>>24]^a[h>>>16&255]^s[u>>>8&255]^i[255&c]^n[p++],b=r[h>>>24]^a[u>>>16&255]^s[c>>>8&255]^i[255&d]^n[p++];u=m,c=g,d=y,h=b}m=(o[u>>>24]<<24|o[c>>>16&255]<<16|o[d>>>8&255]<<8|o[255&h])^n[p++],g=(o[c>>>24]<<24|o[d>>>16&255]<<16|o[h>>>8&255]<<8|o[255&u])^n[p++],y=(o[d>>>24]<<24|o[h>>>16&255]<<16|o[u>>>8&255]<<8|o[255&c])^n[p++],b=(o[h>>>24]<<24|o[u>>>16&255]<<16|o[c>>>8&255]<<8|o[255&d])^n[p++],e[t]=m,e[t+1]=g,e[t+2]=y,e[t+3]=b},keySize:8});e.AES=n._createHelper(m)}(),t.AES)}()},6501:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.BlockCipher,r=e.algo;const a=16,s=[608135816,2242054355,320440878,57701188,2752067618,698298832,137296536,3964562569,1160258022,953160567,3193202383,887688300,3232508343,3380367581,1065670069,3041331479,2450970073,2306472731],i=[[3509652390,2564797868,805139163,3491422135,3101798381,1780907670,3128725573,4046225305,614570311,3012652279,134345442,2240740374,1667834072,1901547113,2757295779,4103290238,227898511,1921955416,1904987480,2182433518,2069144605,3260701109,2620446009,720527379,3318853667,677414384,3393288472,3101374703,2390351024,1614419982,1822297739,2954791486,3608508353,3174124327,2024746970,1432378464,3864339955,2857741204,1464375394,1676153920,1439316330,715854006,3033291828,289532110,2706671279,2087905683,3018724369,1668267050,732546397,1947742710,3462151702,2609353502,2950085171,1814351708,2050118529,680887927,999245976,1800124847,3300911131,1713906067,1641548236,4213287313,1216130144,1575780402,4018429277,3917837745,3693486850,3949271944,596196993,3549867205,258830323,2213823033,772490370,2760122372,1774776394,2652871518,566650946,4142492826,1728879713,2882767088,1783734482,3629395816,2517608232,2874225571,1861159788,326777828,3124490320,2130389656,2716951837,967770486,1724537150,2185432712,2364442137,1164943284,2105845187,998989502,3765401048,2244026483,1075463327,1455516326,1322494562,910128902,469688178,1117454909,936433444,3490320968,3675253459,1240580251,122909385,2157517691,634681816,4142456567,3825094682,3061402683,2540495037,79693498,3249098678,1084186820,1583128258,426386531,1761308591,1047286709,322548459,995290223,1845252383,2603652396,3431023940,2942221577,3202600964,3727903485,1712269319,422464435,3234572375,1170764815,3523960633,3117677531,1434042557,442511882,3600875718,1076654713,1738483198,4213154764,2393238008,3677496056,1014306527,4251020053,793779912,2902807211,842905082,4246964064,1395751752,1040244610,2656851899,3396308128,445077038,3742853595,3577915638,679411651,2892444358,2354009459,1767581616,3150600392,3791627101,3102740896,284835224,4246832056,1258075500,768725851,2589189241,3069724005,3532540348,1274779536,3789419226,2764799539,1660621633,3471099624,4011903706,913787905,3497959166,737222580,2514213453,2928710040,3937242737,1804850592,3499020752,2949064160,2386320175,2390070455,2415321851,4061277028,2290661394,2416832540,1336762016,1754252060,3520065937,3014181293,791618072,3188594551,3933548030,2332172193,3852520463,3043980520,413987798,3465142937,3030929376,4245938359,2093235073,3534596313,375366246,2157278981,2479649556,555357303,3870105701,2008414854,3344188149,4221384143,3956125452,2067696032,3594591187,2921233993,2428461,544322398,577241275,1471733935,610547355,4027169054,1432588573,1507829418,2025931657,3646575487,545086370,48609733,2200306550,1653985193,298326376,1316178497,3007786442,2064951626,458293330,2589141269,3591329599,3164325604,727753846,2179363840,146436021,1461446943,4069977195,705550613,3059967265,3887724982,4281599278,3313849956,1404054877,2845806497,146425753,1854211946],[1266315497,3048417604,3681880366,3289982499,290971e4,1235738493,2632868024,2414719590,3970600049,1771706367,1449415276,3266420449,422970021,1963543593,2690192192,3826793022,1062508698,1531092325,1804592342,2583117782,2714934279,4024971509,1294809318,4028980673,1289560198,2221992742,1669523910,35572830,157838143,1052438473,1016535060,1802137761,1753167236,1386275462,3080475397,2857371447,1040679964,2145300060,2390574316,1461121720,2956646967,4031777805,4028374788,33600511,2920084762,1018524850,629373528,3691585981,3515945977,2091462646,2486323059,586499841,988145025,935516892,3367335476,2599673255,2839830854,265290510,3972581182,2759138881,3795373465,1005194799,847297441,406762289,1314163512,1332590856,1866599683,4127851711,750260880,613907577,1450815602,3165620655,3734664991,3650291728,3012275730,3704569646,1427272223,778793252,1343938022,2676280711,2052605720,1946737175,3164576444,3914038668,3967478842,3682934266,1661551462,3294938066,4011595847,840292616,3712170807,616741398,312560963,711312465,1351876610,322626781,1910503582,271666773,2175563734,1594956187,70604529,3617834859,1007753275,1495573769,4069517037,2549218298,2663038764,504708206,2263041392,3941167025,2249088522,1514023603,1998579484,1312622330,694541497,2582060303,2151582166,1382467621,776784248,2618340202,3323268794,2497899128,2784771155,503983604,4076293799,907881277,423175695,432175456,1378068232,4145222326,3954048622,3938656102,3820766613,2793130115,2977904593,26017576,3274890735,3194772133,1700274565,1756076034,4006520079,3677328699,720338349,1533947780,354530856,688349552,3973924725,1637815568,332179504,3949051286,53804574,2852348879,3044236432,1282449977,3583942155,3416972820,4006381244,1617046695,2628476075,3002303598,1686838959,431878346,2686675385,1700445008,1080580658,1009431731,832498133,3223435511,2605976345,2271191193,2516031870,1648197032,4164389018,2548247927,300782431,375919233,238389289,3353747414,2531188641,2019080857,1475708069,455242339,2609103871,448939670,3451063019,1395535956,2413381860,1841049896,1491858159,885456874,4264095073,4001119347,1565136089,3898914787,1108368660,540939232,1173283510,2745871338,3681308437,4207628240,3343053890,4016749493,1699691293,1103962373,3625875870,2256883143,3830138730,1031889488,3479347698,1535977030,4236805024,3251091107,2132092099,1774941330,1199868427,1452454533,157007616,2904115357,342012276,595725824,1480756522,206960106,497939518,591360097,863170706,2375253569,3596610801,1814182875,2094937945,3421402208,1082520231,3463918190,2785509508,435703966,3908032597,1641649973,2842273706,3305899714,1510255612,2148256476,2655287854,3276092548,4258621189,236887753,3681803219,274041037,1734335097,3815195456,3317970021,1899903192,1026095262,4050517792,356393447,2410691914,3873677099,3682840055],[3913112168,2491498743,4132185628,2489919796,1091903735,1979897079,3170134830,3567386728,3557303409,857797738,1136121015,1342202287,507115054,2535736646,337727348,3213592640,1301675037,2528481711,1895095763,1721773893,3216771564,62756741,2142006736,835421444,2531993523,1442658625,3659876326,2882144922,676362277,1392781812,170690266,3921047035,1759253602,3611846912,1745797284,664899054,1329594018,3901205900,3045908486,2062866102,2865634940,3543621612,3464012697,1080764994,553557557,3656615353,3996768171,991055499,499776247,1265440854,648242737,3940784050,980351604,3713745714,1749149687,3396870395,4211799374,3640570775,1161844396,3125318951,1431517754,545492359,4268468663,3499529547,1437099964,2702547544,3433638243,2581715763,2787789398,1060185593,1593081372,2418618748,4260947970,69676912,2159744348,86519011,2512459080,3838209314,1220612927,3339683548,133810670,1090789135,1078426020,1569222167,845107691,3583754449,4072456591,1091646820,628848692,1613405280,3757631651,526609435,236106946,48312990,2942717905,3402727701,1797494240,859738849,992217954,4005476642,2243076622,3870952857,3732016268,765654824,3490871365,2511836413,1685915746,3888969200,1414112111,2273134842,3281911079,4080962846,172450625,2569994100,980381355,4109958455,2819808352,2716589560,2568741196,3681446669,3329971472,1835478071,660984891,3704678404,4045999559,3422617507,3040415634,1762651403,1719377915,3470491036,2693910283,3642056355,3138596744,1364962596,2073328063,1983633131,926494387,3423689081,2150032023,4096667949,1749200295,3328846651,309677260,2016342300,1779581495,3079819751,111262694,1274766160,443224088,298511866,1025883608,3806446537,1145181785,168956806,3641502830,3584813610,1689216846,3666258015,3200248200,1692713982,2646376535,4042768518,1618508792,1610833997,3523052358,4130873264,2001055236,3610705100,2202168115,4028541809,2961195399,1006657119,2006996926,3186142756,1430667929,3210227297,1314452623,4074634658,4101304120,2273951170,1399257539,3367210612,3027628629,1190975929,2062231137,2333990788,2221543033,2438960610,1181637006,548689776,2362791313,3372408396,3104550113,3145860560,296247880,1970579870,3078560182,3769228297,1714227617,3291629107,3898220290,166772364,1251581989,493813264,448347421,195405023,2709975567,677966185,3703036547,1463355134,2715995803,1338867538,1343315457,2802222074,2684532164,233230375,2599980071,2000651841,3277868038,1638401717,4028070440,3237316320,6314154,819756386,300326615,590932579,1405279636,3267499572,3150704214,2428286686,3959192993,3461946742,1862657033,1266418056,963775037,2089974820,2263052895,1917689273,448879540,3550394620,3981727096,150775221,3627908307,1303187396,508620638,2975983352,2726630617,1817252668,1876281319,1457606340,908771278,3720792119,3617206836,2455994898,1729034894,1080033504],[976866871,3556439503,2881648439,1522871579,1555064734,1336096578,3548522304,2579274686,3574697629,3205460757,3593280638,3338716283,3079412587,564236357,2993598910,1781952180,1464380207,3163844217,3332601554,1699332808,1393555694,1183702653,3581086237,1288719814,691649499,2847557200,2895455976,3193889540,2717570544,1781354906,1676643554,2592534050,3230253752,1126444790,2770207658,2633158820,2210423226,2615765581,2414155088,3127139286,673620729,2805611233,1269405062,4015350505,3341807571,4149409754,1057255273,2012875353,2162469141,2276492801,2601117357,993977747,3918593370,2654263191,753973209,36408145,2530585658,25011837,3520020182,2088578344,530523599,2918365339,1524020338,1518925132,3760827505,3759777254,1202760957,3985898139,3906192525,674977740,4174734889,2031300136,2019492241,3983892565,4153806404,3822280332,352677332,2297720250,60907813,90501309,3286998549,1016092578,2535922412,2839152426,457141659,509813237,4120667899,652014361,1966332200,2975202805,55981186,2327461051,676427537,3255491064,2882294119,3433927263,1307055953,942726286,933058658,2468411793,3933900994,4215176142,1361170020,2001714738,2830558078,3274259782,1222529897,1679025792,2729314320,3714953764,1770335741,151462246,3013232138,1682292957,1483529935,471910574,1539241949,458788160,3436315007,1807016891,3718408830,978976581,1043663428,3165965781,1927990952,4200891579,2372276910,3208408903,3533431907,1412390302,2931980059,4132332400,1947078029,3881505623,4168226417,2941484381,1077988104,1320477388,886195818,18198404,3786409e3,2509781533,112762804,3463356488,1866414978,891333506,18488651,661792760,1628790961,3885187036,3141171499,876946877,2693282273,1372485963,791857591,2686433993,3759982718,3167212022,3472953795,2716379847,445679433,3561995674,3504004811,3574258232,54117162,3331405415,2381918588,3769707343,4154350007,1140177722,4074052095,668550556,3214352940,367459370,261225585,2610173221,4209349473,3468074219,3265815641,314222801,3066103646,3808782860,282218597,3406013506,3773591054,379116347,1285071038,846784868,2669647154,3771962079,3550491691,2305946142,453669953,1268987020,3317592352,3279303384,3744833421,2610507566,3859509063,266596637,3847019092,517658769,3462560207,3443424879,370717030,4247526661,2224018117,4143653529,4112773975,2788324899,2477274417,1456262402,2901442914,1517677493,1846949527,2295493580,3734397586,2176403920,1280348187,1908823572,3871786941,846861322,1172426758,3287448474,3383383037,1655181056,3139813346,901632758,1897031941,2986607138,3066810236,3447102507,1393639104,373351379,950779232,625454576,3124240540,4148612726,2007998917,544563296,2244738638,2330496472,2058025392,1291430526,424198748,50039436,29584100,3605783033,2429876329,2791104160,1057563949,3255363231,3075367218,3463963227,1469046755,985887462]];var o={pbox:[],sbox:[]};function l(e,t){let n=t>>24&255,r=t>>16&255,a=t>>8&255,s=255&t,i=e.sbox[0][n]+e.sbox[1][r];return i^=e.sbox[2][a],i+=e.sbox[3][s],i}function u(e,t,n){let r,s=t,i=n;for(let o=0;o<a;++o)s^=e.pbox[o],i=l(e,s)^i,r=s,s=i,i=r;return r=s,s=i,i=r,i^=e.pbox[a],s^=e.pbox[a+1],{left:s,right:i}}function c(e,t,n){let r,s=t,i=n;for(let o=a+1;o>1;--o)s^=e.pbox[o],i=l(e,s)^i,r=s,s=i,i=r;return r=s,s=i,i=r,i^=e.pbox[1],s^=e.pbox[0],{left:s,right:i}}function d(e,t,n){for(let a=0;a<4;a++){e.sbox[a]=[];for(let t=0;t<256;t++)e.sbox[a][t]=i[a][t]}let r=0;for(let i=0;i<a+2;i++)e.pbox[i]=s[i]^t[r],r++,r>=n&&(r=0);let o=0,l=0,c=0;for(let s=0;s<a+2;s+=2)c=u(e,o,l),o=c.left,l=c.right,e.pbox[s]=o,e.pbox[s+1]=l;for(let a=0;a<4;a++)for(let t=0;t<256;t+=2)c=u(e,o,l),o=c.left,l=c.right,e.sbox[a][t]=o,e.sbox[a][t+1]=l;return!0}var h=r.Blowfish=n.extend({_doReset:function(){if(this._keyPriorReset!==this._key){var e=this._keyPriorReset=this._key,t=e.words,n=e.sigBytes/4;d(o,t,n)}},encryptBlock:function(e,t){var n=u(o,e[t],e[t+1]);e[t]=n.left,e[t+1]=n.right},decryptBlock:function(e,t){var n=c(o,e[t],e[t+1]);e[t]=n.left,e[t+1]=n.right},blockSize:2,keySize:4,ivSize:2});e.Blowfish=n._createHelper(h)}(),t.Blowfish)}()},2238:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8211),void(t.lib.Cipher||function(e){var n=t,r=n.lib,a=r.Base,s=r.WordArray,i=r.BufferedBlockAlgorithm,o=n.enc,l=(o.Utf8,o.Base64),u=n.algo.EvpKDF,c=r.Cipher=i.extend({cfg:a.extend(),createEncryptor:function(e,t){return this.create(this._ENC_XFORM_MODE,e,t)},createDecryptor:function(e,t){return this.create(this._DEC_XFORM_MODE,e,t)},init:function(e,t,n){this.cfg=this.cfg.extend(n),this._xformMode=e,this._key=t,this.reset()},reset:function(){i.reset.call(this),this._doReset()},process:function(e){return this._append(e),this._process()},finalize:function(e){return e&&this._append(e),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function e(e){return"string"==typeof e?v:y}return function(t){return{encrypt:function(n,r,a){return e(r).encrypt(t,n,r,a)},decrypt:function(n,r,a){return e(r).decrypt(t,n,r,a)}}}}()}),d=(r.StreamCipher=c.extend({_doFinalize:function(){return this._process(!0)},blockSize:1}),n.mode={}),h=r.BlockCipherMode=a.extend({createEncryptor:function(e,t){return this.Encryptor.create(e,t)},createDecryptor:function(e,t){return this.Decryptor.create(e,t)},init:function(e,t){this._cipher=e,this._iv=t}}),p=d.CBC=function(){var t=h.extend();function n(t,n,r){var a,s=this._iv;s?(a=s,this._iv=e):a=this._prevBlock;for(var i=0;i<r;i++)t[n+i]^=a[i]}return t.Encryptor=t.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize;n.call(this,e,t,a),r.encryptBlock(e,t),this._prevBlock=e.slice(t,t+a)}}),t.Decryptor=t.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize,s=e.slice(t,t+a);r.decryptBlock(e,t),n.call(this,e,t,a),this._prevBlock=s}}),t}(),f=(n.pad={}).Pkcs7={pad:function(e,t){for(var n=4*t,r=n-e.sigBytes%n,a=r<<24|r<<16|r<<8|r,i=[],o=0;o<r;o+=4)i.push(a);var l=s.create(i,r);e.concat(l)},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},m=(r.BlockCipher=c.extend({cfg:c.cfg.extend({mode:p,padding:f}),reset:function(){var e;c.reset.call(this);var t=this.cfg,n=t.iv,r=t.mode;this._xformMode==this._ENC_XFORM_MODE?e=r.createEncryptor:(e=r.createDecryptor,this._minBufferSize=1),this._mode&&this._mode.__creator==e?this._mode.init(this,n&&n.words):(this._mode=e.call(r,this,n&&n.words),this._mode.__creator=e)},_doProcessBlock:function(e,t){this._mode.processBlock(e,t)},_doFinalize:function(){var e,t=this.cfg.padding;return this._xformMode==this._ENC_XFORM_MODE?(t.pad(this._data,this.blockSize),e=this._process(!0)):(e=this._process(!0),t.unpad(e)),e},blockSize:4}),r.CipherParams=a.extend({init:function(e){this.mixIn(e)},toString:function(e){return(e||this.formatter).stringify(this)}})),g=(n.format={}).OpenSSL={stringify:function(e){var t=e.ciphertext,n=e.salt;return(n?s.create([1398893684,1701076831]).concat(n).concat(t):t).toString(l)},parse:function(e){var t,n=l.parse(e),r=n.words;return 1398893684==r[0]&&1701076831==r[1]&&(t=s.create(r.slice(2,4)),r.splice(0,4),n.sigBytes-=16),m.create({ciphertext:n,salt:t})}},y=r.SerializableCipher=a.extend({cfg:a.extend({format:g}),encrypt:function(e,t,n,r){r=this.cfg.extend(r);var a=e.createEncryptor(n,r),s=a.finalize(t),i=a.cfg;return m.create({ciphertext:s,key:n,iv:i.iv,algorithm:e,mode:i.mode,padding:i.padding,blockSize:e.blockSize,formatter:r.format})},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),e.createDecryptor(n,r).finalize(t.ciphertext)},_parse:function(e,t){return"string"==typeof e?t.parse(e,this):e}}),b=(n.kdf={}).OpenSSL={execute:function(e,t,n,r,a){if(r||(r=s.random(8)),a)i=u.create({keySize:t+n,hasher:a}).compute(e,r);else var i=u.create({keySize:t+n}).compute(e,r);var o=s.create(i.words.slice(t),4*n);return i.sigBytes=4*t,m.create({key:i,iv:o,salt:r})}},v=r.PasswordBasedCipher=y.extend({cfg:y.cfg.extend({kdf:b}),encrypt:function(e,t,n,r){var a=(r=this.cfg.extend(r)).kdf.execute(n,e.keySize,e.ivSize,r.salt,r.hasher);r.iv=a.iv;var s=y.encrypt.call(this,e,t,a.key,r);return s.mixIn(a),s},decrypt:function(e,t,n,r){r=this.cfg.extend(r),t=this._parse(t,r.format);var a=r.kdf.execute(n,e.keySize,e.ivSize,t.salt,r.hasher);return r.iv=a.iv,y.decrypt.call(this,e,t,a.key,r)}})}()))}()},4488:function(e,t,n){e.exports=function(){var e=e||function(e,t){var r;if("undefined"!==typeof window&&window.crypto&&(r=window.crypto),"undefined"!==typeof self&&self.crypto&&(r=self.crypto),"undefined"!==typeof globalThis&&globalThis.crypto&&(r=globalThis.crypto),!r&&"undefined"!==typeof window&&window.msCrypto&&(r=window.msCrypto),!r&&"undefined"!==typeof n.g&&n.g.crypto&&(r=n.g.crypto),!r)try{r=n(477)}catch(g){}var a=function(){if(r){if("function"===typeof r.getRandomValues)try{return r.getRandomValues(new Uint32Array(1))[0]}catch(g){}if("function"===typeof r.randomBytes)try{return r.randomBytes(4).readInt32LE()}catch(g){}}throw new Error("Native crypto module could not be used to get secure random number.")},s=Object.create||function(){function e(){}return function(t){var n;return e.prototype=t,n=new e,e.prototype=null,n}}(),i={},o=i.lib={},l=o.Base={extend:function(e){var t=s(this);return e&&t.mixIn(e),t.hasOwnProperty("init")&&this.init!==t.init||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},u=o.WordArray=l.extend({init:function(e,n){e=this.words=e||[],this.sigBytes=n!=t?n:4*e.length},toString:function(e){return(e||d).stringify(this)},concat:function(e){var t=this.words,n=e.words,r=this.sigBytes,a=e.sigBytes;if(this.clamp(),r%4)for(var s=0;s<a;s++){var i=n[s>>>2]>>>24-s%4*8&255;t[r+s>>>2]|=i<<24-(r+s)%4*8}else for(var o=0;o<a;o+=4)t[r+o>>>2]=n[o>>>2];return this.sigBytes+=a,this},clamp:function(){var t=this.words,n=this.sigBytes;t[n>>>2]&=4294967295<<32-n%4*8,t.length=e.ceil(n/4)},clone:function(){var e=l.clone.call(this);return e.words=this.words.slice(0),e},random:function(e){for(var t=[],n=0;n<e;n+=4)t.push(a());return new u.init(t,e)}}),c=i.enc={},d=c.Hex={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],a=0;a<n;a++){var s=t[a>>>2]>>>24-a%4*8&255;r.push((s>>>4).toString(16)),r.push((15&s).toString(16))}return r.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r+=2)n[r>>>3]|=parseInt(e.substr(r,2),16)<<24-r%8*4;return new u.init(n,t/2)}},h=c.Latin1={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],a=0;a<n;a++){var s=t[a>>>2]>>>24-a%4*8&255;r.push(String.fromCharCode(s))}return r.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r++)n[r>>>2]|=(255&e.charCodeAt(r))<<24-r%4*8;return new u.init(n,t)}},p=c.Utf8={stringify:function(e){try{return decodeURIComponent(escape(h.stringify(e)))}catch(t){throw new Error("Malformed UTF-8 data")}},parse:function(e){return h.parse(unescape(encodeURIComponent(e)))}},f=o.BufferedBlockAlgorithm=l.extend({reset:function(){this._data=new u.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=p.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(t){var n,r=this._data,a=r.words,s=r.sigBytes,i=this.blockSize,o=s/(4*i),l=(o=t?e.ceil(o):e.max((0|o)-this._minBufferSize,0))*i,c=e.min(4*l,s);if(l){for(var d=0;d<l;d+=i)this._doProcessBlock(a,d);n=a.splice(0,l),r.sigBytes-=c}return new u.init(n,c)},clone:function(){var e=l.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0}),m=(o.Hasher=f.extend({cfg:l.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){f.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function(e){return function(t,n){return new e.init(n).finalize(t)}},_createHmacHelper:function(e){return function(t,n){return new m.HMAC.init(e,n).finalize(t)}}}),i.algo={});return i}(Math);return e}()},8523:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib.WordArray;function r(e,t,r){for(var a=[],s=0,i=0;i<t;i++)if(i%4){var o=r[e.charCodeAt(i-1)]<<i%4*2|r[e.charCodeAt(i)]>>>6-i%4*2;a[s>>>2]|=o<<24-s%4*8,s++}return n.create(a,s)}e.enc.Base64={stringify:function(e){var t=e.words,n=e.sigBytes,r=this._map;e.clamp();for(var a=[],s=0;s<n;s+=3)for(var i=(t[s>>>2]>>>24-s%4*8&255)<<16|(t[s+1>>>2]>>>24-(s+1)%4*8&255)<<8|t[s+2>>>2]>>>24-(s+2)%4*8&255,o=0;o<4&&s+.75*o<n;o++)a.push(r.charAt(i>>>6*(3-o)&63));var l=r.charAt(64);if(l)for(;a.length%4;)a.push(l);return a.join("")},parse:function(e){var t=e.length,n=this._map,a=this._reverseMap;if(!a){a=this._reverseMap=[];for(var s=0;s<n.length;s++)a[n.charCodeAt(s)]=s}var i=n.charAt(64);if(i){var o=e.indexOf(i);-1!==o&&(t=o)}return r(e,t,a)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}}(),t.enc.Base64)}()},4646:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib.WordArray;function r(e,t,r){for(var a=[],s=0,i=0;i<t;i++)if(i%4){var o=r[e.charCodeAt(i-1)]<<i%4*2|r[e.charCodeAt(i)]>>>6-i%4*2;a[s>>>2]|=o<<24-s%4*8,s++}return n.create(a,s)}e.enc.Base64url={stringify:function(e,t){void 0===t&&(t=!0);var n=e.words,r=e.sigBytes,a=t?this._safe_map:this._map;e.clamp();for(var s=[],i=0;i<r;i+=3)for(var o=(n[i>>>2]>>>24-i%4*8&255)<<16|(n[i+1>>>2]>>>24-(i+1)%4*8&255)<<8|n[i+2>>>2]>>>24-(i+2)%4*8&255,l=0;l<4&&i+.75*l<r;l++)s.push(a.charAt(o>>>6*(3-l)&63));var u=a.charAt(64);if(u)for(;s.length%4;)s.push(u);return s.join("")},parse:function(e,t){void 0===t&&(t=!0);var n=e.length,a=t?this._safe_map:this._map,s=this._reverseMap;if(!s){s=this._reverseMap=[];for(var i=0;i<a.length;i++)s[a.charCodeAt(i)]=i}var o=a.charAt(64);if(o){var l=e.indexOf(o);-1!==l&&(n=l)}return r(e,n,s)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",_safe_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}}(),t.enc.Base64url)}()},5787:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib.WordArray,r=e.enc;function a(e){return e<<8&4278255360|e>>>8&16711935}r.Utf16=r.Utf16BE={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],a=0;a<n;a+=2){var s=t[a>>>2]>>>16-a%4*8&65535;r.push(String.fromCharCode(s))}return r.join("")},parse:function(e){for(var t=e.length,r=[],a=0;a<t;a++)r[a>>>1]|=e.charCodeAt(a)<<16-a%2*16;return n.create(r,2*t)}},r.Utf16LE={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],s=0;s<n;s+=2){var i=a(t[s>>>2]>>>16-s%4*8&65535);r.push(String.fromCharCode(i))}return r.join("")},parse:function(e){for(var t=e.length,r=[],s=0;s<t;s++)r[s>>>1]|=a(e.charCodeAt(s)<<16-s%2*16);return n.create(r,2*t)}}}(),t.enc.Utf16)}()},8211:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2002),n(4220),function(){var e=t,n=e.lib,r=n.Base,a=n.WordArray,s=e.algo,i=s.MD5,o=s.EvpKDF=r.extend({cfg:r.extend({keySize:4,hasher:i,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var n,r=this.cfg,s=r.hasher.create(),i=a.create(),o=i.words,l=r.keySize,u=r.iterations;o.length<l;){n&&s.update(n),n=s.update(e).finalize(t),s.reset();for(var c=1;c<u;c++)n=s.finalize(n),s.reset();i.concat(n)}return i.sigBytes=4*l,i}});e.EvpKDF=function(e,t,n){return o.create(n).compute(e,t)}}(),t.EvpKDF)}()},4708:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),function(){var e=t,n=e.lib.CipherParams,r=e.enc.Hex;e.format.Hex={stringify:function(e){return e.ciphertext.toString(r)},parse:function(e){var t=r.parse(e);return n.create({ciphertext:t})}}}(),t.format.Hex)}()},4220:function(e,t,n){!function(){var t;e.exports=(t=n(4488),void function(){var e=t,n=e.lib.Base,r=e.enc.Utf8;e.algo.HMAC=n.extend({init:function(e,t){e=this._hasher=new e.init,"string"==typeof t&&(t=r.parse(t));var n=e.blockSize,a=4*n;t.sigBytes>a&&(t=e.finalize(t)),t.clamp();for(var s=this._oKey=t.clone(),i=this._iKey=t.clone(),o=s.words,l=i.words,u=0;u<n;u++)o[u]^=1549556828,l[u]^=909522486;s.sigBytes=i.sigBytes=a,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher,n=t.finalize(e);return t.reset(),t.finalize(this._oKey.clone().concat(n))}})}())}()},6111:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),n(4503),n(5787),n(8523),n(4646),n(4199),n(2002),n(6368),n(1641),n(7061),n(9092),n(6600),n(7423),n(4220),n(3930),n(8211),n(2238),n(1112),n(7962),n(8049),n(6380),n(8099),n(1884),n(9132),n(4423),n(548),n(4087),n(4708),n(7780),n(9475),n(9638),n(8875),n(1659),n(6501),t)}()},4503:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){if("function"==typeof ArrayBuffer){var e=t.lib.WordArray,n=e.init,r=e.init=function(e){if(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),(e instanceof Int8Array||"undefined"!==typeof Uint8ClampedArray&&e instanceof Uint8ClampedArray||e instanceof Int16Array||e instanceof Uint16Array||e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array)&&(e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),e instanceof Uint8Array){for(var t=e.byteLength,r=[],a=0;a<t;a++)r[a>>>2]|=e[a]<<24-a%4*8;n.call(this,r,t)}else n.apply(this,arguments)};r.prototype=e}}(),t.lib.WordArray)}()},4199:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(e){var n=t,r=n.lib,a=r.WordArray,s=r.Hasher,i=n.algo,o=[];!function(){for(var t=0;t<64;t++)o[t]=4294967296*e.abs(e.sin(t+1))|0}();var l=i.MD5=s.extend({_doReset:function(){this._hash=new a.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(e,t){for(var n=0;n<16;n++){var r=t+n,a=e[r];e[r]=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8)}var s=this._hash.words,i=e[t+0],l=e[t+1],p=e[t+2],f=e[t+3],m=e[t+4],g=e[t+5],y=e[t+6],b=e[t+7],v=e[t+8],x=e[t+9],w=e[t+10],k=e[t+11],S=e[t+12],I=e[t+13],C=e[t+14],N=e[t+15],T=s[0],E=s[1],A=s[2],_=s[3];T=u(T,E,A,_,i,7,o[0]),_=u(_,T,E,A,l,12,o[1]),A=u(A,_,T,E,p,17,o[2]),E=u(E,A,_,T,f,22,o[3]),T=u(T,E,A,_,m,7,o[4]),_=u(_,T,E,A,g,12,o[5]),A=u(A,_,T,E,y,17,o[6]),E=u(E,A,_,T,b,22,o[7]),T=u(T,E,A,_,v,7,o[8]),_=u(_,T,E,A,x,12,o[9]),A=u(A,_,T,E,w,17,o[10]),E=u(E,A,_,T,k,22,o[11]),T=u(T,E,A,_,S,7,o[12]),_=u(_,T,E,A,I,12,o[13]),A=u(A,_,T,E,C,17,o[14]),T=c(T,E=u(E,A,_,T,N,22,o[15]),A,_,l,5,o[16]),_=c(_,T,E,A,y,9,o[17]),A=c(A,_,T,E,k,14,o[18]),E=c(E,A,_,T,i,20,o[19]),T=c(T,E,A,_,g,5,o[20]),_=c(_,T,E,A,w,9,o[21]),A=c(A,_,T,E,N,14,o[22]),E=c(E,A,_,T,m,20,o[23]),T=c(T,E,A,_,x,5,o[24]),_=c(_,T,E,A,C,9,o[25]),A=c(A,_,T,E,f,14,o[26]),E=c(E,A,_,T,v,20,o[27]),T=c(T,E,A,_,I,5,o[28]),_=c(_,T,E,A,p,9,o[29]),A=c(A,_,T,E,b,14,o[30]),T=d(T,E=c(E,A,_,T,S,20,o[31]),A,_,g,4,o[32]),_=d(_,T,E,A,v,11,o[33]),A=d(A,_,T,E,k,16,o[34]),E=d(E,A,_,T,C,23,o[35]),T=d(T,E,A,_,l,4,o[36]),_=d(_,T,E,A,m,11,o[37]),A=d(A,_,T,E,b,16,o[38]),E=d(E,A,_,T,w,23,o[39]),T=d(T,E,A,_,I,4,o[40]),_=d(_,T,E,A,i,11,o[41]),A=d(A,_,T,E,f,16,o[42]),E=d(E,A,_,T,y,23,o[43]),T=d(T,E,A,_,x,4,o[44]),_=d(_,T,E,A,S,11,o[45]),A=d(A,_,T,E,N,16,o[46]),T=h(T,E=d(E,A,_,T,p,23,o[47]),A,_,i,6,o[48]),_=h(_,T,E,A,b,10,o[49]),A=h(A,_,T,E,C,15,o[50]),E=h(E,A,_,T,g,21,o[51]),T=h(T,E,A,_,S,6,o[52]),_=h(_,T,E,A,f,10,o[53]),A=h(A,_,T,E,w,15,o[54]),E=h(E,A,_,T,l,21,o[55]),T=h(T,E,A,_,v,6,o[56]),_=h(_,T,E,A,N,10,o[57]),A=h(A,_,T,E,y,15,o[58]),E=h(E,A,_,T,I,21,o[59]),T=h(T,E,A,_,m,6,o[60]),_=h(_,T,E,A,k,10,o[61]),A=h(A,_,T,E,p,15,o[62]),E=h(E,A,_,T,x,21,o[63]),s[0]=s[0]+T|0,s[1]=s[1]+E|0,s[2]=s[2]+A|0,s[3]=s[3]+_|0},_doFinalize:function(){var t=this._data,n=t.words,r=8*this._nDataBytes,a=8*t.sigBytes;n[a>>>5]|=128<<24-a%32;var s=e.floor(r/4294967296),i=r;n[15+(a+64>>>9<<4)]=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),n[14+(a+64>>>9<<4)]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),t.sigBytes=4*(n.length+1),this._process();for(var o=this._hash,l=o.words,u=0;u<4;u++){var c=l[u];l[u]=16711935&(c<<8|c>>>24)|4278255360&(c<<24|c>>>8)}return o},clone:function(){var e=s.clone.call(this);return e._hash=this._hash.clone(),e}});function u(e,t,n,r,a,s,i){var o=e+(t&n|~t&r)+a+i;return(o<<s|o>>>32-s)+t}function c(e,t,n,r,a,s,i){var o=e+(t&r|n&~r)+a+i;return(o<<s|o>>>32-s)+t}function d(e,t,n,r,a,s,i){var o=e+(t^n^r)+a+i;return(o<<s|o>>>32-s)+t}function h(e,t,n,r,a,s,i){var o=e+(n^(t|~r))+a+i;return(o<<s|o>>>32-s)+t}n.MD5=s._createHelper(l),n.HmacMD5=s._createHmacHelper(l)}(Math),t.MD5)}()},1112:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.CFB=function(){var e=t.lib.BlockCipherMode.extend();function n(e,t,n,r){var a,s=this._iv;s?(a=s.slice(0),this._iv=void 0):a=this._prevBlock,r.encryptBlock(a,0);for(var i=0;i<n;i++)e[t+i]^=a[i]}return e.Encryptor=e.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize;n.call(this,e,t,a,r),this._prevBlock=e.slice(t,t+a)}}),e.Decryptor=e.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize,s=e.slice(t,t+a);n.call(this,e,t,a,r),this._prevBlock=s}}),e}(),t.mode.CFB)}()},8049:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.CTRGladman=function(){var e=t.lib.BlockCipherMode.extend();function n(e){if(255===(e>>24&255)){var t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}else e+=1<<24;return e}function r(e){return 0===(e[0]=n(e[0]))&&(e[1]=n(e[1])),e}var a=e.Encryptor=e.extend({processBlock:function(e,t){var n=this._cipher,a=n.blockSize,s=this._iv,i=this._counter;s&&(i=this._counter=s.slice(0),this._iv=void 0),r(i);var o=i.slice(0);n.encryptBlock(o,0);for(var l=0;l<a;l++)e[t+l]^=o[l]}});return e.Decryptor=a,e}(),t.mode.CTRGladman)}()},7962:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.CTR=function(){var e=t.lib.BlockCipherMode.extend(),n=e.Encryptor=e.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize,a=this._iv,s=this._counter;a&&(s=this._counter=a.slice(0),this._iv=void 0);var i=s.slice(0);n.encryptBlock(i,0),s[r-1]=s[r-1]+1|0;for(var o=0;o<r;o++)e[t+o]^=i[o]}});return e.Decryptor=n,e}(),t.mode.CTR)}()},8099:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.ECB=function(){var e=t.lib.BlockCipherMode.extend();return e.Encryptor=e.extend({processBlock:function(e,t){this._cipher.encryptBlock(e,t)}}),e.Decryptor=e.extend({processBlock:function(e,t){this._cipher.decryptBlock(e,t)}}),e}(),t.mode.ECB)}()},6380:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.OFB=function(){var e=t.lib.BlockCipherMode.extend(),n=e.Encryptor=e.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize,a=this._iv,s=this._keystream;a&&(s=this._keystream=a.slice(0),this._iv=void 0),n.encryptBlock(s,0);for(var i=0;i<r;i++)e[t+i]^=s[i]}});return e.Decryptor=n,e}(),t.mode.OFB)}()},1884:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.AnsiX923={pad:function(e,t){var n=e.sigBytes,r=4*t,a=r-n%r,s=n+a-1;e.clamp(),e.words[s>>>2]|=a<<24-s%4*8,e.sigBytes+=a},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},t.pad.Ansix923)}()},9132:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.Iso10126={pad:function(e,n){var r=4*n,a=r-e.sigBytes%r;e.concat(t.lib.WordArray.random(a-1)).concat(t.lib.WordArray.create([a<<24],1))},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},t.pad.Iso10126)}()},4423:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.Iso97971={pad:function(e,n){e.concat(t.lib.WordArray.create([2147483648],1)),t.pad.ZeroPadding.pad(e,n)},unpad:function(e){t.pad.ZeroPadding.unpad(e),e.sigBytes--}},t.pad.Iso97971)}()},4087:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.NoPadding={pad:function(){},unpad:function(){}},t.pad.NoPadding)}()},548:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.ZeroPadding={pad:function(e,t){var n=4*t;e.clamp(),e.sigBytes+=n-(e.sigBytes%n||n)},unpad:function(e){var t=e.words,n=e.sigBytes-1;for(n=e.sigBytes-1;n>=0;n--)if(t[n>>>2]>>>24-n%4*8&255){e.sigBytes=n+1;break}}},t.pad.ZeroPadding)}()},3930:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(6368),n(4220),function(){var e=t,n=e.lib,r=n.Base,a=n.WordArray,s=e.algo,i=s.SHA256,o=s.HMAC,l=s.PBKDF2=r.extend({cfg:r.extend({keySize:4,hasher:i,iterations:25e4}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var n=this.cfg,r=o.create(n.hasher,e),s=a.create(),i=a.create([1]),l=s.words,u=i.words,c=n.keySize,d=n.iterations;l.length<c;){var h=r.update(t).finalize(i);r.reset();for(var p=h.words,f=p.length,m=h,g=1;g<d;g++){m=r.finalize(m),r.reset();for(var y=m.words,b=0;b<f;b++)p[b]^=y[b]}s.concat(h),u[0]++}return s.sigBytes=4*c,s}});e.PBKDF2=function(e,t,n){return l.create(n).compute(e,t)}}(),t.PBKDF2)}()},1659:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.StreamCipher,r=e.algo,a=[],s=[],i=[],o=r.RabbitLegacy=n.extend({_doReset:function(){var e=this._key.words,t=this.cfg.iv,n=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],r=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];this._b=0;for(var a=0;a<4;a++)l.call(this);for(a=0;a<8;a++)r[a]^=n[a+4&7];if(t){var s=t.words,i=s[0],o=s[1],u=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),c=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),d=u>>>16|4294901760&c,h=c<<16|65535&u;for(r[0]^=u,r[1]^=d,r[2]^=c,r[3]^=h,r[4]^=u,r[5]^=d,r[6]^=c,r[7]^=h,a=0;a<4;a++)l.call(this)}},_doProcessBlock:function(e,t){var n=this._X;l.call(this),a[0]=n[0]^n[5]>>>16^n[3]<<16,a[1]=n[2]^n[7]>>>16^n[5]<<16,a[2]=n[4]^n[1]>>>16^n[7]<<16,a[3]=n[6]^n[3]>>>16^n[1]<<16;for(var r=0;r<4;r++)a[r]=16711935&(a[r]<<8|a[r]>>>24)|4278255360&(a[r]<<24|a[r]>>>8),e[t+r]^=a[r]},blockSize:4,ivSize:2});function l(){for(var e=this._X,t=this._C,n=0;n<8;n++)s[n]=t[n];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<s[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<s[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<s[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<s[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<s[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<s[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<s[6]>>>0?1:0)|0,this._b=t[7]>>>0<s[7]>>>0?1:0,n=0;n<8;n++){var r=e[n]+t[n],a=65535&r,o=r>>>16,l=((a*a>>>17)+a*o>>>15)+o*o,u=((4294901760&r)*r|0)+((65535&r)*r|0);i[n]=l^u}e[0]=i[0]+(i[7]<<16|i[7]>>>16)+(i[6]<<16|i[6]>>>16)|0,e[1]=i[1]+(i[0]<<8|i[0]>>>24)+i[7]|0,e[2]=i[2]+(i[1]<<16|i[1]>>>16)+(i[0]<<16|i[0]>>>16)|0,e[3]=i[3]+(i[2]<<8|i[2]>>>24)+i[1]|0,e[4]=i[4]+(i[3]<<16|i[3]>>>16)+(i[2]<<16|i[2]>>>16)|0,e[5]=i[5]+(i[4]<<8|i[4]>>>24)+i[3]|0,e[6]=i[6]+(i[5]<<16|i[5]>>>16)+(i[4]<<16|i[4]>>>16)|0,e[7]=i[7]+(i[6]<<8|i[6]>>>24)+i[5]|0}e.RabbitLegacy=n._createHelper(o)}(),t.RabbitLegacy)}()},8875:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.StreamCipher,r=e.algo,a=[],s=[],i=[],o=r.Rabbit=n.extend({_doReset:function(){for(var e=this._key.words,t=this.cfg.iv,n=0;n<4;n++)e[n]=16711935&(e[n]<<8|e[n]>>>24)|4278255360&(e[n]<<24|e[n]>>>8);var r=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],a=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];for(this._b=0,n=0;n<4;n++)l.call(this);for(n=0;n<8;n++)a[n]^=r[n+4&7];if(t){var s=t.words,i=s[0],o=s[1],u=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),c=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),d=u>>>16|4294901760&c,h=c<<16|65535&u;for(a[0]^=u,a[1]^=d,a[2]^=c,a[3]^=h,a[4]^=u,a[5]^=d,a[6]^=c,a[7]^=h,n=0;n<4;n++)l.call(this)}},_doProcessBlock:function(e,t){var n=this._X;l.call(this),a[0]=n[0]^n[5]>>>16^n[3]<<16,a[1]=n[2]^n[7]>>>16^n[5]<<16,a[2]=n[4]^n[1]>>>16^n[7]<<16,a[3]=n[6]^n[3]>>>16^n[1]<<16;for(var r=0;r<4;r++)a[r]=16711935&(a[r]<<8|a[r]>>>24)|4278255360&(a[r]<<24|a[r]>>>8),e[t+r]^=a[r]},blockSize:4,ivSize:2});function l(){for(var e=this._X,t=this._C,n=0;n<8;n++)s[n]=t[n];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<s[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<s[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<s[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<s[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<s[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<s[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<s[6]>>>0?1:0)|0,this._b=t[7]>>>0<s[7]>>>0?1:0,n=0;n<8;n++){var r=e[n]+t[n],a=65535&r,o=r>>>16,l=((a*a>>>17)+a*o>>>15)+o*o,u=((4294901760&r)*r|0)+((65535&r)*r|0);i[n]=l^u}e[0]=i[0]+(i[7]<<16|i[7]>>>16)+(i[6]<<16|i[6]>>>16)|0,e[1]=i[1]+(i[0]<<8|i[0]>>>24)+i[7]|0,e[2]=i[2]+(i[1]<<16|i[1]>>>16)+(i[0]<<16|i[0]>>>16)|0,e[3]=i[3]+(i[2]<<8|i[2]>>>24)+i[1]|0,e[4]=i[4]+(i[3]<<16|i[3]>>>16)+(i[2]<<16|i[2]>>>16)|0,e[5]=i[5]+(i[4]<<8|i[4]>>>24)+i[3]|0,e[6]=i[6]+(i[5]<<16|i[5]>>>16)+(i[4]<<16|i[4]>>>16)|0,e[7]=i[7]+(i[6]<<8|i[6]>>>24)+i[5]|0}e.Rabbit=n._createHelper(o)}(),t.Rabbit)}()},9638:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.StreamCipher,r=e.algo,a=r.RC4=n.extend({_doReset:function(){for(var e=this._key,t=e.words,n=e.sigBytes,r=this._S=[],a=0;a<256;a++)r[a]=a;a=0;for(var s=0;a<256;a++){var i=a%n,o=t[i>>>2]>>>24-i%4*8&255;s=(s+r[a]+o)%256;var l=r[a];r[a]=r[s],r[s]=l}this._i=this._j=0},_doProcessBlock:function(e,t){e[t]^=s.call(this)},keySize:8,ivSize:0});function s(){for(var e=this._S,t=this._i,n=this._j,r=0,a=0;a<4;a++){n=(n+e[t=(t+1)%256])%256;var s=e[t];e[t]=e[n],e[n]=s,r|=e[(e[t]+e[n])%256]<<24-8*a}return this._i=t,this._j=n,r}e.RC4=n._createHelper(a);var i=r.RC4Drop=a.extend({cfg:a.cfg.extend({drop:192}),_doReset:function(){a._doReset.call(this);for(var e=this.cfg.drop;e>0;e--)s.call(this)}});e.RC4Drop=n._createHelper(i)}(),t.RC4)}()},7423:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib,r=n.WordArray,a=n.Hasher,s=e.algo,i=r.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),o=r.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),l=r.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),u=r.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),c=r.create([0,1518500249,1859775393,2400959708,2840853838]),d=r.create([1352829926,1548603684,1836072691,2053994217,0]),h=s.RIPEMD160=a.extend({_doReset:function(){this._hash=r.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var n=0;n<16;n++){var r=t+n,a=e[r];e[r]=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8)}var s,h,v,x,w,k,S,I,C,N,T,E=this._hash.words,A=c.words,_=d.words,$=i.words,R=o.words,D=l.words,M=u.words;for(k=s=E[0],S=h=E[1],I=v=E[2],C=x=E[3],N=w=E[4],n=0;n<80;n+=1)T=s+e[t+$[n]]|0,T+=n<16?p(h,v,x)+A[0]:n<32?f(h,v,x)+A[1]:n<48?m(h,v,x)+A[2]:n<64?g(h,v,x)+A[3]:y(h,v,x)+A[4],T=(T=b(T|=0,D[n]))+w|0,s=w,w=x,x=b(v,10),v=h,h=T,T=k+e[t+R[n]]|0,T+=n<16?y(S,I,C)+_[0]:n<32?g(S,I,C)+_[1]:n<48?m(S,I,C)+_[2]:n<64?f(S,I,C)+_[3]:p(S,I,C)+_[4],T=(T=b(T|=0,M[n]))+N|0,k=N,N=C,C=b(I,10),I=S,S=T;T=E[1]+v+C|0,E[1]=E[2]+x+N|0,E[2]=E[3]+w+k|0,E[3]=E[4]+s+S|0,E[4]=E[0]+h+I|0,E[0]=T},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;t[r>>>5]|=128<<24-r%32,t[14+(r+64>>>9<<4)]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8),e.sigBytes=4*(t.length+1),this._process();for(var a=this._hash,s=a.words,i=0;i<5;i++){var o=s[i];s[i]=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8)}return a},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}});function p(e,t,n){return e^t^n}function f(e,t,n){return e&t|~e&n}function m(e,t,n){return(e|~t)^n}function g(e,t,n){return e&n|t&~n}function y(e,t,n){return e^(t|~n)}function b(e,t){return e<<t|e>>>32-t}e.RIPEMD160=a._createHelper(h),e.HmacRIPEMD160=a._createHmacHelper(h)}(Math),t.RIPEMD160)}()},2002:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib,r=n.WordArray,a=n.Hasher,s=e.algo,i=[],o=s.SHA1=a.extend({_doReset:function(){this._hash=new r.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],a=n[1],s=n[2],o=n[3],l=n[4],u=0;u<80;u++){if(u<16)i[u]=0|e[t+u];else{var c=i[u-3]^i[u-8]^i[u-14]^i[u-16];i[u]=c<<1|c>>>31}var d=(r<<5|r>>>27)+l+i[u];d+=u<20?1518500249+(a&s|~a&o):u<40?1859775393+(a^s^o):u<60?(a&s|a&o|s&o)-1894007588:(a^s^o)-899497514,l=o,o=s,s=a<<30|a>>>2,a=r,r=d}n[0]=n[0]+r|0,n[1]=n[1]+a|0,n[2]=n[2]+s|0,n[3]=n[3]+o|0,n[4]=n[4]+l|0},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;return t[r>>>5]|=128<<24-r%32,t[14+(r+64>>>9<<4)]=Math.floor(n/4294967296),t[15+(r+64>>>9<<4)]=n,e.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}});e.SHA1=a._createHelper(o),e.HmacSHA1=a._createHmacHelper(o)}(),t.SHA1)}()},1641:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(6368),function(){var e=t,n=e.lib.WordArray,r=e.algo,a=r.SHA256,s=r.SHA224=a.extend({_doReset:function(){this._hash=new n.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var e=a._doFinalize.call(this);return e.sigBytes-=4,e}});e.SHA224=a._createHelper(s),e.HmacSHA224=a._createHmacHelper(s)}(),t.SHA224)}()},6368:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(e){var n=t,r=n.lib,a=r.WordArray,s=r.Hasher,i=n.algo,o=[],l=[];!function(){function t(t){for(var n=e.sqrt(t),r=2;r<=n;r++)if(!(t%r))return!1;return!0}function n(e){return 4294967296*(e-(0|e))|0}for(var r=2,a=0;a<64;)t(r)&&(a<8&&(o[a]=n(e.pow(r,.5))),l[a]=n(e.pow(r,1/3)),a++),r++}();var u=[],c=i.SHA256=s.extend({_doReset:function(){this._hash=new a.init(o.slice(0))},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],a=n[1],s=n[2],i=n[3],o=n[4],c=n[5],d=n[6],h=n[7],p=0;p<64;p++){if(p<16)u[p]=0|e[t+p];else{var f=u[p-15],m=(f<<25|f>>>7)^(f<<14|f>>>18)^f>>>3,g=u[p-2],y=(g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10;u[p]=m+u[p-7]+y+u[p-16]}var b=r&a^r&s^a&s,v=(r<<30|r>>>2)^(r<<19|r>>>13)^(r<<10|r>>>22),x=h+((o<<26|o>>>6)^(o<<21|o>>>11)^(o<<7|o>>>25))+(o&c^~o&d)+l[p]+u[p];h=d,d=c,c=o,o=i+x|0,i=s,s=a,a=r,r=x+(v+b)|0}n[0]=n[0]+r|0,n[1]=n[1]+a|0,n[2]=n[2]+s|0,n[3]=n[3]+i|0,n[4]=n[4]+o|0,n[5]=n[5]+c|0,n[6]=n[6]+d|0,n[7]=n[7]+h|0},_doFinalize:function(){var t=this._data,n=t.words,r=8*this._nDataBytes,a=8*t.sigBytes;return n[a>>>5]|=128<<24-a%32,n[14+(a+64>>>9<<4)]=e.floor(r/4294967296),n[15+(a+64>>>9<<4)]=r,t.sigBytes=4*n.length,this._process(),this._hash},clone:function(){var e=s.clone.call(this);return e._hash=this._hash.clone(),e}});n.SHA256=s._createHelper(c),n.HmacSHA256=s._createHmacHelper(c)}(Math),t.SHA256)}()},6600:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),function(e){var n=t,r=n.lib,a=r.WordArray,s=r.Hasher,i=n.x64.Word,o=n.algo,l=[],u=[],c=[];!function(){for(var e=1,t=0,n=0;n<24;n++){l[e+5*t]=(n+1)*(n+2)/2%64;var r=(2*e+3*t)%5;e=t%5,t=r}for(e=0;e<5;e++)for(t=0;t<5;t++)u[e+5*t]=t+(2*e+3*t)%5*5;for(var a=1,s=0;s<24;s++){for(var o=0,d=0,h=0;h<7;h++){if(1&a){var p=(1<<h)-1;p<32?d^=1<<p:o^=1<<p-32}128&a?a=a<<1^113:a<<=1}c[s]=i.create(o,d)}}();var d=[];!function(){for(var e=0;e<25;e++)d[e]=i.create()}();var h=o.SHA3=s.extend({cfg:s.cfg.extend({outputLength:512}),_doReset:function(){for(var e=this._state=[],t=0;t<25;t++)e[t]=new i.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(e,t){for(var n=this._state,r=this.blockSize/2,a=0;a<r;a++){var s=e[t+2*a],i=e[t+2*a+1];s=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),i=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),(E=n[a]).high^=i,E.low^=s}for(var o=0;o<24;o++){for(var h=0;h<5;h++){for(var p=0,f=0,m=0;m<5;m++)p^=(E=n[h+5*m]).high,f^=E.low;var g=d[h];g.high=p,g.low=f}for(h=0;h<5;h++){var y=d[(h+4)%5],b=d[(h+1)%5],v=b.high,x=b.low;for(p=y.high^(v<<1|x>>>31),f=y.low^(x<<1|v>>>31),m=0;m<5;m++)(E=n[h+5*m]).high^=p,E.low^=f}for(var w=1;w<25;w++){var k=(E=n[w]).high,S=E.low,I=l[w];I<32?(p=k<<I|S>>>32-I,f=S<<I|k>>>32-I):(p=S<<I-32|k>>>64-I,f=k<<I-32|S>>>64-I);var C=d[u[w]];C.high=p,C.low=f}var N=d[0],T=n[0];for(N.high=T.high,N.low=T.low,h=0;h<5;h++)for(m=0;m<5;m++){var E=n[w=h+5*m],A=d[w],_=d[(h+1)%5+5*m],$=d[(h+2)%5+5*m];E.high=A.high^~_.high&$.high,E.low=A.low^~_.low&$.low}E=n[0];var R=c[o];E.high^=R.high,E.low^=R.low}},_doFinalize:function(){var t=this._data,n=t.words,r=(this._nDataBytes,8*t.sigBytes),s=32*this.blockSize;n[r>>>5]|=1<<24-r%32,n[(e.ceil((r+1)/s)*s>>>5)-1]|=128,t.sigBytes=4*n.length,this._process();for(var i=this._state,o=this.cfg.outputLength/8,l=o/8,u=[],c=0;c<l;c++){var d=i[c],h=d.high,p=d.low;h=16711935&(h<<8|h>>>24)|4278255360&(h<<24|h>>>8),p=16711935&(p<<8|p>>>24)|4278255360&(p<<24|p>>>8),u.push(p),u.push(h)}return new a.init(u,o)},clone:function(){for(var e=s.clone.call(this),t=e._state=this._state.slice(0),n=0;n<25;n++)t[n]=t[n].clone();return e}});n.SHA3=s._createHelper(h),n.HmacSHA3=s._createHmacHelper(h)}(Math),t.SHA3)}()},9092:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),n(7061),function(){var e=t,n=e.x64,r=n.Word,a=n.WordArray,s=e.algo,i=s.SHA512,o=s.SHA384=i.extend({_doReset:function(){this._hash=new a.init([new r.init(3418070365,3238371032),new r.init(1654270250,914150663),new r.init(2438529370,812702999),new r.init(355462360,4144912697),new r.init(1731405415,4290775857),new r.init(2394180231,1750603025),new r.init(3675008525,1694076839),new r.init(1203062813,3204075428)])},_doFinalize:function(){var e=i._doFinalize.call(this);return e.sigBytes-=16,e}});e.SHA384=i._createHelper(o),e.HmacSHA384=i._createHmacHelper(o)}(),t.SHA384)}()},7061:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),function(){var e=t,n=e.lib.Hasher,r=e.x64,a=r.Word,s=r.WordArray,i=e.algo;function o(){return a.create.apply(a,arguments)}var l=[o(1116352408,3609767458),o(1899447441,602891725),o(3049323471,3964484399),o(3921009573,2173295548),o(961987163,4081628472),o(1508970993,3053834265),o(2453635748,2937671579),o(2870763221,3664609560),o(3624381080,2734883394),o(310598401,1164996542),o(607225278,1323610764),o(1426881987,3590304994),o(1925078388,4068182383),o(2162078206,991336113),o(2614888103,633803317),o(3248222580,3479774868),o(3835390401,2666613458),o(4022224774,944711139),o(264347078,2341262773),o(604807628,2007800933),o(770255983,1495990901),o(1249150122,1856431235),o(1555081692,3175218132),o(1996064986,2198950837),o(2554220882,3999719339),o(2821834349,766784016),o(2952996808,2566594879),o(3210313671,3203337956),o(3336571891,1034457026),o(3584528711,2466948901),o(113926993,3758326383),o(338241895,168717936),o(666307205,1188179964),o(773529912,1546045734),o(1294757372,1522805485),o(1396182291,2643833823),o(1695183700,2343527390),o(1986661051,1014477480),o(2177026350,1206759142),o(2456956037,344077627),o(2730485921,1290863460),o(2820302411,3158454273),o(3259730800,3505952657),o(3345764771,106217008),o(3516065817,3606008344),o(3600352804,1432725776),o(4094571909,1467031594),o(275423344,851169720),o(430227734,3100823752),o(506948616,1363258195),o(659060556,3750685593),o(883997877,3785050280),o(958139571,3318307427),o(1322822218,3812723403),o(1537002063,2003034995),o(1747873779,3602036899),o(1955562222,1575990012),o(2024104815,1125592928),o(2227730452,2716904306),o(2361852424,442776044),o(2428436474,593698344),o(2756734187,3733110249),o(3204031479,2999351573),o(3329325298,3815920427),o(3391569614,3928383900),o(3515267271,566280711),o(3940187606,3454069534),o(4118630271,4000239992),o(116418474,1914138554),o(174292421,2731055270),o(289380356,3203993006),o(460393269,320620315),o(685471733,587496836),o(852142971,1086792851),o(1017036298,365543100),o(1126000580,2618297676),o(1288033470,3409855158),o(1501505948,4234509866),o(1607167915,987167468),o(1816402316,1246189591)],u=[];!function(){for(var e=0;e<80;e++)u[e]=o()}();var c=i.SHA512=n.extend({_doReset:function(){this._hash=new s.init([new a.init(1779033703,4089235720),new a.init(3144134277,2227873595),new a.init(1013904242,4271175723),new a.init(2773480762,1595750129),new a.init(1359893119,2917565137),new a.init(2600822924,725511199),new a.init(528734635,4215389547),new a.init(1541459225,327033209)])},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],a=n[1],s=n[2],i=n[3],o=n[4],c=n[5],d=n[6],h=n[7],p=r.high,f=r.low,m=a.high,g=a.low,y=s.high,b=s.low,v=i.high,x=i.low,w=o.high,k=o.low,S=c.high,I=c.low,C=d.high,N=d.low,T=h.high,E=h.low,A=p,_=f,$=m,R=g,D=y,M=b,F=v,O=x,P=w,L=k,z=S,B=I,W=C,V=N,U=T,j=E,G=0;G<80;G++){var H,q,K=u[G];if(G<16)q=K.high=0|e[t+2*G],H=K.low=0|e[t+2*G+1];else{var X=u[G-15],Y=X.high,Q=X.low,J=(Y>>>1|Q<<31)^(Y>>>8|Q<<24)^Y>>>7,Z=(Q>>>1|Y<<31)^(Q>>>8|Y<<24)^(Q>>>7|Y<<25),ee=u[G-2],te=ee.high,ne=ee.low,re=(te>>>19|ne<<13)^(te<<3|ne>>>29)^te>>>6,ae=(ne>>>19|te<<13)^(ne<<3|te>>>29)^(ne>>>6|te<<26),se=u[G-7],ie=se.high,oe=se.low,le=u[G-16],ue=le.high,ce=le.low;q=(q=(q=J+ie+((H=Z+oe)>>>0<Z>>>0?1:0))+re+((H+=ae)>>>0<ae>>>0?1:0))+ue+((H+=ce)>>>0<ce>>>0?1:0),K.high=q,K.low=H}var de,he=P&z^~P&W,pe=L&B^~L&V,fe=A&$^A&D^$&D,me=_&R^_&M^R&M,ge=(A>>>28|_<<4)^(A<<30|_>>>2)^(A<<25|_>>>7),ye=(_>>>28|A<<4)^(_<<30|A>>>2)^(_<<25|A>>>7),be=(P>>>14|L<<18)^(P>>>18|L<<14)^(P<<23|L>>>9),ve=(L>>>14|P<<18)^(L>>>18|P<<14)^(L<<23|P>>>9),xe=l[G],we=xe.high,ke=xe.low,Se=U+be+((de=j+ve)>>>0<j>>>0?1:0),Ie=ye+me;U=W,j=V,W=z,V=B,z=P,B=L,P=F+(Se=(Se=(Se=Se+he+((de+=pe)>>>0<pe>>>0?1:0))+we+((de+=ke)>>>0<ke>>>0?1:0))+q+((de+=H)>>>0<H>>>0?1:0))+((L=O+de|0)>>>0<O>>>0?1:0)|0,F=D,O=M,D=$,M=R,$=A,R=_,A=Se+(ge+fe+(Ie>>>0<ye>>>0?1:0))+((_=de+Ie|0)>>>0<de>>>0?1:0)|0}f=r.low=f+_,r.high=p+A+(f>>>0<_>>>0?1:0),g=a.low=g+R,a.high=m+$+(g>>>0<R>>>0?1:0),b=s.low=b+M,s.high=y+D+(b>>>0<M>>>0?1:0),x=i.low=x+O,i.high=v+F+(x>>>0<O>>>0?1:0),k=o.low=k+L,o.high=w+P+(k>>>0<L>>>0?1:0),I=c.low=I+B,c.high=S+z+(I>>>0<B>>>0?1:0),N=d.low=N+V,d.high=C+W+(N>>>0<V>>>0?1:0),E=h.low=E+j,h.high=T+U+(E>>>0<j>>>0?1:0)},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;return t[r>>>5]|=128<<24-r%32,t[30+(r+128>>>10<<5)]=Math.floor(n/4294967296),t[31+(r+128>>>10<<5)]=n,e.sigBytes=4*t.length,this._process(),this._hash.toX32()},clone:function(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e},blockSize:32});e.SHA512=n._createHelper(c),e.HmacSHA512=n._createHmacHelper(c)}(),t.SHA512)}()},9475:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib,r=n.WordArray,a=n.BlockCipher,s=e.algo,i=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],o=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],l=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],u=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],c=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],d=s.DES=a.extend({_doReset:function(){for(var e=this._key.words,t=[],n=0;n<56;n++){var r=i[n]-1;t[n]=e[r>>>5]>>>31-r%32&1}for(var a=this._subKeys=[],s=0;s<16;s++){var u=a[s]=[],c=l[s];for(n=0;n<24;n++)u[n/6|0]|=t[(o[n]-1+c)%28]<<31-n%6,u[4+(n/6|0)]|=t[28+(o[n+24]-1+c)%28]<<31-n%6;for(u[0]=u[0]<<1|u[0]>>>31,n=1;n<7;n++)u[n]=u[n]>>>4*(n-1)+3;u[7]=u[7]<<5|u[7]>>>27}var d=this._invSubKeys=[];for(n=0;n<16;n++)d[n]=a[15-n]},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._subKeys)},decryptBlock:function(e,t){this._doCryptBlock(e,t,this._invSubKeys)},_doCryptBlock:function(e,t,n){this._lBlock=e[t],this._rBlock=e[t+1],h.call(this,4,252645135),h.call(this,16,65535),p.call(this,2,858993459),p.call(this,8,16711935),h.call(this,1,1431655765);for(var r=0;r<16;r++){for(var a=n[r],s=this._lBlock,i=this._rBlock,o=0,l=0;l<8;l++)o|=u[l][((i^a[l])&c[l])>>>0];this._lBlock=i,this._rBlock=s^o}var d=this._lBlock;this._lBlock=this._rBlock,this._rBlock=d,h.call(this,1,1431655765),p.call(this,8,16711935),p.call(this,2,858993459),h.call(this,16,65535),h.call(this,4,252645135),e[t]=this._lBlock,e[t+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});function h(e,t){var n=(this._lBlock>>>e^this._rBlock)&t;this._rBlock^=n,this._lBlock^=n<<e}function p(e,t){var n=(this._rBlock>>>e^this._lBlock)&t;this._lBlock^=n,this._rBlock^=n<<e}e.DES=a._createHelper(d);var f=s.TripleDES=a.extend({_doReset:function(){var e=this._key.words;if(2!==e.length&&4!==e.length&&e.length<6)throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");var t=e.slice(0,2),n=e.length<4?e.slice(0,2):e.slice(2,4),a=e.length<6?e.slice(0,2):e.slice(4,6);this._des1=d.createEncryptor(r.create(t)),this._des2=d.createEncryptor(r.create(n)),this._des3=d.createEncryptor(r.create(a))},encryptBlock:function(e,t){this._des1.encryptBlock(e,t),this._des2.decryptBlock(e,t),this._des3.encryptBlock(e,t)},decryptBlock:function(e,t){this._des3.decryptBlock(e,t),this._des2.encryptBlock(e,t),this._des1.decryptBlock(e,t)},keySize:6,ivSize:2,blockSize:2});e.TripleDES=a._createHelper(f)}(),t.TripleDES)}()},9749:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(e){var n=t,r=n.lib,a=r.Base,s=r.WordArray,i=n.x64={};i.Word=a.extend({init:function(e,t){this.high=e,this.low=t}}),i.WordArray=a.extend({init:function(t,n){t=this.words=t||[],this.sigBytes=n!=e?n:8*t.length},toX32:function(){for(var e=this.words,t=e.length,n=[],r=0;r<t;r++){var a=e[r];n.push(a.high),n.push(a.low)}return s.create(n,this.sigBytes)},clone:function(){for(var e=a.clone.call(this),t=e.words=this.words.slice(0),n=t.length,r=0;r<n;r++)t[r]=t[r].clone();return e}})}(),t)}()},446:function(e){e.exports=function(){"use strict";var e=1e3,t=6e4,n=36e5,r="millisecond",a="second",s="minute",i="hour",o="day",l="week",u="month",c="quarter",d="year",h="date",p="Invalid Date",f=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,m=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,g={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(e){var t=["th","st","nd","rd"],n=e%100;return"["+e+(t[(n-20)%10]||t[n]||t[0])+"]"}},y=function(e,t,n){var r=String(e);return!r||r.length>=t?e:""+Array(t+1-r.length).join(n)+e},b={s:y,z:function(e){var t=-e.utcOffset(),n=Math.abs(t),r=Math.floor(n/60),a=n%60;return(t<=0?"+":"-")+y(r,2,"0")+":"+y(a,2,"0")},m:function e(t,n){if(t.date()<n.date())return-e(n,t);var r=12*(n.year()-t.year())+(n.month()-t.month()),a=t.clone().add(r,u),s=n-a<0,i=t.clone().add(r+(s?-1:1),u);return+(-(r+(n-a)/(s?a-i:i-a))||0)},a:function(e){return e<0?Math.ceil(e)||0:Math.floor(e)},p:function(e){return{M:u,y:d,w:l,d:o,D:h,h:i,m:s,s:a,ms:r,Q:c}[e]||String(e||"").toLowerCase().replace(/s$/,"")},u:function(e){return void 0===e}},v="en",x={};x[v]=g;var w="$isDayjsObject",k=function(e){return e instanceof N||!(!e||!e[w])},S=function e(t,n,r){var a;if(!t)return v;if("string"==typeof t){var s=t.toLowerCase();x[s]&&(a=s),n&&(x[s]=n,a=s);var i=t.split("-");if(!a&&i.length>1)return e(i[0])}else{var o=t.name;x[o]=t,a=o}return!r&&a&&(v=a),a||!r&&v},I=function(e,t){if(k(e))return e.clone();var n="object"==typeof t?t:{};return n.date=e,n.args=arguments,new N(n)},C=b;C.l=S,C.i=k,C.w=function(e,t){return I(e,{locale:t.$L,utc:t.$u,x:t.$x,$offset:t.$offset})};var N=function(){function g(e){this.$L=S(e.locale,null,!0),this.parse(e),this.$x=this.$x||e.x||{},this[w]=!0}var y=g.prototype;return y.parse=function(e){this.$d=function(e){var t=e.date,n=e.utc;if(null===t)return new Date(NaN);if(C.u(t))return new Date;if(t instanceof Date)return new Date(t);if("string"==typeof t&&!/Z$/i.test(t)){var r=t.match(f);if(r){var a=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],a,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],a,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(t)}(e),this.init()},y.init=function(){var e=this.$d;this.$y=e.getFullYear(),this.$M=e.getMonth(),this.$D=e.getDate(),this.$W=e.getDay(),this.$H=e.getHours(),this.$m=e.getMinutes(),this.$s=e.getSeconds(),this.$ms=e.getMilliseconds()},y.$utils=function(){return C},y.isValid=function(){return!(this.$d.toString()===p)},y.isSame=function(e,t){var n=I(e);return this.startOf(t)<=n&&n<=this.endOf(t)},y.isAfter=function(e,t){return I(e)<this.startOf(t)},y.isBefore=function(e,t){return this.endOf(t)<I(e)},y.$g=function(e,t,n){return C.u(e)?this[t]:this.set(n,e)},y.unix=function(){return Math.floor(this.valueOf()/1e3)},y.valueOf=function(){return this.$d.getTime()},y.startOf=function(e,t){var n=this,r=!!C.u(t)||t,c=C.p(e),p=function(e,t){var a=C.w(n.$u?Date.UTC(n.$y,t,e):new Date(n.$y,t,e),n);return r?a:a.endOf(o)},f=function(e,t){return C.w(n.toDate()[e].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(t)),n)},m=this.$W,g=this.$M,y=this.$D,b="set"+(this.$u?"UTC":"");switch(c){case d:return r?p(1,0):p(31,11);case u:return r?p(1,g):p(0,g+1);case l:var v=this.$locale().weekStart||0,x=(m<v?m+7:m)-v;return p(r?y-x:y+(6-x),g);case o:case h:return f(b+"Hours",0);case i:return f(b+"Minutes",1);case s:return f(b+"Seconds",2);case a:return f(b+"Milliseconds",3);default:return this.clone()}},y.endOf=function(e){return this.startOf(e,!1)},y.$set=function(e,t){var n,l=C.p(e),c="set"+(this.$u?"UTC":""),p=(n={},n[o]=c+"Date",n[h]=c+"Date",n[u]=c+"Month",n[d]=c+"FullYear",n[i]=c+"Hours",n[s]=c+"Minutes",n[a]=c+"Seconds",n[r]=c+"Milliseconds",n)[l],f=l===o?this.$D+(t-this.$W):t;if(l===u||l===d){var m=this.clone().set(h,1);m.$d[p](f),m.init(),this.$d=m.set(h,Math.min(this.$D,m.daysInMonth())).$d}else p&&this.$d[p](f);return this.init(),this},y.set=function(e,t){return this.clone().$set(e,t)},y.get=function(e){return this[C.p(e)]()},y.add=function(r,c){var h,p=this;r=Number(r);var f=C.p(c),m=function(e){var t=I(p);return C.w(t.date(t.date()+Math.round(e*r)),p)};if(f===u)return this.set(u,this.$M+r);if(f===d)return this.set(d,this.$y+r);if(f===o)return m(1);if(f===l)return m(7);var g=(h={},h[s]=t,h[i]=n,h[a]=e,h)[f]||1,y=this.$d.getTime()+r*g;return C.w(y,this)},y.subtract=function(e,t){return this.add(-1*e,t)},y.format=function(e){var t=this,n=this.$locale();if(!this.isValid())return n.invalidDate||p;var r=e||"YYYY-MM-DDTHH:mm:ssZ",a=C.z(this),s=this.$H,i=this.$m,o=this.$M,l=n.weekdays,u=n.months,c=n.meridiem,d=function(e,n,a,s){return e&&(e[n]||e(t,r))||a[n].slice(0,s)},h=function(e){return C.s(s%12||12,e,"0")},f=c||function(e,t,n){var r=e<12?"AM":"PM";return n?r.toLowerCase():r};return r.replace(m,(function(e,r){return r||function(e){switch(e){case"YY":return String(t.$y).slice(-2);case"YYYY":return C.s(t.$y,4,"0");case"M":return o+1;case"MM":return C.s(o+1,2,"0");case"MMM":return d(n.monthsShort,o,u,3);case"MMMM":return d(u,o);case"D":return t.$D;case"DD":return C.s(t.$D,2,"0");case"d":return String(t.$W);case"dd":return d(n.weekdaysMin,t.$W,l,2);case"ddd":return d(n.weekdaysShort,t.$W,l,3);case"dddd":return l[t.$W];case"H":return String(s);case"HH":return C.s(s,2,"0");case"h":return h(1);case"hh":return h(2);case"a":return f(s,i,!0);case"A":return f(s,i,!1);case"m":return String(i);case"mm":return C.s(i,2,"0");case"s":return String(t.$s);case"ss":return C.s(t.$s,2,"0");case"SSS":return C.s(t.$ms,3,"0");case"Z":return a}return null}(e)||a.replace(":","")}))},y.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},y.diff=function(r,h,p){var f,m=this,g=C.p(h),y=I(r),b=(y.utcOffset()-this.utcOffset())*t,v=this-y,x=function(){return C.m(m,y)};switch(g){case d:f=x()/12;break;case u:f=x();break;case c:f=x()/3;break;case l:f=(v-b)/6048e5;break;case o:f=(v-b)/864e5;break;case i:f=v/n;break;case s:f=v/t;break;case a:f=v/e;break;default:f=v}return p?f:C.a(f)},y.daysInMonth=function(){return this.endOf(u).$D},y.$locale=function(){return x[this.$L]},y.locale=function(e,t){if(!e)return this.$L;var n=this.clone(),r=S(e,t,!0);return r&&(n.$L=r),n},y.clone=function(){return C.w(this.$d,this)},y.toDate=function(){return new Date(this.valueOf())},y.toJSON=function(){return this.isValid()?this.toISOString():null},y.toISOString=function(){return this.$d.toISOString()},y.toString=function(){return this.$d.toUTCString()},g}(),T=N.prototype;return I.prototype=T,[["$ms",r],["$s",a],["$m",s],["$H",i],["$W",o],["$M",u],["$y",d],["$D",h]].forEach((function(e){T[e[1]]=function(t){return this.$g(t,e[0],e[1])}})),I.extend=function(e,t){return e.$i||(e(t,N,I),e.$i=!0),I},I.locale=S,I.isDayjs=k,I.unix=function(e){return I(1e3*e)},I.en=x[v],I.Ls=x,I.p={},I}()},7076:function(e){e.exports=function(){"use strict";return function(e,t){var n=t.prototype,r=n.format;n.format=function(e){var t=this,n=this.$locale();if(!this.isValid())return r.bind(this)(e);var a=this.$utils(),s=(e||"YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,(function(e){switch(e){case"Q":return Math.ceil((t.$M+1)/3);case"Do":return n.ordinal(t.$D);case"gggg":return t.weekYear();case"GGGG":return t.isoWeekYear();case"wo":return n.ordinal(t.week(),"W");case"w":case"ww":return a.s(t.week(),"w"===e?1:2,"0");case"W":case"WW":return a.s(t.isoWeek(),"W"===e?1:2,"0");case"k":case"kk":return a.s(String(0===t.$H?24:t.$H),"k"===e?1:2,"0");case"X":return Math.floor(t.$d.getTime()/1e3);case"x":return t.$d.getTime();case"z":return"["+t.offsetName()+"]";case"zzz":return"["+t.offsetName("long")+"]";default:return e}}));return r.bind(this)(s)}}}()},8988:function(e){e.exports=function(){"use strict";var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},t=/(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,n=/\d/,r=/\d\d/,a=/\d\d?/,s=/\d*[^-_:/,()\s\d]+/,i={},o=function(e){return(e=+e)+(e>68?1900:2e3)},l=function(e){return function(t){this[e]=+t}},u=[/[+-]\d\d:?(\d\d)?|Z/,function(e){(this.zone||(this.zone={})).offset=function(e){if(!e)return 0;if("Z"===e)return 0;var t=e.match(/([+-]|\d\d)/g),n=60*t[1]+(+t[2]||0);return 0===n?0:"+"===t[0]?-n:n}(e)}],c=function(e){var t=i[e];return t&&(t.indexOf?t:t.s.concat(t.f))},d=function(e,t){var n,r=i.meridiem;if(r){for(var a=1;a<=24;a+=1)if(e.indexOf(r(a,0,t))>-1){n=a>12;break}}else n=e===(t?"pm":"PM");return n},h={A:[s,function(e){this.afternoon=d(e,!1)}],a:[s,function(e){this.afternoon=d(e,!0)}],Q:[n,function(e){this.month=3*(e-1)+1}],S:[n,function(e){this.milliseconds=100*+e}],SS:[r,function(e){this.milliseconds=10*+e}],SSS:[/\d{3}/,function(e){this.milliseconds=+e}],s:[a,l("seconds")],ss:[a,l("seconds")],m:[a,l("minutes")],mm:[a,l("minutes")],H:[a,l("hours")],h:[a,l("hours")],HH:[a,l("hours")],hh:[a,l("hours")],D:[a,l("day")],DD:[r,l("day")],Do:[s,function(e){var t=i.ordinal,n=e.match(/\d+/);if(this.day=n[0],t)for(var r=1;r<=31;r+=1)t(r).replace(/\[|\]/g,"")===e&&(this.day=r)}],w:[a,l("week")],ww:[r,l("week")],M:[a,l("month")],MM:[r,l("month")],MMM:[s,function(e){var t=c("months"),n=(c("monthsShort")||t.map((function(e){return e.slice(0,3)}))).indexOf(e)+1;if(n<1)throw new Error;this.month=n%12||n}],MMMM:[s,function(e){var t=c("months").indexOf(e)+1;if(t<1)throw new Error;this.month=t%12||t}],Y:[/[+-]?\d+/,l("year")],YY:[r,function(e){this.year=o(e)}],YYYY:[/\d{4}/,l("year")],Z:u,ZZ:u};function p(n){var r,a;r=n,a=i&&i.formats;for(var s=(n=r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var s=r&&r.toUpperCase();return n||a[r]||e[r]||a[s].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))).match(t),o=s.length,l=0;l<o;l+=1){var u=s[l],c=h[u],d=c&&c[0],p=c&&c[1];s[l]=p?{regex:d,parser:p}:u.replace(/^\[|\]$/g,"")}return function(e){for(var t={},n=0,r=0;n<o;n+=1){var a=s[n];if("string"==typeof a)r+=a.length;else{var i=a.regex,l=a.parser,u=e.slice(r),c=i.exec(u)[0];l.call(t,c),e=e.replace(c,"")}}return function(e){var t=e.afternoon;if(void 0!==t){var n=e.hours;t?n<12&&(e.hours+=12):12===n&&(e.hours=0),delete e.afternoon}}(t),t}}return function(e,t,n){n.p.customParseFormat=!0,e&&e.parseTwoDigitYear&&(o=e.parseTwoDigitYear);var r=t.prototype,a=r.parse;r.parse=function(e){var t=e.date,r=e.utc,s=e.args;this.$u=r;var o=s[1];if("string"==typeof o){var l=!0===s[2],u=!0===s[3],c=l||u,d=s[2];u&&(d=s[2]),i=this.$locale(),!l&&d&&(i=n.Ls[d]),this.$d=function(e,t,n,r){try{if(["x","X"].indexOf(t)>-1)return new Date(("X"===t?1e3:1)*e);var a=p(t)(e),s=a.year,i=a.month,o=a.day,l=a.hours,u=a.minutes,c=a.seconds,d=a.milliseconds,h=a.zone,f=a.week,m=new Date,g=o||(s||i?1:m.getDate()),y=s||m.getFullYear(),b=0;s&&!i||(b=i>0?i-1:m.getMonth());var v,x=l||0,w=u||0,k=c||0,S=d||0;return h?new Date(Date.UTC(y,b,g,x,w,k,S+60*h.offset*1e3)):n?new Date(Date.UTC(y,b,g,x,w,k,S)):(v=new Date(y,b,g,x,w,k,S),f&&(v=r(v).week(f).toDate()),v)}catch(e){return new Date("")}}(t,o,r,n),this.init(),d&&!0!==d&&(this.$L=this.locale(d).$L),c&&t!=this.format(o)&&(this.$d=new Date("")),i={}}else if(o instanceof Array)for(var h=o.length,f=1;f<=h;f+=1){s[1]=o[f-1];var m=n.apply(this,s);if(m.isValid()){this.$d=m.$d,this.$L=m.$L,this.init();break}f===h&&(this.$d=new Date(""))}else a.call(this,e)}}}()},1525:function(e){e.exports=function(){"use strict";return function(e,t,n){t.prototype.isBetween=function(e,t,r,a){var s=n(e),i=n(t),o="("===(a=a||"()")[0],l=")"===a[1];return(o?this.isAfter(s,r):!this.isBefore(s,r))&&(l?this.isBefore(i,r):!this.isAfter(i,r))||(o?this.isBefore(s,r):!this.isAfter(s,r))&&(l?this.isAfter(i,r):!this.isBefore(i,r))}}}()},4443:function(e){e.exports=function(){"use strict";var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};return function(t,n,r){var a=n.prototype,s=a.format;r.en.formats=e,a.format=function(t){void 0===t&&(t="YYYY-MM-DDTHH:mm:ssZ");var n=this.$locale().formats,r=function(t,n){return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,r,a){var s=a&&a.toUpperCase();return r||n[a]||e[a]||n[s].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))}(t,void 0===n?{}:n);return s.call(this,r)}}}()},6865:function(e){e.exports=function(){"use strict";var e="week",t="year";return function(n,r,a){var s=r.prototype;s.week=function(n){if(void 0===n&&(n=null),null!==n)return this.add(7*(n-this.week()),"day");var r=this.$locale().yearStart||1;if(11===this.month()&&this.date()>25){var s=a(this).startOf(t).add(1,t).date(r),i=a(this).endOf(e);if(s.isBefore(i))return 1}var o=a(this).startOf(t).date(r).startOf(e).subtract(1,"millisecond"),l=this.diff(o,e,!0);return l<0?a(this).startOf("week").week():Math.ceil(l)},s.weeks=function(e){return void 0===e&&(e=null),this.week(e)}}}()},757:function(e){"undefined"!=typeof self&&self,e.exports=function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(r,a,function(t){return e[t]}.bind(null,a));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";n.r(t);var r={};function a(e){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}n.r(r),n.d(r,"VictoryGesture",(function(){return T})),n.d(r,"ThumbsUpGesture",(function(){return R}));var s={Thumb:0,Index:1,Middle:2,Ring:3,Pinky:4,all:[0,1,2,3,4],nameMapping:{0:"Thumb",1:"Index",2:"Middle",3:"Ring",4:"Pinky"},pointsMapping:{0:[[0,1],[1,2],[2,3],[3,4]],1:[[0,5],[5,6],[6,7],[7,8]],2:[[0,9],[9,10],[10,11],[11,12]],3:[[0,13],[13,14],[14,15],[15,16]],4:[[0,17],[17,18],[18,19],[19,20]]},getName:function(e){return void 0!==a(this.nameMapping[e])&&this.nameMapping[e]},getPoints:function(e){return void 0!==a(this.pointsMapping[e])&&this.pointsMapping[e]}},i={NoCurl:0,HalfCurl:1,FullCurl:2,nameMapping:{0:"No Curl",1:"Half Curl",2:"Full Curl"},getName:function(e){return void 0!==a(this.nameMapping[e])&&this.nameMapping[e]}},o={VerticalUp:0,VerticalDown:1,HorizontalLeft:2,HorizontalRight:3,DiagonalUpRight:4,DiagonalUpLeft:5,DiagonalDownRight:6,DiagonalDownLeft:7,nameMapping:{0:"Vertical Up",1:"Vertical Down",2:"Horizontal Left",3:"Horizontal Right",4:"Diagonal Up Right",5:"Diagonal Up Left",6:"Diagonal Down Right",7:"Diagonal Down Left"},getName:function(e){return void 0!==a(this.nameMapping[e])&&this.nameMapping[e]}};function l(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=function(e,t){if(e){if("string"==typeof e)return u(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?u(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,a=function(){};return{s:a,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,i=!0,o=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return i=e.done,e},e:function(e){o=!0,s=e},f:function(){try{i||null==n.return||n.return()}finally{if(o)throw s}}}}function u(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function d(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){h(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function h(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function p(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var f=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options=d(d({},{HALF_CURL_START_LIMIT:60,NO_CURL_START_LIMIT:130,DISTANCE_VOTE_POWER:1.1,SINGLE_ANGLE_VOTE_POWER:.9,TOTAL_ANGLE_VOTE_POWER:1.6}),t)}var t,n,r;return t=e,(n=[{key:"estimate",value:function(e){var t,n=[],r=[],a=l(s.all);try{for(a.s();!(t=a.n()).done;){var i,o=t.value,u=s.getPoints(o),c=[],d=[],h=l(u);try{for(h.s();!(i=h.n()).done;){var p=i.value,f=e[p[0]],m=e[p[1]],g=this.getSlopes(f,m),y=g[0],b=g[1];c.push(y),d.push(b)}}catch(e){h.e(e)}finally{h.f()}n.push(c),r.push(d)}}catch(e){a.e(e)}finally{a.f()}var v,x=[],w=[],k=l(s.all);try{for(k.s();!(v=k.n()).done;){var S=v.value,I=S==s.Thumb?1:0,C=s.getPoints(S),N=e[C[I][0]],T=e[C[I+1][1]],E=e[C[3][1]],A=this.estimateFingerCurl(N,T,E),_=this.calculateFingerDirection(N,T,E,n[S].slice(I));x[S]=A,w[S]=_}}catch(e){k.e(e)}finally{k.f()}return{curls:x,directions:w}}},{key:"getSlopes",value:function(e,t){var n=this.calculateSlope(e[0],e[1],t[0],t[1]);return 2==e.length?n:[n,this.calculateSlope(e[1],e[2],t[1],t[2])]}},{key:"angleOrientationAt",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=0,r=0,a=0;return e>=75&&e<=105?n=1*t:e>=25&&e<=155?r=1*t:a=1*t,[n,r,a]}},{key:"estimateFingerCurl",value:function(e,t,n){var r=e[0]-t[0],a=e[0]-n[0],s=t[0]-n[0],o=e[1]-t[1],l=e[1]-n[1],u=t[1]-n[1],c=e[2]-t[2],d=e[2]-n[2],h=t[2]-n[2],p=Math.sqrt(r*r+o*o+c*c),f=Math.sqrt(a*a+l*l+d*d),m=Math.sqrt(s*s+u*u+h*h),g=(m*m+p*p-f*f)/(2*m*p);g>1?g=1:g<-1&&(g=-1);var y=Math.acos(g);return(y=57.2958*y%180)>this.options.NO_CURL_START_LIMIT?i.NoCurl:y>this.options.HALF_CURL_START_LIMIT?i.HalfCurl:i.FullCurl}},{key:"estimateHorizontalDirection",value:function(e,t,n,r){return r==Math.abs(e)?e>0?o.HorizontalLeft:o.HorizontalRight:r==Math.abs(t)?t>0?o.HorizontalLeft:o.HorizontalRight:n>0?o.HorizontalLeft:o.HorizontalRight}},{key:"estimateVerticalDirection",value:function(e,t,n,r){return r==Math.abs(e)?e<0?o.VerticalDown:o.VerticalUp:r==Math.abs(t)?t<0?o.VerticalDown:o.VerticalUp:n<0?o.VerticalDown:o.VerticalUp}},{key:"estimateDiagonalDirection",value:function(e,t,n,r,a,s,i,l){var u=this.estimateVerticalDirection(e,t,n,r),c=this.estimateHorizontalDirection(a,s,i,l);return u==o.VerticalUp?c==o.HorizontalLeft?o.DiagonalUpLeft:o.DiagonalUpRight:c==o.HorizontalLeft?o.DiagonalDownLeft:o.DiagonalDownRight}},{key:"calculateFingerDirection",value:function(e,t,n,r){var a=e[0]-t[0],s=e[0]-n[0],i=t[0]-n[0],o=e[1]-t[1],u=e[1]-n[1],c=t[1]-n[1],d=Math.max(Math.abs(a),Math.abs(s),Math.abs(i)),h=Math.max(Math.abs(o),Math.abs(u),Math.abs(c)),p=0,f=0,m=0,g=h/(d+1e-5);g>1.5?p+=this.options.DISTANCE_VOTE_POWER:g>.66?f+=this.options.DISTANCE_VOTE_POWER:m+=this.options.DISTANCE_VOTE_POWER;var y=Math.sqrt(a*a+o*o),b=Math.sqrt(s*s+u*u),v=Math.sqrt(i*i+c*c),x=Math.max(y,b,v),w=e[0],k=e[1],S=n[0],I=n[1];x==y?(S=n[0],I=n[1]):x==v&&(w=t[0],k=t[1]);var C=[w,k],N=[S,I],T=this.getSlopes(C,N),E=this.angleOrientationAt(T,this.options.TOTAL_ANGLE_VOTE_POWER);p+=E[0],f+=E[1],m+=E[2];var A,_=l(r);try{for(_.s();!(A=_.n()).done;){var $=A.value,R=this.angleOrientationAt($,this.options.SINGLE_ANGLE_VOTE_POWER);p+=R[0],f+=R[1],m+=R[2]}}catch(e){_.e(e)}finally{_.f()}return p==Math.max(p,f,m)?this.estimateVerticalDirection(u,o,c,h):m==Math.max(f,m)?this.estimateHorizontalDirection(s,a,i,d):this.estimateDiagonalDirection(u,o,c,h,s,a,i,d)}},{key:"calculateSlope",value:function(e,t,n,r){var a=(t-r)/(e-n),s=180*Math.atan(a)/Math.PI;return s<=0?s=-s:s>0&&(s=180-s),s}}])&&p(t.prototype,n),r&&p(t,r),e}();function m(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=function(e,t){if(e){if("string"==typeof e)return g(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?g(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,a=function(){};return{s:a,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,i=!0,o=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return i=e.done,e},e:function(e){o=!0,s=e},f:function(){try{i||null==n.return||n.return()}finally{if(o)throw s}}}}function g(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function y(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function b(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var v=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};y(this,e),this.estimator=new f(n),this.gestures=t}var t,n,r;return t=e,(n=[{key:"estimate",value:function(e,t){var n,r=[],a=this.estimator.estimate(e),l=[],u=m(s.all);try{for(u.s();!(n=u.n()).done;){var c=n.value;l.push([s.getName(c),i.getName(a.curls[c]),o.getName(a.directions[c])])}}catch(e){u.e(e)}finally{u.f()}var d,h=m(this.gestures);try{for(h.s();!(d=h.n()).done;){var p=d.value,f=p.matchAgainst(a.curls,a.directions);f>=t&&r.push({name:p.name,score:f})}}catch(e){h.e(e)}finally{h.f()}return{poseData:l,gestures:r}}}])&&b(t.prototype,n),r&&b(t,r),e}();function x(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=n){var r,a,s=[],i=!0,o=!1;try{for(n=n.call(e);!(i=(r=n.next()).done)&&(s.push(r.value),!t||s.length!==t);i=!0);}catch(e){o=!0,a=e}finally{try{i||null==n.return||n.return()}finally{if(o)throw a}}return s}}(e,t)||k(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function w(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=k(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,a=function(){};return{s:a,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,i=!0,o=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return i=e.done,e},e:function(e){o=!0,s=e},f:function(){try{i||null==n.return||n.return()}finally{if(o)throw s}}}}function k(e,t){if(e){if("string"==typeof e)return S(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?S(e,t):void 0}}function S(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function I(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var C=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.name=t,this.curls={},this.directions={}}var t,n,r;return t=e,(n=[{key:"addCurl",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;void 0===this.curls[e]&&(this.curls[e]=[]),this.curls[e].push([t,n])}},{key:"addDirection",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;void 0===this.directions[e]&&(this.directions[e]=[]),this.directions[e].push([t,n])}},{key:"matchAgainst",value:function(e,t){var n=0,r=0;for(var a in e){var s=e[a],i=this.curls[a];if(void 0!==i){r++;var o,l=!1,u=0,c=w(i);try{for(c.s();!(o=c.n()).done;){var d=x(o.value,2),h=d[0],p=d[1];if(s==h){n+=p,u=Math.max(u,p),l=!0;break}}}catch(e){c.e(e)}finally{c.f()}l||(n-=u)}}for(var f in t){var m=t[f],g=this.directions[f];if(void 0!==g){r++;var y,b=!1,v=0,k=w(g);try{for(k.s();!(y=k.n()).done;){var S=x(y.value,2),I=S[0],C=S[1];if(m==I){n+=C,v=Math.max(v,C),b=!0;break}}}catch(e){k.e(e)}finally{k.f()}b||(n-=v)}}return n/r*10}}])&&I(t.prototype,n),r&&I(t,r),e}(),N=new C("victory");N.addDirection(s.Thumb,o.VerticalUp,1),N.addDirection(s.Thumb,o.DiagonalUpLeft,1),N.addDirection(s.Thumb,o.DiagonalUpRight,1),N.addCurl(s.Index,i.NoCurl,1),N.addDirection(s.Index,o.VerticalUp,1),N.addDirection(s.Index,o.DiagonalUpLeft,1),N.addDirection(s.Index,o.DiagonalUpRight,1),N.addDirection(s.Index,o.HorizontalLeft,1),N.addDirection(s.Index,o.HorizontalRight,1),N.addCurl(s.Middle,i.NoCurl,1),N.addDirection(s.Middle,o.VerticalUp,1),N.addDirection(s.Middle,o.DiagonalUpLeft,1),N.addDirection(s.Middle,o.DiagonalUpRight,1),N.addDirection(s.Middle,o.HorizontalLeft,1),N.addDirection(s.Middle,o.HorizontalRight,1),N.addCurl(s.Ring,i.FullCurl,1),N.addCurl(s.Ring,i.HalfCurl,.9),N.addCurl(s.Pinky,i.FullCurl,1),N.addCurl(s.Pinky,i.HalfCurl,.9);var T=N,E=new C("thumbs_up");E.addCurl(s.Thumb,i.NoCurl,1),E.addDirection(s.Thumb,o.VerticalUp,1),E.addDirection(s.Thumb,o.DiagonalUpLeft,.9),E.addDirection(s.Thumb,o.DiagonalUpRight,.9);for(var A=0,_=[s.Index,s.Middle,s.Ring,s.Pinky];A<_.length;A++){var $=_[A];E.addCurl($,i.FullCurl,1),E.addCurl($,i.HalfCurl,.9)}E.addDirection(s.Index,o.DiagonalUpLeft,1),E.addDirection(s.Index,o.HorizontalLeft,1),E.addDirection(s.Index,o.HorizontalRight,1),E.addDirection(s.Index,o.DiagonalUpRight,1);var R=E;t.default={GestureEstimator:v,GestureDescription:C,Finger:s,FingerCurl:i,FingerDirection:o,Gestures:r}}]).default},219:(e,t,n)=>{"use strict";var r=n(3763),a={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},s={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},i={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},o={};function l(e){return r.isMemo(e)?i:o[e.$$typeof]||a}o[r.ForwardRef]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},o[r.Memo]=i;var u=Object.defineProperty,c=Object.getOwnPropertyNames,d=Object.getOwnPropertySymbols,h=Object.getOwnPropertyDescriptor,p=Object.getPrototypeOf,f=Object.prototype;e.exports=function e(t,n,r){if("string"!==typeof n){if(f){var a=p(n);a&&a!==f&&e(t,a,r)}var i=c(n);d&&(i=i.concat(d(n)));for(var o=l(t),m=l(n),g=0;g<i.length;++g){var y=i[g];if(!s[y]&&(!r||!r[y])&&(!m||!m[y])&&(!o||!o[y])){var b=h(n,y);try{u(t,y,b)}catch(v){}}}}return t}},4983:(e,t)=>{"use strict";var n="function"===typeof Symbol&&Symbol.for,r=n?Symbol.for("react.element"):60103,a=n?Symbol.for("react.portal"):60106,s=n?Symbol.for("react.fragment"):60107,i=n?Symbol.for("react.strict_mode"):60108,o=n?Symbol.for("react.profiler"):60114,l=n?Symbol.for("react.provider"):60109,u=n?Symbol.for("react.context"):60110,c=n?Symbol.for("react.async_mode"):60111,d=n?Symbol.for("react.concurrent_mode"):60111,h=n?Symbol.for("react.forward_ref"):60112,p=n?Symbol.for("react.suspense"):60113,f=n?Symbol.for("react.suspense_list"):60120,m=n?Symbol.for("react.memo"):60115,g=n?Symbol.for("react.lazy"):60116,y=n?Symbol.for("react.block"):60121,b=n?Symbol.for("react.fundamental"):60117,v=n?Symbol.for("react.responder"):60118,x=n?Symbol.for("react.scope"):60119;function w(e){if("object"===typeof e&&null!==e){var t=e.$$typeof;switch(t){case r:switch(e=e.type){case c:case d:case s:case o:case i:case p:return e;default:switch(e=e&&e.$$typeof){case u:case h:case g:case m:case l:return e;default:return t}}case a:return t}}}function k(e){return w(e)===d}t.AsyncMode=c,t.ConcurrentMode=d,t.ContextConsumer=u,t.ContextProvider=l,t.Element=r,t.ForwardRef=h,t.Fragment=s,t.Lazy=g,t.Memo=m,t.Portal=a,t.Profiler=o,t.StrictMode=i,t.Suspense=p,t.isAsyncMode=function(e){return k(e)||w(e)===c},t.isConcurrentMode=k,t.isContextConsumer=function(e){return w(e)===u},t.isContextProvider=function(e){return w(e)===l},t.isElement=function(e){return"object"===typeof e&&null!==e&&e.$$typeof===r},t.isForwardRef=function(e){return w(e)===h},t.isFragment=function(e){return w(e)===s},t.isLazy=function(e){return w(e)===g},t.isMemo=function(e){return w(e)===m},t.isPortal=function(e){return w(e)===a},t.isProfiler=function(e){return w(e)===o},t.isStrictMode=function(e){return w(e)===i},t.isSuspense=function(e){return w(e)===p},t.isValidElementType=function(e){return"string"===typeof e||"function"===typeof e||e===s||e===d||e===o||e===i||e===p||e===f||"object"===typeof e&&null!==e&&(e.$$typeof===g||e.$$typeof===m||e.$$typeof===l||e.$$typeof===u||e.$$typeof===h||e.$$typeof===b||e.$$typeof===v||e.$$typeof===x||e.$$typeof===y)},t.typeOf=w},3763:(e,t,n)=>{"use strict";e.exports=n(4983)},1497:(e,t,n)=>{"use strict";var r=n(3218);function a(){}function s(){}s.resetWarningCache=a,e.exports=function(){function e(e,t,n,a,s,i){if(i!==r){var o=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw o.name="Invariant Violation",o}}function t(){return e}e.isRequired=e;var n={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:s,resetWarningCache:a};return n.PropTypes=n,n}},5173:(e,t,n)=>{e.exports=n(1497)()},3218:e=>{"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},2730:(e,t,n)=>{"use strict";var r=n(5043),a=n(8853);function s(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,o={};function l(e,t){u(e,t),u(e+"Capture",t)}function u(e,t){for(o[e]=t,e=0;e<t.length;e++)i.add(t[e])}var c=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),d=Object.prototype.hasOwnProperty,h=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(e,t,n,r,a,s,i){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=r,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=s,this.removeEmptyString=i}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){g[e]=new m(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){g[e]=new m(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){g[e]=new m(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){g[e]=new m(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){g[e]=new m(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)}));var y=/[\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function v(e,t,n,r){var a=g.hasOwnProperty(t)?g[t]:null;(null!==a?0!==a.type:r||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,r){if(null===t||"undefined"===typeof t||function(e,t,n,r){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,a,r)&&(n=null),r||null===a?function(e){return!!d.call(f,e)||!d.call(p,e)&&(h.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):a.mustUseProperty?e[a.propertyName]=null===n?3!==a.type&&"":n:(t=a.attributeName,r=a.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(a=a.type)||4===a&&!0===n?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)})),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)}));var x=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),I=Symbol.for("react.strict_mode"),C=Symbol.for("react.profiler"),N=Symbol.for("react.provider"),T=Symbol.for("react.context"),E=Symbol.for("react.forward_ref"),A=Symbol.for("react.suspense"),_=Symbol.for("react.suspense_list"),$=Symbol.for("react.memo"),R=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var D=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var M=Symbol.iterator;function F(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=M&&e[M]||e["@@iterator"])?e:null}var O,P=Object.assign;function L(e){if(void 0===O)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);O=t&&t[1]||""}return"\n"+O+e}var z=!1;function B(e,t){if(!e||z)return"";z=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(u){var r=u}Reflect.construct(e,[],t)}else{try{t.call()}catch(u){r=u}e.call(t.prototype)}else{try{throw Error()}catch(u){r=u}e()}}catch(u){if(u&&r&&"string"===typeof u.stack){for(var a=u.stack.split("\n"),s=r.stack.split("\n"),i=a.length-1,o=s.length-1;1<=i&&0<=o&&a[i]!==s[o];)o--;for(;1<=i&&0<=o;i--,o--)if(a[i]!==s[o]){if(1!==i||1!==o)do{if(i--,0>--o||a[i]!==s[o]){var l="\n"+a[i].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=i&&0<=o);break}}}finally{z=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?L(e):""}function W(e){switch(e.tag){case 5:return L(e.type);case 16:return L("Lazy");case 13:return L("Suspense");case 19:return L("SuspenseList");case 0:case 2:case 15:return e=B(e.type,!1);case 11:return e=B(e.type.render,!1);case 1:return e=B(e.type,!0);default:return""}}function V(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case S:return"Fragment";case k:return"Portal";case C:return"Profiler";case I:return"StrictMode";case A:return"Suspense";case _:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case T:return(e.displayName||"Context")+".Consumer";case N:return(e._context.displayName||"Context")+".Provider";case E:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case $:return null!==(t=e.displayName||null)?t:V(e.type)||"Memo";case R:t=e._payload,e=e._init;try{return V(e(t))}catch(n){}}return null}function U(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return V(t);case 8:return t===I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function j(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function G(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function H(e){e._valueTracker||(e._valueTracker=function(e){var t=G(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var a=n.get,s=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(e){r=""+e,s.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=G(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function K(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function X(e,t){var n=t.checked;return P({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Y(e,t){var n=null==t.defaultValue?"":t.defaultValue,r=null!=t.checked?t.checked:t.defaultChecked;n=j(null!=t.value?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Q(e,t){null!=(t=t.checked)&&v(e,"checked",t,!1)}function J(e,t){Q(e,t);var n=j(t.value),r=t.type;if(null!=n)"number"===r?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===r||"reset"===r)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,j(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function Z(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!("submit"!==r&&"reset"!==r||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&K(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,r){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&r&&(e[n].defaultSelected=!0)}else{for(n=""+j(n),t=null,a=0;a<e.length;a++){if(e[a].value===n)return e[a].selected=!0,void(r&&(e[a].defaultSelected=!0));null!==t||e[a].disabled||(t=e[a])}null!==t&&(t.selected=!0)}}function re(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(s(91));return P({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function ae(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(s(92));if(te(n)){if(1<n.length)throw Error(s(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:j(n)}}function se(e,t){var n=j(t.value),r=j(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=r&&(e.defaultValue=""+r)}function ie(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function oe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function le(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?oe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var ue,ce,de=(ce=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((ue=ue||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ue.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,r){MSApp.execUnsafeLocalFunction((function(){return ce(e,t)}))}:ce);function he(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var r=0===n.indexOf("--"),a=me(n,t[n],r);"float"===n&&(n="cssFloat"),r?e.setProperty(n,a):e[n]=a}}Object.keys(pe).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]}))}));var ye=P({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function be(e,t){if(t){if(ye[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(s(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(s(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(s(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(s(62))}}function ve(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var xe=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Se=null,Ie=null;function Ce(e){if(e=va(e)){if("function"!==typeof ke)throw Error(s(280));var t=e.stateNode;t&&(t=wa(t),ke(e.stateNode,e.type,t))}}function Ne(e){Se?Ie?Ie.push(e):Ie=[e]:Se=e}function Te(){if(Se){var e=Se,t=Ie;if(Ie=Se=null,Ce(e),t)for(e=0;e<t.length;e++)Ce(t[e])}}function Ee(e,t){return e(t)}function Ae(){}var _e=!1;function $e(e,t,n){if(_e)return e(t,n);_e=!0;try{return Ee(e,t,n)}finally{_e=!1,(null!==Se||null!==Ie)&&(Ae(),Te())}}function Re(e,t){var n=e.stateNode;if(null===n)return null;var r=wa(n);if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(s(231,t,typeof n));return n}var De=!1;if(c)try{var Me={};Object.defineProperty(Me,"passive",{get:function(){De=!0}}),window.addEventListener("test",Me,Me),window.removeEventListener("test",Me,Me)}catch(ce){De=!1}function Fe(e,t,n,r,a,s,i,o,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(c){this.onError(c)}}var Oe=!1,Pe=null,Le=!1,ze=null,Be={onError:function(e){Oe=!0,Pe=e}};function We(e,t,n,r,a,s,i,o,l){Oe=!1,Pe=null,Fe.apply(Be,arguments)}function Ve(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ue(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function je(e){if(Ve(e)!==e)throw Error(s(188))}function Ge(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ve(e)))throw Error(s(188));return t!==e?null:e}for(var n=e,r=t;;){var a=n.return;if(null===a)break;var i=a.alternate;if(null===i){if(null!==(r=a.return)){n=r;continue}break}if(a.child===i.child){for(i=a.child;i;){if(i===n)return je(a),e;if(i===r)return je(a),t;i=i.sibling}throw Error(s(188))}if(n.return!==r.return)n=a,r=i;else{for(var o=!1,l=a.child;l;){if(l===n){o=!0,n=a,r=i;break}if(l===r){o=!0,r=a,n=i;break}l=l.sibling}if(!o){for(l=i.child;l;){if(l===n){o=!0,n=i,r=a;break}if(l===r){o=!0,r=i,n=a;break}l=l.sibling}if(!o)throw Error(s(189))}}if(n.alternate!==r)throw Error(s(190))}if(3!==n.tag)throw Error(s(188));return n.stateNode.current===n?e:t}(e))?He(e):null}function He(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=He(e);if(null!==t)return t;e=e.sibling}return null}var qe=a.unstable_scheduleCallback,Ke=a.unstable_cancelCallback,Xe=a.unstable_shouldYield,Ye=a.unstable_requestPaint,Qe=a.unstable_now,Je=a.unstable_getCurrentPriorityLevel,Ze=a.unstable_ImmediatePriority,et=a.unstable_UserBlockingPriority,tt=a.unstable_NormalPriority,nt=a.unstable_LowPriority,rt=a.unstable_IdlePriority,at=null,st=null;var it=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(ot(e)/lt|0)|0},ot=Math.log,lt=Math.LN2;var ut=64,ct=4194304;function dt(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function ht(e,t){var n=e.pendingLanes;if(0===n)return 0;var r=0,a=e.suspendedLanes,s=e.pingedLanes,i=268435455&n;if(0!==i){var o=i&~a;0!==o?r=dt(o):0!==(s&=i)&&(r=dt(s))}else 0!==(i=n&~a)?r=dt(i):0!==s&&(r=dt(s));if(0===r)return 0;if(0!==t&&t!==r&&0===(t&a)&&((a=r&-r)>=(s=t&-t)||16===a&&0!==(4194240&s)))return t;if(0!==(4&r)&&(r|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=r;0<t;)a=1<<(n=31-it(t)),r|=e[n],t&=~a;return r}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=ut;return 0===(4194240&(ut<<=1))&&(ut=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function yt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-it(t)]=n}function bt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-it(n),a=1<<r;a&t|e[r]&t&&(e[r]|=t),n&=~a}}var vt=0;function xt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var wt,kt,St,It,Ct,Nt=!1,Tt=[],Et=null,At=null,_t=null,$t=new Map,Rt=new Map,Dt=[],Mt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ft(e,t){switch(e){case"focusin":case"focusout":Et=null;break;case"dragenter":case"dragleave":At=null;break;case"mouseover":case"mouseout":_t=null;break;case"pointerover":case"pointerout":$t.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Rt.delete(t.pointerId)}}function Ot(e,t,n,r,a,s){return null===e||e.nativeEvent!==s?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:s,targetContainers:[a]},null!==t&&(null!==(t=va(t))&&kt(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==a&&-1===t.indexOf(a)&&t.push(a),e)}function Pt(e){var t=ba(e.target);if(null!==t){var n=Ve(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ue(n)))return e.blockedOn=t,void Ct(e.priority,(function(){St(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function Lt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Xt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=va(n))&&kt(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);xe=r,n.target.dispatchEvent(r),xe=null,t.shift()}return!0}function zt(e,t,n){Lt(e)&&n.delete(t)}function Bt(){Nt=!1,null!==Et&&Lt(Et)&&(Et=null),null!==At&&Lt(At)&&(At=null),null!==_t&&Lt(_t)&&(_t=null),$t.forEach(zt),Rt.forEach(zt)}function Wt(e,t){e.blockedOn===t&&(e.blockedOn=null,Nt||(Nt=!0,a.unstable_scheduleCallback(a.unstable_NormalPriority,Bt)))}function Vt(e){function t(t){return Wt(t,e)}if(0<Tt.length){Wt(Tt[0],e);for(var n=1;n<Tt.length;n++){var r=Tt[n];r.blockedOn===e&&(r.blockedOn=null)}}for(null!==Et&&Wt(Et,e),null!==At&&Wt(At,e),null!==_t&&Wt(_t,e),$t.forEach(t),Rt.forEach(t),n=0;n<Dt.length;n++)(r=Dt[n]).blockedOn===e&&(r.blockedOn=null);for(;0<Dt.length&&null===(n=Dt[0]).blockedOn;)Pt(n),null===n.blockedOn&&Dt.shift()}var Ut=x.ReactCurrentBatchConfig,jt=!0;function Gt(e,t,n,r){var a=vt,s=Ut.transition;Ut.transition=null;try{vt=1,qt(e,t,n,r)}finally{vt=a,Ut.transition=s}}function Ht(e,t,n,r){var a=vt,s=Ut.transition;Ut.transition=null;try{vt=4,qt(e,t,n,r)}finally{vt=a,Ut.transition=s}}function qt(e,t,n,r){if(jt){var a=Xt(e,t,n,r);if(null===a)jr(e,t,r,Kt,n),Ft(e,r);else if(function(e,t,n,r,a){switch(t){case"focusin":return Et=Ot(Et,e,t,n,r,a),!0;case"dragenter":return At=Ot(At,e,t,n,r,a),!0;case"mouseover":return _t=Ot(_t,e,t,n,r,a),!0;case"pointerover":var s=a.pointerId;return $t.set(s,Ot($t.get(s)||null,e,t,n,r,a)),!0;case"gotpointercapture":return s=a.pointerId,Rt.set(s,Ot(Rt.get(s)||null,e,t,n,r,a)),!0}return!1}(a,e,t,n,r))r.stopPropagation();else if(Ft(e,r),4&t&&-1<Mt.indexOf(e)){for(;null!==a;){var s=va(a);if(null!==s&&wt(s),null===(s=Xt(e,t,n,r))&&jr(e,t,r,Kt,n),s===a)break;a=s}null!==a&&r.stopPropagation()}else jr(e,t,r,null,n)}}var Kt=null;function Xt(e,t,n,r){if(Kt=null,null!==(e=ba(e=we(r))))if(null===(t=Ve(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Ue(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Kt=e,null}function Yt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Je()){case Ze:return 1;case et:return 4;case tt:case nt:return 16;case rt:return 536870912;default:return 16}default:return 16}}var Qt=null,Jt=null,Zt=null;function en(){if(Zt)return Zt;var e,t,n=Jt,r=n.length,a="value"in Qt?Qt.value:Qt.textContent,s=a.length;for(e=0;e<r&&n[e]===a[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===a[s-t];t++);return Zt=a.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function rn(){return!1}function an(e){function t(t,n,r,a,s){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=a,this.target=s,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(a):a[i]);return this.isDefaultPrevented=(null!=a.defaultPrevented?a.defaultPrevented:!1===a.returnValue)?nn:rn,this.isPropagationStopped=rn,this}return P(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var sn,on,ln,un={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},cn=an(un),dn=P({},un,{view:0,detail:0}),hn=an(dn),pn=P({},dn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Cn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==ln&&(ln&&"mousemove"===e.type?(sn=e.screenX-ln.screenX,on=e.screenY-ln.screenY):on=sn=0,ln=e),sn)},movementY:function(e){return"movementY"in e?e.movementY:on}}),fn=an(pn),mn=an(P({},pn,{dataTransfer:0})),gn=an(P({},dn,{relatedTarget:0})),yn=an(P({},un,{animationName:0,elapsedTime:0,pseudoElement:0})),bn=P({},un,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),vn=an(bn),xn=an(P({},un,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function In(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sn[e])&&!!t[e]}function Cn(){return In}var Nn=P({},dn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Cn,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Tn=an(Nn),En=an(P({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),An=an(P({},dn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Cn})),_n=an(P({},un,{propertyName:0,elapsedTime:0,pseudoElement:0})),$n=P({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Rn=an($n),Dn=[9,13,27,32],Mn=c&&"CompositionEvent"in window,Fn=null;c&&"documentMode"in document&&(Fn=document.documentMode);var On=c&&"TextEvent"in window&&!Fn,Pn=c&&(!Mn||Fn&&8<Fn&&11>=Fn),Ln=String.fromCharCode(32),zn=!1;function Bn(e,t){switch(e){case"keyup":return-1!==Dn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Wn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Vn=!1;var Un={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function jn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Un[e.type]:"textarea"===t}function Gn(e,t,n,r){Ne(r),0<(t=Hr(t,"onChange")).length&&(n=new cn("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Hn=null,qn=null;function Kn(e){Lr(e,0)}function Xn(e){if(q(xa(e)))return e}function Yn(e,t){if("change"===e)return t}var Qn=!1;if(c){var Jn;if(c){var Zn="oninput"in document;if(!Zn){var er=document.createElement("div");er.setAttribute("oninput","return;"),Zn="function"===typeof er.oninput}Jn=Zn}else Jn=!1;Qn=Jn&&(!document.documentMode||9<document.documentMode)}function tr(){Hn&&(Hn.detachEvent("onpropertychange",nr),qn=Hn=null)}function nr(e){if("value"===e.propertyName&&Xn(qn)){var t=[];Gn(t,qn,e,we(e)),$e(Kn,t)}}function rr(e,t,n){"focusin"===e?(tr(),qn=n,(Hn=t).attachEvent("onpropertychange",nr)):"focusout"===e&&tr()}function ar(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Xn(qn)}function sr(e,t){if("click"===e)return Xn(t)}function ir(e,t){if("input"===e||"change"===e)return Xn(t)}var or="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function lr(e,t){if(or(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!d.call(t,a)||!or(e[a],t[a]))return!1}return!0}function ur(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function cr(e,t){var n,r=ur(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=ur(r)}}function dr(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?dr(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function hr(){for(var e=window,t=K();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(r){n=!1}if(!n)break;t=K((e=t.contentWindow).document)}return t}function pr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fr(e){var t=hr(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&dr(n.ownerDocument.documentElement,n)){if(null!==r&&pr(n))if(t=r.start,void 0===(e=r.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var a=n.textContent.length,s=Math.min(r.start,a);r=void 0===r.end?s:Math.min(r.end,a),!e.extend&&s>r&&(a=r,r=s,s=a),a=cr(n,s);var i=cr(n,r);a&&i&&(1!==e.rangeCount||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&((t=t.createRange()).setStart(a.node,a.offset),e.removeAllRanges(),s>r?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var mr=c&&"documentMode"in document&&11>=document.documentMode,gr=null,yr=null,br=null,vr=!1;function xr(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;vr||null==gr||gr!==K(r)||("selectionStart"in(r=gr)&&pr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},br&&lr(br,r)||(br=r,0<(r=Hr(yr,"onSelect")).length&&(t=new cn("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=gr)))}function wr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var kr={animationend:wr("Animation","AnimationEnd"),animationiteration:wr("Animation","AnimationIteration"),animationstart:wr("Animation","AnimationStart"),transitionend:wr("Transition","TransitionEnd")},Sr={},Ir={};function Cr(e){if(Sr[e])return Sr[e];if(!kr[e])return e;var t,n=kr[e];for(t in n)if(n.hasOwnProperty(t)&&t in Ir)return Sr[e]=n[t];return e}c&&(Ir=document.createElement("div").style,"AnimationEvent"in window||(delete kr.animationend.animation,delete kr.animationiteration.animation,delete kr.animationstart.animation),"TransitionEvent"in window||delete kr.transitionend.transition);var Nr=Cr("animationend"),Tr=Cr("animationiteration"),Er=Cr("animationstart"),Ar=Cr("transitionend"),_r=new Map,$r="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Rr(e,t){_r.set(e,t),l(t,[e])}for(var Dr=0;Dr<$r.length;Dr++){var Mr=$r[Dr];Rr(Mr.toLowerCase(),"on"+(Mr[0].toUpperCase()+Mr.slice(1)))}Rr(Nr,"onAnimationEnd"),Rr(Tr,"onAnimationIteration"),Rr(Er,"onAnimationStart"),Rr("dblclick","onDoubleClick"),Rr("focusin","onFocus"),Rr("focusout","onBlur"),Rr(Ar,"onTransitionEnd"),u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Fr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Or=new Set("cancel close invalid load scroll toggle".split(" ").concat(Fr));function Pr(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,r,a,i,o,l,u){if(We.apply(this,arguments),Oe){if(!Oe)throw Error(s(198));var c=Pe;Oe=!1,Pe=null,Le||(Le=!0,ze=c)}}(r,t,void 0,e),e.currentTarget=null}function Lr(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var r=e[n],a=r.event;r=r.listeners;e:{var s=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==s&&a.isPropagationStopped())break e;Pr(a,o,u),s=l}else for(i=0;i<r.length;i++){if(l=(o=r[i]).instance,u=o.currentTarget,o=o.listener,l!==s&&a.isPropagationStopped())break e;Pr(a,o,u),s=l}}}if(Le)throw e=ze,Le=!1,ze=null,e}function zr(e,t){var n=t[ma];void 0===n&&(n=t[ma]=new Set);var r=e+"__bubble";n.has(r)||(Ur(t,e,2,!1),n.add(r))}function Br(e,t,n){var r=0;t&&(r|=4),Ur(n,e,r,t)}var Wr="_reactListening"+Math.random().toString(36).slice(2);function Vr(e){if(!e[Wr]){e[Wr]=!0,i.forEach((function(t){"selectionchange"!==t&&(Or.has(t)||Br(t,!1,e),Br(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Wr]||(t[Wr]=!0,Br("selectionchange",!1,t))}}function Ur(e,t,n,r){switch(Yt(t)){case 1:var a=Gt;break;case 4:a=Ht;break;default:a=qt}n=a.bind(null,t,n,e),a=void 0,!De||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(a=!0),r?void 0!==a?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):void 0!==a?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function jr(e,t,n,r,a){var s=r;if(0===(1&t)&&0===(2&t)&&null!==r)e:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var o=r.stateNode.containerInfo;if(o===a||8===o.nodeType&&o.parentNode===a)break;if(4===i)for(i=r.return;null!==i;){var l=i.tag;if((3===l||4===l)&&((l=i.stateNode.containerInfo)===a||8===l.nodeType&&l.parentNode===a))return;i=i.return}for(;null!==o;){if(null===(i=ba(o)))return;if(5===(l=i.tag)||6===l){r=s=i;continue e}o=o.parentNode}}r=r.return}$e((function(){var r=s,a=we(n),i=[];e:{var o=_r.get(e);if(void 0!==o){var l=cn,u=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":l=Tn;break;case"focusin":u="focus",l=gn;break;case"focusout":u="blur",l=gn;break;case"beforeblur":case"afterblur":l=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=An;break;case Nr:case Tr:case Er:l=yn;break;case Ar:l=_n;break;case"scroll":l=hn;break;case"wheel":l=Rn;break;case"copy":case"cut":case"paste":l=vn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=En}var c=0!==(4&t),d=!c&&"scroll"===e,h=c?null!==o?o+"Capture":null:o;c=[];for(var p,f=r;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==h&&(null!=(m=Re(f,h))&&c.push(Gr(f,m,p)))),d)break;f=f.return}0<c.length&&(o=new l(o,u,null,n,a),i.push({event:o,listeners:c}))}}if(0===(7&t)){if(l="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===xe||!(u=n.relatedTarget||n.fromElement)||!ba(u)&&!u[fa])&&(l||o)&&(o=a.window===a?a:(o=a.ownerDocument)?o.defaultView||o.parentWindow:window,l?(l=r,null!==(u=(u=n.relatedTarget||n.toElement)?ba(u):null)&&(u!==(d=Ve(u))||5!==u.tag&&6!==u.tag)&&(u=null)):(l=null,u=r),l!==u)){if(c=fn,m="onMouseLeave",h="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(c=En,m="onPointerLeave",h="onPointerEnter",f="pointer"),d=null==l?o:xa(l),p=null==u?o:xa(u),(o=new c(m,f+"leave",l,n,a)).target=d,o.relatedTarget=p,m=null,ba(a)===r&&((c=new c(h,f+"enter",u,n,a)).target=p,c.relatedTarget=d,m=c),d=m,l&&u)e:{for(h=u,f=0,p=c=l;p;p=qr(p))f++;for(p=0,m=h;m;m=qr(m))p++;for(;0<f-p;)c=qr(c),f--;for(;0<p-f;)h=qr(h),p--;for(;f--;){if(c===h||null!==h&&c===h.alternate)break e;c=qr(c),h=qr(h)}c=null}else c=null;null!==l&&Kr(i,o,l,c,!1),null!==u&&null!==d&&Kr(i,d,u,c,!0)}if("select"===(l=(o=r?xa(r):window).nodeName&&o.nodeName.toLowerCase())||"input"===l&&"file"===o.type)var g=Yn;else if(jn(o))if(Qn)g=ir;else{g=ar;var y=rr}else(l=o.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(g=sr);switch(g&&(g=g(e,r))?Gn(i,g,n,a):(y&&y(e,o,r),"focusout"===e&&(y=o._wrapperState)&&y.controlled&&"number"===o.type&&ee(o,"number",o.value)),y=r?xa(r):window,e){case"focusin":(jn(y)||"true"===y.contentEditable)&&(gr=y,yr=r,br=null);break;case"focusout":br=yr=gr=null;break;case"mousedown":vr=!0;break;case"contextmenu":case"mouseup":case"dragend":vr=!1,xr(i,n,a);break;case"selectionchange":if(mr)break;case"keydown":case"keyup":xr(i,n,a)}var b;if(Mn)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else Vn?Bn(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(Pn&&"ko"!==n.locale&&(Vn||"onCompositionStart"!==v?"onCompositionEnd"===v&&Vn&&(b=en()):(Jt="value"in(Qt=a)?Qt.value:Qt.textContent,Vn=!0)),0<(y=Hr(r,v)).length&&(v=new xn(v,e,null,n,a),i.push({event:v,listeners:y}),b?v.data=b:null!==(b=Wn(n))&&(v.data=b))),(b=On?function(e,t){switch(e){case"compositionend":return Wn(t);case"keypress":return 32!==t.which?null:(zn=!0,Ln);case"textInput":return(e=t.data)===Ln&&zn?null:e;default:return null}}(e,n):function(e,t){if(Vn)return"compositionend"===e||!Mn&&Bn(e,t)?(e=en(),Zt=Jt=Qt=null,Vn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Pn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(r=Hr(r,"onBeforeInput")).length&&(a=new xn("onBeforeInput","beforeinput",null,n,a),i.push({event:a,listeners:r}),a.data=b))}Lr(i,t)}))}function Gr(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Hr(e,t){for(var n=t+"Capture",r=[];null!==e;){var a=e,s=a.stateNode;5===a.tag&&null!==s&&(a=s,null!=(s=Re(e,n))&&r.unshift(Gr(e,s,a)),null!=(s=Re(e,t))&&r.push(Gr(e,s,a))),e=e.return}return r}function qr(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Kr(e,t,n,r,a){for(var s=t._reactName,i=[];null!==n&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(null!==l&&l===r)break;5===o.tag&&null!==u&&(o=u,a?null!=(l=Re(n,s))&&i.unshift(Gr(n,l,o)):a||null!=(l=Re(n,s))&&i.push(Gr(n,l,o))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var Xr=/\r\n?/g,Yr=/\u0000|\uFFFD/g;function Qr(e){return("string"===typeof e?e:""+e).replace(Xr,"\n").replace(Yr,"")}function Jr(e,t,n){if(t=Qr(t),Qr(e)!==t&&n)throw Error(s(425))}function Zr(){}var ea=null,ta=null;function na(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ra="function"===typeof setTimeout?setTimeout:void 0,aa="function"===typeof clearTimeout?clearTimeout:void 0,sa="function"===typeof Promise?Promise:void 0,ia="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof sa?function(e){return sa.resolve(null).then(e).catch(oa)}:ra;function oa(e){setTimeout((function(){throw e}))}function la(e,t){var n=t,r=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0===r)return e.removeChild(a),void Vt(t);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=a}while(n);Vt(t)}function ua(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function ca(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var da=Math.random().toString(36).slice(2),ha="__reactFiber$"+da,pa="__reactProps$"+da,fa="__reactContainer$"+da,ma="__reactEvents$"+da,ga="__reactListeners$"+da,ya="__reactHandles$"+da;function ba(e){var t=e[ha];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fa]||n[ha]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=ca(e);null!==e;){if(n=e[ha])return n;e=ca(e)}return t}n=(e=n).parentNode}return null}function va(e){return!(e=e[ha]||e[fa])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function xa(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(s(33))}function wa(e){return e[pa]||null}var ka=[],Sa=-1;function Ia(e){return{current:e}}function Ca(e){0>Sa||(e.current=ka[Sa],ka[Sa]=null,Sa--)}function Na(e,t){Sa++,ka[Sa]=e.current,e.current=t}var Ta={},Ea=Ia(Ta),Aa=Ia(!1),_a=Ta;function $a(e,t){var n=e.type.contextTypes;if(!n)return Ta;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var a,s={};for(a in n)s[a]=t[a];return r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function Ra(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Da(){Ca(Aa),Ca(Ea)}function Ma(e,t,n){if(Ea.current!==Ta)throw Error(s(168));Na(Ea,t),Na(Aa,n)}function Fa(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,"function"!==typeof r.getChildContext)return n;for(var a in r=r.getChildContext())if(!(a in t))throw Error(s(108,U(e)||"Unknown",a));return P({},n,r)}function Oa(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Ta,_a=Ea.current,Na(Ea,e),Na(Aa,Aa.current),!0}function Pa(e,t,n){var r=e.stateNode;if(!r)throw Error(s(169));n?(e=Fa(e,t,_a),r.__reactInternalMemoizedMergedChildContext=e,Ca(Aa),Ca(Ea),Na(Ea,e)):Ca(Aa),Na(Aa,n)}var La=null,za=!1,Ba=!1;function Wa(e){null===La?La=[e]:La.push(e)}function Va(){if(!Ba&&null!==La){Ba=!0;var e=0,t=vt;try{var n=La;for(vt=1;e<n.length;e++){var r=n[e];do{r=r(!0)}while(null!==r)}La=null,za=!1}catch(a){throw null!==La&&(La=La.slice(e+1)),qe(Ze,Va),a}finally{vt=t,Ba=!1}}return null}var Ua=[],ja=0,Ga=null,Ha=0,qa=[],Ka=0,Xa=null,Ya=1,Qa="";function Ja(e,t){Ua[ja++]=Ha,Ua[ja++]=Ga,Ga=e,Ha=t}function Za(e,t,n){qa[Ka++]=Ya,qa[Ka++]=Qa,qa[Ka++]=Xa,Xa=e;var r=Ya;e=Qa;var a=32-it(r)-1;r&=~(1<<a),n+=1;var s=32-it(t)+a;if(30<s){var i=a-a%5;s=(r&(1<<i)-1).toString(32),r>>=i,a-=i,Ya=1<<32-it(t)+a|n<<a|r,Qa=s+e}else Ya=1<<s|n<<a|r,Qa=e}function es(e){null!==e.return&&(Ja(e,1),Za(e,1,0))}function ts(e){for(;e===Ga;)Ga=Ua[--ja],Ua[ja]=null,Ha=Ua[--ja],Ua[ja]=null;for(;e===Xa;)Xa=qa[--Ka],qa[Ka]=null,Qa=qa[--Ka],qa[Ka]=null,Ya=qa[--Ka],qa[Ka]=null}var ns=null,rs=null,as=!1,ss=null;function is(e,t){var n=$u(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function os(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,ns=e,rs=ua(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,ns=e,rs=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Xa?{id:Ya,overflow:Qa}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=$u(18,null,null,0)).stateNode=t,n.return=e,e.child=n,ns=e,rs=null,!0);default:return!1}}function ls(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function us(e){if(as){var t=rs;if(t){var n=t;if(!os(e,t)){if(ls(e))throw Error(s(418));t=ua(n.nextSibling);var r=ns;t&&os(e,t)?is(r,n):(e.flags=-4097&e.flags|2,as=!1,ns=e)}}else{if(ls(e))throw Error(s(418));e.flags=-4097&e.flags|2,as=!1,ns=e}}}function cs(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;ns=e}function ds(e){if(e!==ns)return!1;if(!as)return cs(e),as=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!na(e.type,e.memoizedProps)),t&&(t=rs)){if(ls(e))throw hs(),Error(s(418));for(;t;)is(e,t),t=ua(t.nextSibling)}if(cs(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(s(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){rs=ua(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}rs=null}}else rs=ns?ua(e.stateNode.nextSibling):null;return!0}function hs(){for(var e=rs;e;)e=ua(e.nextSibling)}function ps(){rs=ns=null,as=!1}function fs(e){null===ss?ss=[e]:ss.push(e)}var ms=x.ReactCurrentBatchConfig;function gs(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(s(309));var r=n.stateNode}if(!r)throw Error(s(147,e));var a=r,i=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===i?t.ref:(t=function(e){var t=a.refs;null===e?delete t[i]:t[i]=e},t._stringRef=i,t)}if("string"!==typeof e)throw Error(s(284));if(!n._owner)throw Error(s(290,e))}return e}function ys(e,t){throw e=Object.prototype.toString.call(t),Error(s(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function bs(e){return(0,e._init)(e._payload)}function vs(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function a(e,t){return(e=Du(e,t)).index=0,e.sibling=null,e}function i(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=2,n):r:(t.flags|=2,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=2),t}function l(e,t,n,r){return null===t||6!==t.tag?((t=Pu(n,e.mode,r)).return=e,t):((t=a(t,n)).return=e,t)}function u(e,t,n,r){var s=n.type;return s===S?d(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===s||"object"===typeof s&&null!==s&&s.$$typeof===R&&bs(s)===t.type)?((r=a(t,n.props)).ref=gs(e,t,n),r.return=e,r):((r=Mu(n.type,n.key,n.props,null,e.mode,r)).ref=gs(e,t,n),r.return=e,r)}function c(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Lu(n,e.mode,r)).return=e,t):((t=a(t,n.children||[])).return=e,t)}function d(e,t,n,r,s){return null===t||7!==t.tag?((t=Fu(n,e.mode,r,s)).return=e,t):((t=a(t,n)).return=e,t)}function h(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=Pu(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Mu(t.type,t.key,t.props,null,e.mode,n)).ref=gs(e,null,t),n.return=e,n;case k:return(t=Lu(t,e.mode,n)).return=e,t;case R:return h(e,(0,t._init)(t._payload),n)}if(te(t)||F(t))return(t=Fu(t,e.mode,n,null)).return=e,t;ys(e,t)}return null}function p(e,t,n,r){var a=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==a?null:l(e,t,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===a?u(e,t,n,r):null;case k:return n.key===a?c(e,t,n,r):null;case R:return p(e,t,(a=n._init)(n._payload),r)}if(te(n)||F(n))return null!==a?null:d(e,t,n,r,null);ys(e,n)}return null}function f(e,t,n,r,a){if("string"===typeof r&&""!==r||"number"===typeof r)return l(t,e=e.get(n)||null,""+r,a);if("object"===typeof r&&null!==r){switch(r.$$typeof){case w:return u(t,e=e.get(null===r.key?n:r.key)||null,r,a);case k:return c(t,e=e.get(null===r.key?n:r.key)||null,r,a);case R:return f(e,t,n,(0,r._init)(r._payload),a)}if(te(r)||F(r))return d(t,e=e.get(n)||null,r,a,null);ys(t,r)}return null}function m(a,s,o,l){for(var u=null,c=null,d=s,m=s=0,g=null;null!==d&&m<o.length;m++){d.index>m?(g=d,d=null):g=d.sibling;var y=p(a,d,o[m],l);if(null===y){null===d&&(d=g);break}e&&d&&null===y.alternate&&t(a,d),s=i(y,s,m),null===c?u=y:c.sibling=y,c=y,d=g}if(m===o.length)return n(a,d),as&&Ja(a,m),u;if(null===d){for(;m<o.length;m++)null!==(d=h(a,o[m],l))&&(s=i(d,s,m),null===c?u=d:c.sibling=d,c=d);return as&&Ja(a,m),u}for(d=r(a,d);m<o.length;m++)null!==(g=f(d,a,m,o[m],l))&&(e&&null!==g.alternate&&d.delete(null===g.key?m:g.key),s=i(g,s,m),null===c?u=g:c.sibling=g,c=g);return e&&d.forEach((function(e){return t(a,e)})),as&&Ja(a,m),u}function g(a,o,l,u){var c=F(l);if("function"!==typeof c)throw Error(s(150));if(null==(l=c.call(l)))throw Error(s(151));for(var d=c=null,m=o,g=o=0,y=null,b=l.next();null!==m&&!b.done;g++,b=l.next()){m.index>g?(y=m,m=null):y=m.sibling;var v=p(a,m,b.value,u);if(null===v){null===m&&(m=y);break}e&&m&&null===v.alternate&&t(a,m),o=i(v,o,g),null===d?c=v:d.sibling=v,d=v,m=y}if(b.done)return n(a,m),as&&Ja(a,g),c;if(null===m){for(;!b.done;g++,b=l.next())null!==(b=h(a,b.value,u))&&(o=i(b,o,g),null===d?c=b:d.sibling=b,d=b);return as&&Ja(a,g),c}for(m=r(a,m);!b.done;g++,b=l.next())null!==(b=f(m,a,g,b.value,u))&&(e&&null!==b.alternate&&m.delete(null===b.key?g:b.key),o=i(b,o,g),null===d?c=b:d.sibling=b,d=b);return e&&m.forEach((function(e){return t(a,e)})),as&&Ja(a,g),c}return function e(r,s,i,l){if("object"===typeof i&&null!==i&&i.type===S&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case w:e:{for(var u=i.key,c=s;null!==c;){if(c.key===u){if((u=i.type)===S){if(7===c.tag){n(r,c.sibling),(s=a(c,i.props.children)).return=r,r=s;break e}}else if(c.elementType===u||"object"===typeof u&&null!==u&&u.$$typeof===R&&bs(u)===c.type){n(r,c.sibling),(s=a(c,i.props)).ref=gs(r,c,i),s.return=r,r=s;break e}n(r,c);break}t(r,c),c=c.sibling}i.type===S?((s=Fu(i.props.children,r.mode,l,i.key)).return=r,r=s):((l=Mu(i.type,i.key,i.props,null,r.mode,l)).ref=gs(r,s,i),l.return=r,r=l)}return o(r);case k:e:{for(c=i.key;null!==s;){if(s.key===c){if(4===s.tag&&s.stateNode.containerInfo===i.containerInfo&&s.stateNode.implementation===i.implementation){n(r,s.sibling),(s=a(s,i.children||[])).return=r,r=s;break e}n(r,s);break}t(r,s),s=s.sibling}(s=Lu(i,r.mode,l)).return=r,r=s}return o(r);case R:return e(r,s,(c=i._init)(i._payload),l)}if(te(i))return m(r,s,i,l);if(F(i))return g(r,s,i,l);ys(r,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==s&&6===s.tag?(n(r,s.sibling),(s=a(s,i)).return=r,r=s):(n(r,s),(s=Pu(i,r.mode,l)).return=r,r=s),o(r)):n(r,s)}}var xs=vs(!0),ws=vs(!1),ks=Ia(null),Ss=null,Is=null,Cs=null;function Ns(){Cs=Is=Ss=null}function Ts(e){var t=ks.current;Ca(ks),e._currentValue=t}function Es(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function As(e,t){Ss=e,Cs=Is=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(vo=!0),e.firstContext=null)}function _s(e){var t=e._currentValue;if(Cs!==e)if(e={context:e,memoizedValue:t,next:null},null===Is){if(null===Ss)throw Error(s(308));Is=e,Ss.dependencies={lanes:0,firstContext:e}}else Is=Is.next=e;return t}var $s=null;function Rs(e){null===$s?$s=[e]:$s.push(e)}function Ds(e,t,n,r){var a=t.interleaved;return null===a?(n.next=n,Rs(t)):(n.next=a.next,a.next=n),t.interleaved=n,Ms(e,r)}function Ms(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Fs=!1;function Os(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Ps(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Ls(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function zs(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&El)){var a=r.pending;return null===a?t.next=t:(t.next=a.next,a.next=t),r.pending=t,Ms(e,n)}return null===(a=r.interleaved)?(t.next=t,Rs(r)):(t.next=a.next,a.next=t),r.interleaved=t,Ms(e,n)}function Bs(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}function Ws(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var a=null,s=null;if(null!==(n=n.firstBaseUpdate)){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===s?a=s=i:s=s.next=i,n=n.next}while(null!==n);null===s?a=s=t:s=s.next=t}else a=s=t;return n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:s,shared:r.shared,effects:r.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Vs(e,t,n,r){var a=e.updateQueue;Fs=!1;var s=a.firstBaseUpdate,i=a.lastBaseUpdate,o=a.shared.pending;if(null!==o){a.shared.pending=null;var l=o,u=l.next;l.next=null,null===i?s=u:i.next=u,i=l;var c=e.alternate;null!==c&&((o=(c=c.updateQueue).lastBaseUpdate)!==i&&(null===o?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(null!==s){var d=a.baseState;for(i=0,c=u=l=null,o=s;;){var h=o.lane,p=o.eventTime;if((r&h)===h){null!==c&&(c=c.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(h=t,p=n,m.tag){case 1:if("function"===typeof(f=m.payload)){d=f.call(p,d,h);break e}d=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(h="function"===typeof(f=m.payload)?f.call(p,d,h):f)||void 0===h)break e;d=P({},d,h);break e;case 2:Fs=!0}}null!==o.callback&&0!==o.lane&&(e.flags|=64,null===(h=a.effects)?a.effects=[o]:h.push(o))}else p={eventTime:p,lane:h,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===c?(u=c=p,l=d):c=c.next=p,i|=h;if(null===(o=o.next)){if(null===(o=a.shared.pending))break;o=(h=o).next,h.next=null,a.lastBaseUpdate=h,a.shared.pending=null}}if(null===c&&(l=d),a.baseState=l,a.firstBaseUpdate=u,a.lastBaseUpdate=c,null!==(t=a.shared.interleaved)){a=t;do{i|=a.lane,a=a.next}while(a!==t)}else null===s&&(a.shared.lanes=0);Ol|=i,e.lanes=i,e.memoizedState=d}}function Us(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var r=e[t],a=r.callback;if(null!==a){if(r.callback=null,r=n,"function"!==typeof a)throw Error(s(191,a));a.call(r)}}}var js={},Gs=Ia(js),Hs=Ia(js),qs=Ia(js);function Ks(e){if(e===js)throw Error(s(174));return e}function Xs(e,t){switch(Na(qs,t),Na(Hs,e),Na(Gs,js),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:le(null,"");break;default:t=le(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Ca(Gs),Na(Gs,t)}function Ys(){Ca(Gs),Ca(Hs),Ca(qs)}function Qs(e){Ks(qs.current);var t=Ks(Gs.current),n=le(t,e.type);t!==n&&(Na(Hs,e),Na(Gs,n))}function Js(e){Hs.current===e&&(Ca(Gs),Ca(Hs))}var Zs=Ia(0);function ei(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ti=[];function ni(){for(var e=0;e<ti.length;e++)ti[e]._workInProgressVersionPrimary=null;ti.length=0}var ri=x.ReactCurrentDispatcher,ai=x.ReactCurrentBatchConfig,si=0,ii=null,oi=null,li=null,ui=!1,ci=!1,di=0,hi=0;function pi(){throw Error(s(321))}function fi(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!or(e[n],t[n]))return!1;return!0}function mi(e,t,n,r,a,i){if(si=i,ii=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,ri.current=null===e||null===e.memoizedState?Ji:Zi,e=n(r,a),ci){i=0;do{if(ci=!1,di=0,25<=i)throw Error(s(301));i+=1,li=oi=null,t.updateQueue=null,ri.current=eo,e=n(r,a)}while(ci)}if(ri.current=Qi,t=null!==oi&&null!==oi.next,si=0,li=oi=ii=null,ui=!1,t)throw Error(s(300));return e}function gi(){var e=0!==di;return di=0,e}function yi(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===li?ii.memoizedState=li=e:li=li.next=e,li}function bi(){if(null===oi){var e=ii.alternate;e=null!==e?e.memoizedState:null}else e=oi.next;var t=null===li?ii.memoizedState:li.next;if(null!==t)li=t,oi=e;else{if(null===e)throw Error(s(310));e={memoizedState:(oi=e).memoizedState,baseState:oi.baseState,baseQueue:oi.baseQueue,queue:oi.queue,next:null},null===li?ii.memoizedState=li=e:li=li.next=e}return li}function vi(e,t){return"function"===typeof t?t(e):t}function xi(e){var t=bi(),n=t.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=e;var r=oi,a=r.baseQueue,i=n.pending;if(null!==i){if(null!==a){var o=a.next;a.next=i.next,i.next=o}r.baseQueue=a=i,n.pending=null}if(null!==a){i=a.next,r=r.baseState;var l=o=null,u=null,c=i;do{var d=c.lane;if((si&d)===d)null!==u&&(u=u.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),r=c.hasEagerState?c.eagerState:e(r,c.action);else{var h={lane:d,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};null===u?(l=u=h,o=r):u=u.next=h,ii.lanes|=d,Ol|=d}c=c.next}while(null!==c&&c!==i);null===u?o=r:u.next=l,or(r,t.memoizedState)||(vo=!0),t.memoizedState=r,t.baseState=o,t.baseQueue=u,n.lastRenderedState=r}if(null!==(e=n.interleaved)){a=e;do{i=a.lane,ii.lanes|=i,Ol|=i,a=a.next}while(a!==e)}else null===a&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function wi(e){var t=bi(),n=t.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=e;var r=n.dispatch,a=n.pending,i=t.memoizedState;if(null!==a){n.pending=null;var o=a=a.next;do{i=e(i,o.action),o=o.next}while(o!==a);or(i,t.memoizedState)||(vo=!0),t.memoizedState=i,null===t.baseQueue&&(t.baseState=i),n.lastRenderedState=i}return[i,r]}function ki(){}function Si(e,t){var n=ii,r=bi(),a=t(),i=!or(r.memoizedState,a);if(i&&(r.memoizedState=a,vo=!0),r=r.queue,Fi(Ni.bind(null,n,r,e),[e]),r.getSnapshot!==t||i||null!==li&&1&li.memoizedState.tag){if(n.flags|=2048,_i(9,Ci.bind(null,n,r,a,t),void 0,null),null===Al)throw Error(s(349));0!==(30&si)||Ii(n,t,a)}return a}function Ii(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ci(e,t,n,r){t.value=n,t.getSnapshot=r,Ti(t)&&Ei(e)}function Ni(e,t,n){return n((function(){Ti(t)&&Ei(e)}))}function Ti(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!or(e,n)}catch(r){return!0}}function Ei(e){var t=Ms(e,1);null!==t&&nu(t,e,1,-1)}function Ai(e){var t=yi();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:vi,lastRenderedState:e},t.queue=e,e=e.dispatch=qi.bind(null,ii,e),[t.memoizedState,e]}function _i(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function $i(){return bi().memoizedState}function Ri(e,t,n,r){var a=yi();ii.flags|=e,a.memoizedState=_i(1|t,n,void 0,void 0===r?null:r)}function Di(e,t,n,r){var a=bi();r=void 0===r?null:r;var s=void 0;if(null!==oi){var i=oi.memoizedState;if(s=i.destroy,null!==r&&fi(r,i.deps))return void(a.memoizedState=_i(t,n,s,r))}ii.flags|=e,a.memoizedState=_i(1|t,n,s,r)}function Mi(e,t){return Ri(8390656,8,e,t)}function Fi(e,t){return Di(2048,8,e,t)}function Oi(e,t){return Di(4,2,e,t)}function Pi(e,t){return Di(4,4,e,t)}function Li(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function zi(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Di(4,4,Li.bind(null,t,e),n)}function Bi(){}function Wi(e,t){var n=bi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fi(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Vi(e,t){var n=bi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fi(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Ui(e,t,n){return 0===(21&si)?(e.baseState&&(e.baseState=!1,vo=!0),e.memoizedState=n):(or(n,t)||(n=mt(),ii.lanes|=n,Ol|=n,e.baseState=!0),t)}function ji(e,t){var n=vt;vt=0!==n&&4>n?n:4,e(!0);var r=ai.transition;ai.transition={};try{e(!1),t()}finally{vt=n,ai.transition=r}}function Gi(){return bi().memoizedState}function Hi(e,t,n){var r=tu(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},Ki(e))Xi(t,n);else if(null!==(n=Ds(e,t,n,r))){nu(n,e,r,eu()),Yi(n,t,r)}}function qi(e,t,n){var r=tu(e),a={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ki(e))Xi(t,a);else{var s=e.alternate;if(0===e.lanes&&(null===s||0===s.lanes)&&null!==(s=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=s(i,n);if(a.hasEagerState=!0,a.eagerState=o,or(o,i)){var l=t.interleaved;return null===l?(a.next=a,Rs(t)):(a.next=l.next,l.next=a),void(t.interleaved=a)}}catch(u){}null!==(n=Ds(e,t,a,r))&&(nu(n,e,r,a=eu()),Yi(n,t,r))}}function Ki(e){var t=e.alternate;return e===ii||null!==t&&t===ii}function Xi(e,t){ci=ui=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Yi(e,t,n){if(0!==(4194240&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}var Qi={readContext:_s,useCallback:pi,useContext:pi,useEffect:pi,useImperativeHandle:pi,useInsertionEffect:pi,useLayoutEffect:pi,useMemo:pi,useReducer:pi,useRef:pi,useState:pi,useDebugValue:pi,useDeferredValue:pi,useTransition:pi,useMutableSource:pi,useSyncExternalStore:pi,useId:pi,unstable_isNewReconciler:!1},Ji={readContext:_s,useCallback:function(e,t){return yi().memoizedState=[e,void 0===t?null:t],e},useContext:_s,useEffect:Mi,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Ri(4194308,4,Li.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Ri(4194308,4,e,t)},useInsertionEffect:function(e,t){return Ri(4,2,e,t)},useMemo:function(e,t){var n=yi();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=yi();return t=void 0!==n?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=Hi.bind(null,ii,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},yi().memoizedState=e},useState:Ai,useDebugValue:Bi,useDeferredValue:function(e){return yi().memoizedState=e},useTransition:function(){var e=Ai(!1),t=e[0];return e=ji.bind(null,e[1]),yi().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=ii,a=yi();if(as){if(void 0===n)throw Error(s(407));n=n()}else{if(n=t(),null===Al)throw Error(s(349));0!==(30&si)||Ii(r,t,n)}a.memoizedState=n;var i={value:n,getSnapshot:t};return a.queue=i,Mi(Ni.bind(null,r,i,e),[e]),r.flags|=2048,_i(9,Ci.bind(null,r,i,n,t),void 0,null),n},useId:function(){var e=yi(),t=Al.identifierPrefix;if(as){var n=Qa;t=":"+t+"R"+(n=(Ya&~(1<<32-it(Ya)-1)).toString(32)+n),0<(n=di++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=hi++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},Zi={readContext:_s,useCallback:Wi,useContext:_s,useEffect:Fi,useImperativeHandle:zi,useInsertionEffect:Oi,useLayoutEffect:Pi,useMemo:Vi,useReducer:xi,useRef:$i,useState:function(){return xi(vi)},useDebugValue:Bi,useDeferredValue:function(e){return Ui(bi(),oi.memoizedState,e)},useTransition:function(){return[xi(vi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1},eo={readContext:_s,useCallback:Wi,useContext:_s,useEffect:Fi,useImperativeHandle:zi,useInsertionEffect:Oi,useLayoutEffect:Pi,useMemo:Vi,useReducer:wi,useRef:$i,useState:function(){return wi(vi)},useDebugValue:Bi,useDeferredValue:function(e){var t=bi();return null===oi?t.memoizedState=e:Ui(t,oi.memoizedState,e)},useTransition:function(){return[wi(vi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1};function to(e,t){if(e&&e.defaultProps){for(var n in t=P({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function no(e,t,n,r){n=null===(n=n(r,t=e.memoizedState))||void 0===n?t:P({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var ro={isMounted:function(e){return!!(e=e._reactInternals)&&Ve(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=eu(),a=tu(e),s=Ls(r,a);s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=zs(e,s,a))&&(nu(t,e,a,r),Bs(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=eu(),a=tu(e),s=Ls(r,a);s.tag=1,s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=zs(e,s,a))&&(nu(t,e,a,r),Bs(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=eu(),r=tu(e),a=Ls(n,r);a.tag=2,void 0!==t&&null!==t&&(a.callback=t),null!==(t=zs(e,a,r))&&(nu(t,e,r,n),Bs(t,e,r))}};function ao(e,t,n,r,a,s,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,s,i):!t.prototype||!t.prototype.isPureReactComponent||(!lr(n,r)||!lr(a,s))}function so(e,t,n){var r=!1,a=Ta,s=t.contextType;return"object"===typeof s&&null!==s?s=_s(s):(a=Ra(t)?_a:Ea.current,s=(r=null!==(r=t.contextTypes)&&void 0!==r)?$a(e,a):Ta),t=new t(n,s),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ro,e.stateNode=t,t._reactInternals=e,r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=s),t}function io(e,t,n,r){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&ro.enqueueReplaceState(t,t.state,null)}function oo(e,t,n,r){var a=e.stateNode;a.props=n,a.state=e.memoizedState,a.refs={},Os(e);var s=t.contextType;"object"===typeof s&&null!==s?a.context=_s(s):(s=Ra(t)?_a:Ea.current,a.context=$a(e,s)),a.state=e.memoizedState,"function"===typeof(s=t.getDerivedStateFromProps)&&(no(e,t,s,n),a.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof a.getSnapshotBeforeUpdate||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||(t=a.state,"function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),t!==a.state&&ro.enqueueReplaceState(a,a.state,null),Vs(e,n,a,r),a.state=e.memoizedState),"function"===typeof a.componentDidMount&&(e.flags|=4194308)}function lo(e,t){try{var n="",r=t;do{n+=W(r),r=r.return}while(r);var a=n}catch(s){a="\nError generating stack: "+s.message+"\n"+s.stack}return{value:e,source:t,stack:a,digest:null}}function uo(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function co(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}var ho="function"===typeof WeakMap?WeakMap:Map;function po(e,t,n){(n=Ls(-1,n)).tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){jl||(jl=!0,Gl=r),co(0,t)},n}function fo(e,t,n){(n=Ls(-1,n)).tag=3;var r=e.type.getDerivedStateFromError;if("function"===typeof r){var a=t.value;n.payload=function(){return r(a)},n.callback=function(){co(0,t)}}var s=e.stateNode;return null!==s&&"function"===typeof s.componentDidCatch&&(n.callback=function(){co(0,t),"function"!==typeof r&&(null===Hl?Hl=new Set([this]):Hl.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function mo(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new ho;var a=new Set;r.set(t,a)}else void 0===(a=r.get(t))&&(a=new Set,r.set(t,a));a.has(n)||(a.add(n),e=Cu.bind(null,e,t,n),t.then(e,e))}function go(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function yo(e,t,n,r,a){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Ls(-1,1)).tag=2,zs(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=a,e)}var bo=x.ReactCurrentOwner,vo=!1;function xo(e,t,n,r){t.child=null===e?ws(t,null,n,r):xs(t,e.child,n,r)}function wo(e,t,n,r,a){n=n.render;var s=t.ref;return As(t,a),r=mi(e,t,n,r,s,a),n=gi(),null===e||vo?(as&&n&&es(t),t.flags|=1,xo(e,t,r,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,jo(e,t,a))}function ko(e,t,n,r,a){if(null===e){var s=n.type;return"function"!==typeof s||Ru(s)||void 0!==s.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Mu(n.type,null,r,t,t.mode,a)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=s,So(e,t,s,r,a))}if(s=e.child,0===(e.lanes&a)){var i=s.memoizedProps;if((n=null!==(n=n.compare)?n:lr)(i,r)&&e.ref===t.ref)return jo(e,t,a)}return t.flags|=1,(e=Du(s,r)).ref=t.ref,e.return=t,t.child=e}function So(e,t,n,r,a){if(null!==e){var s=e.memoizedProps;if(lr(s,r)&&e.ref===t.ref){if(vo=!1,t.pendingProps=r=s,0===(e.lanes&a))return t.lanes=e.lanes,jo(e,t,a);0!==(131072&e.flags)&&(vo=!0)}}return No(e,t,n,r,a)}function Io(e,t,n){var r=t.pendingProps,a=r.children,s=null!==e?e.memoizedState:null;if("hidden"===r.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Na(Dl,Rl),Rl|=n;else{if(0===(1073741824&n))return e=null!==s?s.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Na(Dl,Rl),Rl|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==s?s.baseLanes:n,Na(Dl,Rl),Rl|=r}else null!==s?(r=s.baseLanes|n,t.memoizedState=null):r=n,Na(Dl,Rl),Rl|=r;return xo(e,t,a,n),t.child}function Co(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function No(e,t,n,r,a){var s=Ra(n)?_a:Ea.current;return s=$a(t,s),As(t,a),n=mi(e,t,n,r,s,a),r=gi(),null===e||vo?(as&&r&&es(t),t.flags|=1,xo(e,t,n,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,jo(e,t,a))}function To(e,t,n,r,a){if(Ra(n)){var s=!0;Oa(t)}else s=!1;if(As(t,a),null===t.stateNode)Uo(e,t),so(t,n,r),oo(t,n,r,a),r=!0;else if(null===e){var i=t.stateNode,o=t.memoizedProps;i.props=o;var l=i.context,u=n.contextType;"object"===typeof u&&null!==u?u=_s(u):u=$a(t,u=Ra(n)?_a:Ea.current);var c=n.getDerivedStateFromProps,d="function"===typeof c||"function"===typeof i.getSnapshotBeforeUpdate;d||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==r||l!==u)&&io(t,i,r,u),Fs=!1;var h=t.memoizedState;i.state=h,Vs(t,r,i,a),l=t.memoizedState,o!==r||h!==l||Aa.current||Fs?("function"===typeof c&&(no(t,n,c,r),l=t.memoizedState),(o=Fs||ao(t,n,o,r,h,l,u))?(d||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(t.flags|=4194308)):("function"===typeof i.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),i.props=r,i.state=l,i.context=u,r=o):("function"===typeof i.componentDidMount&&(t.flags|=4194308),r=!1)}else{i=t.stateNode,Ps(e,t),o=t.memoizedProps,u=t.type===t.elementType?o:to(t.type,o),i.props=u,d=t.pendingProps,h=i.context,"object"===typeof(l=n.contextType)&&null!==l?l=_s(l):l=$a(t,l=Ra(n)?_a:Ea.current);var p=n.getDerivedStateFromProps;(c="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==d||h!==l)&&io(t,i,r,l),Fs=!1,h=t.memoizedState,i.state=h,Vs(t,r,i,a);var f=t.memoizedState;o!==d||h!==f||Aa.current||Fs?("function"===typeof p&&(no(t,n,p,r),f=t.memoizedState),(u=Fs||ao(t,n,u,r,h,f,l)||!1)?(c||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(r,f,l),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(r,f,l)),"function"===typeof i.componentDidUpdate&&(t.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),i.props=r,i.state=f,i.context=l,r=u):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),r=!1)}return Eo(e,t,n,r,s,a)}function Eo(e,t,n,r,a,s){Co(e,t);var i=0!==(128&t.flags);if(!r&&!i)return a&&Pa(t,n,!1),jo(e,t,s);r=t.stateNode,bo.current=t;var o=i&&"function"!==typeof n.getDerivedStateFromError?null:r.render();return t.flags|=1,null!==e&&i?(t.child=xs(t,e.child,null,s),t.child=xs(t,null,o,s)):xo(e,t,o,s),t.memoizedState=r.state,a&&Pa(t,n,!0),t.child}function Ao(e){var t=e.stateNode;t.pendingContext?Ma(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Ma(0,t.context,!1),Xs(e,t.containerInfo)}function _o(e,t,n,r,a){return ps(),fs(a),t.flags|=256,xo(e,t,n,r),t.child}var $o,Ro,Do,Mo,Fo={dehydrated:null,treeContext:null,retryLane:0};function Oo(e){return{baseLanes:e,cachePool:null,transitions:null}}function Po(e,t,n){var r,a=t.pendingProps,i=Zs.current,o=!1,l=0!==(128&t.flags);if((r=l)||(r=(null===e||null!==e.memoizedState)&&0!==(2&i)),r?(o=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(i|=1),Na(Zs,1&i),null===e)return us(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(l=a.children,e=a.fallback,o?(a=t.mode,o=t.child,l={mode:"hidden",children:l},0===(1&a)&&null!==o?(o.childLanes=0,o.pendingProps=l):o=Ou(l,a,0,null),e=Fu(e,a,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=Oo(n),t.memoizedState=Fo,e):Lo(t,l));if(null!==(i=e.memoizedState)&&null!==(r=i.dehydrated))return function(e,t,n,r,a,i,o){if(n)return 256&t.flags?(t.flags&=-257,zo(e,t,o,r=uo(Error(s(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(i=r.fallback,a=t.mode,r=Ou({mode:"visible",children:r.children},a,0,null),(i=Fu(i,a,o,null)).flags|=2,r.return=t,i.return=t,r.sibling=i,t.child=r,0!==(1&t.mode)&&xs(t,e.child,null,o),t.child.memoizedState=Oo(o),t.memoizedState=Fo,i);if(0===(1&t.mode))return zo(e,t,o,null);if("$!"===a.data){if(r=a.nextSibling&&a.nextSibling.dataset)var l=r.dgst;return r=l,zo(e,t,o,r=uo(i=Error(s(419)),r,void 0))}if(l=0!==(o&e.childLanes),vo||l){if(null!==(r=Al)){switch(o&-o){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}0!==(a=0!==(a&(r.suspendedLanes|o))?0:a)&&a!==i.retryLane&&(i.retryLane=a,Ms(e,a),nu(r,e,a,-1))}return mu(),zo(e,t,o,r=uo(Error(s(421))))}return"$?"===a.data?(t.flags|=128,t.child=e.child,t=Tu.bind(null,e),a._reactRetry=t,null):(e=i.treeContext,rs=ua(a.nextSibling),ns=t,as=!0,ss=null,null!==e&&(qa[Ka++]=Ya,qa[Ka++]=Qa,qa[Ka++]=Xa,Ya=e.id,Qa=e.overflow,Xa=t),t=Lo(t,r.children),t.flags|=4096,t)}(e,t,l,a,r,i,n);if(o){o=a.fallback,l=t.mode,r=(i=e.child).sibling;var u={mode:"hidden",children:a.children};return 0===(1&l)&&t.child!==i?((a=t.child).childLanes=0,a.pendingProps=u,t.deletions=null):(a=Du(i,u)).subtreeFlags=14680064&i.subtreeFlags,null!==r?o=Du(r,o):(o=Fu(o,l,n,null)).flags|=2,o.return=t,a.return=t,a.sibling=o,t.child=a,a=o,o=t.child,l=null===(l=e.child.memoizedState)?Oo(n):{baseLanes:l.baseLanes|n,cachePool:null,transitions:l.transitions},o.memoizedState=l,o.childLanes=e.childLanes&~n,t.memoizedState=Fo,a}return e=(o=e.child).sibling,a=Du(o,{mode:"visible",children:a.children}),0===(1&t.mode)&&(a.lanes=n),a.return=t,a.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=a,t.memoizedState=null,a}function Lo(e,t){return(t=Ou({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function zo(e,t,n,r){return null!==r&&fs(r),xs(t,e.child,null,n),(e=Lo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Bo(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),Es(e.return,t,n)}function Wo(e,t,n,r,a){var s=e.memoizedState;null===s?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(s.isBackwards=t,s.rendering=null,s.renderingStartTime=0,s.last=r,s.tail=n,s.tailMode=a)}function Vo(e,t,n){var r=t.pendingProps,a=r.revealOrder,s=r.tail;if(xo(e,t,r.children,n),0!==(2&(r=Zs.current)))r=1&r|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Bo(e,n,t);else if(19===e.tag)Bo(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Na(Zs,r),0===(1&t.mode))t.memoizedState=null;else switch(a){case"forwards":for(n=t.child,a=null;null!==n;)null!==(e=n.alternate)&&null===ei(e)&&(a=n),n=n.sibling;null===(n=a)?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),Wo(t,!1,a,n,s);break;case"backwards":for(n=null,a=t.child,t.child=null;null!==a;){if(null!==(e=a.alternate)&&null===ei(e)){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}Wo(t,!0,n,null,s);break;case"together":Wo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Uo(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function jo(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Ol|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(s(153));if(null!==t.child){for(n=Du(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Du(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Go(e,t){if(!as)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Ho(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=14680064&a.subtreeFlags,r|=14680064&a.flags,a.return=e,a=a.sibling;else for(a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function qo(e,t,n){var r=t.pendingProps;switch(ts(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ho(t),null;case 1:case 17:return Ra(t.type)&&Da(),Ho(t),null;case 3:return r=t.stateNode,Ys(),Ca(Aa),Ca(Ea),ni(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==e&&null!==e.child||(ds(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==ss&&(iu(ss),ss=null))),Ro(e,t),Ho(t),null;case 5:Js(t);var a=Ks(qs.current);if(n=t.type,null!==e&&null!=t.stateNode)Do(e,t,n,r,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(null===t.stateNode)throw Error(s(166));return Ho(t),null}if(e=Ks(Gs.current),ds(t)){r=t.stateNode,n=t.type;var i=t.memoizedProps;switch(r[ha]=t,r[pa]=i,e=0!==(1&t.mode),n){case"dialog":zr("cancel",r),zr("close",r);break;case"iframe":case"object":case"embed":zr("load",r);break;case"video":case"audio":for(a=0;a<Fr.length;a++)zr(Fr[a],r);break;case"source":zr("error",r);break;case"img":case"image":case"link":zr("error",r),zr("load",r);break;case"details":zr("toggle",r);break;case"input":Y(r,i),zr("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!i.multiple},zr("invalid",r);break;case"textarea":ae(r,i),zr("invalid",r)}for(var l in be(n,i),a=null,i)if(i.hasOwnProperty(l)){var u=i[l];"children"===l?"string"===typeof u?r.textContent!==u&&(!0!==i.suppressHydrationWarning&&Jr(r.textContent,u,e),a=["children",u]):"number"===typeof u&&r.textContent!==""+u&&(!0!==i.suppressHydrationWarning&&Jr(r.textContent,u,e),a=["children",""+u]):o.hasOwnProperty(l)&&null!=u&&"onScroll"===l&&zr("scroll",r)}switch(n){case"input":H(r),Z(r,i,!0);break;case"textarea":H(r),ie(r);break;case"select":case"option":break;default:"function"===typeof i.onClick&&(r.onclick=Zr)}r=a,t.updateQueue=r,null!==r&&(t.flags|=4)}else{l=9===a.nodeType?a:a.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=oe(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=l.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof r.is?e=l.createElement(n,{is:r.is}):(e=l.createElement(n),"select"===n&&(l=e,r.multiple?l.multiple=!0:r.size&&(l.size=r.size))):e=l.createElementNS(e,n),e[ha]=t,e[pa]=r,$o(e,t,!1,!1),t.stateNode=e;e:{switch(l=ve(n,r),n){case"dialog":zr("cancel",e),zr("close",e),a=r;break;case"iframe":case"object":case"embed":zr("load",e),a=r;break;case"video":case"audio":for(a=0;a<Fr.length;a++)zr(Fr[a],e);a=r;break;case"source":zr("error",e),a=r;break;case"img":case"image":case"link":zr("error",e),zr("load",e),a=r;break;case"details":zr("toggle",e),a=r;break;case"input":Y(e,r),a=X(e,r),zr("invalid",e);break;case"option":default:a=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},a=P({},r,{value:void 0}),zr("invalid",e);break;case"textarea":ae(e,r),a=re(e,r),zr("invalid",e)}for(i in be(n,a),u=a)if(u.hasOwnProperty(i)){var c=u[i];"style"===i?ge(e,c):"dangerouslySetInnerHTML"===i?null!=(c=c?c.__html:void 0)&&de(e,c):"children"===i?"string"===typeof c?("textarea"!==n||""!==c)&&he(e,c):"number"===typeof c&&he(e,""+c):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(o.hasOwnProperty(i)?null!=c&&"onScroll"===i&&zr("scroll",e):null!=c&&v(e,i,c,l))}switch(n){case"input":H(e),Z(e,r,!1);break;case"textarea":H(e),ie(e);break;case"option":null!=r.value&&e.setAttribute("value",""+j(r.value));break;case"select":e.multiple=!!r.multiple,null!=(i=r.value)?ne(e,!!r.multiple,i,!1):null!=r.defaultValue&&ne(e,!!r.multiple,r.defaultValue,!0);break;default:"function"===typeof a.onClick&&(e.onclick=Zr)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Ho(t),null;case 6:if(e&&null!=t.stateNode)Mo(e,t,e.memoizedProps,r);else{if("string"!==typeof r&&null===t.stateNode)throw Error(s(166));if(n=Ks(qs.current),Ks(Gs.current),ds(t)){if(r=t.stateNode,n=t.memoizedProps,r[ha]=t,(i=r.nodeValue!==n)&&null!==(e=ns))switch(e.tag){case 3:Jr(r.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Jr(r.nodeValue,n,0!==(1&e.mode))}i&&(t.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[ha]=t,t.stateNode=r}return Ho(t),null;case 13:if(Ca(Zs),r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(as&&null!==rs&&0!==(1&t.mode)&&0===(128&t.flags))hs(),ps(),t.flags|=98560,i=!1;else if(i=ds(t),null!==r&&null!==r.dehydrated){if(null===e){if(!i)throw Error(s(318));if(!(i=null!==(i=t.memoizedState)?i.dehydrated:null))throw Error(s(317));i[ha]=t}else ps(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Ho(t),i=!1}else null!==ss&&(iu(ss),ss=null),i=!0;if(!i)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((r=null!==r)!==(null!==e&&null!==e.memoizedState)&&r&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&Zs.current)?0===Ml&&(Ml=3):mu())),null!==t.updateQueue&&(t.flags|=4),Ho(t),null);case 4:return Ys(),Ro(e,t),null===e&&Vr(t.stateNode.containerInfo),Ho(t),null;case 10:return Ts(t.type._context),Ho(t),null;case 19:if(Ca(Zs),null===(i=t.memoizedState))return Ho(t),null;if(r=0!==(128&t.flags),null===(l=i.rendering))if(r)Go(i,!1);else{if(0!==Ml||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(l=ei(e))){for(t.flags|=128,Go(i,!1),null!==(r=l.updateQueue)&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;null!==n;)e=r,(i=n).flags&=14680066,null===(l=i.alternate)?(i.childLanes=0,i.lanes=e,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=l.childLanes,i.lanes=l.lanes,i.child=l.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=l.memoizedProps,i.memoizedState=l.memoizedState,i.updateQueue=l.updateQueue,i.type=l.type,e=l.dependencies,i.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Na(Zs,1&Zs.current|2),t.child}e=e.sibling}null!==i.tail&&Qe()>Vl&&(t.flags|=128,r=!0,Go(i,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=ei(l))){if(t.flags|=128,r=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Go(i,!0),null===i.tail&&"hidden"===i.tailMode&&!l.alternate&&!as)return Ho(t),null}else 2*Qe()-i.renderingStartTime>Vl&&1073741824!==n&&(t.flags|=128,r=!0,Go(i,!1),t.lanes=4194304);i.isBackwards?(l.sibling=t.child,t.child=l):(null!==(n=i.last)?n.sibling=l:t.child=l,i.last=l)}return null!==i.tail?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.renderingStartTime=Qe(),t.sibling=null,n=Zs.current,Na(Zs,r?1&n|2:1&n),t):(Ho(t),null);case 22:case 23:return du(),r=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==r&&(t.flags|=8192),r&&0!==(1&t.mode)?0!==(1073741824&Rl)&&(Ho(t),6&t.subtreeFlags&&(t.flags|=8192)):Ho(t),null;case 24:case 25:return null}throw Error(s(156,t.tag))}function Ko(e,t){switch(ts(t),t.tag){case 1:return Ra(t.type)&&Da(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Ys(),Ca(Aa),Ca(Ea),ni(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return Js(t),null;case 13:if(Ca(Zs),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(s(340));ps()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Ca(Zs),null;case 4:return Ys(),null;case 10:return Ts(t.type._context),null;case 22:case 23:return du(),null;default:return null}}$o=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Ro=function(){},Do=function(e,t,n,r){var a=e.memoizedProps;if(a!==r){e=t.stateNode,Ks(Gs.current);var s,i=null;switch(n){case"input":a=X(e,a),r=X(e,r),i=[];break;case"select":a=P({},a,{value:void 0}),r=P({},r,{value:void 0}),i=[];break;case"textarea":a=re(e,a),r=re(e,r),i=[];break;default:"function"!==typeof a.onClick&&"function"===typeof r.onClick&&(e.onclick=Zr)}for(c in be(n,r),n=null,a)if(!r.hasOwnProperty(c)&&a.hasOwnProperty(c)&&null!=a[c])if("style"===c){var l=a[c];for(s in l)l.hasOwnProperty(s)&&(n||(n={}),n[s]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(o.hasOwnProperty(c)?i||(i=[]):(i=i||[]).push(c,null));for(c in r){var u=r[c];if(l=null!=a?a[c]:void 0,r.hasOwnProperty(c)&&u!==l&&(null!=u||null!=l))if("style"===c)if(l){for(s in l)!l.hasOwnProperty(s)||u&&u.hasOwnProperty(s)||(n||(n={}),n[s]="");for(s in u)u.hasOwnProperty(s)&&l[s]!==u[s]&&(n||(n={}),n[s]=u[s])}else n||(i||(i=[]),i.push(c,n)),n=u;else"dangerouslySetInnerHTML"===c?(u=u?u.__html:void 0,l=l?l.__html:void 0,null!=u&&l!==u&&(i=i||[]).push(c,u)):"children"===c?"string"!==typeof u&&"number"!==typeof u||(i=i||[]).push(c,""+u):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(o.hasOwnProperty(c)?(null!=u&&"onScroll"===c&&zr("scroll",e),i||l===u||(i=[])):(i=i||[]).push(c,u))}n&&(i=i||[]).push("style",n);var c=i;(t.updateQueue=c)&&(t.flags|=4)}},Mo=function(e,t,n,r){n!==r&&(t.flags|=4)};var Xo=!1,Yo=!1,Qo="function"===typeof WeakSet?WeakSet:Set,Jo=null;function Zo(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(r){Iu(e,t,r)}else n.current=null}function el(e,t,n){try{n()}catch(r){Iu(e,t,r)}}var tl=!1;function nl(e,t,n){var r=t.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var a=r=r.next;do{if((a.tag&e)===e){var s=a.destroy;a.destroy=void 0,void 0!==s&&el(t,n,s)}a=a.next}while(a!==r)}}function rl(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function al(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function sl(e){var t=e.alternate;null!==t&&(e.alternate=null,sl(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[ha],delete t[pa],delete t[ma],delete t[ga],delete t[ya])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function il(e){return 5===e.tag||3===e.tag||4===e.tag}function ol(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||il(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function ll(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Zr));else if(4!==r&&null!==(e=e.child))for(ll(e,t,n),e=e.sibling;null!==e;)ll(e,t,n),e=e.sibling}function ul(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&null!==(e=e.child))for(ul(e,t,n),e=e.sibling;null!==e;)ul(e,t,n),e=e.sibling}var cl=null,dl=!1;function hl(e,t,n){for(n=n.child;null!==n;)pl(e,t,n),n=n.sibling}function pl(e,t,n){if(st&&"function"===typeof st.onCommitFiberUnmount)try{st.onCommitFiberUnmount(at,n)}catch(o){}switch(n.tag){case 5:Yo||Zo(n,t);case 6:var r=cl,a=dl;cl=null,hl(e,t,n),dl=a,null!==(cl=r)&&(dl?(e=cl,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):cl.removeChild(n.stateNode));break;case 18:null!==cl&&(dl?(e=cl,n=n.stateNode,8===e.nodeType?la(e.parentNode,n):1===e.nodeType&&la(e,n),Vt(e)):la(cl,n.stateNode));break;case 4:r=cl,a=dl,cl=n.stateNode.containerInfo,dl=!0,hl(e,t,n),cl=r,dl=a;break;case 0:case 11:case 14:case 15:if(!Yo&&(null!==(r=n.updateQueue)&&null!==(r=r.lastEffect))){a=r=r.next;do{var s=a,i=s.destroy;s=s.tag,void 0!==i&&(0!==(2&s)||0!==(4&s))&&el(n,t,i),a=a.next}while(a!==r)}hl(e,t,n);break;case 1:if(!Yo&&(Zo(n,t),"function"===typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(o){Iu(n,t,o)}hl(e,t,n);break;case 21:hl(e,t,n);break;case 22:1&n.mode?(Yo=(r=Yo)||null!==n.memoizedState,hl(e,t,n),Yo=r):hl(e,t,n);break;default:hl(e,t,n)}}function fl(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Qo),t.forEach((function(t){var r=Eu.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}}function ml(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var a=n[r];try{var i=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 5:cl=l.stateNode,dl=!1;break e;case 3:case 4:cl=l.stateNode.containerInfo,dl=!0;break e}l=l.return}if(null===cl)throw Error(s(160));pl(i,o,a),cl=null,dl=!1;var u=a.alternate;null!==u&&(u.return=null),a.return=null}catch(c){Iu(a,t,c)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)gl(t,e),t=t.sibling}function gl(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(ml(t,e),yl(e),4&r){try{nl(3,e,e.return),rl(3,e)}catch(g){Iu(e,e.return,g)}try{nl(5,e,e.return)}catch(g){Iu(e,e.return,g)}}break;case 1:ml(t,e),yl(e),512&r&&null!==n&&Zo(n,n.return);break;case 5:if(ml(t,e),yl(e),512&r&&null!==n&&Zo(n,n.return),32&e.flags){var a=e.stateNode;try{he(a,"")}catch(g){Iu(e,e.return,g)}}if(4&r&&null!=(a=e.stateNode)){var i=e.memoizedProps,o=null!==n?n.memoizedProps:i,l=e.type,u=e.updateQueue;if(e.updateQueue=null,null!==u)try{"input"===l&&"radio"===i.type&&null!=i.name&&Q(a,i),ve(l,o);var c=ve(l,i);for(o=0;o<u.length;o+=2){var d=u[o],h=u[o+1];"style"===d?ge(a,h):"dangerouslySetInnerHTML"===d?de(a,h):"children"===d?he(a,h):v(a,d,h,c)}switch(l){case"input":J(a,i);break;case"textarea":se(a,i);break;case"select":var p=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!i.multiple;var f=i.value;null!=f?ne(a,!!i.multiple,f,!1):p!==!!i.multiple&&(null!=i.defaultValue?ne(a,!!i.multiple,i.defaultValue,!0):ne(a,!!i.multiple,i.multiple?[]:"",!1))}a[pa]=i}catch(g){Iu(e,e.return,g)}}break;case 6:if(ml(t,e),yl(e),4&r){if(null===e.stateNode)throw Error(s(162));a=e.stateNode,i=e.memoizedProps;try{a.nodeValue=i}catch(g){Iu(e,e.return,g)}}break;case 3:if(ml(t,e),yl(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Vt(t.containerInfo)}catch(g){Iu(e,e.return,g)}break;case 4:default:ml(t,e),yl(e);break;case 13:ml(t,e),yl(e),8192&(a=e.child).flags&&(i=null!==a.memoizedState,a.stateNode.isHidden=i,!i||null!==a.alternate&&null!==a.alternate.memoizedState||(Wl=Qe())),4&r&&fl(e);break;case 22:if(d=null!==n&&null!==n.memoizedState,1&e.mode?(Yo=(c=Yo)||d,ml(t,e),Yo=c):ml(t,e),yl(e),8192&r){if(c=null!==e.memoizedState,(e.stateNode.isHidden=c)&&!d&&0!==(1&e.mode))for(Jo=e,d=e.child;null!==d;){for(h=Jo=d;null!==Jo;){switch(f=(p=Jo).child,p.tag){case 0:case 11:case 14:case 15:nl(4,p,p.return);break;case 1:Zo(p,p.return);var m=p.stateNode;if("function"===typeof m.componentWillUnmount){r=p,n=p.return;try{t=r,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(g){Iu(r,n,g)}}break;case 5:Zo(p,p.return);break;case 22:if(null!==p.memoizedState){wl(h);continue}}null!==f?(f.return=p,Jo=f):wl(h)}d=d.sibling}e:for(d=null,h=e;;){if(5===h.tag){if(null===d){d=h;try{a=h.stateNode,c?"function"===typeof(i=a.style).setProperty?i.setProperty("display","none","important"):i.display="none":(l=h.stateNode,o=void 0!==(u=h.memoizedProps.style)&&null!==u&&u.hasOwnProperty("display")?u.display:null,l.style.display=me("display",o))}catch(g){Iu(e,e.return,g)}}}else if(6===h.tag){if(null===d)try{h.stateNode.nodeValue=c?"":h.memoizedProps}catch(g){Iu(e,e.return,g)}}else if((22!==h.tag&&23!==h.tag||null===h.memoizedState||h===e)&&null!==h.child){h.child.return=h,h=h.child;continue}if(h===e)break e;for(;null===h.sibling;){if(null===h.return||h.return===e)break e;d===h&&(d=null),h=h.return}d===h&&(d=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:ml(t,e),yl(e),4&r&&fl(e);case 21:}}function yl(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(il(n)){var r=n;break e}n=n.return}throw Error(s(160))}switch(r.tag){case 5:var a=r.stateNode;32&r.flags&&(he(a,""),r.flags&=-33),ul(e,ol(e),a);break;case 3:case 4:var i=r.stateNode.containerInfo;ll(e,ol(e),i);break;default:throw Error(s(161))}}catch(o){Iu(e,e.return,o)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function bl(e,t,n){Jo=e,vl(e,t,n)}function vl(e,t,n){for(var r=0!==(1&e.mode);null!==Jo;){var a=Jo,s=a.child;if(22===a.tag&&r){var i=null!==a.memoizedState||Xo;if(!i){var o=a.alternate,l=null!==o&&null!==o.memoizedState||Yo;o=Xo;var u=Yo;if(Xo=i,(Yo=l)&&!u)for(Jo=a;null!==Jo;)l=(i=Jo).child,22===i.tag&&null!==i.memoizedState?kl(a):null!==l?(l.return=i,Jo=l):kl(a);for(;null!==s;)Jo=s,vl(s,t,n),s=s.sibling;Jo=a,Xo=o,Yo=u}xl(e)}else 0!==(8772&a.subtreeFlags)&&null!==s?(s.return=a,Jo=s):xl(e)}}function xl(e){for(;null!==Jo;){var t=Jo;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Yo||rl(5,t);break;case 1:var r=t.stateNode;if(4&t.flags&&!Yo)if(null===n)r.componentDidMount();else{var a=t.elementType===t.type?n.memoizedProps:to(t.type,n.memoizedProps);r.componentDidUpdate(a,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var i=t.updateQueue;null!==i&&Us(t,i,r);break;case 3:var o=t.updateQueue;if(null!==o){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Us(t,o,n)}break;case 5:var l=t.stateNode;if(null===n&&4&t.flags){n=l;var u=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":u.autoFocus&&n.focus();break;case"img":u.src&&(n.src=u.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var c=t.alternate;if(null!==c){var d=c.memoizedState;if(null!==d){var h=d.dehydrated;null!==h&&Vt(h)}}}break;default:throw Error(s(163))}Yo||512&t.flags&&al(t)}catch(p){Iu(t,t.return,p)}}if(t===e){Jo=null;break}if(null!==(n=t.sibling)){n.return=t.return,Jo=n;break}Jo=t.return}}function wl(e){for(;null!==Jo;){var t=Jo;if(t===e){Jo=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Jo=n;break}Jo=t.return}}function kl(e){for(;null!==Jo;){var t=Jo;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{rl(4,t)}catch(l){Iu(t,n,l)}break;case 1:var r=t.stateNode;if("function"===typeof r.componentDidMount){var a=t.return;try{r.componentDidMount()}catch(l){Iu(t,a,l)}}var s=t.return;try{al(t)}catch(l){Iu(t,s,l)}break;case 5:var i=t.return;try{al(t)}catch(l){Iu(t,i,l)}}}catch(l){Iu(t,t.return,l)}if(t===e){Jo=null;break}var o=t.sibling;if(null!==o){o.return=t.return,Jo=o;break}Jo=t.return}}var Sl,Il=Math.ceil,Cl=x.ReactCurrentDispatcher,Nl=x.ReactCurrentOwner,Tl=x.ReactCurrentBatchConfig,El=0,Al=null,_l=null,$l=0,Rl=0,Dl=Ia(0),Ml=0,Fl=null,Ol=0,Pl=0,Ll=0,zl=null,Bl=null,Wl=0,Vl=1/0,Ul=null,jl=!1,Gl=null,Hl=null,ql=!1,Kl=null,Xl=0,Yl=0,Ql=null,Jl=-1,Zl=0;function eu(){return 0!==(6&El)?Qe():-1!==Jl?Jl:Jl=Qe()}function tu(e){return 0===(1&e.mode)?1:0!==(2&El)&&0!==$l?$l&-$l:null!==ms.transition?(0===Zl&&(Zl=mt()),Zl):0!==(e=vt)?e:e=void 0===(e=window.event)?16:Yt(e.type)}function nu(e,t,n,r){if(50<Yl)throw Yl=0,Ql=null,Error(s(185));yt(e,n,r),0!==(2&El)&&e===Al||(e===Al&&(0===(2&El)&&(Pl|=n),4===Ml&&ou(e,$l)),ru(e,r),1===n&&0===El&&0===(1&t.mode)&&(Vl=Qe()+500,za&&Va()))}function ru(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,a=e.expirationTimes,s=e.pendingLanes;0<s;){var i=31-it(s),o=1<<i,l=a[i];-1===l?0!==(o&n)&&0===(o&r)||(a[i]=pt(o,t)):l<=t&&(e.expiredLanes|=o),s&=~o}}(e,t);var r=ht(e,e===Al?$l:0);if(0===r)null!==n&&Ke(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(null!=n&&Ke(n),1===t)0===e.tag?function(e){za=!0,Wa(e)}(lu.bind(null,e)):Wa(lu.bind(null,e)),ia((function(){0===(6&El)&&Va()})),n=null;else{switch(xt(r)){case 1:n=Ze;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=rt}n=Au(n,au.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function au(e,t){if(Jl=-1,Zl=0,0!==(6&El))throw Error(s(327));var n=e.callbackNode;if(ku()&&e.callbackNode!==n)return null;var r=ht(e,e===Al?$l:0);if(0===r)return null;if(0!==(30&r)||0!==(r&e.expiredLanes)||t)t=gu(e,r);else{t=r;var a=El;El|=2;var i=fu();for(Al===e&&$l===t||(Ul=null,Vl=Qe()+500,hu(e,t));;)try{bu();break}catch(l){pu(e,l)}Ns(),Cl.current=i,El=a,null!==_l?t=0:(Al=null,$l=0,t=Ml)}if(0!==t){if(2===t&&(0!==(a=ft(e))&&(r=a,t=su(e,a))),1===t)throw n=Fl,hu(e,0),ou(e,r),ru(e,Qe()),n;if(6===t)ou(e,r);else{if(a=e.current.alternate,0===(30&r)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var a=n[r],s=a.getSnapshot;a=a.value;try{if(!or(s(),a))return!1}catch(o){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(a)&&(2===(t=gu(e,r))&&(0!==(i=ft(e))&&(r=i,t=su(e,i))),1===t))throw n=Fl,hu(e,0),ou(e,r),ru(e,Qe()),n;switch(e.finishedWork=a,e.finishedLanes=r,t){case 0:case 1:throw Error(s(345));case 2:case 5:wu(e,Bl,Ul);break;case 3:if(ou(e,r),(130023424&r)===r&&10<(t=Wl+500-Qe())){if(0!==ht(e,0))break;if(((a=e.suspendedLanes)&r)!==r){eu(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=ra(wu.bind(null,e,Bl,Ul),t);break}wu(e,Bl,Ul);break;case 4:if(ou(e,r),(4194240&r)===r)break;for(t=e.eventTimes,a=-1;0<r;){var o=31-it(r);i=1<<o,(o=t[o])>a&&(a=o),r&=~i}if(r=a,10<(r=(120>(r=Qe()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Il(r/1960))-r)){e.timeoutHandle=ra(wu.bind(null,e,Bl,Ul),r);break}wu(e,Bl,Ul);break;default:throw Error(s(329))}}}return ru(e,Qe()),e.callbackNode===n?au.bind(null,e):null}function su(e,t){var n=zl;return e.current.memoizedState.isDehydrated&&(hu(e,t).flags|=256),2!==(e=gu(e,t))&&(t=Bl,Bl=n,null!==t&&iu(t)),e}function iu(e){null===Bl?Bl=e:Bl.push.apply(Bl,e)}function ou(e,t){for(t&=~Ll,t&=~Pl,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-it(t),r=1<<n;e[n]=-1,t&=~r}}function lu(e){if(0!==(6&El))throw Error(s(327));ku();var t=ht(e,0);if(0===(1&t))return ru(e,Qe()),null;var n=gu(e,t);if(0!==e.tag&&2===n){var r=ft(e);0!==r&&(t=r,n=su(e,r))}if(1===n)throw n=Fl,hu(e,0),ou(e,t),ru(e,Qe()),n;if(6===n)throw Error(s(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wu(e,Bl,Ul),ru(e,Qe()),null}function uu(e,t){var n=El;El|=1;try{return e(t)}finally{0===(El=n)&&(Vl=Qe()+500,za&&Va())}}function cu(e){null!==Kl&&0===Kl.tag&&0===(6&El)&&ku();var t=El;El|=1;var n=Tl.transition,r=vt;try{if(Tl.transition=null,vt=1,e)return e()}finally{vt=r,Tl.transition=n,0===(6&(El=t))&&Va()}}function du(){Rl=Dl.current,Ca(Dl)}function hu(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,aa(n)),null!==_l)for(n=_l.return;null!==n;){var r=n;switch(ts(r),r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&Da();break;case 3:Ys(),Ca(Aa),Ca(Ea),ni();break;case 5:Js(r);break;case 4:Ys();break;case 13:case 19:Ca(Zs);break;case 10:Ts(r.type._context);break;case 22:case 23:du()}n=n.return}if(Al=e,_l=e=Du(e.current,null),$l=Rl=t,Ml=0,Fl=null,Ll=Pl=Ol=0,Bl=zl=null,null!==$s){for(t=0;t<$s.length;t++)if(null!==(r=(n=$s[t]).interleaved)){n.interleaved=null;var a=r.next,s=n.pending;if(null!==s){var i=s.next;s.next=a,r.next=i}n.pending=r}$s=null}return e}function pu(e,t){for(;;){var n=_l;try{if(Ns(),ri.current=Qi,ui){for(var r=ii.memoizedState;null!==r;){var a=r.queue;null!==a&&(a.pending=null),r=r.next}ui=!1}if(si=0,li=oi=ii=null,ci=!1,di=0,Nl.current=null,null===n||null===n.return){Ml=1,Fl=t,_l=null;break}e:{var i=e,o=n.return,l=n,u=t;if(t=$l,l.flags|=32768,null!==u&&"object"===typeof u&&"function"===typeof u.then){var c=u,d=l,h=d.tag;if(0===(1&d.mode)&&(0===h||11===h||15===h)){var p=d.alternate;p?(d.updateQueue=p.updateQueue,d.memoizedState=p.memoizedState,d.lanes=p.lanes):(d.updateQueue=null,d.memoizedState=null)}var f=go(o);if(null!==f){f.flags&=-257,yo(f,o,l,0,t),1&f.mode&&mo(i,c,t),u=c;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(u),t.updateQueue=g}else m.add(u);break e}if(0===(1&t)){mo(i,c,t),mu();break e}u=Error(s(426))}else if(as&&1&l.mode){var y=go(o);if(null!==y){0===(65536&y.flags)&&(y.flags|=256),yo(y,o,l,0,t),fs(lo(u,l));break e}}i=u=lo(u,l),4!==Ml&&(Ml=2),null===zl?zl=[i]:zl.push(i),i=o;do{switch(i.tag){case 3:i.flags|=65536,t&=-t,i.lanes|=t,Ws(i,po(0,u,t));break e;case 1:l=u;var b=i.type,v=i.stateNode;if(0===(128&i.flags)&&("function"===typeof b.getDerivedStateFromError||null!==v&&"function"===typeof v.componentDidCatch&&(null===Hl||!Hl.has(v)))){i.flags|=65536,t&=-t,i.lanes|=t,Ws(i,fo(i,l,t));break e}}i=i.return}while(null!==i)}xu(n)}catch(x){t=x,_l===n&&null!==n&&(_l=n=n.return);continue}break}}function fu(){var e=Cl.current;return Cl.current=Qi,null===e?Qi:e}function mu(){0!==Ml&&3!==Ml&&2!==Ml||(Ml=4),null===Al||0===(268435455&Ol)&&0===(268435455&Pl)||ou(Al,$l)}function gu(e,t){var n=El;El|=2;var r=fu();for(Al===e&&$l===t||(Ul=null,hu(e,t));;)try{yu();break}catch(a){pu(e,a)}if(Ns(),El=n,Cl.current=r,null!==_l)throw Error(s(261));return Al=null,$l=0,Ml}function yu(){for(;null!==_l;)vu(_l)}function bu(){for(;null!==_l&&!Xe();)vu(_l)}function vu(e){var t=Sl(e.alternate,e,Rl);e.memoizedProps=e.pendingProps,null===t?xu(e):_l=t,Nl.current=null}function xu(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=qo(n,t,Rl)))return void(_l=n)}else{if(null!==(n=Ko(n,t)))return n.flags&=32767,void(_l=n);if(null===e)return Ml=6,void(_l=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(_l=t);_l=t=e}while(null!==t);0===Ml&&(Ml=5)}function wu(e,t,n){var r=vt,a=Tl.transition;try{Tl.transition=null,vt=1,function(e,t,n,r){do{ku()}while(null!==Kl);if(0!==(6&El))throw Error(s(327));n=e.finishedWork;var a=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(s(177));e.callbackNode=null,e.callbackPriority=0;var i=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var a=31-it(n),s=1<<a;t[a]=0,r[a]=-1,e[a]=-1,n&=~s}}(e,i),e===Al&&(_l=Al=null,$l=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||ql||(ql=!0,Au(tt,(function(){return ku(),null}))),i=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||i){i=Tl.transition,Tl.transition=null;var o=vt;vt=1;var l=El;El|=4,Nl.current=null,function(e,t){if(ea=jt,pr(e=hr())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var a=r.anchorOffset,i=r.focusNode;r=r.focusOffset;try{n.nodeType,i.nodeType}catch(w){n=null;break e}var o=0,l=-1,u=-1,c=0,d=0,h=e,p=null;t:for(;;){for(var f;h!==n||0!==a&&3!==h.nodeType||(l=o+a),h!==i||0!==r&&3!==h.nodeType||(u=o+r),3===h.nodeType&&(o+=h.nodeValue.length),null!==(f=h.firstChild);)p=h,h=f;for(;;){if(h===e)break t;if(p===n&&++c===a&&(l=o),p===i&&++d===r&&(u=o),null!==(f=h.nextSibling))break;p=(h=p).parentNode}h=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(ta={focusedElem:e,selectionRange:n},jt=!1,Jo=t;null!==Jo;)if(e=(t=Jo).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Jo=e;else for(;null!==Jo;){t=Jo;try{var m=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,y=m.memoizedState,b=t.stateNode,v=b.getSnapshotBeforeUpdate(t.elementType===t.type?g:to(t.type,g),y);b.__reactInternalSnapshotBeforeUpdate=v}break;case 3:var x=t.stateNode.containerInfo;1===x.nodeType?x.textContent="":9===x.nodeType&&x.documentElement&&x.removeChild(x.documentElement);break;default:throw Error(s(163))}}catch(w){Iu(t,t.return,w)}if(null!==(e=t.sibling)){e.return=t.return,Jo=e;break}Jo=t.return}m=tl,tl=!1}(e,n),gl(n,e),fr(ta),jt=!!ea,ta=ea=null,e.current=n,bl(n,e,a),Ye(),El=l,vt=o,Tl.transition=i}else e.current=n;if(ql&&(ql=!1,Kl=e,Xl=a),i=e.pendingLanes,0===i&&(Hl=null),function(e){if(st&&"function"===typeof st.onCommitFiberRoot)try{st.onCommitFiberRoot(at,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),ru(e,Qe()),null!==t)for(r=e.onRecoverableError,n=0;n<t.length;n++)a=t[n],r(a.value,{componentStack:a.stack,digest:a.digest});if(jl)throw jl=!1,e=Gl,Gl=null,e;0!==(1&Xl)&&0!==e.tag&&ku(),i=e.pendingLanes,0!==(1&i)?e===Ql?Yl++:(Yl=0,Ql=e):Yl=0,Va()}(e,t,n,r)}finally{Tl.transition=a,vt=r}return null}function ku(){if(null!==Kl){var e=xt(Xl),t=Tl.transition,n=vt;try{if(Tl.transition=null,vt=16>e?16:e,null===Kl)var r=!1;else{if(e=Kl,Kl=null,Xl=0,0!==(6&El))throw Error(s(331));var a=El;for(El|=4,Jo=e.current;null!==Jo;){var i=Jo,o=i.child;if(0!==(16&Jo.flags)){var l=i.deletions;if(null!==l){for(var u=0;u<l.length;u++){var c=l[u];for(Jo=c;null!==Jo;){var d=Jo;switch(d.tag){case 0:case 11:case 15:nl(8,d,i)}var h=d.child;if(null!==h)h.return=d,Jo=h;else for(;null!==Jo;){var p=(d=Jo).sibling,f=d.return;if(sl(d),d===c){Jo=null;break}if(null!==p){p.return=f,Jo=p;break}Jo=f}}}var m=i.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var y=g.sibling;g.sibling=null,g=y}while(null!==g)}}Jo=i}}if(0!==(2064&i.subtreeFlags)&&null!==o)o.return=i,Jo=o;else e:for(;null!==Jo;){if(0!==(2048&(i=Jo).flags))switch(i.tag){case 0:case 11:case 15:nl(9,i,i.return)}var b=i.sibling;if(null!==b){b.return=i.return,Jo=b;break e}Jo=i.return}}var v=e.current;for(Jo=v;null!==Jo;){var x=(o=Jo).child;if(0!==(2064&o.subtreeFlags)&&null!==x)x.return=o,Jo=x;else e:for(o=v;null!==Jo;){if(0!==(2048&(l=Jo).flags))try{switch(l.tag){case 0:case 11:case 15:rl(9,l)}}catch(k){Iu(l,l.return,k)}if(l===o){Jo=null;break e}var w=l.sibling;if(null!==w){w.return=l.return,Jo=w;break e}Jo=l.return}}if(El=a,Va(),st&&"function"===typeof st.onPostCommitFiberRoot)try{st.onPostCommitFiberRoot(at,e)}catch(k){}r=!0}return r}finally{vt=n,Tl.transition=t}}return!1}function Su(e,t,n){e=zs(e,t=po(0,t=lo(n,t),1),1),t=eu(),null!==e&&(yt(e,1,t),ru(e,t))}function Iu(e,t,n){if(3===e.tag)Su(e,e,n);else for(;null!==t;){if(3===t.tag){Su(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===Hl||!Hl.has(r))){t=zs(t,e=fo(t,e=lo(n,e),1),1),e=eu(),null!==t&&(yt(t,1,e),ru(t,e));break}}t=t.return}}function Cu(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),t=eu(),e.pingedLanes|=e.suspendedLanes&n,Al===e&&($l&n)===n&&(4===Ml||3===Ml&&(130023424&$l)===$l&&500>Qe()-Wl?hu(e,0):Ll|=n),ru(e,t)}function Nu(e,t){0===t&&(0===(1&e.mode)?t=1:(t=ct,0===(130023424&(ct<<=1))&&(ct=4194304)));var n=eu();null!==(e=Ms(e,t))&&(yt(e,t,n),ru(e,n))}function Tu(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Nu(e,n)}function Eu(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,a=e.memoizedState;null!==a&&(n=a.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(s(314))}null!==r&&r.delete(t),Nu(e,n)}function Au(e,t){return qe(e,t)}function _u(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function $u(e,t,n,r){return new _u(e,t,n,r)}function Ru(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Du(e,t){var n=e.alternate;return null===n?((n=$u(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Mu(e,t,n,r,a,i){var o=2;if(r=e,"function"===typeof e)Ru(e)&&(o=1);else if("string"===typeof e)o=5;else e:switch(e){case S:return Fu(n.children,a,i,t);case I:o=8,a|=8;break;case C:return(e=$u(12,n,t,2|a)).elementType=C,e.lanes=i,e;case A:return(e=$u(13,n,t,a)).elementType=A,e.lanes=i,e;case _:return(e=$u(19,n,t,a)).elementType=_,e.lanes=i,e;case D:return Ou(n,a,i,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case N:o=10;break e;case T:o=9;break e;case E:o=11;break e;case $:o=14;break e;case R:o=16,r=null;break e}throw Error(s(130,null==e?e:typeof e,""))}return(t=$u(o,n,t,a)).elementType=e,t.type=r,t.lanes=i,t}function Fu(e,t,n,r){return(e=$u(7,e,r,t)).lanes=n,e}function Ou(e,t,n,r){return(e=$u(22,e,r,t)).elementType=D,e.lanes=n,e.stateNode={isHidden:!1},e}function Pu(e,t,n){return(e=$u(6,e,null,t)).lanes=n,e}function Lu(e,t,n){return(t=$u(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function zu(e,t,n,r,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=r,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Bu(e,t,n,r,a,s,i,o,l){return e=new zu(e,t,n,o,l),1===t?(t=1,!0===s&&(t|=8)):t=0,s=$u(3,null,null,t),e.current=s,s.stateNode=e,s.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Os(s),e}function Wu(e){if(!e)return Ta;e:{if(Ve(e=e._reactInternals)!==e||1!==e.tag)throw Error(s(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ra(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(s(171))}if(1===e.tag){var n=e.type;if(Ra(n))return Fa(e,n,t)}return t}function Vu(e,t,n,r,a,s,i,o,l){return(e=Bu(n,r,!0,e,0,s,0,o,l)).context=Wu(null),n=e.current,(s=Ls(r=eu(),a=tu(n))).callback=void 0!==t&&null!==t?t:null,zs(n,s,a),e.current.lanes=a,yt(e,a,r),ru(e,r),e}function Uu(e,t,n,r){var a=t.current,s=eu(),i=tu(a);return n=Wu(n),null===t.context?t.context=n:t.pendingContext=n,(t=Ls(s,i)).payload={element:e},null!==(r=void 0===r?null:r)&&(t.callback=r),null!==(e=zs(a,t,i))&&(nu(e,a,i,s),Bs(e,a,i)),i}function ju(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Gu(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Hu(e,t){Gu(e,t),(e=e.alternate)&&Gu(e,t)}Sl=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Aa.current)vo=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return vo=!1,function(e,t,n){switch(t.tag){case 3:Ao(t),ps();break;case 5:Qs(t);break;case 1:Ra(t.type)&&Oa(t);break;case 4:Xs(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,a=t.memoizedProps.value;Na(ks,r._currentValue),r._currentValue=a;break;case 13:if(null!==(r=t.memoizedState))return null!==r.dehydrated?(Na(Zs,1&Zs.current),t.flags|=128,null):0!==(n&t.child.childLanes)?Po(e,t,n):(Na(Zs,1&Zs.current),null!==(e=jo(e,t,n))?e.sibling:null);Na(Zs,1&Zs.current);break;case 19:if(r=0!==(n&t.childLanes),0!==(128&e.flags)){if(r)return Vo(e,t,n);t.flags|=128}if(null!==(a=t.memoizedState)&&(a.rendering=null,a.tail=null,a.lastEffect=null),Na(Zs,Zs.current),r)break;return null;case 22:case 23:return t.lanes=0,Io(e,t,n)}return jo(e,t,n)}(e,t,n);vo=0!==(131072&e.flags)}else vo=!1,as&&0!==(1048576&t.flags)&&Za(t,Ha,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;Uo(e,t),e=t.pendingProps;var a=$a(t,Ea.current);As(t,n),a=mi(null,t,r,e,a,n);var i=gi();return t.flags|=1,"object"===typeof a&&null!==a&&"function"===typeof a.render&&void 0===a.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ra(r)?(i=!0,Oa(t)):i=!1,t.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,Os(t),a.updater=ro,t.stateNode=a,a._reactInternals=t,oo(t,r,e,n),t=Eo(null,t,r,!0,i,n)):(t.tag=0,as&&i&&es(t),xo(null,t,a,n),t=t.child),t;case 16:r=t.elementType;e:{switch(Uo(e,t),e=t.pendingProps,r=(a=r._init)(r._payload),t.type=r,a=t.tag=function(e){if("function"===typeof e)return Ru(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===E)return 11;if(e===$)return 14}return 2}(r),e=to(r,e),a){case 0:t=No(null,t,r,e,n);break e;case 1:t=To(null,t,r,e,n);break e;case 11:t=wo(null,t,r,e,n);break e;case 14:t=ko(null,t,r,to(r.type,e),n);break e}throw Error(s(306,r,""))}return t;case 0:return r=t.type,a=t.pendingProps,No(e,t,r,a=t.elementType===r?a:to(r,a),n);case 1:return r=t.type,a=t.pendingProps,To(e,t,r,a=t.elementType===r?a:to(r,a),n);case 3:e:{if(Ao(t),null===e)throw Error(s(387));r=t.pendingProps,a=(i=t.memoizedState).element,Ps(e,t),Vs(t,r,null,n);var o=t.memoizedState;if(r=o.element,i.isDehydrated){if(i={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=i,t.memoizedState=i,256&t.flags){t=_o(e,t,r,n,a=lo(Error(s(423)),t));break e}if(r!==a){t=_o(e,t,r,n,a=lo(Error(s(424)),t));break e}for(rs=ua(t.stateNode.containerInfo.firstChild),ns=t,as=!0,ss=null,n=ws(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ps(),r===a){t=jo(e,t,n);break e}xo(e,t,r,n)}t=t.child}return t;case 5:return Qs(t),null===e&&us(t),r=t.type,a=t.pendingProps,i=null!==e?e.memoizedProps:null,o=a.children,na(r,a)?o=null:null!==i&&na(r,i)&&(t.flags|=32),Co(e,t),xo(e,t,o,n),t.child;case 6:return null===e&&us(t),null;case 13:return Po(e,t,n);case 4:return Xs(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=xs(t,null,r,n):xo(e,t,r,n),t.child;case 11:return r=t.type,a=t.pendingProps,wo(e,t,r,a=t.elementType===r?a:to(r,a),n);case 7:return xo(e,t,t.pendingProps,n),t.child;case 8:case 12:return xo(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,a=t.pendingProps,i=t.memoizedProps,o=a.value,Na(ks,r._currentValue),r._currentValue=o,null!==i)if(or(i.value,o)){if(i.children===a.children&&!Aa.current){t=jo(e,t,n);break e}}else for(null!==(i=t.child)&&(i.return=t);null!==i;){var l=i.dependencies;if(null!==l){o=i.child;for(var u=l.firstContext;null!==u;){if(u.context===r){if(1===i.tag){(u=Ls(-1,n&-n)).tag=2;var c=i.updateQueue;if(null!==c){var d=(c=c.shared).pending;null===d?u.next=u:(u.next=d.next,d.next=u),c.pending=u}}i.lanes|=n,null!==(u=i.alternate)&&(u.lanes|=n),Es(i.return,n,t),l.lanes|=n;break}u=u.next}}else if(10===i.tag)o=i.type===t.type?null:i.child;else if(18===i.tag){if(null===(o=i.return))throw Error(s(341));o.lanes|=n,null!==(l=o.alternate)&&(l.lanes|=n),Es(o,n,t),o=i.sibling}else o=i.child;if(null!==o)o.return=i;else for(o=i;null!==o;){if(o===t){o=null;break}if(null!==(i=o.sibling)){i.return=o.return,o=i;break}o=o.return}i=o}xo(e,t,a.children,n),t=t.child}return t;case 9:return a=t.type,r=t.pendingProps.children,As(t,n),r=r(a=_s(a)),t.flags|=1,xo(e,t,r,n),t.child;case 14:return a=to(r=t.type,t.pendingProps),ko(e,t,r,a=to(r.type,a),n);case 15:return So(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:to(r,a),Uo(e,t),t.tag=1,Ra(r)?(e=!0,Oa(t)):e=!1,As(t,n),so(t,r,a),oo(t,r,a,n),Eo(null,t,r,!0,e,n);case 19:return Vo(e,t,n);case 22:return Io(e,t,n)}throw Error(s(156,t.tag))};var qu="function"===typeof reportError?reportError:function(e){console.error(e)};function Ku(e){this._internalRoot=e}function Xu(e){this._internalRoot=e}function Yu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Qu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Ju(){}function Zu(e,t,n,r,a){var s=n._reactRootContainer;if(s){var i=s;if("function"===typeof a){var o=a;a=function(){var e=ju(i);o.call(e)}}Uu(t,i,e,a)}else i=function(e,t,n,r,a){if(a){if("function"===typeof r){var s=r;r=function(){var e=ju(i);s.call(e)}}var i=Vu(t,r,e,0,null,!1,0,"",Ju);return e._reactRootContainer=i,e[fa]=i.current,Vr(8===e.nodeType?e.parentNode:e),cu(),i}for(;a=e.lastChild;)e.removeChild(a);if("function"===typeof r){var o=r;r=function(){var e=ju(l);o.call(e)}}var l=Bu(e,0,!1,null,0,!1,0,"",Ju);return e._reactRootContainer=l,e[fa]=l.current,Vr(8===e.nodeType?e.parentNode:e),cu((function(){Uu(t,l,n,r)})),l}(n,t,e,a,r);return ju(i)}Xu.prototype.render=Ku.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(s(409));Uu(e,t,null,null)},Xu.prototype.unmount=Ku.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;cu((function(){Uu(null,e,null,null)})),t[fa]=null}},Xu.prototype.unstable_scheduleHydration=function(e){if(e){var t=It();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Dt.length&&0!==t&&t<Dt[n].priority;n++);Dt.splice(n,0,e),0===n&&Pt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=dt(t.pendingLanes);0!==n&&(bt(t,1|n),ru(t,Qe()),0===(6&El)&&(Vl=Qe()+500,Va()))}break;case 13:cu((function(){var t=Ms(e,1);if(null!==t){var n=eu();nu(t,e,1,n)}})),Hu(e,1)}},kt=function(e){if(13===e.tag){var t=Ms(e,134217728);if(null!==t)nu(t,e,134217728,eu());Hu(e,134217728)}},St=function(e){if(13===e.tag){var t=tu(e),n=Ms(e,t);if(null!==n)nu(n,e,t,eu());Hu(e,t)}},It=function(){return vt},Ct=function(e,t){var n=vt;try{return vt=e,t()}finally{vt=n}},ke=function(e,t,n){switch(t){case"input":if(J(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var a=wa(r);if(!a)throw Error(s(90));q(r),J(r,a)}}}break;case"textarea":se(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ee=uu,Ae=cu;var ec={usingClientEntryPoint:!1,Events:[va,xa,wa,Ne,Te,uu]},tc={findFiberByHostInstance:ba,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},nc={bundleType:tc.bundleType,version:tc.version,rendererPackageName:tc.rendererPackageName,rendererConfig:tc.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:x.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Ge(e))?null:e.stateNode},findFiberByHostInstance:tc.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var rc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rc.isDisabled&&rc.supportsFiber)try{at=rc.inject(nc),st=rc}catch(ce){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ec,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Yu(t))throw Error(s(200));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Yu(e))throw Error(s(299));var n=!1,r="",a=qu;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onRecoverableError&&(a=t.onRecoverableError)),t=Bu(e,1,!1,null,0,n,0,r,a),e[fa]=t.current,Vr(8===e.nodeType?e.parentNode:e),new Ku(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(s(188));throw e=Object.keys(e).join(","),Error(s(268,e))}return e=null===(e=Ge(t))?null:e.stateNode},t.flushSync=function(e){return cu(e)},t.hydrate=function(e,t,n){if(!Qu(t))throw Error(s(200));return Zu(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Yu(e))throw Error(s(405));var r=null!=n&&n.hydratedSources||null,a=!1,i="",o=qu;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(a=!0),void 0!==n.identifierPrefix&&(i=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),t=Vu(t,null,e,1,null!=n?n:null,a,0,i,o),e[fa]=t.current,Vr(e),r)for(e=0;e<r.length;e++)a=(a=(n=r[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,a]:t.mutableSourceEagerHydrationData.push(n,a);return new Xu(t)},t.render=function(e,t,n){if(!Qu(t))throw Error(s(200));return Zu(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Qu(e))throw Error(s(40));return!!e._reactRootContainer&&(cu((function(){Zu(null,null,e,!1,(function(){e._reactRootContainer=null,e[fa]=null}))})),!0)},t.unstable_batchedUpdates=uu,t.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Qu(n))throw Error(s(200));if(null==e||void 0===e._reactInternals)throw Error(s(38));return Zu(e,t,n,!1,r)},t.version="18.3.1-next-f1338f8080-20240426"},7950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(2730)},5082:(e,t)=>{"use strict";var n,r=Symbol.for("react.element"),a=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),i=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),l=Symbol.for("react.provider"),u=Symbol.for("react.context"),c=Symbol.for("react.server_context"),d=Symbol.for("react.forward_ref"),h=Symbol.for("react.suspense"),p=Symbol.for("react.suspense_list"),f=Symbol.for("react.memo"),m=Symbol.for("react.lazy"),g=Symbol.for("react.offscreen");function y(e){if("object"===typeof e&&null!==e){var t=e.$$typeof;switch(t){case r:switch(e=e.type){case s:case o:case i:case h:case p:return e;default:switch(e=e&&e.$$typeof){case c:case u:case d:case m:case f:case l:return e;default:return t}}case a:return t}}}n=Symbol.for("react.module.reference")},2086:(e,t,n)=>{"use strict";n(5082)},7029:function(e,t,n){var r;r=function(e){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(r,a,function(t){return e[t]}.bind(null,a));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(e,t,n){"use strict";n.r(t);var r=n("react"),a=function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function r(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),s=function(){return s=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var a in t=arguments[n])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e},s.apply(this,arguments)},i=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};function o(){return!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)}"undefined"!==typeof window&&(void 0===navigator.mediaDevices&&(navigator.mediaDevices={}),void 0===navigator.mediaDevices.getUserMedia&&(navigator.mediaDevices.getUserMedia=function(e){var t=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return t?new Promise((function(n,r){t.call(navigator,e,n,r)})):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}));var l=function(e){function t(t){var n=e.call(this,t)||this;return n.canvas=null,n.ctx=null,n.requestUserMediaId=0,n.unmounted=!1,n.state={hasUserMedia:!1},n}return a(t,e),t.prototype.componentDidMount=function(){var e=this.state,t=this.props;this.unmounted=!1,o()?(e.hasUserMedia||this.requestUserMedia(),t.children&&"function"!=typeof t.children&&console.warn("children must be a function")):t.onUserMediaError("getUserMedia not supported")},t.prototype.componentDidUpdate=function(e){var t=this.props;if(o()){var n=JSON.stringify(e.audioConstraints)!==JSON.stringify(t.audioConstraints),r=JSON.stringify(e.videoConstraints)!==JSON.stringify(t.videoConstraints),a=e.minScreenshotWidth!==t.minScreenshotWidth,s=e.minScreenshotHeight!==t.minScreenshotHeight;(r||a||s)&&(this.canvas=null,this.ctx=null),(n||r)&&(this.stopAndCleanup(),this.requestUserMedia())}else t.onUserMediaError("getUserMedia not supported")},t.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},t.stopMediaStream=function(e){e&&(e.getVideoTracks&&e.getAudioTracks?(e.getVideoTracks().map((function(t){e.removeTrack(t),t.stop()})),e.getAudioTracks().map((function(t){e.removeTrack(t),t.stop()}))):e.stop())},t.prototype.stopAndCleanup=function(){var e=this.state;e.hasUserMedia&&(t.stopMediaStream(this.stream),e.src&&window.URL.revokeObjectURL(e.src))},t.prototype.getScreenshot=function(e){var t=this.state,n=this.props;if(!t.hasUserMedia)return null;var r=this.getCanvas(e);return r&&r.toDataURL(n.screenshotFormat,n.screenshotQuality)},t.prototype.getCanvas=function(e){var t=this.state,n=this.props;if(!this.video)return null;if(!t.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var r=this.video.videoWidth,a=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var s=r/a;a=(r=n.minScreenshotWidth||this.video.clientWidth)/s,n.minScreenshotHeight&&a<n.minScreenshotHeight&&(r=(a=n.minScreenshotHeight)*s)}this.canvas=document.createElement("canvas"),this.canvas.width=(null===e||void 0===e?void 0:e.width)||r,this.canvas.height=(null===e||void 0===e?void 0:e.height)||a,this.ctx=this.canvas.getContext("2d")}var i=this.ctx,o=this.canvas;return i&&o&&(o.width=(null===e||void 0===e?void 0:e.width)||o.width,o.height=(null===e||void 0===e?void 0:e.height)||o.height,n.mirrored&&(i.translate(o.width,0),i.scale(-1,1)),i.imageSmoothingEnabled=n.imageSmoothing,i.drawImage(this.video,0,0,(null===e||void 0===e?void 0:e.width)||o.width,(null===e||void 0===e?void 0:e.height)||o.height),n.mirrored&&(i.scale(-1,1),i.translate(-o.width,0))),o},t.prototype.requestUserMedia=function(){var e=this,n=this.props,r=function(r,a){var s={video:"undefined"===typeof a||a};n.audio&&(s.audio="undefined"===typeof r||r),e.requestUserMediaId++;var i=e.requestUserMediaId;navigator.mediaDevices.getUserMedia(s).then((function(n){e.unmounted||i!==e.requestUserMediaId?t.stopMediaStream(n):e.handleUserMedia(null,n)})).catch((function(t){e.handleUserMedia(t)}))};if("mediaDevices"in navigator)r(n.audioConstraints,n.videoConstraints);else{var a=function(e){return{optional:[{sourceId:e}]}},s=function(e){var t=e.deviceId;return"string"===typeof t?t:Array.isArray(t)&&t.length>0?t[0]:"object"===typeof t&&t.ideal?t.ideal:null};MediaStreamTrack.getSources((function(e){var t=null,i=null;e.forEach((function(e){"audio"===e.kind?t=e.id:"video"===e.kind&&(i=e.id)}));var o=s(n.audioConstraints);o&&(t=o);var l=s(n.videoConstraints);l&&(i=l),r(a(t),a(i))}))}},t.prototype.handleUserMedia=function(e,t){var n=this.props;if(e||!t)return this.setState({hasUserMedia:!1}),void n.onUserMediaError(e);this.stream=t;try{this.video&&(this.video.srcObject=t),this.setState({hasUserMedia:!0})}catch(r){this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(t)})}n.onUserMedia(t)},t.prototype.render=function(){var e=this,t=this.state,n=this.props,a=n.audio,o=(n.forceScreenshotSourceSize,n.disablePictureInPicture),l=(n.onUserMedia,n.onUserMediaError,n.screenshotFormat,n.screenshotQuality,n.minScreenshotWidth,n.minScreenshotHeight,n.audioConstraints,n.videoConstraints,n.imageSmoothing,n.mirrored),u=n.style,c=void 0===u?{}:u,d=n.children,h=i(n,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),p=l?s(s({},c),{transform:(c.transform||"")+" scaleX(-1)"}):c,f={getScreenshot:this.getScreenshot.bind(this)};return r.createElement(r.Fragment,null,r.createElement("video",s({autoPlay:!0,disablePictureInPicture:o,src:t.src,muted:!a,playsInline:!0,ref:function(t){e.video=t},style:p},h)),d&&d(f))},t.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},t}(r.Component);t.default=l},react:function(t,n){t.exports=e}}).default},e.exports=r(n(5043))},1153:(e,t,n)=>{"use strict";var r=n(5043),a=Symbol.for("react.element"),s=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,o=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function u(e,t,n){var r,s={},u=null,c=null;for(r in void 0!==n&&(u=""+n),void 0!==t.key&&(u=""+t.key),void 0!==t.ref&&(c=t.ref),t)i.call(t,r)&&!l.hasOwnProperty(r)&&(s[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps)void 0===s[r]&&(s[r]=t[r]);return{$$typeof:a,type:e,key:u,ref:c,props:s,_owner:o.current}}t.Fragment=s,t.jsx=u,t.jsxs=u},4202:(e,t)=>{"use strict";var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function v(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var x=v.prototype=new b;x.constructor=v,m(x,y.prototype),x.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},I={key:!0,ref:!0,__self:!0,__source:!0};function C(e,t,r){var a,s={},i=null,o=null;if(null!=t)for(a in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(i=""+t.key),t)k.call(t,a)&&!I.hasOwnProperty(a)&&(s[a]=t[a]);var l=arguments.length-2;if(1===l)s.children=r;else if(1<l){for(var u=Array(l),c=0;c<l;c++)u[c]=arguments[c+2];s.children=u}if(e&&e.defaultProps)for(a in l=e.defaultProps)void 0===s[a]&&(s[a]=l[a]);return{$$typeof:n,type:e,key:i,ref:o,props:s,_owner:S.current}}function N(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var T=/\/+/g;function E(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function A(e,t,a,s,i){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var l=!1;if(null===e)l=!0;else switch(o){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case n:case r:l=!0}}if(l)return i=i(l=e),e=""===s?"."+E(l,0):s,w(i)?(a="",null!=e&&(a=e.replace(T,"$&/")+"/"),A(i,t,a,"",(function(e){return e}))):null!=i&&(N(i)&&(i=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,a+(!i.key||l&&l.key===i.key?"":(""+i.key).replace(T,"$&/")+"/")+e)),t.push(i)),1;if(l=0,s=""===s?".":s+":",w(e))for(var u=0;u<e.length;u++){var c=s+E(o=e[u],u);l+=A(o,t,a,c,i)}else if(c=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"===typeof c)for(e=c.call(e),u=0;!(o=e.next()).done;)l+=A(o=o.value,t,a,c=s+E(o,u++),i);else if("object"===o)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return l}function _(e,t,n){if(null==e)return e;var r=[],a=0;return A(e,r,"","",(function(e){return t.call(n,e,a++)})),r}function $(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var R={current:null},D={transition:null},M={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:D,ReactCurrentOwner:S};function F(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:_,forEach:function(e,t,n){_(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return _(e,(function(){t++})),t},toArray:function(e){return _(e,(function(e){return e}))||[]},only:function(e){if(!N(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=a,t.Profiler=i,t.PureComponent=v,t.StrictMode=s,t.Suspense=c,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=M,t.act=F,t.cloneElement=function(e,t,r){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var a=m({},e.props),s=e.key,i=e.ref,o=e._owner;if(null!=t){if(void 0!==t.ref&&(i=t.ref,o=S.current),void 0!==t.key&&(s=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(u in t)k.call(t,u)&&!I.hasOwnProperty(u)&&(a[u]=void 0===t[u]&&void 0!==l?l[u]:t[u])}var u=arguments.length-2;if(1===u)a.children=r;else if(1<u){l=Array(u);for(var c=0;c<u;c++)l[c]=arguments[c+2];a.children=l}return{$$typeof:n,type:e.type,key:s,ref:i,props:a,_owner:o}},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=C,t.createFactory=function(e){var t=C.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=N,t.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:$}},t.memo=function(e,t){return{$$typeof:d,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=D.transition;D.transition={};try{e()}finally{D.transition=t}},t.unstable_act=F,t.useCallback=function(e,t){return R.current.useCallback(e,t)},t.useContext=function(e){return R.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return R.current.useDeferredValue(e)},t.useEffect=function(e,t){return R.current.useEffect(e,t)},t.useId=function(){return R.current.useId()},t.useImperativeHandle=function(e,t,n){return R.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return R.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return R.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return R.current.useMemo(e,t)},t.useReducer=function(e,t,n){return R.current.useReducer(e,t,n)},t.useRef=function(e){return R.current.useRef(e)},t.useState=function(e){return R.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return R.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return R.current.useTransition()},t.version="18.3.1"},5043:(e,t,n)=>{"use strict";e.exports=n(4202)},579:(e,t,n)=>{"use strict";e.exports=n(1153)},7234:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,a=e[r];if(!(0<s(a,t)))break e;e[r]=t,e[n]=a,n=r}}function r(e){return 0===e.length?null:e[0]}function a(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,a=e.length,i=a>>>1;r<i;){var o=2*(r+1)-1,l=e[o],u=o+1,c=e[u];if(0>s(l,n))u<a&&0>s(c,l)?(e[r]=c,e[u]=n,r=u):(e[r]=l,e[o]=n,r=o);else{if(!(u<a&&0>s(c,n)))break e;e[r]=c,e[u]=n,r=u}}}return t}function s(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],c=[],d=1,h=null,p=3,f=!1,m=!1,g=!1,y="function"===typeof setTimeout?setTimeout:null,b="function"===typeof clearTimeout?clearTimeout:null,v="undefined"!==typeof setImmediate?setImmediate:null;function x(e){for(var t=r(c);null!==t;){if(null===t.callback)a(c);else{if(!(t.startTime<=e))break;a(c),t.sortIndex=t.expirationTime,n(u,t)}t=r(c)}}function w(e){if(g=!1,x(e),!m)if(null!==r(u))m=!0,D(k);else{var t=r(c);null!==t&&M(w,t.startTime-e)}}function k(e,n){m=!1,g&&(g=!1,b(N),N=-1),f=!0;var s=p;try{for(x(n),h=r(u);null!==h&&(!(h.expirationTime>n)||e&&!A());){var i=h.callback;if("function"===typeof i){h.callback=null,p=h.priorityLevel;var o=i(h.expirationTime<=n);n=t.unstable_now(),"function"===typeof o?h.callback=o:h===r(u)&&a(u),x(n)}else a(u);h=r(u)}if(null!==h)var l=!0;else{var d=r(c);null!==d&&M(w,d.startTime-n),l=!1}return l}finally{h=null,p=s,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,I=!1,C=null,N=-1,T=5,E=-1;function A(){return!(t.unstable_now()-E<T)}function _(){if(null!==C){var e=t.unstable_now();E=e;var n=!0;try{n=C(!0,e)}finally{n?S():(I=!1,C=null)}}else I=!1}if("function"===typeof v)S=function(){v(_)};else if("undefined"!==typeof MessageChannel){var $=new MessageChannel,R=$.port2;$.port1.onmessage=_,S=function(){R.postMessage(null)}}else S=function(){y(_,0)};function D(e){C=e,I||(I=!0,S())}function M(e,n){N=y((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,D(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):T=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return r(u)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,a,s){var i=t.unstable_now();switch("object"===typeof s&&null!==s?s="number"===typeof(s=s.delay)&&0<s?i+s:i:s=i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:d++,callback:a,priorityLevel:e,startTime:s,expirationTime:o=s+o,sortIndex:-1},s>i?(e.sortIndex=s,n(c,e),null===r(u)&&e===r(c)&&(g?(b(N),N=-1):g=!0,M(w,s-i))):(e.sortIndex=o,n(u,e),m||f||(m=!0,D(k))),e},t.unstable_shouldYield=A,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},8853:(e,t,n)=>{"use strict";e.exports=n(7234)},4334:(e,t,n)=>{var r=n(7359),a=n(7066),s=n(9016),i=n(9538),o=n(6288),l=n(5262),u=n(2430);u.alea=r,u.xor128=a,u.xorwow=s,u.xorshift7=i,u.xor4096=o,u.tychei=l,e.exports=u},7359:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new s(e),r=t&&t.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.alea=o}(0,e=n.nmd(e),n.amdD)},5262:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.tychei=o}(0,e=n.nmd(e),n.amdD)},7066:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xor128=o}(0,e=n.nmd(e),n.amdD)},6288:function(e,t,n){var r;!function(e,a){function s(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,a=0==(n=o[127&s]^=r+i)?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.X&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},9538:function(e,t,n){var r;!function(e,a){function s(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.x&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},9016:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},2430:function(e,t,n){var r;!function(a,s,i){var o,l=256,u=i.pow(l,6),c=i.pow(2,52),d=2*c,h=l-1;function p(e,t,n){var r=[],h=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(s)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(l):(e=new Uint8Array(l),(a.crypto||a.msCrypto).getRandomValues(e)),b(e)}catch(r){var t=a.navigator,n=t&&t.plugins;return[+new Date,a,n,a.screen,b(s)]}}():e,3),r),p=new f(r),v=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),s),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(v,h,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);a<l;)i[a]=a++;for(a=0;a<l;a++)i[a]=i[s=h&s+e[a%n]+(t=i[a])],i[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,i=r.S;e--;)t=i[a=h&a+1],n=n*l+i[h&(i[a]=i[s=h&s+t])+(i[s]=t)];return r.i=a,r.j=s,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(g(e[n],t-1))}catch(s){}return r.length?r:"string"==a?e:e+"\0"}function y(e,t){for(var n,r=e+"",a=0;a<r.length;)t[h&a]=h&(n^=19*t[h&a])+r.charCodeAt(a++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),s),e.exports){e.exports=p;try{o=n(1234)}catch(v){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!==typeof self?self:this,[],Math)},3895:(e,t,n)=>{"use strict";var r=n(5043);var a="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t},s=r.useSyncExternalStore,i=r.useRef,o=r.useEffect,l=r.useMemo,u=r.useDebugValue;t.useSyncExternalStoreWithSelector=function(e,t,n,r,c){var d=i(null);if(null===d.current){var h={hasValue:!1,value:null};d.current=h}else h=d.current;d=l((function(){function e(e){if(!o){if(o=!0,s=e,e=r(e),void 0!==c&&h.hasValue){var t=h.value;if(c(t,e))return i=t}return i=e}if(t=i,a(s,e))return t;var n=r(e);return void 0!==c&&c(t,n)?t:(s=e,i=n)}var s,i,o=!1,l=void 0===n?null:n;return[function(){return e(t())},null===l?void 0:function(){return e(l())}]}),[t,n,r,c]);var p=s(e,d[0],d[1]);return o((function(){h.hasValue=!0,h.value=p}),[p]),u(p),p}},7237:(e,t,n)=>{"use strict";e.exports=n(3895)},5817:()=>{},8590:()=>{},4530:()=>{},8108:()=>{},551:()=>{},477:()=>{},1234:()=>{},4994:e=>{e.exports=function(e){return e&&e.__esModule?e:{default:e}},e.exports.__esModule=!0,e.exports.default=e.exports},8168:(e,t,n)=>{"use strict";function r(){return r=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},r.apply(null,arguments)}n.d(t,{A:()=>r})},8387:(e,t,n)=>{"use strict";function r(e){var t,n,a="";if("string"==typeof e||"number"==typeof e)a+=e;else if("object"==typeof e)if(Array.isArray(e)){var s=e.length;for(t=0;t<s;t++)e[t]&&(n=r(e[t]))&&(a&&(a+=" "),a+=n)}else for(n in e)e[n]&&(a&&(a+=" "),a+=n);return a}n.d(t,{A:()=>a});const a=function(){for(var e,t,n=0,a="",s=arguments.length;n<s;n++)(e=arguments[n])&&(t=r(e))&&(a&&(a+=" "),a+=t);return a}}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var s=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},(()=>{var e,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;n.t=function(r,a){if(1&a&&(r=this(r)),8&a)return r;if("object"===typeof r&&r){if(4&a&&r.__esModule)return r;if(16&a&&"function"===typeof r.then)return r}var s=Object.create(null);n.r(s);var i={};e=e||[null,t({}),t([]),t(t)];for(var o=2&a&&r;"object"==typeof o&&!~e.indexOf(o);o=t(o))Object.getOwnPropertyNames(o).forEach((e=>i[e]=()=>r[e]));return i.default=()=>r,n.d(s,i),s}})(),n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{"use strict";var e={};n.r(e),n.d(e,{CompositeArrayBuffer:()=>fCe,browserFiles:()=>uTe,browserHTTPRequest:()=>bTe,concatenateArrayBuffers:()=>MCe,copyModel:()=>vNe,decodeWeights:()=>CCe,decodeWeightsStream:()=>_Ce,encodeWeights:()=>ICe,fromMemory:()=>kTe,fromMemorySync:()=>STe,getLoadHandlers:()=>GCe,getModelArtifactsForJSON:()=>LCe,getModelArtifactsForJSONSync:()=>PCe,getModelArtifactsInfoForJSON:()=>zCe,getSaveHandlers:()=>jCe,getWeightSpecs:()=>BCe,http:()=>yTe,isHTTPScheme:()=>mTe,listModels:()=>yNe,loadWeights:()=>hTe,moveModel:()=>xNe,registerLoadRouter:()=>UCe,registerSaveRouter:()=>VCe,removeModel:()=>bNe,weightsLoaderFactory:()=>pTe,withSaveHandler:()=>ITe,withSaveHandlerSync:()=>CTe});var t={};n.r(t),n.d(t,{assertParamsValid:()=>RTe,computeFlatOffset:()=>GTe,computeOutShape:()=>MTe,getNormalizedAxes:()=>LTe,isSliceContinous:()=>jTe,maskToAxes:()=>DTe,parseSliceParams:()=>HTe,sliceInfo:()=>qTe,startForAxis:()=>VTe,startIndicesWithElidedDims:()=>zTe,stopForAxis:()=>UTe,stopIndicesWithElidedDims:()=>BTe,stridesForAxis:()=>WTe,stridesWithElidedDims:()=>FTe});var r={};n.r(r),n.d(r,{conv2d:()=>iRe,depthwiseConv2d:()=>uRe,matMul:()=>cRe});var a={};n.r(a),n.d(a,{collectGatherOpShapeInfo:()=>wMe,computeOutShape:()=>xMe,segOpComputeOptimalWindowSize:()=>vMe});var s={};n.r(s),n.d(s,{ERF_A1:()=>PDe,ERF_A2:()=>LDe,ERF_A3:()=>zDe,ERF_A4:()=>BDe,ERF_A5:()=>WDe,ERF_P:()=>ODe,PARALLELIZE_THRESHOLD:()=>CDe,RowPartitionType:()=>xDe,SELU_SCALE:()=>FDe,SELU_SCALEALPHA:()=>MDe,applyActivation:()=>aRe,assertAndGetBroadcastShape:()=>ZNe,assertAxesAreInnerMostDims:()=>xAe,assertParamsConsistent:()=>bDe,assignToTypedArray:()=>qDe,axesAreInnerMostDims:()=>gAe,calculateShapes:()=>M$e,checkEinsumDimSizes:()=>nMe,checkPadOnDimRoundingMode:()=>wEe,combineLocations:()=>yAe,combineRaggedTensorToTensorShapes:()=>wDe,complexWithEvenIndex:()=>jDe,complexWithOddIndex:()=>GDe,computeConv2DInfo:()=>cEe,computeConv3DInfo:()=>dEe,computeDefaultPad:()=>hEe,computeDilation2DInfo:()=>oEe,computeOptimalWindowSize:()=>NDe,computeOutAndReduceShapes:()=>bAe,computeOutShape:()=>vDe,computePool2DInfo:()=>lEe,computePool3DInfo:()=>uEe,convertConv2DDataFormat:()=>xEe,decodeEinsumEquation:()=>eMe,eitherStridesOrDilationsAreOne:()=>bEe,expandShapeToKeepDim:()=>vAe,exponent:()=>XDe,exponents:()=>KDe,fromStringArrayToUint8:()=>SMe,fromUint8ToStringArray:()=>kMe,getAxesPermutation:()=>wAe,getBroadcastDims:()=>QNe,getComplexWithIndex:()=>HDe,getEinsumComputePath:()=>rMe,getEinsumPermutation:()=>tMe,getFusedBiasGradient:()=>rRe,getFusedDyActivation:()=>nRe,getImageCenter:()=>TDe,getInnerMostAxes:()=>SAe,getPermuted:()=>ADe,getRaggedRank:()=>SDe,getReductionAxes:()=>JNe,getReshaped:()=>EDe,getReshapedPermuted:()=>_De,getRowPartitionTypesHelper:()=>kDe,getSliceBeginCoords:()=>$De,getSliceSize:()=>RDe,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>oMe,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>lMe,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>uMe,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>hMe,getSparseReshapeInputOutputMismatchErrorMessage:()=>fMe,getSparseReshapeInputOutputMultipleErrorMessage:()=>pMe,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>cMe,getSparseReshapeNegativeOutputDimErrorMessage:()=>dMe,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>bMe,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>mMe,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>gMe,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>yMe,getUndoAxesPermutation:()=>kAe,isIdentityPermutation:()=>aMe,log:()=>PSe,mergeRealAndImagArrays:()=>VDe,prepareAndValidate:()=>DDe,prepareSplitSize:()=>iMe,segment_util:()=>a,shouldFuse:()=>sRe,slice_util:()=>t,splitRealAndImagArrays:()=>UDe,stridesOrDilationsArePositive:()=>vEe,tupleValuesAreOne:()=>yEe,upcastType:()=>zIe,validateDefaultValueShape:()=>IDe,validateInput:()=>D$e,validateUpdateShape:()=>R$e,warn:()=>OSe});var i={};n.r(i),n.d(i,{json:()=>yVe});var o={};n.r(o),n.d(o,{json:()=>bVe});var l={};n.r(l),n.d(l,{json:()=>vVe});var u={};n.r(u),n.d(u,{json:()=>xVe});var c={};n.r(c),n.d(c,{json:()=>wVe});var d={};n.r(d),n.d(d,{json:()=>kVe});var h={};n.r(h),n.d(h,{json:()=>SVe});var p={};n.r(p),n.d(p,{json:()=>IVe});var f={};n.r(f),n.d(f,{json:()=>CVe});var m={};n.r(m),n.d(m,{json:()=>NVe});var g={};n.r(g),n.d(g,{json:()=>TVe});var y={};n.r(y),n.d(y,{json:()=>EVe});var b={};n.r(b),n.d(b,{json:()=>AVe});var v={};n.r(v),n.d(v,{json:()=>_Ve});var x={};n.r(x),n.d(x,{json:()=>$Ve});var w={};n.r(w),n.d(w,{json:()=>RVe});var k={};n.r(k),n.d(k,{json:()=>DVe});var S={};n.r(S),n.d(S,{json:()=>MVe});var I={};n.r(I),n.d(I,{json:()=>FVe});var C={};n.r(C),n.d(C,{OP_SCOPE_SUFFIX:()=>lCe,abs:()=>YNe,acos:()=>XTe,acosh:()=>YTe,add:()=>ANe,addN:()=>QTe,all:()=>JTe,any:()=>ZTe,argMax:()=>eEe,argMin:()=>tEe,asin:()=>nEe,asinh:()=>rEe,atan:()=>aEe,atan2:()=>sEe,atanh:()=>iEe,avgPool:()=>SEe,avgPool3d:()=>IEe,basicLSTMCell:()=>_Ee,batchNorm:()=>REe,batchNorm2d:()=>DEe,batchNorm3d:()=>MEe,batchNorm4d:()=>FEe,batchToSpaceND:()=>$Ee,bincount:()=>OEe,bitwiseAnd:()=>PEe,booleanMaskAsync:()=>G$e,broadcastArgs:()=>LEe,broadcastTo:()=>zEe,buffer:()=>CNe,cast:()=>NNe,ceil:()=>BEe,clipByValue:()=>WEe,clone:()=>TNe,complex:()=>cCe,concat:()=>CEe,concat1d:()=>VEe,concat2d:()=>UEe,concat3d:()=>jEe,concat4d:()=>GEe,conv1d:()=>qEe,conv2d:()=>HEe,conv2dTranspose:()=>XEe,conv3d:()=>YEe,conv3dTranspose:()=>JEe,cos:()=>ZEe,cosh:()=>eAe,cosineWindow:()=>Z$e,cumprod:()=>tAe,cumsum:()=>nAe,denseBincount:()=>rAe,depthToSpace:()=>aAe,depthwiseConv2d:()=>sAe,diag:()=>iAe,dilation2d:()=>oAe,div:()=>$Ne,divNoNan:()=>cAe,dot:()=>dAe,dropout:()=>Q$e,einsum:()=>hAe,elu:()=>pAe,enclosingPowerOfTwo:()=>J$e,ensureShape:()=>fAe,equal:()=>lAe,erf:()=>mAe,euclideanNorm:()=>AAe,exp:()=>_Ae,expandDims:()=>$Ae,expm1:()=>RAe,eye:()=>MAe,fft:()=>g$e,fill:()=>GNe,floor:()=>FAe,floorDiv:()=>_Ne,fused:()=>r,gather:()=>OAe,gatherND:()=>Y$e,greater:()=>PAe,greaterEqual:()=>LAe,ifft:()=>y$e,imag:()=>zAe,image:()=>cDe,inTopKAsync:()=>eRe,irfft:()=>b$e,isFinite:()=>BAe,isInf:()=>WAe,isNaN:()=>VAe,leakyRelu:()=>UAe,less:()=>jAe,lessEqual:()=>GAe,linalg:()=>dDe,linspace:()=>HAe,localResponseNormalization:()=>qAe,log:()=>KAe,log1p:()=>XAe,logSigmoid:()=>JAe,logSoftmax:()=>ZAe,logSumExp:()=>e_e,logicalAnd:()=>t_e,logicalNot:()=>n_e,logicalOr:()=>r_e,logicalXor:()=>a_e,losses:()=>hDe,lowerBound:()=>o_e,matMul:()=>NEe,max:()=>IAe,maxPool:()=>l_e,maxPool3d:()=>u_e,maxPoolWithArgmax:()=>c_e,maximum:()=>eTe,mean:()=>d_e,meshgrid:()=>f_e,min:()=>CAe,minimum:()=>m_e,mirrorPad:()=>g_e,mod:()=>y_e,moments:()=>b_e,movingAverage:()=>q$e,mul:()=>RNe,multiRNNCell:()=>v_e,multinomial:()=>x_e,neg:()=>YAe,norm:()=>EAe,notEqual:()=>w_e,oneHot:()=>k_e,ones:()=>p_e,onesLike:()=>S_e,op:()=>uCe,outerProduct:()=>I_e,pad:()=>C_e,pad1d:()=>N_e,pad2d:()=>T_e,pad3d:()=>E_e,pad4d:()=>A_e,pool:()=>$_e,pow:()=>qNe,prelu:()=>R_e,print:()=>ENe,prod:()=>D_e,raggedGather:()=>M_e,raggedRange:()=>F_e,raggedTensorToTensor:()=>O_e,rand:()=>P_e,randomGamma:()=>V_e,randomNormal:()=>U_e,randomStandardNormal:()=>j_e,randomUniform:()=>G_e,randomUniformInt:()=>H_e,range:()=>q_e,real:()=>K_e,reciprocal:()=>X_e,relu:()=>Y_e,relu6:()=>Q_e,reshape:()=>kEe,reverse:()=>J_e,reverse1d:()=>Z_e,reverse2d:()=>e$e,reverse3d:()=>t$e,reverse4d:()=>n$e,rfft:()=>x$e,round:()=>r$e,rsqrt:()=>a$e,scalar:()=>PNe,scatterND:()=>K$e,searchSorted:()=>i_e,selu:()=>s$e,separableConv2d:()=>i$e,setdiff1dAsync:()=>o$e,sigmoid:()=>TEe,sign:()=>l$e,signal:()=>uDe,sin:()=>u$e,sinh:()=>c$e,slice:()=>EEe,slice1d:()=>d$e,slice2d:()=>h$e,slice3d:()=>p$e,slice4d:()=>f$e,softmax:()=>m$e,softplus:()=>QAe,spaceToBatchND:()=>__e,sparse:()=>pDe,sparseToDense:()=>X$e,spectral:()=>lDe,split:()=>v$e,sqrt:()=>DNe,square:()=>MNe,squaredDifference:()=>w$e,squeeze:()=>k$e,stack:()=>S$e,step:()=>I$e,stridedSlice:()=>C$e,string:()=>fDe,sub:()=>KNe,sum:()=>NAe,tan:()=>N$e,tanh:()=>AEe,tensor:()=>hCe,tensor1d:()=>T$e,tensor2d:()=>E$e,tensor3d:()=>NTe,tensor4d:()=>A$e,tensor5d:()=>_$e,tensor6d:()=>$$e,tensorScatterUpdate:()=>F$e,tile:()=>DAe,topk:()=>O$e,transpose:()=>H$e,truncatedNormal:()=>P$e,unique:()=>L$e,unsortedSegmentSum:()=>z$e,unstack:()=>B$e,upperBound:()=>W$e,variable:()=>V$e,where:()=>uAe,whereAsync:()=>j$e,zeros:()=>h_e,zerosLike:()=>FNe});var N={};n.r(N),n.d(N,{mx:()=>Oje,XI:()=>EGe,Nk:()=>AGe,f6:()=>$Ge,ct:()=>$je,YG:()=>FGe,hH:()=>WGe,z3:()=>CHe,sG:()=>OHe,uM:()=>WHe,vS:()=>aqe,qB:()=>hqe,GG:()=>fqe,lg:()=>vqe,rq:()=>gqe,cu:()=>Rqe,WR:()=>Aqe,GE:()=>Fqe,px:()=>Pqe,jC:()=>Jqe,He:()=>tKe,hE:()=>dKe,BF:()=>yHe,Dk:()=>wKe,cl:()=>AKe,_B:()=>VKe,ub:()=>qKe,_f:()=>YKe,Ku:()=>nXe,qy:()=>aXe,Zy:()=>gXe,bu:()=>vXe,zv:()=>kje,dH:()=>Gje,HS:()=>IGe,yH:()=>zXe,l3:()=>WXe,z9:()=>UXe,x6:()=>KXe,_m:()=>tYe,eW:()=>iYe,GK:()=>uYe,SP:()=>hYe,yr:()=>fYe,dl:()=>qHe,Dw:()=>xYe,xT:()=>IYe,_X:()=>Jje,wz:()=>$Ye});var T=n(5043),E=n.t(T,2),A=n(7950),_=n.t(A,2),$=n(7237),R=T,D=Symbol.for("react-redux-context"),M="undefined"!==typeof globalThis?globalThis:{};function F(){if(!R.createContext)return{};const e=M[D]??(M[D]=new Map);let t=e.get(R.createContext);return t||(t=R.createContext(null),e.set(R.createContext,t)),t}var O=F(),P=()=>{throw new Error("uSES not initialized!")};function L(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:O;return function(){return R.useContext(e)}}var z=L(),B=P,W=(e,t)=>e===t;function V(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:O;const t=e===O?z:L(e),n=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{equalityFn:r=W,devModeChecks:a={}}="function"===typeof n?{equalityFn:n}:n;const{store:s,subscription:i,getServerState:o,stabilityCheck:l,identityFunctionCheck:u}=t(),c=(R.useRef(!0),R.useCallback({[e.name]:t=>e(t)}[e.name],[e,l,a.stabilityCheck])),d=B(i.addNestedSub,s.getState,o||s.getState,c,r);return R.useDebugValue(d),d};return Object.assign(n,{withTypes:()=>n}),n}var U=V();Symbol.for("react.element"),Symbol.for("react.portal"),Symbol.for("react.fragment"),Symbol.for("react.strict_mode"),Symbol.for("react.profiler"),Symbol.for("react.provider"),Symbol.for("react.context"),Symbol.for("react.server_context"),Symbol.for("react.forward_ref"),Symbol.for("react.suspense"),Symbol.for("react.suspense_list"),Symbol.for("react.memo"),Symbol.for("react.lazy"),Symbol.for("react.offscreen"),Symbol.for("react.client.reference");function j(e){e()}var G={notify(){},get:()=>[]};function H(e,t){let n,r=G,a=0,s=!1;function i(){u.onStateChange&&u.onStateChange()}function o(){a++,n||(n=t?t.addNestedSub(i):e.subscribe(i),r=function(){let e=null,t=null;return{clear(){e=null,t=null},notify(){j((()=>{let t=e;for(;t;)t.callback(),t=t.next}))},get(){const t=[];let n=e;for(;n;)t.push(n),n=n.next;return t},subscribe(n){let r=!0;const a=t={callback:n,next:null,prev:t};return a.prev?a.prev.next=a:e=a,function(){r&&null!==e&&(r=!1,a.next?a.next.prev=a.prev:t=a.prev,a.prev?a.prev.next=a.next:e=a.next)}}}}())}function l(){a--,n&&0===a&&(n(),n=void 0,r.clear(),r=G)}const u={addNestedSub:function(e){o();const t=r.subscribe(e);let n=!1;return()=>{n||(n=!0,t(),l())}},notifyNestedSubs:function(){r.notify()},handleChangeWrapper:i,isSubscribed:function(){return s},trySubscribe:function(){s||(s=!0,o())},tryUnsubscribe:function(){s&&(s=!1,l())},getListeners:()=>r};return u}var q=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),K="undefined"!==typeof navigator&&"ReactNative"===navigator.product,X=q||K?R.useLayoutEffect:R.useEffect;Object.defineProperty,Object.getOwnPropertyNames,Object.getOwnPropertySymbols,Object.getOwnPropertyDescriptor,Object.getPrototypeOf,Object.prototype;var Y=function(e){let{store:t,context:n,children:r,serverState:a,stabilityCheck:s="once",identityFunctionCheck:i="once"}=e;const o=R.useMemo((()=>{const e=H(t);return{store:t,subscription:e,getServerState:a?()=>a:void 0,stabilityCheck:s,identityFunctionCheck:i}}),[t,a,s,i]),l=R.useMemo((()=>t.getState()),[t]);X((()=>{const{subscription:e}=o;return e.onStateChange=e.notifyNestedSubs,e.trySubscribe(),l!==t.getState()&&e.notifyNestedSubs(),()=>{e.tryUnsubscribe(),e.onStateChange=void 0}}),[o,l]);const u=n||O;return R.createElement(u.Provider,{value:o},r)};function Q(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:O;const t=e===O?z:L(e),n=()=>{const{store:e}=t();return e};return Object.assign(n,{withTypes:()=>n}),n}var J=Q();function Z(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:O;const t=e===O?J:Q(e),n=()=>t().dispatch;return Object.assign(n,{withTypes:()=>n}),n}var ee=Z();function te(e){return`Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `}(e=>{B=e})($.useSyncExternalStoreWithSelector),(e=>{e})(T.useSyncExternalStore);var ne=(()=>"function"===typeof Symbol&&Symbol.observable||"@@observable")(),re=()=>Math.random().toString(36).substring(7).split("").join("."),ae={INIT:`@@redux/INIT${re()}`,REPLACE:`@@redux/REPLACE${re()}`,PROBE_UNKNOWN_ACTION:()=>`@@redux/PROBE_UNKNOWN_ACTION${re()}`};function se(e){if("object"!==typeof e||null===e)return!1;let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t||null===Object.getPrototypeOf(e)}function ie(e,t,n){if("function"!==typeof e)throw new Error(te(2));if("function"===typeof t&&"function"===typeof n||"function"===typeof n&&"function"===typeof arguments[3])throw new Error(te(0));if("function"===typeof t&&"undefined"===typeof n&&(n=t,t=void 0),"undefined"!==typeof n){if("function"!==typeof n)throw new Error(te(1));return n(ie)(e,t)}let r=e,a=t,s=new Map,i=s,o=0,l=!1;function u(){i===s&&(i=new Map,s.forEach(((e,t)=>{i.set(t,e)})))}function c(){if(l)throw new Error(te(3));return a}function d(e){if("function"!==typeof e)throw new Error(te(4));if(l)throw new Error(te(5));let t=!0;u();const n=o++;return i.set(n,e),function(){if(t){if(l)throw new Error(te(6));t=!1,u(),i.delete(n),s=null}}}function h(e){if(!se(e))throw new Error(te(7));if("undefined"===typeof e.type)throw new Error(te(8));if("string"!==typeof e.type)throw new Error(te(17));if(l)throw new Error(te(9));try{l=!0,a=r(a,e)}finally{l=!1}return(s=i).forEach((e=>{e()})),e}h({type:ae.INIT});return{dispatch:h,subscribe:d,getState:c,replaceReducer:function(e){if("function"!==typeof e)throw new Error(te(10));r=e,h({type:ae.REPLACE})},[ne]:function(){const e=d;return{subscribe(t){if("object"!==typeof t||null===t)throw new Error(te(11));function n(){const e=t;e.next&&e.next(c())}n();return{unsubscribe:e(n)}},[ne](){return this}}}}}function oe(e){const t=Object.keys(e),n={};for(let s=0;s<t.length;s++){const r=t[s];0,"function"===typeof e[r]&&(n[r]=e[r])}const r=Object.keys(n);let a;try{!function(e){Object.keys(e).forEach((t=>{const n=e[t];if("undefined"===typeof n(void 0,{type:ae.INIT}))throw new Error(te(12));if("undefined"===typeof n(void 0,{type:ae.PROBE_UNKNOWN_ACTION()}))throw new Error(te(13))}))}(n)}catch(mD){a=mD}return function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;if(a)throw a;let s=!1;const i={};for(let a=0;a<r.length;a++){const o=r[a],l=n[o],u=e[o],c=l(u,t);if("undefined"===typeof c){t&&t.type;throw new Error(te(14))}i[o]=c,s=s||c!==u}return s=s||r.length!==Object.keys(e).length,s?i:e}}function le(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 0===t.length?e=>e:1===t.length?t[0]:t.reduce(((e,t)=>function(){return e(t(...arguments))}))}function ue(e){return t=>{let{dispatch:n,getState:r}=t;return t=>a=>"function"===typeof a?a(n,r,e):t(a)}}var ce=ue(),de=ue,he=Symbol.for("immer-nothing"),pe=Symbol.for("immer-draftable"),fe=Symbol.for("immer-state");function me(e){throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)}var ge=Object.getPrototypeOf;function ye(e){return!!e&&!!e[fe]}function be(e){return!!e&&(xe(e)||Array.isArray(e)||!!e[pe]||!!e.constructor?.[pe]||Ce(e)||Ne(e))}var ve=Object.prototype.constructor.toString();function xe(e){if(!e||"object"!==typeof e)return!1;const t=ge(e);if(null===t)return!0;const n=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return n===Object||"function"==typeof n&&Function.toString.call(n)===ve}function we(e,t){0===ke(e)?Reflect.ownKeys(e).forEach((n=>{t(n,e[n],e)})):e.forEach(((n,r)=>t(r,n,e)))}function ke(e){const t=e[fe];return t?t.type_:Array.isArray(e)?1:Ce(e)?2:Ne(e)?3:0}function Se(e,t){return 2===ke(e)?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function Ie(e,t,n){const r=ke(e);2===r?e.set(t,n):3===r?e.add(n):e[t]=n}function Ce(e){return e instanceof Map}function Ne(e){return e instanceof Set}function Te(e){return e.copy_||e.base_}function Ee(e,t){if(Ce(e))return new Map(e);if(Ne(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);const n=xe(e);if(!0===t||"class_only"===t&&!n){const t=Object.getOwnPropertyDescriptors(e);delete t[fe];let n=Reflect.ownKeys(t);for(let r=0;r<n.length;r++){const a=n[r],s=t[a];!1===s.writable&&(s.writable=!0,s.configurable=!0),(s.get||s.set)&&(t[a]={configurable:!0,writable:!0,enumerable:s.enumerable,value:e[a]})}return Object.create(ge(e),t)}{const t=ge(e);if(null!==t&&n)return{...e};const r=Object.create(t);return Object.assign(r,e)}}function Ae(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return $e(e)||ye(e)||!be(e)||(ke(e)>1&&(e.set=e.add=e.clear=e.delete=_e),Object.freeze(e),t&&Object.entries(e).forEach((e=>{let[t,n]=e;return Ae(n,!0)}))),e}function _e(){me(2)}function $e(e){return Object.isFrozen(e)}var Re,De={};function Me(e){const t=De[e];return t||me(0),t}function Fe(){return Re}function Oe(e,t){t&&(Me("Patches"),e.patches_=[],e.inversePatches_=[],e.patchListener_=t)}function Pe(e){Le(e),e.drafts_.forEach(Be),e.drafts_=null}function Le(e){e===Re&&(Re=e.parent_)}function ze(e){return Re={drafts_:[],parent_:Re,immer_:e,canAutoFreeze_:!0,unfinalizedDrafts_:0}}function Be(e){const t=e[fe];0===t.type_||1===t.type_?t.revoke_():t.revoked_=!0}function We(e,t){t.unfinalizedDrafts_=t.drafts_.length;const n=t.drafts_[0];return void 0!==e&&e!==n?(n[fe].modified_&&(Pe(t),me(4)),be(e)&&(e=Ve(t,e),t.parent_||je(t,e)),t.patches_&&Me("Patches").generateReplacementPatches_(n[fe].base_,e,t.patches_,t.inversePatches_)):e=Ve(t,n,[]),Pe(t),t.patches_&&t.patchListener_(t.patches_,t.inversePatches_),e!==he?e:void 0}function Ve(e,t,n){if($e(t))return t;const r=t[fe];if(!r)return we(t,((a,s)=>Ue(e,r,t,a,s,n))),t;if(r.scope_!==e)return t;if(!r.modified_)return je(e,r.base_,!0),r.base_;if(!r.finalized_){r.finalized_=!0,r.scope_.unfinalizedDrafts_--;const t=r.copy_;let a=t,s=!1;3===r.type_&&(a=new Set(t),t.clear(),s=!0),we(a,((a,i)=>Ue(e,r,t,a,i,n,s))),je(e,t,!1),n&&e.patches_&&Me("Patches").generatePatches_(r,n,e.patches_,e.inversePatches_)}return r.copy_}function Ue(e,t,n,r,a,s,i){if(ye(a)){const i=Ve(e,a,s&&t&&3!==t.type_&&!Se(t.assigned_,r)?s.concat(r):void 0);if(Ie(n,r,i),!ye(i))return;e.canAutoFreeze_=!1}else i&&n.add(a);if(be(a)&&!$e(a)){if(!e.immer_.autoFreeze_&&e.unfinalizedDrafts_<1)return;Ve(e,a),t&&t.scope_.parent_||"symbol"===typeof r||!Object.prototype.propertyIsEnumerable.call(n,r)||je(e,a)}}function je(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];!e.parent_&&e.immer_.autoFreeze_&&e.canAutoFreeze_&&Ae(t,n)}var Ge={get(e,t){if(t===fe)return e;const n=Te(e);if(!Se(n,t))return function(e,t,n){const r=Ke(t,n);return r?"value"in r?r.value:r.get?.call(e.draft_):void 0}(e,n,t);const r=n[t];return e.finalized_||!be(r)?r:r===qe(e.base_,t)?(Ye(e),e.copy_[t]=Qe(r,e)):r},has:(e,t)=>t in Te(e),ownKeys:e=>Reflect.ownKeys(Te(e)),set(e,t,n){const r=Ke(Te(e),t);if(r?.set)return r.set.call(e.draft_,n),!0;if(!e.modified_){const r=qe(Te(e),t),a=r?.[fe];if(a&&a.base_===n)return e.copy_[t]=n,e.assigned_[t]=!1,!0;if(function(e,t){return e===t?0!==e||1/e===1/t:e!==e&&t!==t}(n,r)&&(void 0!==n||Se(e.base_,t)))return!0;Ye(e),Xe(e)}return e.copy_[t]===n&&(void 0!==n||t in e.copy_)||Number.isNaN(n)&&Number.isNaN(e.copy_[t])||(e.copy_[t]=n,e.assigned_[t]=!0),!0},deleteProperty:(e,t)=>(void 0!==qe(e.base_,t)||t in e.base_?(e.assigned_[t]=!1,Ye(e),Xe(e)):delete e.assigned_[t],e.copy_&&delete e.copy_[t],!0),getOwnPropertyDescriptor(e,t){const n=Te(e),r=Reflect.getOwnPropertyDescriptor(n,t);return r?{writable:!0,configurable:1!==e.type_||"length"!==t,enumerable:r.enumerable,value:n[t]}:r},defineProperty(){me(11)},getPrototypeOf:e=>ge(e.base_),setPrototypeOf(){me(12)}},He={};function qe(e,t){const n=e[fe];return(n?Te(n):e)[t]}function Ke(e,t){if(!(t in e))return;let n=ge(e);for(;n;){const e=Object.getOwnPropertyDescriptor(n,t);if(e)return e;n=ge(n)}}function Xe(e){e.modified_||(e.modified_=!0,e.parent_&&Xe(e.parent_))}function Ye(e){e.copy_||(e.copy_=Ee(e.base_,e.scope_.immer_.useStrictShallowCopy_))}we(Ge,((e,t)=>{He[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),He.deleteProperty=function(e,t){return He.set.call(this,e,t,void 0)},He.set=function(e,t,n){return Ge.set.call(this,e[0],t,n,e[0])};function Qe(e,t){const n=Ce(e)?Me("MapSet").proxyMap_(e,t):Ne(e)?Me("MapSet").proxySet_(e,t):function(e,t){const n=Array.isArray(e),r={type_:n?1:0,scope_:t?t.scope_:Fe(),modified_:!1,finalized_:!1,assigned_:{},parent_:t,base_:e,draft_:null,copy_:null,revoke_:null,isManual_:!1};let a=r,s=Ge;n&&(a=[r],s=He);const{revoke:i,proxy:o}=Proxy.revocable(a,s);return r.draft_=o,r.revoke_=i,o}(e,t);return(t?t.scope_:Fe()).drafts_.push(n),n}function Je(e){if(!be(e)||$e(e))return e;const t=e[fe];let n;if(t){if(!t.modified_)return t.base_;t.finalized_=!0,n=Ee(e,t.scope_.immer_.useStrictShallowCopy_)}else n=Ee(e,!0);return we(n,((e,t)=>{Ie(n,e,Je(t))})),t&&(t.finalized_=!1),n}var Ze=new class{constructor(e){var t=this;this.autoFreeze_=!0,this.useStrictShallowCopy_=!1,this.produce=(e,t,n)=>{if("function"===typeof e&&"function"!==typeof t){const n=t;t=e;const r=this;return function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;for(var a=arguments.length,s=new Array(a>1?a-1:0),i=1;i<a;i++)s[i-1]=arguments[i];return r.produce(e,(e=>t.call(this,e,...s)))}}let r;if("function"!==typeof t&&me(6),void 0!==n&&"function"!==typeof n&&me(7),be(e)){const a=ze(this),s=Qe(e,void 0);let i=!0;try{r=t(s),i=!1}finally{i?Pe(a):Le(a)}return Oe(a,n),We(r,a)}if(!e||"object"!==typeof e){if(r=t(e),void 0===r&&(r=e),r===he&&(r=void 0),this.autoFreeze_&&Ae(r,!0),n){const t=[],a=[];Me("Patches").generateReplacementPatches_(e,r,t,a),n(t,a)}return r}me(1)},this.produceWithPatches=(e,n)=>{if("function"===typeof e)return function(n){for(var r=arguments.length,a=new Array(r>1?r-1:0),s=1;s<r;s++)a[s-1]=arguments[s];return t.produceWithPatches(n,(t=>e(t,...a)))};let r,a;const s=this.produce(e,n,((e,t)=>{r=e,a=t}));return[s,r,a]},"boolean"===typeof e?.autoFreeze&&this.setAutoFreeze(e.autoFreeze),"boolean"===typeof e?.useStrictShallowCopy&&this.setUseStrictShallowCopy(e.useStrictShallowCopy)}createDraft(e){be(e)||me(8),ye(e)&&(e=function(e){ye(e)||me(10);return Je(e)}(e));const t=ze(this),n=Qe(e,void 0);return n[fe].isManual_=!0,Le(t),n}finishDraft(e,t){const n=e&&e[fe];n&&n.isManual_||me(9);const{scope_:r}=n;return Oe(r,t),We(void 0,r)}setAutoFreeze(e){this.autoFreeze_=e}setUseStrictShallowCopy(e){this.useStrictShallowCopy_=e}applyPatches(e,t){let n;for(n=t.length-1;n>=0;n--){const r=t[n];if(0===r.path.length&&"replace"===r.op){e=r.value;break}}n>-1&&(t=t.slice(n+1));const r=Me("Patches").applyPatches_;return ye(e)?r(e,t):this.produce(e,(e=>r(e,t)))}},et=Ze.produce;Ze.produceWithPatches.bind(Ze),Ze.setAutoFreeze.bind(Ze),Ze.setUseStrictShallowCopy.bind(Ze),Ze.applyPatches.bind(Ze),Ze.createDraft.bind(Ze),Ze.finishDraft.bind(Ze);var tt="undefined"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__:function(){if(0!==arguments.length)return"object"===typeof arguments[0]?le:le.apply(null,arguments)};"undefined"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__&&window.__REDUX_DEVTOOLS_EXTENSION__;function nt(e,t){function n(){if(t){let n=t(...arguments);if(!n)throw new Error(bt(0));return{type:e,payload:n.payload,..."meta"in n&&{meta:n.meta},..."error"in n&&{error:n.error}}}return{type:e,payload:arguments.length<=0?void 0:arguments[0]}}return n.toString=()=>`${e}`,n.type=e,n.match=t=>function(e){return se(e)&&"type"in e&&"string"===typeof e.type}(t)&&t.type===e,n}var rt=class e extends Array{constructor(){super(...arguments),Object.setPrototypeOf(this,e.prototype)}static get[Symbol.species](){return e}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return super.concat.apply(this,t)}prepend(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return 1===n.length&&Array.isArray(n[0])?new e(...n[0].concat(this)):new e(...n.concat(this))}};function at(e){return be(e)?et(e,(()=>{})):e}function st(e,t,n){if(e.has(t)){let r=e.get(t);return n.update&&(r=n.update(r,t,e),e.set(t,r)),r}if(!n.insert)throw new Error(bt(10));const r=n.insert(t,e);return e.set(t,r),r}var it="RTK_autoBatch",ot=e=>t=>{setTimeout(t,e)},lt="undefined"!==typeof window&&window.requestAnimationFrame?window.requestAnimationFrame:ot(10),ut=e=>function(t){const{autoBatch:n=!0}=t??{};let r=new rt(e);return n&&r.push(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{type:"raf"};return t=>function(){const n=t(...arguments);let r=!0,a=!1,s=!1;const i=new Set,o="tick"===e.type?queueMicrotask:"raf"===e.type?lt:"callback"===e.type?e.queueNotification:ot(e.timeout),l=()=>{s=!1,a&&(a=!1,i.forEach((e=>e())))};return Object.assign({},n,{subscribe(e){const t=n.subscribe((()=>r&&e()));return i.add(e),()=>{t(),i.delete(e)}},dispatch(e){try{return r=!e?.meta?.[it],a=!r,a&&(s||(s=!0,o(l))),n.dispatch(e)}finally{r=!0}}})}}("object"===typeof n?n:void 0)),r};function ct(e){const t={},n=[];let r;const a={addCase(e,n){const r="string"===typeof e?e:e.type;if(!r)throw new Error(bt(28));if(r in t)throw new Error(bt(29));return t[r]=n,a},addMatcher:(e,t)=>(n.push({matcher:e,reducer:t}),a),addDefaultCase:e=>(r=e,a)};return e(a),[t,n,r]}var dt=Symbol.for("rtk-slice-createasyncthunk");function ht(e,t){return`${e}/${t}`}function pt(){let{creators:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=e?.asyncThunk?.[dt];return function(e){const{name:n,reducerPath:r=n}=e;if(!n)throw new Error(bt(11));const a=("function"===typeof e.reducers?e.reducers(function(){function e(e,t){return{_reducerDefinitionType:"asyncThunk",payloadCreator:e,...t}}return e.withTypes=()=>e,{reducer:e=>Object.assign({[e.name](){return e(...arguments)}}[e.name],{_reducerDefinitionType:"reducer"}),preparedReducer:(e,t)=>({_reducerDefinitionType:"reducerWithPrepare",prepare:e,reducer:t}),asyncThunk:e}}()):e.reducers)||{},s=Object.keys(a),i={sliceCaseReducersByName:{},sliceCaseReducersByType:{},actionCreators:{},sliceMatchers:[]},o={addCase(e,t){const n="string"===typeof e?e:e.type;if(!n)throw new Error(bt(12));if(n in i.sliceCaseReducersByType)throw new Error(bt(13));return i.sliceCaseReducersByType[n]=t,o},addMatcher:(e,t)=>(i.sliceMatchers.push({matcher:e,reducer:t}),o),exposeAction:(e,t)=>(i.actionCreators[e]=t,o),exposeCaseReducer:(e,t)=>(i.sliceCaseReducersByName[e]=t,o)};function l(){const[t={},n=[],r]="function"===typeof e.extraReducers?ct(e.extraReducers):[e.extraReducers],a={...t,...i.sliceCaseReducersByType};return function(e,t){let n,[r,a,s]=ct(t);if(function(e){return"function"===typeof e}(e))n=()=>at(e());else{const t=at(e);n=()=>t}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n(),t=arguments.length>1?arguments[1]:void 0,i=[r[t.type],...a.filter((e=>{let{matcher:n}=e;return n(t)})).map((e=>{let{reducer:t}=e;return t}))];return 0===i.filter((e=>!!e)).length&&(i=[s]),i.reduce(((e,n)=>{if(n){if(ye(e)){const r=n(e,t);return void 0===r?e:r}if(be(e))return et(e,(e=>n(e,t)));{const r=n(e,t);if(void 0===r){if(null===e)return e;throw new Error(bt(9))}return r}}return e}),e)}return i.getInitialState=n,i}(e.initialState,(e=>{for(let t in a)e.addCase(t,a[t]);for(let t of i.sliceMatchers)e.addMatcher(t.matcher,t.reducer);for(let t of n)e.addMatcher(t.matcher,t.reducer);r&&e.addDefaultCase(r)}))}s.forEach((r=>{const s=a[r],i={reducerName:r,type:ht(n,r),createNotation:"function"===typeof e.reducers};!function(e){return"asyncThunk"===e._reducerDefinitionType}(s)?function(e,t,n){let r,a,{type:s,reducerName:i,createNotation:o}=e;if("reducer"in t){if(o&&!function(e){return"reducerWithPrepare"===e._reducerDefinitionType}(t))throw new Error(bt(17));r=t.reducer,a=t.prepare}else r=t;n.addCase(s,r).exposeCaseReducer(i,r).exposeAction(i,a?nt(s,a):nt(s))}(i,s,o):function(e,t,n,r){let{type:a,reducerName:s}=e;if(!r)throw new Error(bt(18));const{payloadCreator:i,fulfilled:o,pending:l,rejected:u,settled:c,options:d}=t,h=r(a,i,d);n.exposeAction(s,h),o&&n.addCase(h.fulfilled,o);l&&n.addCase(h.pending,l);u&&n.addCase(h.rejected,u);c&&n.addMatcher(h.settled,c);n.exposeCaseReducer(s,{fulfilled:o||gt,pending:l||gt,rejected:u||gt,settled:c||gt})}(i,s,o,t)}));const u=e=>e,c=new Map;let d;function h(e,t){return d||(d=l()),d(e,t)}function p(){return d||(d=l()),d.getInitialState()}function f(t){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];function r(e){let r=e[t];return"undefined"===typeof r&&n&&(r=p()),r}function a(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:u;const r=st(c,n,{insert:()=>new WeakMap});return st(r,t,{insert:()=>{const r={};for(const[a,s]of Object.entries(e.selectors??{}))r[a]=ft(s,t,p,n);return r}})}return{reducerPath:t,getSelectors:a,get selectors(){return a(r)},selectSlice:r}}const m={name:n,reducer:h,actions:i.actionCreators,caseReducers:i.sliceCaseReducersByName,getInitialState:p,...f(r),injectInto(e){let{reducerPath:t,...n}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const a=t??r;return e.inject({reducerPath:a,reducer:h},n),{...m,...f(a,!0)}}};return m}}function ft(e,t,n,r){function a(a){let s=t(a);"undefined"===typeof s&&r&&(s=n());for(var i=arguments.length,o=new Array(i>1?i-1:0),l=1;l<i;l++)o[l-1]=arguments[l];return e(s,...o)}return a.unwrapped=e,a}var mt=pt();function gt(){}var{assign:yt}=Object;Symbol.for("rtk-state-proxy-original");function bt(e){return`Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `}const vt=mt({name:"user",initialState:{name:"",email:"",dateOfBirth:"",userId:""},reducers:{setUser:(e,t)=>{const{name:n,email:r,dateOfBirth:a,userId:s}=t.payload;e.name=n,e.email=r,e.dateOfBirth=a,e.userId=s},clearUser:e=>{e.name="",e.email="",e.dateOfBirth="",e.userId=""}}}),{setUser:xt,clearUser:wt}=vt.actions,kt=function(e){const t=function(e){const{thunk:t=!0,immutableCheck:n=!0,serializableCheck:r=!0,actionCreatorCheck:a=!0}=e??{};let s=new rt;return t&&(function(e){return"boolean"===typeof e}(t)?s.push(ce):s.push(de(t.extraArgument))),s},{reducer:n,middleware:r,devTools:a=!0,preloadedState:s,enhancers:i}=e||{};let o,l;if("function"===typeof n)o=n;else{if(!se(n))throw new Error(bt(1));o=oe(n)}l="function"===typeof r?r(t):t();let u=le;a&&(u=tt({trace:!1,..."object"===typeof a&&a}));const c=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return e=>(n,r)=>{const a=e(n,r);let s=()=>{throw new Error(te(15))};const i={getState:a.getState,dispatch:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return s(e,...n)}},o=t.map((e=>e(i)));return s=le(...o)(a.dispatch),{...a,dispatch:s}}}(...l),d=ut(c);return ie(o,s,u(..."function"===typeof i?i(d):d()))}({reducer:{user:vt.reducer}}),St=kt;function It(){return It=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},It.apply(this,arguments)}var Ct;!function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"}(Ct||(Ct={}));const Nt="popstate";function Tt(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function Et(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(mD){}}}function At(e,t){return{usr:e.state,key:e.key,idx:t}}function _t(e,t,n,r){return void 0===n&&(n=null),It({pathname:"string"===typeof e?e:e.pathname,search:"",hash:""},"string"===typeof t?Rt(t):t,{state:n,key:t&&t.key||r||Math.random().toString(36).substr(2,8)})}function $t(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(t+="#"===r.charAt(0)?r:"#"+r),t}function Rt(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substr(r),e=e.substr(0,r)),e&&(t.pathname=e)}return t}function Dt(e,t,n,r){void 0===r&&(r={});let{window:a=document.defaultView,v5Compat:s=!1}=r,i=a.history,o=Ct.Pop,l=null,u=c();function c(){return(i.state||{idx:null}).idx}function d(){o=Ct.Pop;let e=c(),t=null==e?null:e-u;u=e,l&&l({action:o,location:p.location,delta:t})}function h(e){let t="null"!==a.location.origin?a.location.origin:a.location.href,n="string"===typeof e?e:$t(e);return n=n.replace(/ $/,"%20"),Tt(t,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,t)}null==u&&(u=0,i.replaceState(It({},i.state,{idx:u}),""));let p={get action(){return o},get location(){return e(a,i)},listen(e){if(l)throw new Error("A history only accepts one active listener");return a.addEventListener(Nt,d),l=e,()=>{a.removeEventListener(Nt,d),l=null}},createHref:e=>t(a,e),createURL:h,encodeLocation(e){let t=h(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){o=Ct.Push;let r=_t(p.location,e,t);n&&n(r,e),u=c()+1;let d=At(r,u),h=p.createHref(r);try{i.pushState(d,"",h)}catch(f){if(f instanceof DOMException&&"DataCloneError"===f.name)throw f;a.location.assign(h)}s&&l&&l({action:o,location:p.location,delta:1})},replace:function(e,t){o=Ct.Replace;let r=_t(p.location,e,t);n&&n(r,e),u=c();let a=At(r,u),d=p.createHref(r);i.replaceState(a,"",d),s&&l&&l({action:o,location:p.location,delta:0})},go:e=>i.go(e)};return p}var Mt;!function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"}(Mt||(Mt={}));new Set(["lazy","caseSensitive","path","id","index","children"]);function Ft(e,t,n){return void 0===n&&(n="/"),Ot(e,t,n,!1)}function Ot(e,t,n,r){let a=Yt(("string"===typeof t?Rt(t):t).pathname||"/",n);if(null==a)return null;let s=Pt(e);!function(e){e.sort(((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every(((e,n)=>e===t[n]));return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map((e=>e.childrenIndex)),t.routesMeta.map((e=>e.childrenIndex)))))}(s);let i=null;for(let o=0;null==i&&o<s.length;++o){let e=Xt(a);i=qt(s[o],e,r)}return i}function Pt(e,t,n,r){void 0===t&&(t=[]),void 0===n&&(n=[]),void 0===r&&(r="");let a=(e,a,s)=>{let i={relativePath:void 0===s?e.path||"":s,caseSensitive:!0===e.caseSensitive,childrenIndex:a,route:e};i.relativePath.startsWith("/")&&(Tt(i.relativePath.startsWith(r),'Absolute route path "'+i.relativePath+'" nested under path "'+r+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),i.relativePath=i.relativePath.slice(r.length));let o=tn([r,i.relativePath]),l=n.concat(i);e.children&&e.children.length>0&&(Tt(!0!==e.index,'Index routes must not have child routes. Please remove all child routes from route path "'+o+'".'),Pt(e.children,t,l,o)),(null!=e.path||e.index)&&t.push({path:o,score:Ht(o,e.index),routesMeta:l})};return e.forEach(((e,t)=>{var n;if(""!==e.path&&null!=(n=e.path)&&n.includes("?"))for(let r of Lt(e.path))a(e,t,r);else a(e,t)})),t}function Lt(e){let t=e.split("/");if(0===t.length)return[];let[n,...r]=t,a=n.endsWith("?"),s=n.replace(/\?$/,"");if(0===r.length)return a?[s,""]:[s];let i=Lt(r.join("/")),o=[];return o.push(...i.map((e=>""===e?s:[s,e].join("/")))),a&&o.push(...i),o.map((t=>e.startsWith("/")&&""===t?"/":t))}const zt=/^:[\w-]+$/,Bt=3,Wt=2,Vt=1,Ut=10,jt=-2,Gt=e=>"*"===e;function Ht(e,t){let n=e.split("/"),r=n.length;return n.some(Gt)&&(r+=jt),t&&(r+=Wt),n.filter((e=>!Gt(e))).reduce(((e,t)=>e+(zt.test(t)?Bt:""===t?Vt:Ut)),r)}function qt(e,t,n){void 0===n&&(n=!1);let{routesMeta:r}=e,a={},s="/",i=[];for(let o=0;o<r.length;++o){let e=r[o],l=o===r.length-1,u="/"===s?t:t.slice(s.length)||"/",c=Kt({path:e.relativePath,caseSensitive:e.caseSensitive,end:l},u),d=e.route;if(!c&&l&&n&&!r[r.length-1].route.index&&(c=Kt({path:e.relativePath,caseSensitive:e.caseSensitive,end:!1},u)),!c)return null;Object.assign(a,c.params),i.push({params:a,pathname:tn([s,c.pathname]),pathnameBase:nn(tn([s,c.pathnameBase])),route:d}),"/"!==c.pathnameBase&&(s=tn([s,c.pathnameBase]))}return i}function Kt(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=!0);Et("*"===e||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were "'+e.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+e.replace(/\*$/,"/*")+'".');let r=[],a="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((e,t,n)=>(r.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));e.endsWith("*")?(r.push({paramName:"*"}),a+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?a+="\\/*$":""!==e&&"/"!==e&&(a+="(?:(?=\\/|$))");let s=new RegExp(a,t?void 0:"i");return[s,r]}(e.path,e.caseSensitive,e.end),a=t.match(n);if(!a)return null;let s=a[0],i=s.replace(/(.)\/+$/,"$1"),o=a.slice(1);return{params:r.reduce(((e,t,n)=>{let{paramName:r,isOptional:a}=t;if("*"===r){let e=o[n]||"";i=s.slice(0,s.length-e.length).replace(/(.)\/+$/,"$1")}const l=o[n];return e[r]=a&&!l?void 0:(l||"").replace(/%2F/g,"/"),e}),{}),pathname:s,pathnameBase:i,pattern:e}}function Xt(e){try{return e.split("/").map((e=>decodeURIComponent(e).replace(/\//g,"%2F"))).join("/")}catch(t){return Et(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+t+")."),e}}function Yt(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&"/"!==r?null:e.slice(n)||"/"}function Qt(e,t,n,r){return"Cannot include a '"+e+"' character in a manually specified `to."+t+"` field ["+JSON.stringify(r)+"].  Please separate it out to the `to."+n+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function Jt(e){return e.filter(((e,t)=>0===t||e.route.path&&e.route.path.length>0))}function Zt(e,t){let n=Jt(e);return t?n.map(((e,t)=>t===n.length-1?e.pathname:e.pathnameBase)):n.map((e=>e.pathnameBase))}function en(e,t,n,r){let a;void 0===r&&(r=!1),"string"===typeof e?a=Rt(e):(a=It({},e),Tt(!a.pathname||!a.pathname.includes("?"),Qt("?","pathname","search",a)),Tt(!a.pathname||!a.pathname.includes("#"),Qt("#","pathname","hash",a)),Tt(!a.search||!a.search.includes("#"),Qt("#","search","hash",a)));let s,i=""===e||""===a.pathname,o=i?"/":a.pathname;if(null==o)s=n;else{let e=t.length-1;if(!r&&o.startsWith("..")){let t=o.split("/");for(;".."===t[0];)t.shift(),e-=1;a.pathname=t.join("/")}s=e>=0?t[e]:"/"}let l=function(e,t){void 0===t&&(t="/");let{pathname:n,search:r="",hash:a=""}="string"===typeof e?Rt(e):e,s=n?n.startsWith("/")?n:function(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach((e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)})),n.length>1?n.join("/"):"/"}(n,t):t;return{pathname:s,search:rn(r),hash:an(a)}}(a,s),u=o&&"/"!==o&&o.endsWith("/"),c=(i||"."===o)&&n.endsWith("/");return l.pathname.endsWith("/")||!u&&!c||(l.pathname+="/"),l}const tn=e=>e.join("/").replace(/\/\/+/g,"/"),nn=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),rn=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",an=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:"";Error;function sn(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}const on=["post","put","patch","delete"],ln=(new Set(on),["get",...on]);new Set(ln),new Set([301,302,303,307,308]),new Set([307,308]);Symbol("deferred");function un(){return un=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},un.apply(this,arguments)}const cn=T.createContext(null);const dn=T.createContext(null);const hn=T.createContext(null);const pn=T.createContext(null);const fn=T.createContext({outlet:null,matches:[],isDataRoute:!1});const mn=T.createContext(null);function gn(){return null!=T.useContext(pn)}function yn(){return gn()||Tt(!1),T.useContext(pn).location}function bn(e){T.useContext(hn).static||T.useLayoutEffect(e)}function vn(){let{isDataRoute:e}=T.useContext(fn);return e?function(){let{router:e}=En(Nn.UseNavigateStable),t=_n(Tn.UseNavigateStable),n=T.useRef(!1);bn((()=>{n.current=!0}));let r=T.useCallback((function(r,a){void 0===a&&(a={}),n.current&&("number"===typeof r?e.navigate(r):e.navigate(r,un({fromRouteId:t},a)))}),[e,t]);return r}():function(){gn()||Tt(!1);let e=T.useContext(cn),{basename:t,future:n,navigator:r}=T.useContext(hn),{matches:a}=T.useContext(fn),{pathname:s}=yn(),i=JSON.stringify(Zt(a,n.v7_relativeSplatPath)),o=T.useRef(!1);bn((()=>{o.current=!0}));let l=T.useCallback((function(n,a){if(void 0===a&&(a={}),!o.current)return;if("number"===typeof n)return void r.go(n);let l=en(n,JSON.parse(i),s,"path"===a.relative);null==e&&"/"!==t&&(l.pathname="/"===l.pathname?t:tn([t,l.pathname])),(a.replace?r.replace:r.push)(l,a.state,a)}),[t,r,i,s,e]);return l}()}function xn(e,t,n,r){gn()||Tt(!1);let{navigator:a}=T.useContext(hn),{matches:s}=T.useContext(fn),i=s[s.length-1],o=i?i.params:{},l=(i&&i.pathname,i?i.pathnameBase:"/");i&&i.route;let u,c=yn();if(t){var d;let e="string"===typeof t?Rt(t):t;"/"===l||(null==(d=e.pathname)?void 0:d.startsWith(l))||Tt(!1),u=e}else u=c;let h=u.pathname||"/",p=h;if("/"!==l){let e=l.replace(/^\//,"").split("/");p="/"+h.replace(/^\//,"").split("/").slice(e.length).join("/")}let f=Ft(e,{pathname:p});let m=Cn(f&&f.map((e=>Object.assign({},e,{params:Object.assign({},o,e.params),pathname:tn([l,a.encodeLocation?a.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?l:tn([l,a.encodeLocation?a.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])}))),s,n,r);return t&&m?T.createElement(pn.Provider,{value:{location:un({pathname:"/",search:"",hash:"",state:null,key:"default"},u),navigationType:Ct.Pop}},m):m}function wn(){let e=function(){var e;let t=T.useContext(mn),n=An(Tn.UseRouteError),r=_n(Tn.UseRouteError);if(void 0!==t)return t;return null==(e=n.errors)?void 0:e[r]}(),t=sn(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,r="rgba(200,200,200, 0.5)",a={padding:"0.5rem",backgroundColor:r};return T.createElement(T.Fragment,null,T.createElement("h2",null,"Unexpected Application Error!"),T.createElement("h3",{style:{fontStyle:"italic"}},t),n?T.createElement("pre",{style:a},n):null,null)}const kn=T.createElement(wn,null);class Sn extends T.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?T.createElement(fn.Provider,{value:this.props.routeContext},T.createElement(mn.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function In(e){let{routeContext:t,match:n,children:r}=e,a=T.useContext(cn);return a&&a.static&&a.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=n.route.id),T.createElement(fn.Provider,{value:t},r)}function Cn(e,t,n,r){var a;if(void 0===t&&(t=[]),void 0===n&&(n=null),void 0===r&&(r=null),null==e){var s;if(!n)return null;if(n.errors)e=n.matches;else{if(!(null!=(s=r)&&s.v7_partialHydration&&0===t.length&&!n.initialized&&n.matches.length>0))return null;e=n.matches}}let i=e,o=null==(a=n)?void 0:a.errors;if(null!=o){let e=i.findIndex((e=>e.route.id&&void 0!==(null==o?void 0:o[e.route.id])));e>=0||Tt(!1),i=i.slice(0,Math.min(i.length,e+1))}let l=!1,u=-1;if(n&&r&&r.v7_partialHydration)for(let c=0;c<i.length;c++){let e=i[c];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(u=c),e.route.id){let{loaderData:t,errors:r}=n,a=e.route.loader&&void 0===t[e.route.id]&&(!r||void 0===r[e.route.id]);if(e.route.lazy||a){l=!0,i=u>=0?i.slice(0,u+1):[i[0]];break}}}return i.reduceRight(((e,r,a)=>{let s,c=!1,d=null,h=null;var p;n&&(s=o&&r.route.id?o[r.route.id]:void 0,d=r.route.errorElement||kn,l&&(u<0&&0===a?(p="route-fallback",!1||$n[p]||($n[p]=!0),c=!0,h=null):u===a&&(c=!0,h=r.route.hydrateFallbackElement||null)));let f=t.concat(i.slice(0,a+1)),m=()=>{let t;return t=s?d:c?h:r.route.Component?T.createElement(r.route.Component,null):r.route.element?r.route.element:e,T.createElement(In,{match:r,routeContext:{outlet:e,matches:f,isDataRoute:null!=n},children:t})};return n&&(r.route.ErrorBoundary||r.route.errorElement||0===a)?T.createElement(Sn,{location:n.location,revalidation:n.revalidation,component:d,error:s,children:m(),routeContext:{outlet:null,matches:f,isDataRoute:!0}}):m()}),null)}var Nn=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(Nn||{}),Tn=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(Tn||{});function En(e){let t=T.useContext(cn);return t||Tt(!1),t}function An(e){let t=T.useContext(dn);return t||Tt(!1),t}function _n(e){let t=function(){let e=T.useContext(fn);return e||Tt(!1),e}(),n=t.matches[t.matches.length-1];return n.route.id||Tt(!1),n.route.id}const $n={};E.startTransition;function Rn(e){Tt(!1)}function Dn(e){let{basename:t="/",children:n=null,location:r,navigationType:a=Ct.Pop,navigator:s,static:i=!1,future:o}=e;gn()&&Tt(!1);let l=t.replace(/^\/*/,"/"),u=T.useMemo((()=>({basename:l,navigator:s,static:i,future:un({v7_relativeSplatPath:!1},o)})),[l,o,s,i]);"string"===typeof r&&(r=Rt(r));let{pathname:c="/",search:d="",hash:h="",state:p=null,key:f="default"}=r,m=T.useMemo((()=>{let e=Yt(c,l);return null==e?null:{location:{pathname:e,search:d,hash:h,state:p,key:f},navigationType:a}}),[l,c,d,h,p,f,a]);return null==m?null:T.createElement(hn.Provider,{value:u},T.createElement(pn.Provider,{children:n,value:m}))}function Mn(e){let{children:t,location:n}=e;return xn(Fn(t),n)}new Promise((()=>{}));T.Component;function Fn(e,t){void 0===t&&(t=[]);let n=[];return T.Children.forEach(e,((e,r)=>{if(!T.isValidElement(e))return;let a=[...t,r];if(e.type===T.Fragment)return void n.push.apply(n,Fn(e.props.children,a));e.type!==Rn&&Tt(!1),e.props.index&&e.props.children&&Tt(!1);let s={id:e.props.id||a.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(s.children=Fn(e.props.children,a)),n.push(s)})),n}new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);try{window.__reactRouterVersion="6"}catch(mD){}new Map;const On=E.startTransition;_.flushSync,E.useId;function Pn(e){let{basename:t,children:n,future:r,window:a}=e,s=T.useRef();var i;null==s.current&&(s.current=(void 0===(i={window:a,v5Compat:!0})&&(i={}),Dt((function(e,t){let{pathname:n="/",search:r="",hash:a=""}=Rt(e.location.hash.substr(1));return n.startsWith("/")||n.startsWith(".")||(n="/"+n),_t("",{pathname:n,search:r,hash:a},t.state&&t.state.usr||null,t.state&&t.state.key||"default")}),(function(e,t){let n=e.document.querySelector("base"),r="";if(n&&n.getAttribute("href")){let t=e.location.href,n=t.indexOf("#");r=-1===n?t:t.slice(0,n)}return r+"#"+("string"===typeof t?t:$t(t))}),(function(e,t){Et("/"===e.pathname.charAt(0),"relative pathnames are not supported in hash history.push("+JSON.stringify(t)+")")}),i)));let o=s.current,[l,u]=T.useState({action:o.action,location:o.location}),{v7_startTransition:c}=r||{},d=T.useCallback((e=>{c&&On?On((()=>u(e))):u(e)}),[u,c]);return T.useLayoutEffect((()=>o.listen(d)),[o,d]),T.createElement(Dn,{basename:t,children:n,location:l.location,navigationType:l.action,navigator:o,future:r})}"undefined"!==typeof window&&"undefined"!==typeof window.document&&window.document.createElement;var Ln,zn;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(Ln||(Ln={})),function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"}(zn||(zn={}));var Bn=n(8387),Wn=n(6596),Vn=n(8610);function Un(e){try{return e.matches(":focus-visible")}catch(t){0}return!1}var jn=n(6803),Gn=n(4535),Hn=n(2390),qn=n(4575);const Kn=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const t=T.useContext(qn.T);return t&&(n=t,0!==Object.keys(n).length)?t:e;var n},Xn=(0,Hn.A)();const Yn=function(){return Kn(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Xn)};var Qn=n(5170),Jn=n(3375);function Zn(){const e=Yn(Qn.A);return e[Jn.A]||e}var er=n(6870),tr=n(8249),nr=n(9172),rr=n(138);const ar=e=>{const t={systemProps:{},otherProps:{}},n=e?.theme?.unstable_sxConfig??rr.A;return Object.keys(e).forEach((r=>{n[r]?t.systemProps[r]=e[r]:t.otherProps[r]=e[r]})),t};function sr(e){const{sx:t,...n}=e,{systemProps:r,otherProps:a}=ar(n);let s;return s=Array.isArray(t)?[r,...t]:"function"===typeof t?function(){const e=t(...arguments);return(0,nr.Q)(e)?{...r,...e}:r}:{...r,...t},{...a,sx:s}}var ir=n(1722),or=n(9436),lr=n(6598),ur=(n(3803),n(219),(0,qn.w)((function(e,t){var n=e.styles,r=(0,lr.J)([n],void 0,T.useContext(qn.T)),a=T.useRef();return(0,or.i)((function(){var e=t.key+"-global",n=new t.sheet.constructor({key:e,nonce:t.sheet.nonce,container:t.sheet.container,speedy:t.sheet.isSpeedy}),s=!1,i=document.querySelector('style[data-emotion="'+e+" "+r.name+'"]');return t.sheet.tags.length&&(n.before=t.sheet.tags[0]),null!==i&&(s=!0,i.setAttribute("data-emotion",e),n.hydrate([i])),a.current=[n,s],function(){n.flush()}}),[t]),(0,or.i)((function(){var e=a.current,n=e[0];if(e[1])e[1]=!1;else{if(void 0!==r.next&&(0,ir.sk)(t,r.next,!0),n.tags.length){var s=n.tags[n.tags.length-1].nextElementSibling;n.before=s,n.flush()}t.insert("",r,n,!1)}}),[t,r.name]),null})));function cr(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return(0,lr.J)(t)}var dr=function(){var e=cr.apply(void 0,arguments),t="animation-"+e.name;return{name:t,styles:"@keyframes "+t+"{"+e.styles+"}",anim:1,toString:function(){return"_EMO_"+this.name+"_"+this.styles+"_EMO_"}}};var hr=n(579);function pr(e){const{styles:t,defaultTheme:n={}}=e,r="function"===typeof t?e=>{return t(void 0===(r=e)||null===r||0===Object.keys(r).length?n:e);var r}:t;return(0,hr.jsx)(ur,{styles:r})}const fr=function(e){let{styles:t,themeId:n,defaultTheme:r={}}=e;const a=Yn(r),s="function"===typeof t?t(n&&a[n]||a):t;return(0,hr.jsx)(pr,{styles:s})};const mr=function(e){return(0,hr.jsx)(fr,{...e,defaultTheme:Qn.A,themeId:Jn.A})};var gr=n(2532),yr=n(2372);function br(e){return(0,yr.Ay)("MuiTypography",e)}(0,gr.A)("MuiTypography",["root","h1","h2","h3","h4","h5","h6","subtitle1","subtitle2","body1","body2","inherit","button","caption","overline","alignLeft","alignRight","alignCenter","alignJustify","noWrap","gutterBottom","paragraph"]);const vr={primary:!0,secondary:!0,error:!0,info:!0,success:!0,warning:!0,textPrimary:!0,textSecondary:!0,textDisabled:!0},xr=sr,wr=(0,Gn.Ay)("span",{name:"MuiTypography",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.variant&&t[n.variant],"inherit"!==n.align&&t[`align${(0,jn.A)(n.align)}`],n.noWrap&&t.noWrap,n.gutterBottom&&t.gutterBottom,n.paragraph&&t.paragraph]}})((0,er.A)((e=>{let{theme:t}=e;return{margin:0,variants:[{props:{variant:"inherit"},style:{font:"inherit",lineHeight:"inherit",letterSpacing:"inherit"}},...Object.entries(t.typography).filter((e=>{let[t,n]=e;return"inherit"!==t&&n&&"object"===typeof n})).map((e=>{let[t,n]=e;return{props:{variant:t},style:n}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars||t).palette[n].main}}})),...Object.entries(t.palette?.text||{}).filter((e=>{let[,t]=e;return"string"===typeof t})).map((e=>{let[n]=e;return{props:{color:`text${(0,jn.A)(n)}`},style:{color:(t.vars||t).palette.text[n]}}})),{props:e=>{let{ownerState:t}=e;return"inherit"!==t.align},style:{textAlign:"var(--Typography-textAlign)"}},{props:e=>{let{ownerState:t}=e;return t.noWrap},style:{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}},{props:e=>{let{ownerState:t}=e;return t.gutterBottom},style:{marginBottom:"0.35em"}},{props:e=>{let{ownerState:t}=e;return t.paragraph},style:{marginBottom:16}}]}}))),kr={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",subtitle1:"h6",subtitle2:"h6",body1:"p",body2:"p",inherit:"p"},Sr=T.forwardRef((function(e,t){const{color:n,...r}=(0,tr.b)({props:e,name:"MuiTypography"}),a=xr({...r,...!vr[n]&&{color:n}}),{align:s="inherit",className:i,component:o,gutterBottom:l=!1,noWrap:u=!1,paragraph:c=!1,variant:d="body1",variantMapping:h=kr,...p}=a,f={...a,align:s,color:n,className:i,component:o,gutterBottom:l,noWrap:u,paragraph:c,variant:d,variantMapping:h},m=o||(c?"p":h[d]||kr[d])||"span",g=(e=>{const{align:t,gutterBottom:n,noWrap:r,paragraph:a,variant:s,classes:i}=e,o={root:["root",s,"inherit"!==e.align&&`align${(0,jn.A)(t)}`,n&&"gutterBottom",r&&"noWrap",a&&"paragraph"]};return(0,Vn.A)(o,br,i)})(f);return(0,hr.jsx)(wr,{as:m,ref:t,className:(0,Bn.A)(g.root,i),...p,ownerState:f,style:{..."inherit"!==s&&{"--Typography-textAlign":s},...p.style}})})),Ir=Sr;function Cr(e){return(0,yr.Ay)("MuiLink",e)}const Nr=(0,gr.A)("MuiLink",["root","underlineNone","underlineHover","underlineAlways","button","focusVisible"]);var Tr=n(6224);const Er=e=>{let{theme:t,ownerState:n}=e;const r=n.color,a=(0,Tr.Yn)(t,`palette.${r}`,!1)||n.color,s=(0,Tr.Yn)(t,`palette.${r}Channel`);return"vars"in t&&s?`rgba(${s} / 0.4)`:(0,Wn.X4)(a,.4)},Ar={primary:!0,secondary:!0,error:!0,info:!0,success:!0,warning:!0,textPrimary:!0,textSecondary:!0,textDisabled:!0},_r=(0,Gn.Ay)(Ir,{name:"MuiLink",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`underline${(0,jn.A)(n.underline)}`],"button"===n.component&&t.button]}})((0,er.A)((e=>{let{theme:t}=e;return{variants:[{props:{underline:"none"},style:{textDecoration:"none"}},{props:{underline:"hover"},style:{textDecoration:"none","&:hover":{textDecoration:"underline"}}},{props:{underline:"always"},style:{textDecoration:"underline","&:hover":{textDecorationColor:"inherit"}}},{props:e=>{let{underline:t,ownerState:n}=e;return"always"===t&&"inherit"!==n.color},style:{textDecorationColor:"var(--Link-underlineColor)"}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{underline:"always",color:n},style:{"--Link-underlineColor":t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.4)`:(0,Wn.X4)(t.palette[n].main,.4)}}})),{props:{underline:"always",color:"textPrimary"},style:{"--Link-underlineColor":t.vars?`rgba(${t.vars.palette.text.primaryChannel} / 0.4)`:(0,Wn.X4)(t.palette.text.primary,.4)}},{props:{underline:"always",color:"textSecondary"},style:{"--Link-underlineColor":t.vars?`rgba(${t.vars.palette.text.secondaryChannel} / 0.4)`:(0,Wn.X4)(t.palette.text.secondary,.4)}},{props:{underline:"always",color:"textDisabled"},style:{"--Link-underlineColor":(t.vars||t).palette.text.disabled}},{props:{component:"button"},style:{position:"relative",WebkitTapHighlightColor:"transparent",backgroundColor:"transparent",outline:0,border:0,margin:0,borderRadius:0,padding:0,cursor:"pointer",userSelect:"none",verticalAlign:"middle",MozAppearance:"none",WebkitAppearance:"none","&::-moz-focus-inner":{borderStyle:"none"},[`&.${Nr.focusVisible}`]:{outline:"auto"}}}]}}))),$r=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiLink"}),r=Zn(),{className:a,color:s="primary",component:i="a",onBlur:o,onFocus:l,TypographyClasses:u,underline:c="always",variant:d="inherit",sx:h,...p}=n,[f,m]=T.useState(!1),g={...n,color:s,component:i,focusVisible:f,underline:c,variant:d},y=(e=>{const{classes:t,component:n,focusVisible:r,underline:a}=e,s={root:["root",`underline${(0,jn.A)(a)}`,"button"===n&&"button",r&&"focusVisible"]};return(0,Vn.A)(s,Cr,t)})(g);return(0,hr.jsx)(_r,{color:s,className:(0,Bn.A)(y.root,a),classes:u,component:i,onBlur:e=>{Un(e.target)||m(!1),o&&o(e)},onFocus:e=>{Un(e.target)&&m(!0),l&&l(e)},ref:t,ownerState:g,variant:d,...p,sx:[...void 0===Ar[s]?[{color:s}]:[],...Array.isArray(h)?h:[h]],style:{...p.style,..."always"===c&&"inherit"!==s&&!Ar[s]&&{"--Link-underlineColor":Er({theme:r,ownerState:g})}}})})),Rr=$r;var Dr=n(4984),Mr=n(2768);var Fr=n(9386),Or=n(5913);const Pr=(0,gr.A)("MuiBox",["root"]),Lr=(0,Or.A)(),zr=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{themeId:t,defaultTheme:n,defaultClassName:r="MuiBox-root",generateClassName:a}=e,s=(0,Dr.Ay)("div",{shouldForwardProp:e=>"theme"!==e&&"sx"!==e&&"as"!==e})(Mr.A);return T.forwardRef((function(e,i){const o=Yn(n),{className:l,component:u="div",...c}=sr(e);return(0,hr.jsx)(s,{as:u,ref:i,className:(0,Bn.A)(l,a?a(r):r),theme:t&&o[t]||o,...c})}))}({themeId:Jn.A,defaultTheme:Lr,defaultClassName:Pr.root,generateClassName:Fr.A.generate}),Br=zr;var Wr=n(3582);function Vr(e){return(0,yr.Ay)("MuiPaper",e)}(0,gr.A)("MuiPaper",["root","rounded","outlined","elevation","elevation0","elevation1","elevation2","elevation3","elevation4","elevation5","elevation6","elevation7","elevation8","elevation9","elevation10","elevation11","elevation12","elevation13","elevation14","elevation15","elevation16","elevation17","elevation18","elevation19","elevation20","elevation21","elevation22","elevation23","elevation24"]);const Ur=(0,Gn.Ay)("div",{name:"MuiPaper",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],!n.square&&t.rounded,"elevation"===n.variant&&t[`elevation${n.elevation}`]]}})((0,er.A)((e=>{let{theme:t}=e;return{backgroundColor:(t.vars||t).palette.background.paper,color:(t.vars||t).palette.text.primary,transition:t.transitions.create("box-shadow"),variants:[{props:e=>{let{ownerState:t}=e;return!t.square},style:{borderRadius:t.shape.borderRadius}},{props:{variant:"outlined"},style:{border:`1px solid ${(t.vars||t).palette.divider}`}},{props:{variant:"elevation"},style:{boxShadow:"var(--Paper-shadow)",backgroundImage:"var(--Paper-overlay)"}}]}}))),jr=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiPaper"}),r=Zn(),{className:a,component:s="div",elevation:i=1,square:o=!1,variant:l="elevation",...u}=n,c={...n,component:s,elevation:i,square:o,variant:l},d=(e=>{const{square:t,elevation:n,variant:r,classes:a}=e,s={root:["root",r,!t&&"rounded","elevation"===r&&`elevation${n}`]};return(0,Vn.A)(s,Vr,a)})(c);return(0,hr.jsx)(Ur,{as:s,ownerState:c,className:(0,Bn.A)(d.root,a),ref:t,...u,style:{..."elevation"===l&&{"--Paper-shadow":(r.vars||r).shadows[i],...r.vars&&{"--Paper-overlay":r.vars.overlays?.[i]},...!r.vars&&"dark"===r.palette.mode&&{"--Paper-overlay":`linear-gradient(${(0,Wn.X4)("#fff",(0,Wr.A)(i))}, ${(0,Wn.X4)("#fff",(0,Wr.A)(i))})`}},...u.style}})})),Gr=jr;var Hr=n(5844),qr=n(7868),Kr=n(3462),Xr=n(3940),Yr=n(4440),Qr=n(3468);function Jr(e){return parseInt(e,10)||0}const Zr={visibility:"hidden",position:"absolute",overflow:"hidden",height:0,top:0,left:0,transform:"translateZ(0)"};const ea=T.forwardRef((function(e,t){const{onChange:n,maxRows:r,minRows:a=1,style:s,value:i,...o}=e,{current:l}=T.useRef(null!=i),u=T.useRef(null),c=(0,Kr.A)(t,u),d=T.useRef(null),h=T.useRef(null),p=T.useCallback((()=>{const t=u.current,n=(0,Xr.A)(t).getComputedStyle(t);if("0px"===n.width)return{outerHeightStyle:0,overflowing:!1};const s=h.current;s.style.width=n.width,s.value=t.value||e.placeholder||"x","\n"===s.value.slice(-1)&&(s.value+=" ");const i=n.boxSizing,o=Jr(n.paddingBottom)+Jr(n.paddingTop),l=Jr(n.borderBottomWidth)+Jr(n.borderTopWidth),c=s.scrollHeight;s.value="x";const d=s.scrollHeight;let p=c;a&&(p=Math.max(Number(a)*d,p)),r&&(p=Math.min(Number(r)*d,p)),p=Math.max(p,d);return{outerHeightStyle:p+("border-box"===i?o+l:0),overflowing:Math.abs(p-c)<=1}}),[r,a,e.placeholder]),f=T.useCallback((()=>{const e=p();if(void 0===(t=e)||null===t||0===Object.keys(t).length||0===t.outerHeightStyle&&!t.overflowing)return;var t;const n=e.outerHeightStyle,r=u.current;d.current!==n&&(d.current=n,r.style.height=`${n}px`),r.style.overflow=e.overflowing?"hidden":""}),[p]);(0,Yr.A)((()=>{const e=()=>{f()};let t;const n=(0,Qr.A)(e),r=u.current,a=(0,Xr.A)(r);let s;return a.addEventListener("resize",n),"undefined"!==typeof ResizeObserver&&(s=new ResizeObserver(e),s.observe(r)),()=>{n.clear(),cancelAnimationFrame(t),a.removeEventListener("resize",n),s&&s.disconnect()}}),[p,f]),(0,Yr.A)((()=>{f()}));return(0,hr.jsxs)(T.Fragment,{children:[(0,hr.jsx)("textarea",{value:i,onChange:e=>{l||f(),n&&n(e)},ref:c,rows:a,style:s,...o}),(0,hr.jsx)("textarea",{"aria-hidden":!0,className:e.className,readOnly:!0,ref:h,tabIndex:-1,style:{...Zr,...s,paddingTop:0,paddingBottom:0}})]})})),ta=ea;const na=function(e){return"string"===typeof e};function ra(e){let{props:t,states:n,muiFormControl:r}=e;return n.reduce(((e,n)=>(e[n]=t[n],r&&"undefined"===typeof t[n]&&(e[n]=r[n]),e)),{})}const aa=T.createContext(void 0);function sa(){return T.useContext(aa)}var ia=n(5849),oa=n(5013);function la(e){return null!=e&&!(Array.isArray(e)&&0===e.length)}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return e&&(la(e.value)&&""!==e.value||t&&la(e.defaultValue)&&""!==e.defaultValue)}function ca(e){return(0,yr.Ay)("MuiInputBase",e)}const da=(0,gr.A)("MuiInputBase",["root","formControl","focused","disabled","adornedStart","adornedEnd","error","sizeSmall","multiline","colorSecondary","fullWidth","hiddenLabel","readOnly","input","inputSizeSmall","inputMultiline","inputTypeSearch","inputAdornedStart","inputAdornedEnd","inputHiddenLabel"]);var ha;const pa=(e,t)=>{const{ownerState:n}=e;return[t.root,n.formControl&&t.formControl,n.startAdornment&&t.adornedStart,n.endAdornment&&t.adornedEnd,n.error&&t.error,"small"===n.size&&t.sizeSmall,n.multiline&&t.multiline,n.color&&t[`color${(0,jn.A)(n.color)}`],n.fullWidth&&t.fullWidth,n.hiddenLabel&&t.hiddenLabel]},fa=(e,t)=>{const{ownerState:n}=e;return[t.input,"small"===n.size&&t.inputSizeSmall,n.multiline&&t.inputMultiline,"search"===n.type&&t.inputTypeSearch,n.startAdornment&&t.inputAdornedStart,n.endAdornment&&t.inputAdornedEnd,n.hiddenLabel&&t.inputHiddenLabel]},ma=(0,Gn.Ay)("div",{name:"MuiInputBase",slot:"Root",overridesResolver:pa})((0,er.A)((e=>{let{theme:t}=e;return{...t.typography.body1,color:(t.vars||t).palette.text.primary,lineHeight:"1.4375em",boxSizing:"border-box",position:"relative",cursor:"text",display:"inline-flex",alignItems:"center",[`&.${da.disabled}`]:{color:(t.vars||t).palette.text.disabled,cursor:"default"},variants:[{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:"4px 0 5px"}},{props:e=>{let{ownerState:t,size:n}=e;return t.multiline&&"small"===n},style:{paddingTop:1}},{props:e=>{let{ownerState:t}=e;return t.fullWidth},style:{width:"100%"}}]}}))),ga=(0,Gn.Ay)("input",{name:"MuiInputBase",slot:"Input",overridesResolver:fa})((0,er.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode,r={color:"currentColor",...t.vars?{opacity:t.vars.opacity.inputPlaceholder}:{opacity:n?.42:.5},transition:t.transitions.create("opacity",{duration:t.transitions.duration.shorter})},a={opacity:"0 !important"},s=t.vars?{opacity:t.vars.opacity.inputPlaceholder}:{opacity:n?.42:.5};return{font:"inherit",letterSpacing:"inherit",color:"currentColor",padding:"4px 0 5px",border:0,boxSizing:"content-box",background:"none",height:"1.4375em",margin:0,WebkitTapHighlightColor:"transparent",display:"block",minWidth:0,width:"100%","&::-webkit-input-placeholder":r,"&::-moz-placeholder":r,"&::-ms-input-placeholder":r,"&:focus":{outline:0},"&:invalid":{boxShadow:"none"},"&::-webkit-search-decoration":{WebkitAppearance:"none"},[`label[data-shrink=false] + .${da.formControl} &`]:{"&::-webkit-input-placeholder":a,"&::-moz-placeholder":a,"&::-ms-input-placeholder":a,"&:focus::-webkit-input-placeholder":s,"&:focus::-moz-placeholder":s,"&:focus::-ms-input-placeholder":s},[`&.${da.disabled}`]:{opacity:1,WebkitTextFillColor:(t.vars||t).palette.text.disabled},variants:[{props:e=>{let{ownerState:t}=e;return!t.disableInjectingGlobalStyles},style:{animationName:"mui-auto-fill-cancel",animationDuration:"10ms","&:-webkit-autofill":{animationDuration:"5000s",animationName:"mui-auto-fill"}}},{props:{size:"small"},style:{paddingTop:1}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{height:"auto",resize:"none",padding:0,paddingTop:0}},{props:{type:"search"},style:{MozAppearance:"textfield"}}]}}))),ya=function(e){return function(t){return(0,hr.jsx)(mr,{styles:"function"===typeof e?n=>e({theme:n,...t}):e})}}({"@keyframes mui-auto-fill":{from:{display:"block"}},"@keyframes mui-auto-fill-cancel":{from:{display:"block"}}}),ba=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiInputBase"}),{"aria-describedby":r,autoComplete:a,autoFocus:s,className:i,color:o,components:l={},componentsProps:u={},defaultValue:c,disabled:d,disableInjectingGlobalStyles:h,endAdornment:p,error:f,fullWidth:m=!1,id:g,inputComponent:y="input",inputProps:b={},inputRef:v,margin:x,maxRows:w,minRows:k,multiline:S=!1,name:I,onBlur:C,onChange:N,onClick:E,onFocus:A,onKeyDown:_,onKeyUp:$,placeholder:R,readOnly:D,renderSuffix:M,rows:F,size:O,slotProps:P={},slots:L={},startAdornment:z,type:B="text",value:W,...V}=n,U=null!=b.value?b.value:W,{current:j}=T.useRef(null!=U),G=T.useRef(),H=T.useCallback((e=>{0}),[]),q=(0,ia.A)(G,v,b.ref,H),[K,X]=T.useState(!1),Y=sa();const Q=ra({props:n,muiFormControl:Y,states:["color","disabled","error","hiddenLabel","size","required","filled"]});Q.focused=Y?Y.focused:K,T.useEffect((()=>{!Y&&d&&K&&(X(!1),C&&C())}),[Y,d,K,C]);const J=Y&&Y.onFilled,Z=Y&&Y.onEmpty,ee=T.useCallback((e=>{ua(e)?J&&J():Z&&Z()}),[J,Z]);(0,oa.A)((()=>{j&&ee({value:U})}),[U,ee,j]);T.useEffect((()=>{ee(G.current)}),[]);let te=y,ne=b;S&&"input"===te&&(ne=F?{type:void 0,minRows:F,maxRows:F,...ne}:{type:void 0,maxRows:w,minRows:k,...ne},te=ta);T.useEffect((()=>{Y&&Y.setAdornedStart(Boolean(z))}),[Y,z]);const re={...n,color:Q.color||"primary",disabled:Q.disabled,endAdornment:p,error:Q.error,focused:Q.focused,formControl:Y,fullWidth:m,hiddenLabel:Q.hiddenLabel,multiline:S,size:Q.size,startAdornment:z,type:B},ae=(e=>{const{classes:t,color:n,disabled:r,error:a,endAdornment:s,focused:i,formControl:o,fullWidth:l,hiddenLabel:u,multiline:c,readOnly:d,size:h,startAdornment:p,type:f}=e,m={root:["root",`color${(0,jn.A)(n)}`,r&&"disabled",a&&"error",l&&"fullWidth",i&&"focused",o&&"formControl",h&&"medium"!==h&&`size${(0,jn.A)(h)}`,c&&"multiline",p&&"adornedStart",s&&"adornedEnd",u&&"hiddenLabel",d&&"readOnly"],input:["input",r&&"disabled","search"===f&&"inputTypeSearch",c&&"inputMultiline","small"===h&&"inputSizeSmall",u&&"inputHiddenLabel",p&&"inputAdornedStart",s&&"inputAdornedEnd",d&&"readOnly"]};return(0,Vn.A)(m,ca,t)})(re),se=L.root||l.Root||ma,ie=P.root||u.root||{},oe=L.input||l.Input||ga;return ne={...ne,...P.input??u.input},(0,hr.jsxs)(T.Fragment,{children:[!h&&"function"===typeof ya&&(ha||(ha=(0,hr.jsx)(ya,{}))),(0,hr.jsxs)(se,{...ie,ref:t,onClick:e=>{G.current&&e.currentTarget===e.target&&G.current.focus(),E&&E(e)},...V,...!na(se)&&{ownerState:{...re,...ie.ownerState}},className:(0,Bn.A)(ae.root,ie.className,i,D&&"MuiInputBase-readOnly"),children:[z,(0,hr.jsx)(aa.Provider,{value:null,children:(0,hr.jsx)(oe,{"aria-invalid":Q.error,"aria-describedby":r,autoComplete:a,autoFocus:s,defaultValue:c,disabled:Q.disabled,id:g,onAnimationStart:e=>{ee("mui-auto-fill-cancel"===e.animationName?G.current:{value:"x"})},name:I,placeholder:R,readOnly:D,required:Q.required,rows:F,value:U,onKeyDown:_,onKeyUp:$,type:B,...ne,...!na(oe)&&{as:te,ownerState:{...re,...ne.ownerState}},ref:q,className:(0,Bn.A)(ae.input,ne.className,D&&"MuiInputBase-readOnly"),onBlur:e=>{C&&C(e),b.onBlur&&b.onBlur(e),Y&&Y.onBlur?Y.onBlur(e):X(!1)},onChange:function(e){if(!j){const t=e.target||G.current;if(null==t)throw new Error((0,qr.A)(1));ee({value:t.value})}for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];b.onChange&&b.onChange(e,...n),N&&N(e,...n)},onFocus:e=>{A&&A(e),b.onFocus&&b.onFocus(e),Y&&Y.onFocus?Y.onFocus(e):X(!0)}})}),p,M?M({...Q,startAdornment:z}):null]})]})})),va=ba;var xa=n(1475);function wa(e){return(0,yr.Ay)("MuiInput",e)}const ka={...da,...(0,gr.A)("MuiInput",["root","underline","input"])},Sa=(0,Gn.Ay)(ma,{shouldForwardProp:e=>(0,xa.A)(e)||"classes"===e,name:"MuiInput",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[...pa(e,t),!n.disableUnderline&&t.underline]}})((0,er.A)((e=>{let{theme:t}=e;let n="light"===t.palette.mode?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)";return t.vars&&(n=`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`),{position:"relative",variants:[{props:e=>{let{ownerState:t}=e;return t.formControl},style:{"label + &":{marginTop:16}}},{props:e=>{let{ownerState:t}=e;return!t.disableUnderline},style:{"&::after":{left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${ka.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${ka.error}`]:{"&::before, &::after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${n}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${ka.disabled}, .${ka.error}):before`]:{borderBottom:`2px solid ${(t.vars||t).palette.text.primary}`,"@media (hover: none)":{borderBottom:`1px solid ${n}`}},[`&.${ka.disabled}:before`]:{borderBottomStyle:"dotted"}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n,disableUnderline:!1},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[n].main}`}}}}))]}}))),Ia=(0,Gn.Ay)(ga,{name:"MuiInput",slot:"Input",overridesResolver:fa})({}),Ca=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiInput"}),{disableUnderline:r=!1,components:a={},componentsProps:s,fullWidth:i=!1,inputComponent:o="input",multiline:l=!1,slotProps:u,slots:c={},type:d="text",...h}=n,p=(e=>{const{classes:t,disableUnderline:n}=e,r={root:["root",!n&&"underline"],input:["input"]},a=(0,Vn.A)(r,wa,t);return{...t,...a}})(n),f={root:{ownerState:{disableUnderline:r}}},m=u??s?(0,nr.A)(u??s,f):f,g=c.root??a.Root??Sa,y=c.input??a.Input??Ia;return(0,hr.jsx)(va,{slots:{root:g,input:y},slotProps:m,fullWidth:i,inputComponent:o,multiline:l,ref:t,type:d,...h,classes:p})}));Ca&&(Ca.muiName="Input");const Na=Ca;function Ta(e){return(0,yr.Ay)("MuiFilledInput",e)}const Ea={...da,...(0,gr.A)("MuiFilledInput",["root","underline","input","adornedStart","adornedEnd","sizeSmall","multiline","hiddenLabel"])},Aa=(0,Gn.Ay)(ma,{shouldForwardProp:e=>(0,xa.A)(e)||"classes"===e,name:"MuiFilledInput",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[...pa(e,t),!n.disableUnderline&&t.underline]}})((0,er.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode,r=n?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)",a=n?"rgba(0, 0, 0, 0.06)":"rgba(255, 255, 255, 0.09)",s=n?"rgba(0, 0, 0, 0.09)":"rgba(255, 255, 255, 0.13)",i=n?"rgba(0, 0, 0, 0.12)":"rgba(255, 255, 255, 0.12)";return{position:"relative",backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a,borderTopLeftRadius:(t.vars||t).shape.borderRadius,borderTopRightRadius:(t.vars||t).shape.borderRadius,transition:t.transitions.create("background-color",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),"&:hover":{backgroundColor:t.vars?t.vars.palette.FilledInput.hoverBg:s,"@media (hover: none)":{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a}},[`&.${Ea.focused}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a},[`&.${Ea.disabled}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.disabledBg:i},variants:[{props:e=>{let{ownerState:t}=e;return!t.disableUnderline},style:{"&::after":{left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${Ea.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${Ea.error}`]:{"&::before, &::after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`:r}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${Ea.disabled}, .${Ea.error}):before`]:{borderBottom:`1px solid ${(t.vars||t).palette.text.primary}`},[`&.${Ea.disabled}:before`]:{borderBottomStyle:"dotted"}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{disableUnderline:!1,color:n},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[n]?.main}`}}}})),{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:12}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:12}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:"25px 12px 8px"}},{props:e=>{let{ownerState:t,size:n}=e;return t.multiline&&"small"===n},style:{paddingTop:21,paddingBottom:4}},{props:e=>{let{ownerState:t}=e;return t.multiline&&t.hiddenLabel},style:{paddingTop:16,paddingBottom:17}},{props:e=>{let{ownerState:t}=e;return t.multiline&&t.hiddenLabel&&"small"===t.size},style:{paddingTop:8,paddingBottom:9}}]}}))),_a=(0,Gn.Ay)(ga,{name:"MuiFilledInput",slot:"Input",overridesResolver:fa})((0,er.A)((e=>{let{theme:t}=e;return{paddingTop:25,paddingRight:12,paddingBottom:8,paddingLeft:12,...!t.vars&&{"&:-webkit-autofill":{WebkitBoxShadow:"light"===t.palette.mode?null:"0 0 0 100px #266798 inset",WebkitTextFillColor:"light"===t.palette.mode?null:"#fff",caretColor:"light"===t.palette.mode?null:"#fff",borderTopLeftRadius:"inherit",borderTopRightRadius:"inherit"}},...t.vars&&{"&:-webkit-autofill":{borderTopLeftRadius:"inherit",borderTopRightRadius:"inherit"},[t.getColorSchemeSelector("dark")]:{"&:-webkit-autofill":{WebkitBoxShadow:"0 0 0 100px #266798 inset",WebkitTextFillColor:"#fff",caretColor:"#fff"}}},variants:[{props:{size:"small"},style:{paddingTop:21,paddingBottom:4}},{props:e=>{let{ownerState:t}=e;return t.hiddenLabel},style:{paddingTop:16,paddingBottom:17}},{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:0}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:0}},{props:e=>{let{ownerState:t}=e;return t.hiddenLabel&&"small"===t.size},style:{paddingTop:8,paddingBottom:9}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{paddingTop:0,paddingBottom:0,paddingLeft:0,paddingRight:0}}]}}))),$a=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiFilledInput"}),{disableUnderline:r=!1,components:a={},componentsProps:s,fullWidth:i=!1,hiddenLabel:o,inputComponent:l="input",multiline:u=!1,slotProps:c,slots:d={},type:h="text",...p}=n,f={...n,disableUnderline:r,fullWidth:i,inputComponent:l,multiline:u,type:h},m=(e=>{const{classes:t,disableUnderline:n,startAdornment:r,endAdornment:a,size:s,hiddenLabel:i,multiline:o}=e,l={root:["root",!n&&"underline",r&&"adornedStart",a&&"adornedEnd","small"===s&&`size${(0,jn.A)(s)}`,i&&"hiddenLabel",o&&"multiline"],input:["input"]},u=(0,Vn.A)(l,Ta,t);return{...t,...u}})(n),g={root:{ownerState:f},input:{ownerState:f}},y=c??s?(0,nr.A)(g,c??s):g,b=d.root??a.Root??Aa,v=d.input??a.Input??_a;return(0,hr.jsx)(va,{slots:{root:b,input:v},componentsProps:y,fullWidth:i,inputComponent:l,multiline:u,ref:t,type:h,...p,classes:m})}));$a&&($a.muiName="Input");const Ra=$a;var Da;const Ma=(0,Gn.Ay)("fieldset",{shouldForwardProp:xa.A})({textAlign:"left",position:"absolute",bottom:0,right:0,top:-5,left:0,margin:0,padding:"0 8px",pointerEvents:"none",borderRadius:"inherit",borderStyle:"solid",borderWidth:1,overflow:"hidden",minWidth:"0%"}),Fa=(0,Gn.Ay)("legend",{shouldForwardProp:xa.A})((0,er.A)((e=>{let{theme:t}=e;return{float:"unset",width:"auto",overflow:"hidden",variants:[{props:e=>{let{ownerState:t}=e;return!t.withLabel},style:{padding:0,lineHeight:"11px",transition:t.transitions.create("width",{duration:150,easing:t.transitions.easing.easeOut})}},{props:e=>{let{ownerState:t}=e;return t.withLabel},style:{display:"block",padding:0,height:11,fontSize:"0.75em",visibility:"hidden",maxWidth:.01,transition:t.transitions.create("max-width",{duration:50,easing:t.transitions.easing.easeOut}),whiteSpace:"nowrap","& > span":{paddingLeft:5,paddingRight:5,display:"inline-block",opacity:0,visibility:"visible"}}},{props:e=>{let{ownerState:t}=e;return t.withLabel&&t.notched},style:{maxWidth:"100%",transition:t.transitions.create("max-width",{duration:100,easing:t.transitions.easing.easeOut,delay:50})}}]}})));function Oa(e){return(0,yr.Ay)("MuiOutlinedInput",e)}const Pa={...da,...(0,gr.A)("MuiOutlinedInput",["root","notchedOutline","input"])},La=(0,Gn.Ay)(ma,{shouldForwardProp:e=>(0,xa.A)(e)||"classes"===e,name:"MuiOutlinedInput",slot:"Root",overridesResolver:pa})((0,er.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{position:"relative",borderRadius:(t.vars||t).shape.borderRadius,[`&:hover .${Pa.notchedOutline}`]:{borderColor:(t.vars||t).palette.text.primary},[`&.${Pa.focused} .${Pa.notchedOutline}`]:{borderWidth:2},variants:[...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{[`&.${Pa.focused} .${Pa.notchedOutline}`]:{borderColor:(t.vars||t).palette[n].main}}}})),{props:{},style:{"@media (hover: none)":{[`&:hover .${Pa.notchedOutline}`]:{borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}},[`&.${Pa.error} .${Pa.notchedOutline}`]:{borderColor:(t.vars||t).palette.error.main},[`&.${Pa.disabled} .${Pa.notchedOutline}`]:{borderColor:(t.vars||t).palette.action.disabled}}},{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:14}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:14}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:"16.5px 14px"}},{props:e=>{let{ownerState:t,size:n}=e;return t.multiline&&"small"===n},style:{padding:"8.5px 14px"}}]}}))),za=(0,Gn.Ay)((function(e){const{children:t,classes:n,className:r,label:a,notched:s,...i}=e,o=null!=a&&""!==a,l={...e,notched:s,withLabel:o};return(0,hr.jsx)(Ma,{"aria-hidden":!0,className:r,ownerState:l,...i,children:(0,hr.jsx)(Fa,{ownerState:l,children:o?(0,hr.jsx)("span",{children:a}):Da||(Da=(0,hr.jsx)("span",{className:"notranslate",children:"\u200b"}))})})}),{name:"MuiOutlinedInput",slot:"NotchedOutline",overridesResolver:(e,t)=>t.notchedOutline})((0,er.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}}))),Ba=(0,Gn.Ay)(ga,{name:"MuiOutlinedInput",slot:"Input",overridesResolver:fa})((0,er.A)((e=>{let{theme:t}=e;return{padding:"16.5px 14px",...!t.vars&&{"&:-webkit-autofill":{WebkitBoxShadow:"light"===t.palette.mode?null:"0 0 0 100px #266798 inset",WebkitTextFillColor:"light"===t.palette.mode?null:"#fff",caretColor:"light"===t.palette.mode?null:"#fff",borderRadius:"inherit"}},...t.vars&&{"&:-webkit-autofill":{borderRadius:"inherit"},[t.getColorSchemeSelector("dark")]:{"&:-webkit-autofill":{WebkitBoxShadow:"0 0 0 100px #266798 inset",WebkitTextFillColor:"#fff",caretColor:"#fff"}}},variants:[{props:{size:"small"},style:{padding:"8.5px 14px"}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:0}},{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:0}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:0}}]}}))),Wa=T.forwardRef((function(e,t){var n;const r=(0,tr.b)({props:e,name:"MuiOutlinedInput"}),{components:a={},fullWidth:s=!1,inputComponent:i="input",label:o,multiline:l=!1,notched:u,slots:c={},type:d="text",...h}=r,p=(e=>{const{classes:t}=e,n=(0,Vn.A)({root:["root"],notchedOutline:["notchedOutline"],input:["input"]},Oa,t);return{...t,...n}})(r),f=sa(),m=ra({props:r,muiFormControl:f,states:["color","disabled","error","focused","hiddenLabel","size","required"]}),g={...r,color:m.color||"primary",disabled:m.disabled,error:m.error,focused:m.focused,formControl:f,fullWidth:s,hiddenLabel:m.hiddenLabel,multiline:l,size:m.size,type:d},y=c.root??a.Root??La,b=c.input??a.Input??Ba;return(0,hr.jsx)(va,{slots:{root:y,input:b},renderSuffix:e=>(0,hr.jsx)(za,{ownerState:g,className:p.notchedOutline,label:null!=o&&""!==o&&m.required?n||(n=(0,hr.jsxs)(T.Fragment,{children:[o,"\u2009","*"]})):o,notched:"undefined"!==typeof u?u:Boolean(e.startAdornment||e.filled||e.focused)}),fullWidth:s,inputComponent:i,multiline:l,ref:t,type:d,...h,classes:{...p,notchedOutline:null}})}));Wa&&(Wa.muiName="Input");const Va=Wa;function Ua(e){return(0,yr.Ay)("MuiFormLabel",e)}const ja=(0,gr.A)("MuiFormLabel",["root","colorSecondary","focused","disabled","error","filled","required","asterisk"]),Ga=(0,Gn.Ay)("label",{name:"MuiFormLabel",slot:"Root",overridesResolver:(e,t)=>{let{ownerState:n}=e;return{...t.root,..."secondary"===n.color&&t.colorSecondary,...n.filled&&t.filled}}})((0,er.A)((e=>{let{theme:t}=e;return{color:(t.vars||t).palette.text.secondary,...t.typography.body1,lineHeight:"1.4375em",padding:0,position:"relative",variants:[...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{[`&.${ja.focused}`]:{color:(t.vars||t).palette[n].main}}}})),{props:{},style:{[`&.${ja.disabled}`]:{color:(t.vars||t).palette.text.disabled},[`&.${ja.error}`]:{color:(t.vars||t).palette.error.main}}}]}}))),Ha=(0,Gn.Ay)("span",{name:"MuiFormLabel",slot:"Asterisk",overridesResolver:(e,t)=>t.asterisk})((0,er.A)((e=>{let{theme:t}=e;return{[`&.${ja.error}`]:{color:(t.vars||t).palette.error.main}}}))),qa=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiFormLabel"}),{children:r,className:a,color:s,component:i="label",disabled:o,error:l,filled:u,focused:c,required:d,...h}=n,p=ra({props:n,muiFormControl:sa(),states:["color","required","focused","disabled","error","filled"]}),f={...n,color:p.color||"primary",component:i,disabled:p.disabled,error:p.error,filled:p.filled,focused:p.focused,required:p.required},m=(e=>{const{classes:t,color:n,focused:r,disabled:a,error:s,filled:i,required:o}=e,l={root:["root",`color${(0,jn.A)(n)}`,a&&"disabled",s&&"error",i&&"filled",r&&"focused",o&&"required"],asterisk:["asterisk",s&&"error"]};return(0,Vn.A)(l,Ua,t)})(f);return(0,hr.jsxs)(Ga,{as:i,ownerState:f,className:(0,Bn.A)(m.root,a),ref:t,...h,children:[r,p.required&&(0,hr.jsxs)(Ha,{ownerState:f,"aria-hidden":!0,className:m.asterisk,children:["\u2009","*"]})]})}));function Ka(e){return(0,yr.Ay)("MuiInputLabel",e)}(0,gr.A)("MuiInputLabel",["root","focused","disabled","error","required","asterisk","formControl","sizeSmall","shrink","animated","standard","filled","outlined"]);const Xa=(0,Gn.Ay)(qa,{shouldForwardProp:e=>(0,xa.A)(e)||"classes"===e,name:"MuiInputLabel",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[{[`& .${ja.asterisk}`]:t.asterisk},t.root,n.formControl&&t.formControl,"small"===n.size&&t.sizeSmall,n.shrink&&t.shrink,!n.disableAnimation&&t.animated,n.focused&&t.focused,t[n.variant]]}})((0,er.A)((e=>{let{theme:t}=e;return{display:"block",transformOrigin:"top left",whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis",maxWidth:"100%",variants:[{props:e=>{let{ownerState:t}=e;return t.formControl},style:{position:"absolute",left:0,top:0,transform:"translate(0, 20px) scale(1)"}},{props:{size:"small"},style:{transform:"translate(0, 17px) scale(1)"}},{props:e=>{let{ownerState:t}=e;return t.shrink},style:{transform:"translate(0, -1.5px) scale(0.75)",transformOrigin:"top left",maxWidth:"133%"}},{props:e=>{let{ownerState:t}=e;return!t.disableAnimation},style:{transition:t.transitions.create(["color","transform","max-width"],{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut})}},{props:{variant:"filled"},style:{zIndex:1,pointerEvents:"none",transform:"translate(12px, 16px) scale(1)",maxWidth:"calc(100% - 24px)"}},{props:{variant:"filled",size:"small"},style:{transform:"translate(12px, 13px) scale(1)"}},{props:e=>{let{variant:t,ownerState:n}=e;return"filled"===t&&n.shrink},style:{userSelect:"none",pointerEvents:"auto",transform:"translate(12px, 7px) scale(0.75)",maxWidth:"calc(133% - 24px)"}},{props:e=>{let{variant:t,ownerState:n,size:r}=e;return"filled"===t&&n.shrink&&"small"===r},style:{transform:"translate(12px, 4px) scale(0.75)"}},{props:{variant:"outlined"},style:{zIndex:1,pointerEvents:"none",transform:"translate(14px, 16px) scale(1)",maxWidth:"calc(100% - 24px)"}},{props:{variant:"outlined",size:"small"},style:{transform:"translate(14px, 9px) scale(1)"}},{props:e=>{let{variant:t,ownerState:n}=e;return"outlined"===t&&n.shrink},style:{userSelect:"none",pointerEvents:"auto",maxWidth:"calc(133% - 32px)",transform:"translate(14px, -9px) scale(0.75)"}}]}}))),Ya=T.forwardRef((function(e,t){const n=(0,tr.b)({name:"MuiInputLabel",props:e}),{disableAnimation:r=!1,margin:a,shrink:s,variant:i,className:o,...l}=n,u=sa();let c=s;"undefined"===typeof c&&u&&(c=u.filled||u.focused||u.adornedStart);const d=ra({props:n,muiFormControl:u,states:["size","variant","required","focused"]}),h={...n,disableAnimation:r,formControl:u,shrink:c,size:d.size,variant:d.variant,required:d.required,focused:d.focused},p=(e=>{const{classes:t,formControl:n,size:r,shrink:a,disableAnimation:s,variant:i,required:o}=e,l={root:["root",n&&"formControl",!s&&"animated",a&&"shrink",r&&"normal"!==r&&`size${(0,jn.A)(r)}`,i],asterisk:[o&&"asterisk"]},u=(0,Vn.A)(l,Ka,t);return{...t,...u}})(h);return(0,hr.jsx)(Xa,{"data-shrink":c,ref:t,className:(0,Bn.A)(p.root,o),...l,ownerState:h,classes:p})})),Qa=Ya;var Ja=n(7328);function Za(e){return(0,yr.Ay)("MuiFormControl",e)}(0,gr.A)("MuiFormControl",["root","marginNone","marginNormal","marginDense","fullWidth","disabled"]);const es=(0,Gn.Ay)("div",{name:"MuiFormControl",slot:"Root",overridesResolver:(e,t)=>{let{ownerState:n}=e;return{...t.root,...t[`margin${(0,jn.A)(n.margin)}`],...n.fullWidth&&t.fullWidth}}})({display:"inline-flex",flexDirection:"column",position:"relative",minWidth:0,padding:0,margin:0,border:0,verticalAlign:"top",variants:[{props:{margin:"normal"},style:{marginTop:16,marginBottom:8}},{props:{margin:"dense"},style:{marginTop:8,marginBottom:4}},{props:{fullWidth:!0},style:{width:"100%"}}]}),ts=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiFormControl"}),{children:r,className:a,color:s="primary",component:i="div",disabled:o=!1,error:l=!1,focused:u,fullWidth:c=!1,hiddenLabel:d=!1,margin:h="none",required:p=!1,size:f="medium",variant:m="outlined",...g}=n,y={...n,color:s,component:i,disabled:o,error:l,fullWidth:c,hiddenLabel:d,margin:h,required:p,size:f,variant:m},b=(e=>{const{classes:t,margin:n,fullWidth:r}=e,a={root:["root","none"!==n&&`margin${(0,jn.A)(n)}`,r&&"fullWidth"]};return(0,Vn.A)(a,Za,t)})(y),[v,x]=T.useState((()=>{let e=!1;return r&&T.Children.forEach(r,(t=>{if(!(0,Ja.A)(t,["Input","Select"]))return;const n=(0,Ja.A)(t,["Select"])?t.props.input:t;n&&n.props.startAdornment&&(e=!0)})),e})),[w,k]=T.useState((()=>{let e=!1;return r&&T.Children.forEach(r,(t=>{(0,Ja.A)(t,["Input","Select"])&&(ua(t.props,!0)||ua(t.props.inputProps,!0))&&(e=!0)})),e})),[S,I]=T.useState(!1);o&&S&&I(!1);const C=void 0===u||o?S:u;let N;const E=T.useMemo((()=>({adornedStart:v,setAdornedStart:x,color:s,disabled:o,error:l,filled:w,focused:C,fullWidth:c,hiddenLabel:d,size:f,onBlur:()=>{I(!1)},onEmpty:()=>{k(!1)},onFilled:()=>{k(!0)},onFocus:()=>{I(!0)},registerEffect:N,required:p,variant:m})),[v,s,o,l,w,C,c,d,N,p,f,m]);return(0,hr.jsx)(aa.Provider,{value:E,children:(0,hr.jsx)(es,{as:i,ownerState:y,className:(0,Bn.A)(b.root,a),ref:t,...g,children:r})})})),ns=ts;function rs(e){return(0,yr.Ay)("MuiFormHelperText",e)}const as=(0,gr.A)("MuiFormHelperText",["root","error","disabled","sizeSmall","sizeMedium","contained","focused","filled","required"]);var ss;const is=(0,Gn.Ay)("p",{name:"MuiFormHelperText",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.size&&t[`size${(0,jn.A)(n.size)}`],n.contained&&t.contained,n.filled&&t.filled]}})((0,er.A)((e=>{let{theme:t}=e;return{color:(t.vars||t).palette.text.secondary,...t.typography.caption,textAlign:"left",marginTop:3,marginRight:0,marginBottom:0,marginLeft:0,[`&.${as.disabled}`]:{color:(t.vars||t).palette.text.disabled},[`&.${as.error}`]:{color:(t.vars||t).palette.error.main},variants:[{props:{size:"small"},style:{marginTop:4}},{props:e=>{let{ownerState:t}=e;return t.contained},style:{marginLeft:14,marginRight:14}}]}}))),os=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiFormHelperText"}),{children:r,className:a,component:s="p",disabled:i,error:o,filled:l,focused:u,margin:c,required:d,variant:h,...p}=n,f=ra({props:n,muiFormControl:sa(),states:["variant","size","disabled","error","filled","focused","required"]}),m={...n,component:s,contained:"filled"===f.variant||"outlined"===f.variant,variant:f.variant,size:f.size,disabled:f.disabled,error:f.error,filled:f.filled,focused:f.focused,required:f.required};delete m.ownerState;const g=(e=>{const{classes:t,contained:n,size:r,disabled:a,error:s,filled:i,focused:o,required:l}=e,u={root:["root",a&&"disabled",s&&"error",r&&`size${(0,jn.A)(r)}`,n&&"contained",o&&"focused",i&&"filled",l&&"required"]};return(0,Vn.A)(u,rs,t)})(m);return(0,hr.jsx)(is,{as:s,className:(0,Bn.A)(g.root,a),ref:t,...p,ownerState:m,children:" "===r?ss||(ss=(0,hr.jsx)("span",{className:"notranslate",children:"\u200b"})):r})}));function ls(e){return e&&T.isValidElement(e)?e.props.propertyIsEnumerable("ref")?e.props.ref:e.ref:null}n(2086);var us=n(2427);const cs=T.createContext();const ds=()=>T.useContext(cs)??!1;const hs=function(e){return"string"===typeof e};const ps=function(e,t,n){return void 0===e||hs(e)?t:{...t,ownerState:{...t.ownerState,...n}}};const fs=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];if(void 0===e)return{};const n={};return Object.keys(e).filter((n=>n.match(/^on[A-Z]/)&&"function"===typeof e[n]&&!t.includes(n))).forEach((t=>{n[t]=e[t]})),n};const ms=function(e){if(void 0===e)return{};const t={};return Object.keys(e).filter((t=>!(t.match(/^on[A-Z]/)&&"function"===typeof e[t]))).forEach((n=>{t[n]=e[n]})),t};const gs=function(e){const{getSlotProps:t,additionalProps:n,externalSlotProps:r,externalForwardedProps:a,className:s}=e;if(!t){const e=(0,Bn.A)(n?.className,s,a?.className,r?.className),t={...n?.style,...a?.style,...r?.style},i={...n,...a,...r};return e.length>0&&(i.className=e),Object.keys(t).length>0&&(i.style=t),{props:i,internalRef:void 0}}const i=fs({...a,...r}),o=ms(r),l=ms(a),u=t(i),c=(0,Bn.A)(u?.className,n?.className,s,a?.className,r?.className),d={...u?.style,...n?.style,...a?.style,...r?.style},h={...u,...n,...l,...o};return c.length>0&&(h.className=c),Object.keys(d).length>0&&(h.style=d),{props:h,internalRef:u.ref}};const ys=function(e,t,n){return"function"===typeof e?e(t,n):e};const bs=function(e){const{elementType:t,externalSlotProps:n,ownerState:r,skipResolvingSlotProps:a=!1,...s}=e,i=a?{}:ys(n,r),{props:o,internalRef:l}=gs({...s,externalSlotProps:i}),u=(0,Kr.A)(l,i?.ref,e.additionalProps?.ref);return ps(t,{...o,ref:u},r)};const vs=T.createContext({});function xs(e){return(0,yr.Ay)("MuiList",e)}(0,gr.A)("MuiList",["root","padding","dense","subheader"]);const ws=(0,Gn.Ay)("ul",{name:"MuiList",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,!n.disablePadding&&t.padding,n.dense&&t.dense,n.subheader&&t.subheader]}})({listStyle:"none",margin:0,padding:0,position:"relative",variants:[{props:e=>{let{ownerState:t}=e;return!t.disablePadding},style:{paddingTop:8,paddingBottom:8}},{props:e=>{let{ownerState:t}=e;return t.subheader},style:{paddingTop:0}}]}),ks=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiList"}),{children:r,className:a,component:s="ul",dense:i=!1,disablePadding:o=!1,subheader:l,...u}=n,c=T.useMemo((()=>({dense:i})),[i]),d={...n,component:s,dense:i,disablePadding:o},h=(e=>{const{classes:t,disablePadding:n,dense:r,subheader:a}=e,s={root:["root",!n&&"padding",r&&"dense",a&&"subheader"]};return(0,Vn.A)(s,xs,t)})(d);return(0,hr.jsx)(vs.Provider,{value:c,children:(0,hr.jsxs)(ws,{as:s,className:(0,Bn.A)(h.root,a),ref:t,ownerState:d,...u,children:[l,r]})})})),Ss=ks;function Is(e){const t=e.documentElement.clientWidth;return Math.abs(window.innerWidth-t)}const Cs=Is;function Ns(e,t,n){return e===t?e.firstChild:t&&t.nextElementSibling?t.nextElementSibling:n?null:e.firstChild}function Ts(e,t,n){return e===t?n?e.firstChild:e.lastChild:t&&t.previousElementSibling?t.previousElementSibling:n?null:e.lastChild}function Es(e,t){if(void 0===t)return!0;let n=e.innerText;return void 0===n&&(n=e.textContent),n=n.trim().toLowerCase(),0!==n.length&&(t.repeating?n[0]===t.keys[0]:n.startsWith(t.keys.join("")))}function As(e,t,n,r,a,s){let i=!1,o=a(e,t,!!t&&n);for(;o;){if(o===e.firstChild){if(i)return!1;i=!0}const t=!r&&(o.disabled||"true"===o.getAttribute("aria-disabled"));if(o.hasAttribute("tabindex")&&Es(o,s)&&!t)return o.focus(),!0;o=a(e,o,n)}return!1}const _s=T.forwardRef((function(e,t){const{actions:n,autoFocus:r=!1,autoFocusItem:a=!1,children:s,className:i,disabledItemsFocusable:o=!1,disableListWrap:l=!1,onKeyDown:u,variant:c="selectedMenu",...d}=e,h=T.useRef(null),p=T.useRef({keys:[],repeating:!0,previousKeyMatched:!0,lastTime:null});(0,oa.A)((()=>{r&&h.current.focus()}),[r]),T.useImperativeHandle(n,(()=>({adjustStyleForScrollbar:(e,t)=>{let{direction:n}=t;const r=!h.current.style.width;if(e.clientHeight<h.current.clientHeight&&r){const t=`${Cs((0,us.A)(e))}px`;h.current.style["rtl"===n?"paddingLeft":"paddingRight"]=t,h.current.style.width=`calc(100% + ${t})`}return h.current}})),[]);const f=(0,ia.A)(h,t);let m=-1;T.Children.forEach(s,((e,t)=>{T.isValidElement(e)?(e.props.disabled||("selectedMenu"===c&&e.props.selected||-1===m)&&(m=t),m===t&&(e.props.disabled||e.props.muiSkipListHighlight||e.type.muiSkipListHighlight)&&(m+=1,m>=s.length&&(m=-1))):m===t&&(m+=1,m>=s.length&&(m=-1))}));const g=T.Children.map(s,((e,t)=>{if(t===m){const t={};return a&&(t.autoFocus=!0),void 0===e.props.tabIndex&&"selectedMenu"===c&&(t.tabIndex=0),T.cloneElement(e,t)}return e}));return(0,hr.jsx)(Ss,{role:"menu",ref:f,className:i,onKeyDown:e=>{const t=h.current,n=e.key;if(e.ctrlKey||e.metaKey||e.altKey)return void(u&&u(e));const r=(0,us.A)(t).activeElement;if("ArrowDown"===n)e.preventDefault(),As(t,r,l,o,Ns);else if("ArrowUp"===n)e.preventDefault(),As(t,r,l,o,Ts);else if("Home"===n)e.preventDefault(),As(t,null,l,o,Ns);else if("End"===n)e.preventDefault(),As(t,null,l,o,Ts);else if(1===n.length){const a=p.current,s=n.toLowerCase(),i=performance.now();a.keys.length>0&&(i-a.lastTime>500?(a.keys=[],a.repeating=!0,a.previousKeyMatched=!0):a.repeating&&s!==a.keys[0]&&(a.repeating=!1)),a.lastTime=i,a.keys.push(s);const l=r&&!a.repeating&&Es(r,a);a.previousKeyMatched&&(l||As(t,r,!1,o,Ns,a))?e.preventDefault():a.previousKeyMatched=!1}u&&u(e)},tabIndex:r?0:-1,...d,children:g})})),$s=_s;var Rs=n(950),Ds=n(6078);const Ms={};function Fs(e,t){const n=T.useRef(Ms);return n.current===Ms&&(n.current=e(t)),n}const Os=[];class Ps{static create(){return new Ps}currentId=null;start(e,t){this.clear(),this.currentId=setTimeout((()=>{this.currentId=null,t()}),e)}clear=()=>{null!==this.currentId&&(clearTimeout(this.currentId),this.currentId=null)};disposeEffect=()=>this.clear}function Ls(){const e=Fs(Ps.create).current;return function(e){T.useEffect(e,Os)}(e.disposeEffect),e}function zs(e,t){if(null==e)return{};var n={};for(var r in e)if({}.hasOwnProperty.call(e,r)){if(t.includes(r))continue;n[r]=e[r]}return n}function Bs(e,t){return Bs=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},Bs(e,t)}function Ws(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Bs(e,t)}const Vs=!1,Us=T.createContext(null);var js=function(e){return e.scrollTop},Gs="unmounted",Hs="exited",qs="entering",Ks="entered",Xs="exiting",Ys=function(e){function t(t,n){var r;r=e.call(this,t,n)||this;var a,s=n&&!n.isMounting?t.enter:t.appear;return r.appearStatus=null,t.in?s?(a=Hs,r.appearStatus=qs):a=Ks:a=t.unmountOnExit||t.mountOnEnter?Gs:Hs,r.state={status:a},r.nextCallback=null,r}Ws(t,e),t.getDerivedStateFromProps=function(e,t){return e.in&&t.status===Gs?{status:Hs}:null};var n=t.prototype;return n.componentDidMount=function(){this.updateStatus(!0,this.appearStatus)},n.componentDidUpdate=function(e){var t=null;if(e!==this.props){var n=this.state.status;this.props.in?n!==qs&&n!==Ks&&(t=qs):n!==qs&&n!==Ks||(t=Xs)}this.updateStatus(!1,t)},n.componentWillUnmount=function(){this.cancelNextCallback()},n.getTimeouts=function(){var e,t,n,r=this.props.timeout;return e=t=n=r,null!=r&&"number"!==typeof r&&(e=r.exit,t=r.enter,n=void 0!==r.appear?r.appear:t),{exit:e,enter:t,appear:n}},n.updateStatus=function(e,t){if(void 0===e&&(e=!1),null!==t)if(this.cancelNextCallback(),t===qs){if(this.props.unmountOnExit||this.props.mountOnEnter){var n=this.props.nodeRef?this.props.nodeRef.current:A.findDOMNode(this);n&&js(n)}this.performEnter(e)}else this.performExit();else this.props.unmountOnExit&&this.state.status===Hs&&this.setState({status:Gs})},n.performEnter=function(e){var t=this,n=this.props.enter,r=this.context?this.context.isMounting:e,a=this.props.nodeRef?[r]:[A.findDOMNode(this),r],s=a[0],i=a[1],o=this.getTimeouts(),l=r?o.appear:o.enter;!e&&!n||Vs?this.safeSetState({status:Ks},(function(){t.props.onEntered(s)})):(this.props.onEnter(s,i),this.safeSetState({status:qs},(function(){t.props.onEntering(s,i),t.onTransitionEnd(l,(function(){t.safeSetState({status:Ks},(function(){t.props.onEntered(s,i)}))}))})))},n.performExit=function(){var e=this,t=this.props.exit,n=this.getTimeouts(),r=this.props.nodeRef?void 0:A.findDOMNode(this);t&&!Vs?(this.props.onExit(r),this.safeSetState({status:Xs},(function(){e.props.onExiting(r),e.onTransitionEnd(n.exit,(function(){e.safeSetState({status:Hs},(function(){e.props.onExited(r)}))}))}))):this.safeSetState({status:Hs},(function(){e.props.onExited(r)}))},n.cancelNextCallback=function(){null!==this.nextCallback&&(this.nextCallback.cancel(),this.nextCallback=null)},n.safeSetState=function(e,t){t=this.setNextCallback(t),this.setState(e,t)},n.setNextCallback=function(e){var t=this,n=!0;return this.nextCallback=function(r){n&&(n=!1,t.nextCallback=null,e(r))},this.nextCallback.cancel=function(){n=!1},this.nextCallback},n.onTransitionEnd=function(e,t){this.setNextCallback(t);var n=this.props.nodeRef?this.props.nodeRef.current:A.findDOMNode(this),r=null==e&&!this.props.addEndListener;if(n&&!r){if(this.props.addEndListener){var a=this.props.nodeRef?[this.nextCallback]:[n,this.nextCallback],s=a[0],i=a[1];this.props.addEndListener(s,i)}null!=e&&setTimeout(this.nextCallback,e)}else setTimeout(this.nextCallback,0)},n.render=function(){var e=this.state.status;if(e===Gs)return null;var t=this.props,n=t.children,r=(t.in,t.mountOnEnter,t.unmountOnExit,t.appear,t.enter,t.exit,t.timeout,t.addEndListener,t.onEnter,t.onEntering,t.onEntered,t.onExit,t.onExiting,t.onExited,t.nodeRef,zs(t,["children","in","mountOnEnter","unmountOnExit","appear","enter","exit","timeout","addEndListener","onEnter","onEntering","onEntered","onExit","onExiting","onExited","nodeRef"]));return T.createElement(Us.Provider,{value:null},"function"===typeof n?n(e,r):T.cloneElement(T.Children.only(n),r))},t}(T.Component);function Qs(){}Ys.contextType=Us,Ys.propTypes={},Ys.defaultProps={in:!1,mountOnEnter:!1,unmountOnExit:!1,appear:!1,enter:!0,exit:!0,onEnter:Qs,onEntering:Qs,onEntered:Qs,onExit:Qs,onExiting:Qs,onExited:Qs},Ys.UNMOUNTED=Gs,Ys.EXITED=Hs,Ys.ENTERING=qs,Ys.ENTERED=Ks,Ys.EXITING=Xs;const Js=Ys,Zs=e=>e.scrollTop;function ei(e,t){const{timeout:n,easing:r,style:a={}}=e;return{duration:a.transitionDuration??("number"===typeof n?n:n[t.mode]||0),easing:a.transitionTimingFunction??("object"===typeof r?r[t.mode]:r),delay:a.transitionDelay}}function ti(e){return`scale(${e}, ${e**2})`}const ni={entering:{opacity:1,transform:ti(1)},entered:{opacity:1,transform:"none"}},ri="undefined"!==typeof navigator&&/^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent)&&/(os |version\/)15(.|_)4/i.test(navigator.userAgent),ai=T.forwardRef((function(e,t){const{addEndListener:n,appear:r=!0,children:a,easing:s,in:i,onEnter:o,onEntered:l,onEntering:u,onExit:c,onExited:d,onExiting:h,style:p,timeout:f="auto",TransitionComponent:m=Js,...g}=e,y=Ls(),b=T.useRef(),v=Zn(),x=T.useRef(null),w=(0,ia.A)(x,ls(a),t),k=e=>t=>{if(e){const n=x.current;void 0===t?e(n):e(n,t)}},S=k(u),I=k(((e,t)=>{Zs(e);const{duration:n,delay:r,easing:a}=ei({style:p,timeout:f,easing:s},{mode:"enter"});let i;"auto"===f?(i=v.transitions.getAutoHeightDuration(e.clientHeight),b.current=i):i=n,e.style.transition=[v.transitions.create("opacity",{duration:i,delay:r}),v.transitions.create("transform",{duration:ri?i:.666*i,delay:r,easing:a})].join(","),o&&o(e,t)})),C=k(l),N=k(h),E=k((e=>{const{duration:t,delay:n,easing:r}=ei({style:p,timeout:f,easing:s},{mode:"exit"});let a;"auto"===f?(a=v.transitions.getAutoHeightDuration(e.clientHeight),b.current=a):a=t,e.style.transition=[v.transitions.create("opacity",{duration:a,delay:n}),v.transitions.create("transform",{duration:ri?a:.666*a,delay:ri?n:n||.333*a,easing:r})].join(","),e.style.opacity=0,e.style.transform=ti(.75),c&&c(e)})),A=k(d);return(0,hr.jsx)(m,{appear:r,in:i,nodeRef:x,onEnter:I,onEntered:C,onEntering:S,onExit:E,onExited:A,onExiting:N,addEndListener:e=>{"auto"===f&&y.start(b.current||0,e),n&&n(x.current,e)},timeout:"auto"===f?null:f,...g,children:(e,t)=>T.cloneElement(a,{style:{opacity:0,transform:ti(.75),visibility:"exited"!==e||i?void 0:"hidden",...ni[e],...p,...a.props.style},ref:w,...t})})}));ai&&(ai.muiSupportAuto=!0);const si=ai;var ii=n(1668);const oi=["input","select","textarea","a[href]","button","[tabindex]","audio[controls]","video[controls]",'[contenteditable]:not([contenteditable="false"])'].join(",");function li(e){const t=[],n=[];return Array.from(e.querySelectorAll(oi)).forEach(((e,r)=>{const a=function(e){const t=parseInt(e.getAttribute("tabindex")||"",10);return Number.isNaN(t)?"true"===e.contentEditable||("AUDIO"===e.nodeName||"VIDEO"===e.nodeName||"DETAILS"===e.nodeName)&&null===e.getAttribute("tabindex")?0:e.tabIndex:t}(e);-1!==a&&function(e){return!(e.disabled||"INPUT"===e.tagName&&"hidden"===e.type||function(e){if("INPUT"!==e.tagName||"radio"!==e.type)return!1;if(!e.name)return!1;const t=t=>e.ownerDocument.querySelector(`input[type="radio"]${t}`);let n=t(`[name="${e.name}"]:checked`);return n||(n=t(`[name="${e.name}"]`)),n!==e}(e))}(e)&&(0===a?t.push(e):n.push({documentOrder:r,tabIndex:a,node:e}))})),n.sort(((e,t)=>e.tabIndex===t.tabIndex?e.documentOrder-t.documentOrder:e.tabIndex-t.tabIndex)).map((e=>e.node)).concat(t)}function ui(){return!0}const ci=function(e){const{children:t,disableAutoFocus:n=!1,disableEnforceFocus:r=!1,disableRestoreFocus:a=!1,getTabbable:s=li,isEnabled:i=ui,open:o}=e,l=T.useRef(!1),u=T.useRef(null),c=T.useRef(null),d=T.useRef(null),h=T.useRef(null),p=T.useRef(!1),f=T.useRef(null),m=(0,Kr.A)(ls(t),f),g=T.useRef(null);T.useEffect((()=>{o&&f.current&&(p.current=!n)}),[n,o]),T.useEffect((()=>{if(!o||!f.current)return;const e=(0,ii.A)(f.current);return f.current.contains(e.activeElement)||(f.current.hasAttribute("tabIndex")||f.current.setAttribute("tabIndex","-1"),p.current&&f.current.focus()),()=>{a||(d.current&&d.current.focus&&(l.current=!0,d.current.focus()),d.current=null)}}),[o]),T.useEffect((()=>{if(!o||!f.current)return;const e=(0,ii.A)(f.current),t=t=>{g.current=t,!r&&i()&&"Tab"===t.key&&e.activeElement===f.current&&t.shiftKey&&(l.current=!0,c.current&&c.current.focus())},n=()=>{const t=f.current;if(null===t)return;if(!e.hasFocus()||!i()||l.current)return void(l.current=!1);if(t.contains(e.activeElement))return;if(r&&e.activeElement!==u.current&&e.activeElement!==c.current)return;if(e.activeElement!==h.current)h.current=null;else if(null!==h.current)return;if(!p.current)return;let n=[];if(e.activeElement!==u.current&&e.activeElement!==c.current||(n=s(f.current)),n.length>0){const e=Boolean(g.current?.shiftKey&&"Tab"===g.current?.key),t=n[0],r=n[n.length-1];"string"!==typeof t&&"string"!==typeof r&&(e?r.focus():t.focus())}else t.focus()};e.addEventListener("focusin",n),e.addEventListener("keydown",t,!0);const a=setInterval((()=>{e.activeElement&&"BODY"===e.activeElement.tagName&&n()}),50);return()=>{clearInterval(a),e.removeEventListener("focusin",n),e.removeEventListener("keydown",t,!0)}}),[n,r,a,i,o,s]);const y=e=>{null===d.current&&(d.current=e.relatedTarget),p.current=!0};return(0,hr.jsxs)(T.Fragment,{children:[(0,hr.jsx)("div",{tabIndex:o?0:-1,onFocus:y,ref:u,"data-testid":"sentinelStart"}),T.cloneElement(t,{ref:m,onFocus:e=>{null===d.current&&(d.current=e.relatedTarget),p.current=!0,h.current=e.target;const n=t.props.onFocus;n&&n(e)}}),(0,hr.jsx)("div",{tabIndex:o?0:-1,onFocus:y,ref:c,"data-testid":"sentinelEnd"})]})};var di=n(6564);const hi=T.forwardRef((function(e,t){const{children:n,container:r,disablePortal:a=!1}=e,[s,i]=T.useState(null),o=(0,Kr.A)(ls(n),t);if((0,Yr.A)((()=>{a||i(function(e){return"function"===typeof e?e():e}(r)||document.body)}),[r,a]),(0,Yr.A)((()=>{if(s&&!a)return(0,di.A)(t,s),()=>{(0,di.A)(t,null)}}),[t,s,a]),a){if(T.isValidElement(n)){const e={ref:o};return T.cloneElement(n,e)}return(0,hr.jsx)(T.Fragment,{children:n})}return(0,hr.jsx)(T.Fragment,{children:s?A.createPortal(n,s):s})}));function pi(e,t){const{className:n,elementType:r,ownerState:a,externalForwardedProps:s,getSlotOwnerState:i,internalForwardedProps:o,...l}=t,{component:u,slots:c={[e]:void 0},slotProps:d={[e]:void 0},...h}=s,p=c[e]||r,f=ys(d[e],a),{props:{component:m,...g},internalRef:y}=gs({className:n,...l,externalForwardedProps:"root"===e?h:void 0,externalSlotProps:f}),b=(0,Kr.A)(y,f?.ref,t.ref),v=i?i(g):{},x={...a,...v},w="root"===e?m||u:m,k=ps(p,{..."root"===e&&!u&&!c[e]&&o,..."root"!==e&&!c[e]&&o,...g,...w&&{as:w},ref:b},x);return Object.keys(v).forEach((e=>{delete k[e]})),[p,k]}const fi={entering:{opacity:1},entered:{opacity:1}},mi=T.forwardRef((function(e,t){const n=Zn(),r={enter:n.transitions.duration.enteringScreen,exit:n.transitions.duration.leavingScreen},{addEndListener:a,appear:s=!0,children:i,easing:o,in:l,onEnter:u,onEntered:c,onEntering:d,onExit:h,onExited:p,onExiting:f,style:m,timeout:g=r,TransitionComponent:y=Js,...b}=e,v=T.useRef(null),x=(0,ia.A)(v,ls(i),t),w=e=>t=>{if(e){const n=v.current;void 0===t?e(n):e(n,t)}},k=w(d),S=w(((e,t)=>{Zs(e);const r=ei({style:m,timeout:g,easing:o},{mode:"enter"});e.style.webkitTransition=n.transitions.create("opacity",r),e.style.transition=n.transitions.create("opacity",r),u&&u(e,t)})),I=w(c),C=w(f),N=w((e=>{const t=ei({style:m,timeout:g,easing:o},{mode:"exit"});e.style.webkitTransition=n.transitions.create("opacity",t),e.style.transition=n.transitions.create("opacity",t),h&&h(e)})),E=w(p);return(0,hr.jsx)(y,{appear:s,in:l,nodeRef:v,onEnter:S,onEntered:I,onEntering:k,onExit:N,onExited:E,onExiting:C,addEndListener:e=>{a&&a(v.current,e)},timeout:g,...b,children:(e,t)=>T.cloneElement(i,{style:{opacity:0,visibility:"exited"!==e||l?void 0:"hidden",...fi[e],...m,...i.props.style},ref:x,...t})})})),gi=mi;function yi(e){return(0,yr.Ay)("MuiBackdrop",e)}(0,gr.A)("MuiBackdrop",["root","invisible"]);const bi=(0,Gn.Ay)("div",{name:"MuiBackdrop",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.invisible&&t.invisible]}})({position:"fixed",display:"flex",alignItems:"center",justifyContent:"center",right:0,bottom:0,top:0,left:0,backgroundColor:"rgba(0, 0, 0, 0.5)",WebkitTapHighlightColor:"transparent",variants:[{props:{invisible:!0},style:{backgroundColor:"transparent"}}]}),vi=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiBackdrop"}),{children:r,className:a,component:s="div",invisible:i=!1,open:o,components:l={},componentsProps:u={},slotProps:c={},slots:d={},TransitionComponent:h,transitionDuration:p,...f}=n,m={...n,component:s,invisible:i},g=(e=>{const{classes:t,invisible:n}=e,r={root:["root",n&&"invisible"]};return(0,Vn.A)(r,yi,t)})(m),y={slots:{transition:h,root:l.Root,...d},slotProps:{...u,...c}},[b,v]=pi("root",{elementType:bi,externalForwardedProps:y,className:(0,Bn.A)(g.root,a),ownerState:m}),[x,w]=pi("transition",{elementType:gi,externalForwardedProps:y,ownerState:m});return delete w.ownerState,(0,hr.jsx)(x,{in:o,timeout:p,...f,...w,children:(0,hr.jsx)(b,{"aria-hidden":!0,...v,classes:g,ref:t,children:r})})}));var xi=n(1782),wi=n(2456);function ki(e,t){t?e.setAttribute("aria-hidden","true"):e.removeAttribute("aria-hidden")}function Si(e){return parseInt((0,Xr.A)(e).getComputedStyle(e).paddingRight,10)||0}function Ii(e,t,n,r,a){const s=[t,n,...r];[].forEach.call(e.children,(e=>{const t=-1===s.indexOf(e),n=!function(e){const t=-1!==["TEMPLATE","SCRIPT","STYLE","LINK","MAP","META","NOSCRIPT","PICTURE","COL","COLGROUP","PARAM","SLOT","SOURCE","TRACK"].indexOf(e.tagName),n="INPUT"===e.tagName&&"hidden"===e.getAttribute("type");return t||n}(e);t&&n&&ki(e,a)}))}function Ci(e,t){let n=-1;return e.some(((e,r)=>!!t(e)&&(n=r,!0))),n}function Ni(e,t){const n=[],r=e.container;if(!t.disableScrollLock){if(function(e){const t=(0,ii.A)(e);return t.body===e?(0,Xr.A)(e).innerWidth>t.documentElement.clientWidth:e.scrollHeight>e.clientHeight}(r)){const e=Is((0,ii.A)(r));n.push({value:r.style.paddingRight,property:"padding-right",el:r}),r.style.paddingRight=`${Si(r)+e}px`;const t=(0,ii.A)(r).querySelectorAll(".mui-fixed");[].forEach.call(t,(t=>{n.push({value:t.style.paddingRight,property:"padding-right",el:t}),t.style.paddingRight=`${Si(t)+e}px`}))}let e;if(r.parentNode instanceof DocumentFragment)e=(0,ii.A)(r).body;else{const t=r.parentElement,n=(0,Xr.A)(r);e="HTML"===t?.nodeName&&"scroll"===n.getComputedStyle(t).overflowY?t:r}n.push({value:e.style.overflow,property:"overflow",el:e},{value:e.style.overflowX,property:"overflow-x",el:e},{value:e.style.overflowY,property:"overflow-y",el:e}),e.style.overflow="hidden"}return()=>{n.forEach((e=>{let{value:t,el:n,property:r}=e;t?n.style.setProperty(r,t):n.style.removeProperty(r)}))}}const Ti=new class{constructor(){this.modals=[],this.containers=[]}add(e,t){let n=this.modals.indexOf(e);if(-1!==n)return n;n=this.modals.length,this.modals.push(e),e.modalRef&&ki(e.modalRef,!1);const r=function(e){const t=[];return[].forEach.call(e.children,(e=>{"true"===e.getAttribute("aria-hidden")&&t.push(e)})),t}(t);Ii(t,e.mount,e.modalRef,r,!0);const a=Ci(this.containers,(e=>e.container===t));return-1!==a?(this.containers[a].modals.push(e),n):(this.containers.push({modals:[e],container:t,restore:null,hiddenSiblings:r}),n)}mount(e,t){const n=Ci(this.containers,(t=>-1!==t.modals.indexOf(e))),r=this.containers[n];r.restore||(r.restore=Ni(r,t))}remove(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this.modals.indexOf(e);if(-1===n)return n;const r=Ci(this.containers,(t=>-1!==t.modals.indexOf(e))),a=this.containers[r];if(a.modals.splice(a.modals.indexOf(e),1),this.modals.splice(n,1),0===a.modals.length)a.restore&&a.restore(),e.modalRef&&ki(e.modalRef,t),Ii(a.container,e.mount,e.modalRef,a.hiddenSiblings,!1),this.containers.splice(r,1);else{const e=a.modals[a.modals.length-1];e.modalRef&&ki(e.modalRef,!1)}return n}isTopModal(e){return this.modals.length>0&&this.modals[this.modals.length-1]===e}};const Ei=function(e){const{container:t,disableEscapeKeyDown:n=!1,disableScrollLock:r=!1,manager:a=Ti,closeAfterTransition:s=!1,onTransitionEnter:i,onTransitionExited:o,children:l,onClose:u,open:c,rootRef:d}=e,h=T.useRef({}),p=T.useRef(null),f=T.useRef(null),m=(0,Kr.A)(f,d),[g,y]=T.useState(!c),b=function(e){return!!e&&e.props.hasOwnProperty("in")}(l);let v=!0;"false"!==e["aria-hidden"]&&!1!==e["aria-hidden"]||(v=!1);const x=()=>(h.current.modalRef=f.current,h.current.mount=p.current,h.current),w=()=>{a.mount(x(),{disableScrollLock:r}),f.current&&(f.current.scrollTop=0)},k=(0,xi.A)((()=>{const e=function(e){return"function"===typeof e?e():e}(t)||(0,ii.A)(p.current).body;a.add(x(),e),f.current&&w()})),S=T.useCallback((()=>a.isTopModal(x())),[a]),I=(0,xi.A)((e=>{p.current=e,e&&(c&&S()?w():f.current&&ki(f.current,v))})),C=T.useCallback((()=>{a.remove(x(),v)}),[v,a]);T.useEffect((()=>()=>{C()}),[C]),T.useEffect((()=>{c?k():b&&s||C()}),[c,C,b,s,k]);const N=e=>t=>{e.onKeyDown?.(t),"Escape"===t.key&&229!==t.which&&S()&&(n||(t.stopPropagation(),u&&u(t,"escapeKeyDown")))},E=e=>t=>{e.onClick?.(t),t.target===t.currentTarget&&u&&u(t,"backdropClick")};return{getRootProps:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=fs(e);delete n.onTransitionEnter,delete n.onTransitionExited;const r={...n,...t};return{role:"presentation",...r,onKeyDown:N(r),ref:m}},getBackdropProps:function(){const e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{"aria-hidden":!0,...e,onClick:E(e),open:c}},getTransitionProps:()=>({onEnter:(0,wi.A)((()=>{y(!1),i&&i()}),l?.props.onEnter),onExited:(0,wi.A)((()=>{y(!0),o&&o(),s&&C()}),l?.props.onExited)}),rootRef:m,portalRef:I,isTopModal:S,exited:g,hasTransition:b}};function Ai(e){return(0,yr.Ay)("MuiModal",e)}(0,gr.A)("MuiModal",["root","hidden","backdrop"]);const _i=(0,Gn.Ay)("div",{name:"MuiModal",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,!n.open&&n.exited&&t.hidden]}})((0,er.A)((e=>{let{theme:t}=e;return{position:"fixed",zIndex:(t.vars||t).zIndex.modal,right:0,bottom:0,top:0,left:0,variants:[{props:e=>{let{ownerState:t}=e;return!t.open&&t.exited},style:{visibility:"hidden"}}]}}))),$i=(0,Gn.Ay)(vi,{name:"MuiModal",slot:"Backdrop",overridesResolver:(e,t)=>t.backdrop})({zIndex:-1}),Ri=T.forwardRef((function(e,t){const n=(0,tr.b)({name:"MuiModal",props:e}),{BackdropComponent:r=$i,BackdropProps:a,classes:s,className:i,closeAfterTransition:o=!1,children:l,container:u,component:c,components:d={},componentsProps:h={},disableAutoFocus:p=!1,disableEnforceFocus:f=!1,disableEscapeKeyDown:m=!1,disablePortal:g=!1,disableRestoreFocus:y=!1,disableScrollLock:b=!1,hideBackdrop:v=!1,keepMounted:x=!1,onBackdropClick:w,onClose:k,onTransitionEnter:S,onTransitionExited:I,open:C,slotProps:N={},slots:E={},theme:A,..._}=n,$={...n,closeAfterTransition:o,disableAutoFocus:p,disableEnforceFocus:f,disableEscapeKeyDown:m,disablePortal:g,disableRestoreFocus:y,disableScrollLock:b,hideBackdrop:v,keepMounted:x},{getRootProps:R,getBackdropProps:D,getTransitionProps:M,portalRef:F,isTopModal:O,exited:P,hasTransition:L}=Ei({...$,rootRef:t}),z={...$,exited:P},B=(e=>{const{open:t,exited:n,classes:r}=e,a={root:["root",!t&&n&&"hidden"],backdrop:["backdrop"]};return(0,Vn.A)(a,Ai,r)})(z),W={};if(void 0===l.props.tabIndex&&(W.tabIndex="-1"),L){const{onEnter:e,onExited:t}=M();W.onEnter=e,W.onExited=t}const V={slots:{root:d.Root,backdrop:d.Backdrop,...E},slotProps:{...h,...N}},[U,j]=pi("root",{elementType:_i,externalForwardedProps:V,getSlotProps:R,additionalProps:{ref:t,as:c},ownerState:z,className:(0,Bn.A)(i,B?.root,!z.open&&z.exited&&B?.hidden)}),[G,H]=pi("backdrop",{elementType:r,externalForwardedProps:V,additionalProps:a,getSlotProps:e=>D({...e,onClick:t=>{w&&w(t),e?.onClick&&e.onClick(t)}}),className:(0,Bn.A)(a?.className,B?.backdrop),ownerState:z}),q=(0,ia.A)(a?.ref,H.ref);return x||C||L&&!P?(0,hr.jsx)(hi,{ref:F,container:u,disablePortal:g,children:(0,hr.jsxs)(U,{...j,..._,children:[!v&&r?(0,hr.jsx)(G,{...H,ref:q}):null,(0,hr.jsx)(ci,{disableEnforceFocus:f,disableAutoFocus:p,disableRestoreFocus:y,isEnabled:O,open:C,children:T.cloneElement(l,W)})]})}):null})),Di=Ri;function Mi(e){return(0,yr.Ay)("MuiPopover",e)}(0,gr.A)("MuiPopover",["root","paper"]);function Fi(e,t){let n=0;return"number"===typeof t?n=t:"center"===t?n=e.height/2:"bottom"===t&&(n=e.height),n}function Oi(e,t){let n=0;return"number"===typeof t?n=t:"center"===t?n=e.width/2:"right"===t&&(n=e.width),n}function Pi(e){return[e.horizontal,e.vertical].map((e=>"number"===typeof e?`${e}px`:e)).join(" ")}function Li(e){return"function"===typeof e?e():e}const zi=(0,Gn.Ay)(Di,{name:"MuiPopover",slot:"Root",overridesResolver:(e,t)=>t.root})({}),Bi=(0,Gn.Ay)(Gr,{name:"MuiPopover",slot:"Paper",overridesResolver:(e,t)=>t.paper})({position:"absolute",overflowY:"auto",overflowX:"hidden",minWidth:16,minHeight:16,maxWidth:"calc(100% - 32px)",maxHeight:"calc(100% - 32px)",outline:0}),Wi=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiPopover"}),{action:r,anchorEl:a,anchorOrigin:s={vertical:"top",horizontal:"left"},anchorPosition:i,anchorReference:o="anchorEl",children:l,className:u,container:c,elevation:d=8,marginThreshold:h=16,open:p,PaperProps:f={},slots:m={},slotProps:g={},transformOrigin:y={vertical:"top",horizontal:"left"},TransitionComponent:b=si,transitionDuration:v="auto",TransitionProps:{onEntering:x,...w}={},disableScrollLock:k=!1,...S}=n,I=g?.paper??f,C=T.useRef(),N={...n,anchorOrigin:s,anchorReference:o,elevation:d,marginThreshold:h,externalPaperSlotProps:I,transformOrigin:y,TransitionComponent:b,transitionDuration:v,TransitionProps:w},E=(e=>{const{classes:t}=e;return(0,Vn.A)({root:["root"],paper:["paper"]},Mi,t)})(N),A=T.useCallback((()=>{if("anchorPosition"===o)return i;const e=Li(a),t=(e&&1===e.nodeType?e:(0,us.A)(C.current).body).getBoundingClientRect();return{top:t.top+Fi(t,s.vertical),left:t.left+Oi(t,s.horizontal)}}),[a,s.horizontal,s.vertical,i,o]),_=T.useCallback((e=>({vertical:Fi(e,y.vertical),horizontal:Oi(e,y.horizontal)})),[y.horizontal,y.vertical]),$=T.useCallback((e=>{const t={width:e.offsetWidth,height:e.offsetHeight},n=_(t);if("none"===o)return{top:null,left:null,transformOrigin:Pi(n)};const r=A();let s=r.top-n.vertical,i=r.left-n.horizontal;const l=s+t.height,u=i+t.width,c=(0,Ds.A)(Li(a)),d=c.innerHeight-h,p=c.innerWidth-h;if(null!==h&&s<h){const e=s-h;s-=e,n.vertical+=e}else if(null!==h&&l>d){const e=l-d;s-=e,n.vertical+=e}if(null!==h&&i<h){const e=i-h;i-=e,n.horizontal+=e}else if(u>p){const e=u-p;i-=e,n.horizontal+=e}return{top:`${Math.round(s)}px`,left:`${Math.round(i)}px`,transformOrigin:Pi(n)}}),[a,o,A,_,h]),[R,D]=T.useState(p),M=T.useCallback((()=>{const e=C.current;if(!e)return;const t=$(e);null!==t.top&&(e.style.top=t.top),null!==t.left&&(e.style.left=t.left),e.style.transformOrigin=t.transformOrigin,D(!0)}),[$]);T.useEffect((()=>(k&&window.addEventListener("scroll",M),()=>window.removeEventListener("scroll",M))),[a,k,M]);T.useEffect((()=>{p&&M()})),T.useImperativeHandle(r,(()=>p?{updatePosition:()=>{M()}}:null),[p,M]),T.useEffect((()=>{if(!p)return;const e=(0,Rs.A)((()=>{M()})),t=(0,Ds.A)(a);return t.addEventListener("resize",e),()=>{e.clear(),t.removeEventListener("resize",e)}}),[a,p,M]);let F=v;"auto"!==v||b.muiSupportAuto||(F=void 0);const O=c||(a?(0,us.A)(Li(a)).body:void 0),P={slots:m,slotProps:{...g,paper:I}},[L,z]=pi("paper",{elementType:Bi,externalForwardedProps:P,additionalProps:{elevation:d,className:(0,Bn.A)(E.paper,I?.className),style:R?I.style:{...I.style,opacity:0}},ownerState:N}),[B,{slotProps:W,...V}]=pi("root",{elementType:zi,externalForwardedProps:P,additionalProps:{slotProps:{backdrop:{invisible:!0}},container:O,open:p},ownerState:N,className:(0,Bn.A)(E.root,u)}),U=(0,ia.A)(C,z.ref);return(0,hr.jsx)(B,{...V,...!na(B)&&{slotProps:W,disableScrollLock:k},...S,ref:t,children:(0,hr.jsx)(b,{appear:!0,in:p,onEntering:(e,t)=>{x&&x(e,t),M()},onExited:()=>{D(!1)},timeout:F,...w,children:(0,hr.jsx)(L,{...z,ref:U,children:l})})})})),Vi=Wi;function Ui(e){return(0,yr.Ay)("MuiMenu",e)}(0,gr.A)("MuiMenu",["root","paper","list"]);const ji={vertical:"top",horizontal:"right"},Gi={vertical:"top",horizontal:"left"},Hi=(0,Gn.Ay)(Vi,{shouldForwardProp:e=>(0,xa.A)(e)||"classes"===e,name:"MuiMenu",slot:"Root",overridesResolver:(e,t)=>t.root})({}),qi=(0,Gn.Ay)(Bi,{name:"MuiMenu",slot:"Paper",overridesResolver:(e,t)=>t.paper})({maxHeight:"calc(100% - 96px)",WebkitOverflowScrolling:"touch"}),Ki=(0,Gn.Ay)($s,{name:"MuiMenu",slot:"List",overridesResolver:(e,t)=>t.list})({outline:0}),Xi=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiMenu"}),{autoFocus:r=!0,children:a,className:s,disableAutoFocusItem:i=!1,MenuListProps:o={},onClose:l,open:u,PaperProps:c={},PopoverClasses:d,transitionDuration:h="auto",TransitionProps:{onEntering:p,...f}={},variant:m="selectedMenu",slots:g={},slotProps:y={},...b}=n,v=ds(),x={...n,autoFocus:r,disableAutoFocusItem:i,MenuListProps:o,onEntering:p,PaperProps:c,transitionDuration:h,TransitionProps:f,variant:m},w=(e=>{const{classes:t}=e;return(0,Vn.A)({root:["root"],paper:["paper"],list:["list"]},Ui,t)})(x),k=r&&!i&&u,S=T.useRef(null);let I=-1;T.Children.map(a,((e,t)=>{T.isValidElement(e)&&(e.props.disabled||("selectedMenu"===m&&e.props.selected||-1===I)&&(I=t))}));const C=g.paper??qi,N=y.paper??c,E=bs({elementType:g.root,externalSlotProps:y.root,ownerState:x,className:[w.root,s]}),A=bs({elementType:C,externalSlotProps:N,ownerState:x,className:w.paper});return(0,hr.jsx)(Hi,{onClose:l,anchorOrigin:{vertical:"bottom",horizontal:v?"right":"left"},transformOrigin:v?ji:Gi,slots:{paper:C,root:g.root},slotProps:{root:E,paper:A},open:u,ref:t,transitionDuration:h,TransitionProps:{onEntering:(e,t)=>{S.current&&S.current.adjustStyleForScrollbar(e,{direction:v?"rtl":"ltr"}),p&&p(e,t)},...f},ownerState:x,...b,classes:d,children:(0,hr.jsx)(Ki,{onKeyDown:e=>{"Tab"===e.key&&(e.preventDefault(),l&&l(e,"tabKeyDown"))},actions:S,autoFocus:r&&(-1===I||i),autoFocusItem:k,variant:m,...o,className:(0,Bn.A)(w.list,o.className),children:a})})})),Yi=Xi;function Qi(e){return(0,yr.Ay)("MuiNativeSelect",e)}const Ji=(0,gr.A)("MuiNativeSelect",["root","select","multiple","filled","outlined","standard","disabled","icon","iconOpen","iconFilled","iconOutlined","iconStandard","nativeInput","error"]),Zi=(0,Gn.Ay)("select")((e=>{let{theme:t}=e;return{MozAppearance:"none",WebkitAppearance:"none",userSelect:"none",borderRadius:0,cursor:"pointer","&:focus":{borderRadius:0},[`&.${Ji.disabled}`]:{cursor:"default"},"&[multiple]":{height:"auto"},"&:not([multiple]) option, &:not([multiple]) optgroup":{backgroundColor:(t.vars||t).palette.background.paper},variants:[{props:e=>{let{ownerState:t}=e;return"filled"!==t.variant&&"outlined"!==t.variant},style:{"&&&":{paddingRight:24,minWidth:16}}},{props:{variant:"filled"},style:{"&&&":{paddingRight:32}}},{props:{variant:"outlined"},style:{borderRadius:(t.vars||t).shape.borderRadius,"&:focus":{borderRadius:(t.vars||t).shape.borderRadius},"&&&":{paddingRight:32}}}]}})),eo=(0,Gn.Ay)(Zi,{name:"MuiNativeSelect",slot:"Select",shouldForwardProp:xa.A,overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.select,t[n.variant],n.error&&t.error,{[`&.${Ji.multiple}`]:t.multiple}]}})({}),to=(0,Gn.Ay)("svg")((e=>{let{theme:t}=e;return{position:"absolute",right:0,top:"calc(50% - .5em)",pointerEvents:"none",color:(t.vars||t).palette.action.active,[`&.${Ji.disabled}`]:{color:(t.vars||t).palette.action.disabled},variants:[{props:e=>{let{ownerState:t}=e;return t.open},style:{transform:"rotate(180deg)"}},{props:{variant:"filled"},style:{right:7}},{props:{variant:"outlined"},style:{right:7}}]}})),no=(0,Gn.Ay)(to,{name:"MuiNativeSelect",slot:"Icon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.icon,n.variant&&t[`icon${(0,jn.A)(n.variant)}`],n.open&&t.iconOpen]}})({}),ro=T.forwardRef((function(e,t){const{className:n,disabled:r,error:a,IconComponent:s,inputRef:i,variant:o="standard",...l}=e,u={...e,disabled:r,variant:o,error:a},c=(e=>{const{classes:t,variant:n,disabled:r,multiple:a,open:s,error:i}=e,o={select:["select",n,r&&"disabled",a&&"multiple",i&&"error"],icon:["icon",`icon${(0,jn.A)(n)}`,s&&"iconOpen",r&&"disabled"]};return(0,Vn.A)(o,Qi,t)})(u);return(0,hr.jsxs)(T.Fragment,{children:[(0,hr.jsx)(eo,{ownerState:u,className:(0,Bn.A)(c.select,n),disabled:r,ref:i||t,...l}),e.multiple?null:(0,hr.jsx)(no,{as:s,ownerState:u,className:c.icon})]})})),ao=ro;var so=n(7123),io=n(5420);function oo(e){return(0,yr.Ay)("MuiSelect",e)}const lo=(0,gr.A)("MuiSelect",["root","select","multiple","filled","outlined","standard","disabled","focused","icon","iconOpen","iconFilled","iconOutlined","iconStandard","nativeInput","error"]);var uo;const co=(0,Gn.Ay)(Zi,{name:"MuiSelect",slot:"Select",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[{[`&.${lo.select}`]:t.select},{[`&.${lo.select}`]:t[n.variant]},{[`&.${lo.error}`]:t.error},{[`&.${lo.multiple}`]:t.multiple}]}})({[`&.${lo.select}`]:{height:"auto",minHeight:"1.4375em",textOverflow:"ellipsis",whiteSpace:"nowrap",overflow:"hidden"}}),ho=(0,Gn.Ay)(to,{name:"MuiSelect",slot:"Icon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.icon,n.variant&&t[`icon${(0,jn.A)(n.variant)}`],n.open&&t.iconOpen]}})({}),po=(0,Gn.Ay)("input",{shouldForwardProp:e=>(0,so.A)(e)&&"classes"!==e,name:"MuiSelect",slot:"NativeInput",overridesResolver:(e,t)=>t.nativeInput})({bottom:0,left:0,position:"absolute",opacity:0,pointerEvents:"none",width:"100%",boxSizing:"border-box"});function fo(e,t){return"object"===typeof t&&null!==t?e===t:String(e)===String(t)}function mo(e){return null==e||"string"===typeof e&&!e.trim()}const go=T.forwardRef((function(e,t){const{"aria-describedby":n,"aria-label":r,autoFocus:a,autoWidth:s,children:i,className:o,defaultOpen:l,defaultValue:u,disabled:c,displayEmpty:d,error:h=!1,IconComponent:p,inputRef:f,labelId:m,MenuProps:g={},multiple:y,name:b,onBlur:v,onChange:x,onClose:w,onFocus:k,onOpen:S,open:I,readOnly:C,renderValue:N,SelectDisplayProps:E={},tabIndex:A,type:_,value:$,variant:R="standard",...D}=e,[M,F]=(0,io.A)({controlled:$,default:u,name:"Select"}),[O,P]=(0,io.A)({controlled:I,default:l,name:"Select"}),L=T.useRef(null),z=T.useRef(null),[B,W]=T.useState(null),{current:V}=T.useRef(null!=I),[U,j]=T.useState(),G=(0,ia.A)(t,f),H=T.useCallback((e=>{z.current=e,e&&W(e)}),[]),q=B?.parentNode;T.useImperativeHandle(G,(()=>({focus:()=>{z.current.focus()},node:L.current,value:M})),[M]),T.useEffect((()=>{l&&O&&B&&!V&&(j(s?null:q.clientWidth),z.current.focus())}),[B,s]),T.useEffect((()=>{a&&z.current.focus()}),[a]),T.useEffect((()=>{if(!m)return;const e=(0,us.A)(z.current).getElementById(m);if(e){const t=()=>{getSelection().isCollapsed&&z.current.focus()};return e.addEventListener("click",t),()=>{e.removeEventListener("click",t)}}}),[m]);const K=(e,t)=>{e?S&&S(t):w&&w(t),V||(j(s?null:q.clientWidth),P(e))},X=T.Children.toArray(i),Y=e=>t=>{let n;if(t.currentTarget.hasAttribute("tabindex")){if(y){n=Array.isArray(M)?M.slice():[];const t=M.indexOf(e.props.value);-1===t?n.push(e.props.value):n.splice(t,1)}else n=e.props.value;if(e.props.onClick&&e.props.onClick(t),M!==n&&(F(n),x)){const r=t.nativeEvent||t,a=new r.constructor(r.type,r);Object.defineProperty(a,"target",{writable:!0,value:{value:n,name:b}}),x(a,e)}y||K(!1,t)}},Q=null!==B&&O;let J,Z;delete D["aria-invalid"];const ee=[];let te=!1,ne=!1;(ua({value:M})||d)&&(N?J=N(M):te=!0);const re=X.map((e=>{if(!T.isValidElement(e))return null;let t;if(y){if(!Array.isArray(M))throw new Error((0,qr.A)(2));t=M.some((t=>fo(t,e.props.value))),t&&te&&ee.push(e.props.children)}else t=fo(M,e.props.value),t&&te&&(Z=e.props.children);return t&&(ne=!0),T.cloneElement(e,{"aria-selected":t?"true":"false",onClick:Y(e),onKeyUp:t=>{" "===t.key&&t.preventDefault(),e.props.onKeyUp&&e.props.onKeyUp(t)},role:"option",selected:t,value:void 0,"data-value":e.props.value})}));te&&(J=y?0===ee.length?null:ee.reduce(((e,t,n)=>(e.push(t),n<ee.length-1&&e.push(", "),e)),[]):Z);let ae,se=U;!s&&V&&B&&(se=q.clientWidth),ae="undefined"!==typeof A?A:c?null:0;const ie=E.id||(b?`mui-component-select-${b}`:void 0),oe={...e,variant:R,value:M,open:Q,error:h},le=(e=>{const{classes:t,variant:n,disabled:r,multiple:a,open:s,error:i}=e,o={select:["select",n,r&&"disabled",a&&"multiple",i&&"error"],icon:["icon",`icon${(0,jn.A)(n)}`,s&&"iconOpen",r&&"disabled"],nativeInput:["nativeInput"]};return(0,Vn.A)(o,oo,t)})(oe),ue={...g.PaperProps,...g.slotProps?.paper},ce=(0,Hr.A)();return(0,hr.jsxs)(T.Fragment,{children:[(0,hr.jsx)(co,{as:"div",ref:H,tabIndex:ae,role:"combobox","aria-controls":ce,"aria-disabled":c?"true":void 0,"aria-expanded":Q?"true":"false","aria-haspopup":"listbox","aria-label":r,"aria-labelledby":[m,ie].filter(Boolean).join(" ")||void 0,"aria-describedby":n,onKeyDown:e=>{if(!C){[" ","ArrowUp","ArrowDown","Enter"].includes(e.key)&&(e.preventDefault(),K(!0,e))}},onMouseDown:c||C?null:e=>{0===e.button&&(e.preventDefault(),z.current.focus(),K(!0,e))},onBlur:e=>{!Q&&v&&(Object.defineProperty(e,"target",{writable:!0,value:{value:M,name:b}}),v(e))},onFocus:k,...E,ownerState:oe,className:(0,Bn.A)(E.className,le.select,o),id:ie,children:mo(J)?uo||(uo=(0,hr.jsx)("span",{className:"notranslate",children:"\u200b"})):J}),(0,hr.jsx)(po,{"aria-invalid":h,value:Array.isArray(M)?M.join(","):M,name:b,ref:L,"aria-hidden":!0,onChange:e=>{const t=X.find((t=>t.props.value===e.target.value));void 0!==t&&(F(t.props.value),x&&x(e,t))},tabIndex:-1,disabled:c,className:le.nativeInput,autoFocus:a,...D,ownerState:oe}),(0,hr.jsx)(ho,{as:p,className:le.icon,ownerState:oe}),(0,hr.jsx)(Yi,{id:`menu-${b||""}`,anchorEl:q,open:Q,onClose:e=>{K(!1,e)},anchorOrigin:{vertical:"bottom",horizontal:"center"},transformOrigin:{vertical:"top",horizontal:"center"},...g,MenuListProps:{"aria-labelledby":m,role:"listbox","aria-multiselectable":y?"true":void 0,disableListWrap:!0,id:ce,...g.MenuListProps},slotProps:{...g.slotProps,paper:{...ue,style:{minWidth:se,...null!=ue?ue.style:null}}},children:re})]})})),yo=go;var bo=n(9662);const vo=(0,bo.A)((0,hr.jsx)("path",{d:"M7 10l5 5 5-5z"}),"ArrowDropDown");var xo=n(3030);function wo(e){const{theme:t,name:n,props:r}=e;return t&&t.components&&t.components[n]&&t.components[n].defaultProps?(0,xo.A)(t.components[n].defaultProps,r):r}function ko(e){let{props:t,name:n,defaultTheme:r,themeId:a}=e,s=Yn(r);return a&&(s=s[a]||s),wo({theme:s,name:n,props:t})}function So(e){let{props:t,name:n}=e;return ko({props:t,name:n,defaultTheme:Qn.A,themeId:Jn.A})}const Io={name:"MuiSelect",overridesResolver:(e,t)=>t.root,shouldForwardProp:e=>(0,xa.A)(e)&&"variant"!==e,slot:"Root"},Co=(0,Gn.Ay)(Na,Io)(""),No=(0,Gn.Ay)(Va,Io)(""),To=(0,Gn.Ay)(Ra,Io)(""),Eo=T.forwardRef((function(e,t){const n=So({name:"MuiSelect",props:e}),{autoWidth:r=!1,children:a,classes:s={},className:i,defaultOpen:o=!1,displayEmpty:l=!1,IconComponent:u=vo,id:c,input:d,inputProps:h,label:p,labelId:f,MenuProps:m,multiple:g=!1,native:y=!1,onClose:b,onOpen:v,open:x,renderValue:w,SelectDisplayProps:k,variant:S="outlined",...I}=n,C=y?ao:yo,N=ra({props:n,muiFormControl:sa(),states:["variant","error"]}),E=N.variant||S,A={...n,variant:E,classes:s},_=(e=>{const{classes:t}=e;return t})(A),{root:$,...R}=_,D=d||{standard:(0,hr.jsx)(Co,{ownerState:A}),outlined:(0,hr.jsx)(No,{label:p,ownerState:A}),filled:(0,hr.jsx)(To,{ownerState:A})}[E],M=(0,ia.A)(t,ls(D));return(0,hr.jsx)(T.Fragment,{children:T.cloneElement(D,{inputComponent:C,inputProps:{children:a,error:N.error,IconComponent:u,variant:E,type:void 0,multiple:g,...y?{id:c}:{autoWidth:r,defaultOpen:o,displayEmpty:l,labelId:f,MenuProps:m,onClose:b,onOpen:v,open:x,renderValue:w,SelectDisplayProps:{id:c,...k}},...h,classes:h?(0,nr.A)(R,h.classes):R,...d?d.props.inputProps:{}},...(g&&y||l)&&"outlined"===E?{notched:!0}:{},ref:M,className:(0,Bn.A)(D.props.className,i,_.root),...!d&&{variant:E},...I})})}));Eo.muiName="Select";const Ao=Eo;function _o(e){return(0,yr.Ay)("MuiTextField",e)}(0,gr.A)("MuiTextField",["root"]);const $o={standard:Na,filled:Ra,outlined:Va},Ro=(0,Gn.Ay)(ns,{name:"MuiTextField",slot:"Root",overridesResolver:(e,t)=>t.root})({}),Do=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiTextField"}),{autoComplete:r,autoFocus:a=!1,children:s,className:i,color:o="primary",defaultValue:l,disabled:u=!1,error:c=!1,FormHelperTextProps:d,fullWidth:h=!1,helperText:p,id:f,InputLabelProps:m,inputProps:g,InputProps:y,inputRef:b,label:v,maxRows:x,minRows:w,multiline:k=!1,name:S,onBlur:I,onChange:C,onFocus:N,placeholder:T,required:E=!1,rows:A,select:_=!1,SelectProps:$,slots:R={},slotProps:D={},type:M,value:F,variant:O="outlined",...P}=n,L={...n,autoFocus:a,color:o,disabled:u,error:c,fullWidth:h,multiline:k,required:E,select:_,variant:O},z=(e=>{const{classes:t}=e;return(0,Vn.A)({root:["root"]},_o,t)})(L);const B=(0,Hr.A)(f),W=p&&B?`${B}-helper-text`:void 0,V=v&&B?`${B}-label`:void 0,U=$o[O],j={slots:R,slotProps:{input:y,inputLabel:m,htmlInput:g,formHelperText:d,select:$,...D}},G={},H=j.slotProps.inputLabel;"outlined"===O&&(H&&"undefined"!==typeof H.shrink&&(G.notched=H.shrink),G.label=v),_&&($&&$.native||(G.id=void 0),G["aria-describedby"]=void 0);const[q,K]=pi("input",{elementType:U,externalForwardedProps:j,additionalProps:G,ownerState:L}),[X,Y]=pi("inputLabel",{elementType:Qa,externalForwardedProps:j,ownerState:L}),[Q,J]=pi("htmlInput",{elementType:"input",externalForwardedProps:j,ownerState:L}),[Z,ee]=pi("formHelperText",{elementType:os,externalForwardedProps:j,ownerState:L}),[te,ne]=pi("select",{elementType:Ao,externalForwardedProps:j,ownerState:L}),re=(0,hr.jsx)(q,{"aria-describedby":W,autoComplete:r,autoFocus:a,defaultValue:l,fullWidth:h,multiline:k,name:S,rows:A,maxRows:x,minRows:w,type:M,value:F,id:B,inputRef:b,onBlur:I,onChange:C,onFocus:N,placeholder:T,inputProps:J,slots:{input:R.htmlInput?Q:void 0},...K});return(0,hr.jsxs)(Ro,{className:(0,Bn.A)(z.root,i),disabled:u,error:c,fullWidth:h,ref:t,required:E,color:o,variant:O,ownerState:L,...P,children:[null!=v&&""!==v&&(0,hr.jsx)(X,{htmlFor:B,id:V,...Y,children:v}),_?(0,hr.jsx)(te,{"aria-describedby":W,id:B,labelId:V,value:F,input:re,...ne,children:s}):re,p&&(0,hr.jsx)(Z,{id:W,...ee,children:p})]})})),Mo=Do;var Fo=n(3319);class Oo{static create(){return new Oo}static use(){const e=Fs(Oo.create).current,[t,n]=T.useState(!1);return e.shouldMount=t,e.setShouldMount=n,T.useEffect(e.mountEffect,[t]),e}constructor(){this.ref={current:null},this.mounted=null,this.didMount=!1,this.shouldMount=!1,this.setShouldMount=null}mount(){return this.mounted||(this.mounted=function(){let e,t;const n=new Promise(((n,r)=>{e=n,t=r}));return n.resolve=e,n.reject=t,n}(),this.shouldMount=!0,this.setShouldMount(this.shouldMount)),this.mounted}mountEffect=()=>{this.shouldMount&&!this.didMount&&null!==this.ref.current&&(this.didMount=!0,this.mounted.resolve())};start(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this.mount().then((()=>this.ref.current?.start(...t)))}stop(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this.mount().then((()=>this.ref.current?.stop(...t)))}pulsate(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this.mount().then((()=>this.ref.current?.pulsate(...t)))}}var Po=n(8168);function Lo(e,t){var n=Object.create(null);return e&&T.Children.map(e,(function(e){return e})).forEach((function(e){n[e.key]=function(e){return t&&(0,T.isValidElement)(e)?t(e):e}(e)})),n}function zo(e,t,n){return null!=n[t]?n[t]:e.props[t]}function Bo(e,t,n){var r=Lo(e.children),a=function(e,t){function n(n){return n in t?t[n]:e[n]}e=e||{},t=t||{};var r,a=Object.create(null),s=[];for(var i in e)i in t?s.length&&(a[i]=s,s=[]):s.push(i);var o={};for(var l in t){if(a[l])for(r=0;r<a[l].length;r++){var u=a[l][r];o[a[l][r]]=n(u)}o[l]=n(l)}for(r=0;r<s.length;r++)o[s[r]]=n(s[r]);return o}(t,r);return Object.keys(a).forEach((function(s){var i=a[s];if((0,T.isValidElement)(i)){var o=s in t,l=s in r,u=t[s],c=(0,T.isValidElement)(u)&&!u.props.in;!l||o&&!c?l||!o||c?l&&o&&(0,T.isValidElement)(u)&&(a[s]=(0,T.cloneElement)(i,{onExited:n.bind(null,i),in:u.props.in,exit:zo(i,"exit",e),enter:zo(i,"enter",e)})):a[s]=(0,T.cloneElement)(i,{in:!1}):a[s]=(0,T.cloneElement)(i,{onExited:n.bind(null,i),in:!0,exit:zo(i,"exit",e),enter:zo(i,"enter",e)})}})),a}var Wo=Object.values||function(e){return Object.keys(e).map((function(t){return e[t]}))},Vo=function(e){function t(t,n){var r,a=(r=e.call(this,t,n)||this).handleExited.bind(function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(r));return r.state={contextValue:{isMounting:!0},handleExited:a,firstRender:!0},r}Ws(t,e);var n=t.prototype;return n.componentDidMount=function(){this.mounted=!0,this.setState({contextValue:{isMounting:!1}})},n.componentWillUnmount=function(){this.mounted=!1},t.getDerivedStateFromProps=function(e,t){var n,r,a=t.children,s=t.handleExited;return{children:t.firstRender?(n=e,r=s,Lo(n.children,(function(e){return(0,T.cloneElement)(e,{onExited:r.bind(null,e),in:!0,appear:zo(e,"appear",n),enter:zo(e,"enter",n),exit:zo(e,"exit",n)})}))):Bo(e,a,s),firstRender:!1}},n.handleExited=function(e,t){var n=Lo(this.props.children);e.key in n||(e.props.onExited&&e.props.onExited(t),this.mounted&&this.setState((function(t){var n=(0,Po.A)({},t.children);return delete n[e.key],{children:n}})))},n.render=function(){var e=this.props,t=e.component,n=e.childFactory,r=zs(e,["component","childFactory"]),a=this.state.contextValue,s=Wo(this.state.children).map(n);return delete r.appear,delete r.enter,delete r.exit,null===t?T.createElement(Us.Provider,{value:a},s):T.createElement(Us.Provider,{value:a},T.createElement(t,r,s))},t}(T.Component);Vo.propTypes={},Vo.defaultProps={component:"div",childFactory:function(e){return e}};const Uo=Vo;const jo=function(e){const{className:t,classes:n,pulsate:r=!1,rippleX:a,rippleY:s,rippleSize:i,in:o,onExited:l,timeout:u}=e,[c,d]=T.useState(!1),h=(0,Bn.A)(t,n.ripple,n.rippleVisible,r&&n.ripplePulsate),p={width:i,height:i,top:-i/2+s,left:-i/2+a},f=(0,Bn.A)(n.child,c&&n.childLeaving,r&&n.childPulsate);return o||c||d(!0),T.useEffect((()=>{if(!o&&null!=l){const e=setTimeout(l,u);return()=>{clearTimeout(e)}}}),[l,o,u]),(0,hr.jsx)("span",{className:h,style:p,children:(0,hr.jsx)("span",{className:f})})};const Go=(0,gr.A)("MuiTouchRipple",["root","ripple","rippleVisible","ripplePulsate","child","childLeaving","childPulsate"]),Ho=dr`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`,qo=dr`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`,Ko=dr`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`,Xo=(0,Gn.Ay)("span",{name:"MuiTouchRipple",slot:"Root"})({overflow:"hidden",pointerEvents:"none",position:"absolute",zIndex:0,top:0,right:0,bottom:0,left:0,borderRadius:"inherit"}),Yo=(0,Gn.Ay)(jo,{name:"MuiTouchRipple",slot:"Ripple"})`
  opacity: 0;
  position: absolute;

  &.${Go.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${Ho};
    animation-duration: ${550}ms;
    animation-timing-function: ${e=>{let{theme:t}=e;return t.transitions.easing.easeInOut}};
  }

  &.${Go.ripplePulsate} {
    animation-duration: ${e=>{let{theme:t}=e;return t.transitions.duration.shorter}}ms;
  }

  & .${Go.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${Go.childLeaving} {
    opacity: 0;
    animation-name: ${qo};
    animation-duration: ${550}ms;
    animation-timing-function: ${e=>{let{theme:t}=e;return t.transitions.easing.easeInOut}};
  }

  & .${Go.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${Ko};
    animation-duration: 2500ms;
    animation-timing-function: ${e=>{let{theme:t}=e;return t.transitions.easing.easeInOut}};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`,Qo=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiTouchRipple"}),{center:r=!1,classes:a={},className:s,...i}=n,[o,l]=T.useState([]),u=T.useRef(0),c=T.useRef(null);T.useEffect((()=>{c.current&&(c.current(),c.current=null)}),[o]);const d=T.useRef(!1),h=Ls(),p=T.useRef(null),f=T.useRef(null),m=T.useCallback((e=>{const{pulsate:t,rippleX:n,rippleY:r,rippleSize:s,cb:i}=e;l((e=>[...e,(0,hr.jsx)(Yo,{classes:{ripple:(0,Bn.A)(a.ripple,Go.ripple),rippleVisible:(0,Bn.A)(a.rippleVisible,Go.rippleVisible),ripplePulsate:(0,Bn.A)(a.ripplePulsate,Go.ripplePulsate),child:(0,Bn.A)(a.child,Go.child),childLeaving:(0,Bn.A)(a.childLeaving,Go.childLeaving),childPulsate:(0,Bn.A)(a.childPulsate,Go.childPulsate)},timeout:550,pulsate:t,rippleX:n,rippleY:r,rippleSize:s},u.current)])),u.current+=1,c.current=i}),[a]),g=T.useCallback((function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>{};const{pulsate:a=!1,center:s=r||t.pulsate,fakeElement:i=!1}=t;if("mousedown"===e?.type&&d.current)return void(d.current=!1);"touchstart"===e?.type&&(d.current=!0);const o=i?null:f.current,l=o?o.getBoundingClientRect():{width:0,height:0,left:0,top:0};let u,c,g;if(s||void 0===e||0===e.clientX&&0===e.clientY||!e.clientX&&!e.touches)u=Math.round(l.width/2),c=Math.round(l.height/2);else{const{clientX:t,clientY:n}=e.touches&&e.touches.length>0?e.touches[0]:e;u=Math.round(t-l.left),c=Math.round(n-l.top)}if(s)g=Math.sqrt((2*l.width**2+l.height**2)/3),g%2===0&&(g+=1);else{const e=2*Math.max(Math.abs((o?o.clientWidth:0)-u),u)+2,t=2*Math.max(Math.abs((o?o.clientHeight:0)-c),c)+2;g=Math.sqrt(e**2+t**2)}e?.touches?null===p.current&&(p.current=()=>{m({pulsate:a,rippleX:u,rippleY:c,rippleSize:g,cb:n})},h.start(80,(()=>{p.current&&(p.current(),p.current=null)}))):m({pulsate:a,rippleX:u,rippleY:c,rippleSize:g,cb:n})}),[r,m,h]),y=T.useCallback((()=>{g({},{pulsate:!0})}),[g]),b=T.useCallback(((e,t)=>{if(h.clear(),"touchend"===e?.type&&p.current)return p.current(),p.current=null,void h.start(0,(()=>{b(e,t)}));p.current=null,l((e=>e.length>0?e.slice(1):e)),c.current=t}),[h]);return T.useImperativeHandle(t,(()=>({pulsate:y,start:g,stop:b})),[y,g,b]),(0,hr.jsx)(Xo,{className:(0,Bn.A)(Go.root,a.root,s),ref:f,...i,children:(0,hr.jsx)(Uo,{component:null,exit:!0,children:o})})})),Jo=Qo;function Zo(e){return(0,yr.Ay)("MuiButtonBase",e)}const el=(0,gr.A)("MuiButtonBase",["root","disabled","focusVisible"]),tl=(0,Gn.Ay)("button",{name:"MuiButtonBase",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"inline-flex",alignItems:"center",justifyContent:"center",position:"relative",boxSizing:"border-box",WebkitTapHighlightColor:"transparent",backgroundColor:"transparent",outline:0,border:0,margin:0,borderRadius:0,padding:0,cursor:"pointer",userSelect:"none",verticalAlign:"middle",MozAppearance:"none",WebkitAppearance:"none",textDecoration:"none",color:"inherit","&::-moz-focus-inner":{borderStyle:"none"},[`&.${el.disabled}`]:{pointerEvents:"none",cursor:"default"},"@media print":{colorAdjust:"exact"}}),nl=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiButtonBase"}),{action:r,centerRipple:a=!1,children:s,className:i,component:o="button",disabled:l=!1,disableRipple:u=!1,disableTouchRipple:c=!1,focusRipple:d=!1,focusVisibleClassName:h,LinkComponent:p="a",onBlur:f,onClick:m,onContextMenu:g,onDragLeave:y,onFocus:b,onFocusVisible:v,onKeyDown:x,onKeyUp:w,onMouseDown:k,onMouseLeave:S,onMouseUp:I,onTouchEnd:C,onTouchMove:N,onTouchStart:E,tabIndex:A=0,TouchRippleProps:_,touchRippleRef:$,type:R,...D}=n,M=T.useRef(null),F=Oo.use(),O=(0,ia.A)(F.ref,$),[P,L]=T.useState(!1);l&&P&&L(!1),T.useImperativeHandle(r,(()=>({focusVisible:()=>{L(!0),M.current.focus()}})),[]);const z=F.shouldMount&&!u&&!l;function B(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:c;return(0,Fo.A)((r=>{t&&t(r);return n||F[e](r),!0}))}T.useEffect((()=>{P&&d&&!u&&F.pulsate()}),[u,d,P,F]);const W=B("start",k),V=B("stop",g),U=B("stop",y),j=B("stop",I),G=B("stop",(e=>{P&&e.preventDefault(),S&&S(e)})),H=B("start",E),q=B("stop",C),K=B("stop",N),X=B("stop",(e=>{Un(e.target)||L(!1),f&&f(e)}),!1),Y=(0,Fo.A)((e=>{M.current||(M.current=e.currentTarget),Un(e.target)&&(L(!0),v&&v(e)),b&&b(e)})),Q=()=>{const e=M.current;return o&&"button"!==o&&!("A"===e.tagName&&e.href)},J=(0,Fo.A)((e=>{d&&!e.repeat&&P&&" "===e.key&&F.stop(e,(()=>{F.start(e)})),e.target===e.currentTarget&&Q()&&" "===e.key&&e.preventDefault(),x&&x(e),e.target===e.currentTarget&&Q()&&"Enter"===e.key&&!l&&(e.preventDefault(),m&&m(e))})),Z=(0,Fo.A)((e=>{d&&" "===e.key&&P&&!e.defaultPrevented&&F.stop(e,(()=>{F.pulsate(e)})),w&&w(e),m&&e.target===e.currentTarget&&Q()&&" "===e.key&&!e.defaultPrevented&&m(e)}));let ee=o;"button"===ee&&(D.href||D.to)&&(ee=p);const te={};"button"===ee?(te.type=void 0===R?"button":R,te.disabled=l):(D.href||D.to||(te.role="button"),l&&(te["aria-disabled"]=l));const ne=(0,ia.A)(t,M),re={...n,centerRipple:a,component:o,disabled:l,disableRipple:u,disableTouchRipple:c,focusRipple:d,tabIndex:A,focusVisible:P},ae=(e=>{const{disabled:t,focusVisible:n,focusVisibleClassName:r,classes:a}=e,s={root:["root",t&&"disabled",n&&"focusVisible"]},i=(0,Vn.A)(s,Zo,a);return n&&r&&(i.root+=` ${r}`),i})(re);return(0,hr.jsxs)(tl,{as:ee,className:(0,Bn.A)(ae.root,i),ownerState:re,onBlur:X,onClick:m,onContextMenu:V,onFocus:Y,onKeyDown:J,onKeyUp:Z,onMouseDown:W,onMouseLeave:G,onMouseUp:j,onDragLeave:U,onTouchEnd:q,onTouchMove:K,onTouchStart:H,ref:ne,tabIndex:l?-1:A,type:R,...te,...D,children:[s,z?(0,hr.jsx)(Jo,{ref:O,center:a,..._}):null]})}));function rl(e){return(0,yr.Ay)("MuiButton",e)}const al=(0,gr.A)("MuiButton",["root","text","textInherit","textPrimary","textSecondary","textSuccess","textError","textInfo","textWarning","outlined","outlinedInherit","outlinedPrimary","outlinedSecondary","outlinedSuccess","outlinedError","outlinedInfo","outlinedWarning","contained","containedInherit","containedPrimary","containedSecondary","containedSuccess","containedError","containedInfo","containedWarning","disableElevation","focusVisible","disabled","colorInherit","colorPrimary","colorSecondary","colorSuccess","colorError","colorInfo","colorWarning","textSizeSmall","textSizeMedium","textSizeLarge","outlinedSizeSmall","outlinedSizeMedium","outlinedSizeLarge","containedSizeSmall","containedSizeMedium","containedSizeLarge","sizeMedium","sizeSmall","sizeLarge","fullWidth","startIcon","endIcon","icon","iconSizeSmall","iconSizeMedium","iconSizeLarge"]);const sl=T.createContext({});const il=T.createContext(void 0),ol=[{props:{size:"small"},style:{"& > *:nth-of-type(1)":{fontSize:18}}},{props:{size:"medium"},style:{"& > *:nth-of-type(1)":{fontSize:20}}},{props:{size:"large"},style:{"& > *:nth-of-type(1)":{fontSize:22}}}],ll=(0,Gn.Ay)(nl,{shouldForwardProp:e=>(0,xa.A)(e)||"classes"===e,name:"MuiButton",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],t[`${n.variant}${(0,jn.A)(n.color)}`],t[`size${(0,jn.A)(n.size)}`],t[`${n.variant}Size${(0,jn.A)(n.size)}`],"inherit"===n.color&&t.colorInherit,n.disableElevation&&t.disableElevation,n.fullWidth&&t.fullWidth]}})((0,er.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?t.palette.grey[300]:t.palette.grey[800],r="light"===t.palette.mode?t.palette.grey.A100:t.palette.grey[700];return{...t.typography.button,minWidth:64,padding:"6px 16px",border:0,borderRadius:(t.vars||t).shape.borderRadius,transition:t.transitions.create(["background-color","box-shadow","border-color","color"],{duration:t.transitions.duration.short}),"&:hover":{textDecoration:"none"},[`&.${al.disabled}`]:{color:(t.vars||t).palette.action.disabled},variants:[{props:{variant:"contained"},style:{color:"var(--variant-containedColor)",backgroundColor:"var(--variant-containedBg)",boxShadow:(t.vars||t).shadows[2],"&:hover":{boxShadow:(t.vars||t).shadows[4],"@media (hover: none)":{boxShadow:(t.vars||t).shadows[2]}},"&:active":{boxShadow:(t.vars||t).shadows[8]},[`&.${al.focusVisible}`]:{boxShadow:(t.vars||t).shadows[6]},[`&.${al.disabled}`]:{color:(t.vars||t).palette.action.disabled,boxShadow:(t.vars||t).shadows[0],backgroundColor:(t.vars||t).palette.action.disabledBackground}}},{props:{variant:"outlined"},style:{padding:"5px 15px",border:"1px solid currentColor",borderColor:"var(--variant-outlinedBorder, currentColor)",backgroundColor:"var(--variant-outlinedBg)",color:"var(--variant-outlinedColor)",[`&.${al.disabled}`]:{border:`1px solid ${(t.vars||t).palette.action.disabledBackground}`}}},{props:{variant:"text"},style:{padding:"6px 8px",color:"var(--variant-textColor)",backgroundColor:"var(--variant-textBg)"}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.dark&&t.contrastText})).map((e=>{let[n]=e;return{props:{color:n},style:{"--variant-textColor":(t.vars||t).palette[n].main,"--variant-outlinedColor":(t.vars||t).palette[n].main,"--variant-outlinedBorder":t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.5)`:(0,Wn.X4)(t.palette[n].main,.5),"--variant-containedColor":(t.vars||t).palette[n].contrastText,"--variant-containedBg":(t.vars||t).palette[n].main,"@media (hover: hover)":{"&:hover":{"--variant-containedBg":(t.vars||t).palette[n].dark,"--variant-textBg":t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Wn.X4)(t.palette[n].main,t.palette.action.hoverOpacity),"--variant-outlinedBorder":(t.vars||t).palette[n].main,"--variant-outlinedBg":t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Wn.X4)(t.palette[n].main,t.palette.action.hoverOpacity)}}}}})),{props:{color:"inherit"},style:{"--variant-containedColor":t.vars?t.vars.palette.text.primary:t.palette.getContrastText?.(n),"--variant-containedBg":t.vars?t.vars.palette.Button.inheritContainedBg:n,"@media (hover: hover)":{"&:hover":{"--variant-containedBg":t.vars?t.vars.palette.Button.inheritContainedHoverBg:r,"--variant-textBg":t.vars?`rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Wn.X4)(t.palette.text.primary,t.palette.action.hoverOpacity),"--variant-outlinedBg":t.vars?`rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Wn.X4)(t.palette.text.primary,t.palette.action.hoverOpacity)}}}},{props:{size:"small",variant:"text"},style:{padding:"4px 5px",fontSize:t.typography.pxToRem(13)}},{props:{size:"large",variant:"text"},style:{padding:"8px 11px",fontSize:t.typography.pxToRem(15)}},{props:{size:"small",variant:"outlined"},style:{padding:"3px 9px",fontSize:t.typography.pxToRem(13)}},{props:{size:"large",variant:"outlined"},style:{padding:"7px 21px",fontSize:t.typography.pxToRem(15)}},{props:{size:"small",variant:"contained"},style:{padding:"4px 10px",fontSize:t.typography.pxToRem(13)}},{props:{size:"large",variant:"contained"},style:{padding:"8px 22px",fontSize:t.typography.pxToRem(15)}},{props:{disableElevation:!0},style:{boxShadow:"none","&:hover":{boxShadow:"none"},[`&.${al.focusVisible}`]:{boxShadow:"none"},"&:active":{boxShadow:"none"},[`&.${al.disabled}`]:{boxShadow:"none"}}},{props:{fullWidth:!0},style:{width:"100%"}}]}}))),ul=(0,Gn.Ay)("span",{name:"MuiButton",slot:"StartIcon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.startIcon,t[`iconSize${(0,jn.A)(n.size)}`]]}})({display:"inherit",marginRight:8,marginLeft:-4,variants:[{props:{size:"small"},style:{marginLeft:-2}},...ol]}),cl=(0,Gn.Ay)("span",{name:"MuiButton",slot:"EndIcon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.endIcon,t[`iconSize${(0,jn.A)(n.size)}`]]}})({display:"inherit",marginRight:-4,marginLeft:8,variants:[{props:{size:"small"},style:{marginRight:-2}},...ol]}),dl=T.forwardRef((function(e,t){const n=T.useContext(sl),r=T.useContext(il),a=(0,xo.A)(n,e),s=(0,tr.b)({props:a,name:"MuiButton"}),{children:i,color:o="primary",component:l="button",className:u,disabled:c=!1,disableElevation:d=!1,disableFocusRipple:h=!1,endIcon:p,focusVisibleClassName:f,fullWidth:m=!1,size:g="medium",startIcon:y,type:b,variant:v="text",...x}=s,w={...s,color:o,component:l,disabled:c,disableElevation:d,disableFocusRipple:h,fullWidth:m,size:g,type:b,variant:v},k=(e=>{const{color:t,disableElevation:n,fullWidth:r,size:a,variant:s,classes:i}=e,o={root:["root",s,`${s}${(0,jn.A)(t)}`,`size${(0,jn.A)(a)}`,`${s}Size${(0,jn.A)(a)}`,`color${(0,jn.A)(t)}`,n&&"disableElevation",r&&"fullWidth"],label:["label"],startIcon:["icon","startIcon",`iconSize${(0,jn.A)(a)}`],endIcon:["icon","endIcon",`iconSize${(0,jn.A)(a)}`]},l=(0,Vn.A)(o,rl,i);return{...i,...l}})(w),S=y&&(0,hr.jsx)(ul,{className:k.startIcon,ownerState:w,children:y}),I=p&&(0,hr.jsx)(cl,{className:k.endIcon,ownerState:w,children:p}),C=r||"";return(0,hr.jsxs)(ll,{ownerState:w,className:(0,Bn.A)(n.className,k.root,u,C),component:l,disabled:c,focusRipple:!h,focusVisibleClassName:(0,Bn.A)(k.focusVisible,f),ref:t,type:b,...x,classes:k,children:[S,i,I]})})),hl=dl;function pl(e){return(0,yr.Ay)("MuiAlert",e)}const fl=(0,gr.A)("MuiAlert",["root","action","icon","message","filled","colorSuccess","colorInfo","colorWarning","colorError","filledSuccess","filledInfo","filledWarning","filledError","outlined","outlinedSuccess","outlinedInfo","outlinedWarning","outlinedError","standard","standardSuccess","standardInfo","standardWarning","standardError"]);function ml(e){return(0,yr.Ay)("MuiIconButton",e)}const gl=(0,gr.A)("MuiIconButton",["root","disabled","colorInherit","colorPrimary","colorSecondary","colorError","colorInfo","colorSuccess","colorWarning","edgeStart","edgeEnd","sizeSmall","sizeMedium","sizeLarge"]),yl=(0,Gn.Ay)(nl,{name:"MuiIconButton",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,"default"!==n.color&&t[`color${(0,jn.A)(n.color)}`],n.edge&&t[`edge${(0,jn.A)(n.edge)}`],t[`size${(0,jn.A)(n.size)}`]]}})((0,er.A)((e=>{let{theme:t}=e;return{textAlign:"center",flex:"0 0 auto",fontSize:t.typography.pxToRem(24),padding:8,borderRadius:"50%",color:(t.vars||t).palette.action.active,transition:t.transitions.create("background-color",{duration:t.transitions.duration.shortest}),variants:[{props:{disableRipple:!1},style:{"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Wn.X4)(t.palette.action.active,t.palette.action.hoverOpacity),"@media (hover: none)":{backgroundColor:"transparent"}}}},{props:{edge:"start"},style:{marginLeft:-12}},{props:{edge:"start",size:"small"},style:{marginLeft:-3}},{props:{edge:"end"},style:{marginRight:-12}},{props:{edge:"end",size:"small"},style:{marginRight:-3}}]}})),(0,er.A)((e=>{let{theme:t}=e;return{variants:[{props:{color:"inherit"},style:{color:"inherit"}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars||t).palette[n].main}}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n,disableRipple:!1},style:{"&:hover":{backgroundColor:t.vars?`rgba(${(t.vars||t).palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Wn.X4)((t.vars||t).palette[n].main,t.palette.action.hoverOpacity),"@media (hover: none)":{backgroundColor:"transparent"}}}}})),{props:{size:"small"},style:{padding:5,fontSize:t.typography.pxToRem(18)}},{props:{size:"large"},style:{padding:12,fontSize:t.typography.pxToRem(28)}}],[`&.${gl.disabled}`]:{backgroundColor:"transparent",color:(t.vars||t).palette.action.disabled}}}))),bl=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiIconButton"}),{edge:r=!1,children:a,className:s,color:i="default",disabled:o=!1,disableFocusRipple:l=!1,disableRipple:u=!1,size:c="medium",...d}=n,h={...n,edge:r,color:i,disabled:o,disableFocusRipple:l,disableRipple:u,size:c},p=(e=>{const{classes:t,disabled:n,color:r,edge:a,size:s}=e,i={root:["root",n&&"disabled","default"!==r&&`color${(0,jn.A)(r)}`,a&&`edge${(0,jn.A)(a)}`,`size${(0,jn.A)(s)}`]};return(0,Vn.A)(i,ml,t)})(h);return(0,hr.jsx)(yl,{className:(0,Bn.A)(p.root,s),centerRipple:!0,focusRipple:!l,disabled:o,disableRipple:u,ref:t,...d,ownerState:h,children:a})})),vl=(0,bo.A)((0,hr.jsx)("path",{d:"M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"}),"SuccessOutlined"),xl=(0,bo.A)((0,hr.jsx)("path",{d:"M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"}),"ReportProblemOutlined"),wl=(0,bo.A)((0,hr.jsx)("path",{d:"M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"}),"ErrorOutline"),kl=(0,bo.A)((0,hr.jsx)("path",{d:"M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"}),"InfoOutlined"),Sl=(0,bo.A)((0,hr.jsx)("path",{d:"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"}),"Close"),Il=(0,Gn.Ay)(Gr,{name:"MuiAlert",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],t[`${n.variant}${(0,jn.A)(n.color||n.severity)}`]]}})((0,er.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?Wn.e$:Wn.a,r="light"===t.palette.mode?Wn.a:Wn.e$;return{...t.typography.body2,backgroundColor:"transparent",display:"flex",padding:"6px 16px",variants:[...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.light})).map((e=>{let[a]=e;return{props:{colorSeverity:a,variant:"standard"},style:{color:t.vars?t.vars.palette.Alert[`${a}Color`]:n(t.palette[a].light,.6),backgroundColor:t.vars?t.vars.palette.Alert[`${a}StandardBg`]:r(t.palette[a].light,.9),[`& .${fl.icon}`]:t.vars?{color:t.vars.palette.Alert[`${a}IconColor`]}:{color:t.palette[a].main}}}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.light})).map((e=>{let[r]=e;return{props:{colorSeverity:r,variant:"outlined"},style:{color:t.vars?t.vars.palette.Alert[`${r}Color`]:n(t.palette[r].light,.6),border:`1px solid ${(t.vars||t).palette[r].light}`,[`& .${fl.icon}`]:t.vars?{color:t.vars.palette.Alert[`${r}IconColor`]}:{color:t.palette[r].main}}}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.dark})).map((e=>{let[n]=e;return{props:{colorSeverity:n,variant:"filled"},style:{fontWeight:t.typography.fontWeightMedium,...t.vars?{color:t.vars.palette.Alert[`${n}FilledColor`],backgroundColor:t.vars.palette.Alert[`${n}FilledBg`]}:{backgroundColor:"dark"===t.palette.mode?t.palette[n].dark:t.palette[n].main,color:t.palette.getContrastText(t.palette[n].main)}}}}))]}}))),Cl=(0,Gn.Ay)("div",{name:"MuiAlert",slot:"Icon",overridesResolver:(e,t)=>t.icon})({marginRight:12,padding:"7px 0",display:"flex",fontSize:22,opacity:.9}),Nl=(0,Gn.Ay)("div",{name:"MuiAlert",slot:"Message",overridesResolver:(e,t)=>t.message})({padding:"8px 0",minWidth:0,overflow:"auto"}),Tl=(0,Gn.Ay)("div",{name:"MuiAlert",slot:"Action",overridesResolver:(e,t)=>t.action})({display:"flex",alignItems:"flex-start",padding:"4px 0 0 16px",marginLeft:"auto",marginRight:-8}),El={success:(0,hr.jsx)(vl,{fontSize:"inherit"}),warning:(0,hr.jsx)(xl,{fontSize:"inherit"}),error:(0,hr.jsx)(wl,{fontSize:"inherit"}),info:(0,hr.jsx)(kl,{fontSize:"inherit"})},Al=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiAlert"}),{action:r,children:a,className:s,closeText:i="Close",color:o,components:l={},componentsProps:u={},icon:c,iconMapping:d=El,onClose:h,role:p="alert",severity:f="success",slotProps:m={},slots:g={},variant:y="standard",...b}=n,v={...n,color:o,severity:f,variant:y,colorSeverity:o||f},x=(e=>{const{variant:t,color:n,severity:r,classes:a}=e,s={root:["root",`color${(0,jn.A)(n||r)}`,`${t}${(0,jn.A)(n||r)}`,`${t}`],icon:["icon"],message:["message"],action:["action"]};return(0,Vn.A)(s,pl,a)})(v),w={slots:{closeButton:l.CloseButton,closeIcon:l.CloseIcon,...g},slotProps:{...u,...m}},[k,S]=pi("closeButton",{elementType:bl,externalForwardedProps:w,ownerState:v}),[I,C]=pi("closeIcon",{elementType:Sl,externalForwardedProps:w,ownerState:v});return(0,hr.jsxs)(Il,{role:p,elevation:0,ownerState:v,className:(0,Bn.A)(x.root,s),ref:t,...b,children:[!1!==c?(0,hr.jsx)(Cl,{ownerState:v,className:x.icon,children:c||d[f]||El[f]}):null,(0,hr.jsx)(Nl,{ownerState:v,className:x.message,children:a}),null!=r?(0,hr.jsx)(Tl,{ownerState:v,className:x.action,children:r}):null,null==r&&h?(0,hr.jsx)(Tl,{ownerState:v,className:x.action,children:(0,hr.jsx)(k,{size:"small","aria-label":i,title:i,color:"inherit",onClick:h,...S,children:(0,hr.jsx)(I,{fontSize:"small",...C})})}):null]})})),_l=Al;var $l=n(4914);const Rl=()=>{const e=yn(),t=new URLSearchParams(e.search).get("userId"),[n,r]=(0,T.useState)(!1),a=vn();return(0,hr.jsx)(Br,{display:"flex",justifyContent:"center",alignItems:"center",minHeight:"100vh",bgcolor:"#f5f5f5",padding:3,children:(0,hr.jsxs)(Gr,{elevation:3,sx:{padding:4,borderRadius:2,maxWidth:500},children:[(0,hr.jsx)(Ir,{variant:"h4",textAlign:"center",gutterBottom:!0,children:"Congratulations!"}),(0,hr.jsx)(Ir,{variant:"body1",textAlign:"center",gutterBottom:!0,children:"You have been successfully registered in our system."}),(0,hr.jsx)(Ir,{variant:"h6",textAlign:"center",gutterBottom:!0,children:"User ID:"}),(0,hr.jsxs)(Br,{display:"flex",alignItems:"center",justifyContent:"center",mb:2,children:[(0,hr.jsx)(Mo,{value:t,InputProps:{readOnly:!0},sx:{width:"80%"}}),(0,hr.jsx)(hl,{variant:"contained",color:"primary",onClick:()=>{navigator.clipboard.writeText(t),r(!0),setTimeout((()=>r(!1)),2e3)},sx:{ml:2},startIcon:(0,hr.jsx)($l.A,{}),children:"Copy"})]}),n&&(0,hr.jsx)(_l,{severity:"success",sx:{mb:2},onClose:()=>r(!1),children:"User ID copied to clipboard!"}),(0,hr.jsx)(Ir,{variant:"body2",textAlign:"center",children:"Kindly save this ID safely as it will be used to authenticate you."}),(0,hr.jsxs)(Ir,{variant:"body2",textAlign:"center",children:["Want to use this ID \xa0",(0,hr.jsx)(Rr,{component:"button",variant:"body2",onClick:()=>{a("/login")},children:"Click here to Login"})]})]})})};var Dl=n(7598),Ml=n(3860);const Fl=(0,Ml.Ay)(),Ol=(0,Hn.A)(),Pl=Fl("div",{name:"MuiContainer",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`maxWidth${(0,Dl.A)(String(n.maxWidth))}`],n.fixed&&t.fixed,n.disableGutters&&t.disableGutters]}}),Ll=e=>ko({props:e,name:"MuiContainer",defaultTheme:Ol});const zl=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{createStyledComponent:t=Pl,useThemeProps:n=Ll,componentName:r="MuiContainer"}=e,a=t((e=>{let{theme:t,ownerState:n}=e;return{width:"100%",marginLeft:"auto",boxSizing:"border-box",marginRight:"auto",...!n.disableGutters&&{paddingLeft:t.spacing(2),paddingRight:t.spacing(2),[t.breakpoints.up("sm")]:{paddingLeft:t.spacing(3),paddingRight:t.spacing(3)}}}}),(e=>{let{theme:t,ownerState:n}=e;return n.fixed&&Object.keys(t.breakpoints.values).reduce(((e,n)=>{const r=n,a=t.breakpoints.values[r];return 0!==a&&(e[t.breakpoints.up(r)]={maxWidth:`${a}${t.breakpoints.unit}`}),e}),{})}),(e=>{let{theme:t,ownerState:n}=e;return{..."xs"===n.maxWidth&&{[t.breakpoints.up("xs")]:{maxWidth:Math.max(t.breakpoints.values.xs,444)}},...n.maxWidth&&"xs"!==n.maxWidth&&{[t.breakpoints.up(n.maxWidth)]:{maxWidth:`${t.breakpoints.values[n.maxWidth]}${t.breakpoints.unit}`}}}})),s=T.forwardRef((function(e,t){const s=n(e),{className:i,component:o="div",disableGutters:l=!1,fixed:u=!1,maxWidth:c="lg",classes:d,...h}=s,p={...s,component:o,disableGutters:l,fixed:u,maxWidth:c},f=((e,t)=>{const{classes:n,fixed:r,disableGutters:a,maxWidth:s}=e,i={root:["root",s&&`maxWidth${(0,Dl.A)(String(s))}`,r&&"fixed",a&&"disableGutters"]};return(0,Vn.A)(i,(e=>(0,yr.Ay)(t,e)),n)})(p,r);return(0,hr.jsx)(a,{as:o,ownerState:p,className:(0,Bn.A)(f.root,i),ref:t,...h})}));return s}({createStyledComponent:(0,Gn.Ay)("div",{name:"MuiContainer",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`maxWidth${(0,jn.A)(String(n.maxWidth))}`],n.fixed&&t.fixed,n.disableGutters&&t.disableGutters]}}),useThemeProps:e=>So({props:e,name:"MuiContainer"})}),Bl=zl;function Wl(e){return(0,yr.Ay)("MuiDialog",e)}const Vl=(0,gr.A)("MuiDialog",["root","scrollPaper","scrollBody","container","paper","paperScrollPaper","paperScrollBody","paperWidthFalse","paperWidthXs","paperWidthSm","paperWidthMd","paperWidthLg","paperWidthXl","paperFullWidth","paperFullScreen"]);const Ul=T.createContext({}),jl=(0,Gn.Ay)(vi,{name:"MuiDialog",slot:"Backdrop",overrides:(e,t)=>t.backdrop})({zIndex:-1}),Gl=(0,Gn.Ay)(Di,{name:"MuiDialog",slot:"Root",overridesResolver:(e,t)=>t.root})({"@media print":{position:"absolute !important"}}),Hl=(0,Gn.Ay)("div",{name:"MuiDialog",slot:"Container",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.container,t[`scroll${(0,jn.A)(n.scroll)}`]]}})({height:"100%","@media print":{height:"auto"},outline:0,variants:[{props:{scroll:"paper"},style:{display:"flex",justifyContent:"center",alignItems:"center"}},{props:{scroll:"body"},style:{overflowY:"auto",overflowX:"hidden",textAlign:"center","&::after":{content:'""',display:"inline-block",verticalAlign:"middle",height:"100%",width:"0"}}}]}),ql=(0,Gn.Ay)(Gr,{name:"MuiDialog",slot:"Paper",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.paper,t[`scrollPaper${(0,jn.A)(n.scroll)}`],t[`paperWidth${(0,jn.A)(String(n.maxWidth))}`],n.fullWidth&&t.paperFullWidth,n.fullScreen&&t.paperFullScreen]}})((0,er.A)((e=>{let{theme:t}=e;return{margin:32,position:"relative","@media print":{overflowY:"visible",boxShadow:"none"},variants:[{props:{scroll:"paper"},style:{display:"flex",flexDirection:"column",maxHeight:"calc(100% - 64px)"}},{props:{scroll:"body"},style:{display:"inline-block",verticalAlign:"middle",textAlign:"initial"}},{props:e=>{let{ownerState:t}=e;return!t.maxWidth},style:{maxWidth:"calc(100% - 64px)"}},{props:{maxWidth:"xs"},style:{maxWidth:"px"===t.breakpoints.unit?Math.max(t.breakpoints.values.xs,444):`max(${t.breakpoints.values.xs}${t.breakpoints.unit}, 444px)`,[`&.${Vl.paperScrollBody}`]:{[t.breakpoints.down(Math.max(t.breakpoints.values.xs,444)+64)]:{maxWidth:"calc(100% - 64px)"}}}},...Object.keys(t.breakpoints.values).filter((e=>"xs"!==e)).map((e=>({props:{maxWidth:e},style:{maxWidth:`${t.breakpoints.values[e]}${t.breakpoints.unit}`,[`&.${Vl.paperScrollBody}`]:{[t.breakpoints.down(t.breakpoints.values[e]+64)]:{maxWidth:"calc(100% - 64px)"}}}}))),{props:e=>{let{ownerState:t}=e;return t.fullWidth},style:{width:"calc(100% - 64px)"}},{props:e=>{let{ownerState:t}=e;return t.fullScreen},style:{margin:0,width:"100%",maxWidth:"100%",height:"100%",maxHeight:"none",borderRadius:0,[`&.${Vl.paperScrollBody}`]:{margin:0,maxWidth:"100%"}}}]}}))),Kl=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiDialog"}),r=Zn(),a={enter:r.transitions.duration.enteringScreen,exit:r.transitions.duration.leavingScreen},{"aria-describedby":s,"aria-labelledby":i,BackdropComponent:o,BackdropProps:l,children:u,className:c,disableEscapeKeyDown:d=!1,fullScreen:h=!1,fullWidth:p=!1,maxWidth:f="sm",onBackdropClick:m,onClick:g,onClose:y,open:b,PaperComponent:v=Gr,PaperProps:x={},scroll:w="paper",TransitionComponent:k=gi,transitionDuration:S=a,TransitionProps:I,...C}=n,N={...n,disableEscapeKeyDown:d,fullScreen:h,fullWidth:p,maxWidth:f,scroll:w},E=(e=>{const{classes:t,scroll:n,maxWidth:r,fullWidth:a,fullScreen:s}=e,i={root:["root"],container:["container",`scroll${(0,jn.A)(n)}`],paper:["paper",`paperScroll${(0,jn.A)(n)}`,`paperWidth${(0,jn.A)(String(r))}`,a&&"paperFullWidth",s&&"paperFullScreen"]};return(0,Vn.A)(i,Wl,t)})(N),A=T.useRef(),_=(0,Hr.A)(i),$=T.useMemo((()=>({titleId:_})),[_]);return(0,hr.jsx)(Gl,{className:(0,Bn.A)(E.root,c),closeAfterTransition:!0,components:{Backdrop:jl},componentsProps:{backdrop:{transitionDuration:S,as:o,...l}},disableEscapeKeyDown:d,onClose:y,open:b,ref:t,onClick:e=>{g&&g(e),A.current&&(A.current=null,m&&m(e),y&&y(e,"backdropClick"))},ownerState:N,...C,children:(0,hr.jsx)(k,{appear:!0,in:b,timeout:S,role:"presentation",...I,children:(0,hr.jsx)(Hl,{className:(0,Bn.A)(E.container),onMouseDown:e=>{A.current=e.target===e.currentTarget},ownerState:N,children:(0,hr.jsx)(ql,{as:v,elevation:24,role:"dialog","aria-describedby":s,"aria-labelledby":_,...x,className:(0,Bn.A)(E.paper,x.className),ownerState:N,children:(0,hr.jsx)(Ul.Provider,{value:$,children:u})})})})})}));function Xl(e){return(0,yr.Ay)("MuiDialogTitle",e)}const Yl=(0,gr.A)("MuiDialogTitle",["root"]),Ql=(0,Gn.Ay)(Ir,{name:"MuiDialogTitle",slot:"Root",overridesResolver:(e,t)=>t.root})({padding:"16px 24px",flex:"0 0 auto"}),Jl=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiDialogTitle"}),{className:r,id:a,...s}=n,i=n,o=(e=>{const{classes:t}=e;return(0,Vn.A)({root:["root"]},Xl,t)})(i),{titleId:l=a}=T.useContext(Ul);return(0,hr.jsx)(Ql,{component:"h2",className:(0,Bn.A)(o.root,r),ownerState:i,ref:t,variant:"h6",id:a??l,...s})}));function Zl(e){return(0,yr.Ay)("MuiDialogContent",e)}(0,gr.A)("MuiDialogContent",["root","dividers"]);const eu=(0,Gn.Ay)("div",{name:"MuiDialogContent",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.dividers&&t.dividers]}})((0,er.A)((e=>{let{theme:t}=e;return{flex:"1 1 auto",WebkitOverflowScrolling:"touch",overflowY:"auto",padding:"20px 24px",variants:[{props:e=>{let{ownerState:t}=e;return t.dividers},style:{padding:"16px 24px",borderTop:`1px solid ${(t.vars||t).palette.divider}`,borderBottom:`1px solid ${(t.vars||t).palette.divider}`}},{props:e=>{let{ownerState:t}=e;return!t.dividers},style:{[`.${Yl.root} + &`]:{paddingTop:0}}}]}}))),tu=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiDialogContent"}),{className:r,dividers:a=!1,...s}=n,i={...n,dividers:a},o=(e=>{const{classes:t,dividers:n}=e,r={root:["root",n&&"dividers"]};return(0,Vn.A)(r,Zl,t)})(i);return(0,hr.jsx)(eu,{className:(0,Bn.A)(o.root,r),ownerState:i,ref:t,...s})}));function nu(e){return(0,yr.Ay)("MuiDialogActions",e)}(0,gr.A)("MuiDialogActions",["root","spacing"]);const ru=(0,Gn.Ay)("div",{name:"MuiDialogActions",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,!n.disableSpacing&&t.spacing]}})({display:"flex",alignItems:"center",padding:8,justifyContent:"flex-end",flex:"0 0 auto",variants:[{props:e=>{let{ownerState:t}=e;return!t.disableSpacing},style:{"& > :not(style) ~ :not(style)":{marginLeft:8}}}]}),au=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiDialogActions"}),{className:r,disableSpacing:a=!1,...s}=n,i={...n,disableSpacing:a},o=(e=>{const{classes:t,disableSpacing:n}=e,r={root:["root",!n&&"spacing"]};return(0,Vn.A)(r,nu,t)})(i);return(0,hr.jsx)(ru,{className:(0,Bn.A)(o.root,r),ownerState:i,ref:t,...s})}));var su=n(3531),iu=n(7948);const ou=function(e){const t=[];let n=0;for(let r=0;r<e.length;r++){let a=e.charCodeAt(r);a<128?t[n++]=a:a<2048?(t[n++]=a>>6|192,t[n++]=63&a|128):55296===(64512&a)&&r+1<e.length&&56320===(64512&e.charCodeAt(r+1))?(a=65536+((1023&a)<<10)+(1023&e.charCodeAt(++r)),t[n++]=a>>18|240,t[n++]=a>>12&63|128,t[n++]=a>>6&63|128,t[n++]=63&a|128):(t[n++]=a>>12|224,t[n++]=a>>6&63|128,t[n++]=63&a|128)}return t},lu={byteToCharMap_:null,charToByteMap_:null,byteToCharMapWebSafe_:null,charToByteMapWebSafe_:null,ENCODED_VALS_BASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",get ENCODED_VALS(){return this.ENCODED_VALS_BASE+"+/="},get ENCODED_VALS_WEBSAFE(){return this.ENCODED_VALS_BASE+"-_."},HAS_NATIVE_SUPPORT:"function"===typeof atob,encodeByteArray(e,t){if(!Array.isArray(e))throw Error("encodeByteArray takes an array as a parameter");this.init_();const n=t?this.byteToCharMapWebSafe_:this.byteToCharMap_,r=[];for(let a=0;a<e.length;a+=3){const t=e[a],s=a+1<e.length,i=s?e[a+1]:0,o=a+2<e.length,l=o?e[a+2]:0,u=t>>2,c=(3&t)<<4|i>>4;let d=(15&i)<<2|l>>6,h=63&l;o||(h=64,s||(d=64)),r.push(n[u],n[c],n[d],n[h])}return r.join("")},encodeString(e,t){return this.HAS_NATIVE_SUPPORT&&!t?btoa(e):this.encodeByteArray(ou(e),t)},decodeString(e,t){return this.HAS_NATIVE_SUPPORT&&!t?atob(e):function(e){const t=[];let n=0,r=0;for(;n<e.length;){const a=e[n++];if(a<128)t[r++]=String.fromCharCode(a);else if(a>191&&a<224){const s=e[n++];t[r++]=String.fromCharCode((31&a)<<6|63&s)}else if(a>239&&a<365){const s=((7&a)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536;t[r++]=String.fromCharCode(55296+(s>>10)),t[r++]=String.fromCharCode(56320+(1023&s))}else{const s=e[n++],i=e[n++];t[r++]=String.fromCharCode((15&a)<<12|(63&s)<<6|63&i)}}return t.join("")}(this.decodeStringToByteArray(e,t))},decodeStringToByteArray(e,t){this.init_();const n=t?this.charToByteMapWebSafe_:this.charToByteMap_,r=[];for(let a=0;a<e.length;){const t=n[e.charAt(a++)],s=a<e.length?n[e.charAt(a)]:0;++a;const i=a<e.length?n[e.charAt(a)]:64;++a;const o=a<e.length?n[e.charAt(a)]:64;if(++a,null==t||null==s||null==i||null==o)throw new uu;const l=t<<2|s>>4;if(r.push(l),64!==i){const e=s<<4&240|i>>2;if(r.push(e),64!==o){const e=i<<6&192|o;r.push(e)}}}return r},init_(){if(!this.byteToCharMap_){this.byteToCharMap_={},this.charToByteMap_={},this.byteToCharMapWebSafe_={},this.charToByteMapWebSafe_={};for(let e=0;e<this.ENCODED_VALS.length;e++)this.byteToCharMap_[e]=this.ENCODED_VALS.charAt(e),this.charToByteMap_[this.byteToCharMap_[e]]=e,this.byteToCharMapWebSafe_[e]=this.ENCODED_VALS_WEBSAFE.charAt(e),this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]]=e,e>=this.ENCODED_VALS_BASE.length&&(this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)]=e,this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)]=e)}}};class uu extends Error{constructor(){super(...arguments),this.name="DecodeBase64StringError"}}const cu=function(e){return function(e){const t=ou(e);return lu.encodeByteArray(t,!0)}(e).replace(/\./g,"")},du=function(e){try{return lu.decodeString(e,!0)}catch(mD){console.error("base64Decode failed: ",mD)}return null};const hu=()=>function(){if("undefined"!==typeof self)return self;if("undefined"!==typeof window)return window;if("undefined"!==typeof n.g)return n.g;throw new Error("Unable to locate global object.")}().__FIREBASE_DEFAULTS__,pu=()=>{try{return hu()||(()=>{if("undefined"===typeof process)return;const e={NODE_ENV:"production",PUBLIC_URL:"/auth-tfjs",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0,REACT_APP_API_KEY:"'AIzaSyCMm9VBymR43tOkkv4wQ6szA2yGfH3j3RE';",REACT_APP_APP_ID:"1:1021363670094:web:252b1088a0266e0573c71f",REACT_APP_ENV_SENDER_ID:"1021363670094",REACT_APP_TOKEN:"d891e715-d5ab-49ee-8c4c-d14c25d7fb7a"}.__FIREBASE_DEFAULTS__;return e?JSON.parse(e):void 0})()||(()=>{if("undefined"===typeof document)return;let e;try{e=document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)}catch(mD){return}const t=e&&du(e[1]);return t&&JSON.parse(t)})()}catch(mD){return void console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${mD}`)}},fu=e=>{const t=(e=>{var t,n;return null===(n=null===(t=pu())||void 0===t?void 0:t.emulatorHosts)||void 0===n?void 0:n[e]})(e);if(!t)return;const n=t.lastIndexOf(":");if(n<=0||n+1===t.length)throw new Error(`Invalid host ${t} with no separate hostname and port!`);const r=parseInt(t.substring(n+1),10);return"["===t[0]?[t.substring(1,n-1),r]:[t.substring(0,n),r]},mu=()=>{var e;return null===(e=pu())||void 0===e?void 0:e.config};class gu{constructor(){this.reject=()=>{},this.resolve=()=>{},this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}wrapCallback(e){return(t,n)=>{t?this.reject(t):this.resolve(n),"function"===typeof e&&(this.promise.catch((()=>{})),1===e.length?e(t):e(t,n))}}}function yu(){return"undefined"!==typeof navigator&&"string"===typeof navigator.userAgent?navigator.userAgent:""}function bu(){return!function(){var e;const t=null===(e=pu())||void 0===e?void 0:e.forceEnvironment;if("node"===t)return!0;if("browser"===t)return!1;try{return"[object process]"===Object.prototype.toString.call(n.g.process)}catch(mD){return!1}}()&&!!navigator.userAgent&&navigator.userAgent.includes("Safari")&&!navigator.userAgent.includes("Chrome")}function vu(){try{return"object"===typeof indexedDB}catch(mD){return!1}}class xu extends Error{constructor(e,t,n){super(t),this.code=e,this.customData=n,this.name="FirebaseError",Object.setPrototypeOf(this,xu.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,wu.prototype.create)}}class wu{constructor(e,t,n){this.service=e,this.serviceName=t,this.errors=n}create(e){const t=(arguments.length<=1?void 0:arguments[1])||{},n=`${this.service}/${e}`,r=this.errors[e],a=r?function(e,t){return e.replace(ku,((e,n)=>{const r=t[n];return null!=r?String(r):`<${n}?>`}))}(r,t):"Error",s=`${this.serviceName}: ${a} (${n}).`;return new xu(n,s,t)}}const ku=/\{\$([^}]+)}/g;function Su(e,t){if(e===t)return!0;const n=Object.keys(e),r=Object.keys(t);for(const a of n){if(!r.includes(a))return!1;const n=e[a],s=t[a];if(Iu(n)&&Iu(s)){if(!Su(n,s))return!1}else if(n!==s)return!1}for(const a of r)if(!n.includes(a))return!1;return!0}function Iu(e){return null!==e&&"object"===typeof e}function Cu(e){return e&&e._delegate?e._delegate:e}class Nu{constructor(e,t,n){this.name=e,this.instanceFactory=t,this.type=n,this.multipleInstances=!1,this.serviceProps={},this.instantiationMode="LAZY",this.onInstanceCreated=null}setInstantiationMode(e){return this.instantiationMode=e,this}setMultipleInstances(e){return this.multipleInstances=e,this}setServiceProps(e){return this.serviceProps=e,this}setInstanceCreatedCallback(e){return this.onInstanceCreated=e,this}}const Tu="[DEFAULT]";class Eu{constructor(e,t){this.name=e,this.container=t,this.component=null,this.instances=new Map,this.instancesDeferred=new Map,this.instancesOptions=new Map,this.onInitCallbacks=new Map}get(e){const t=this.normalizeInstanceIdentifier(e);if(!this.instancesDeferred.has(t)){const e=new gu;if(this.instancesDeferred.set(t,e),this.isInitialized(t)||this.shouldAutoInitialize())try{const n=this.getOrInitializeService({instanceIdentifier:t});n&&e.resolve(n)}catch(mD){}}return this.instancesDeferred.get(t).promise}getImmediate(e){var t;const n=this.normalizeInstanceIdentifier(null===e||void 0===e?void 0:e.identifier),r=null!==(t=null===e||void 0===e?void 0:e.optional)&&void 0!==t&&t;if(!this.isInitialized(n)&&!this.shouldAutoInitialize()){if(r)return null;throw Error(`Service ${this.name} is not available`)}try{return this.getOrInitializeService({instanceIdentifier:n})}catch(mD){if(r)return null;throw mD}}getComponent(){return this.component}setComponent(e){if(e.name!==this.name)throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);if(this.component)throw Error(`Component for ${this.name} has already been provided`);if(this.component=e,this.shouldAutoInitialize()){if(function(e){return"EAGER"===e.instantiationMode}(e))try{this.getOrInitializeService({instanceIdentifier:Tu})}catch(mD){}for(const[e,t]of this.instancesDeferred.entries()){const n=this.normalizeInstanceIdentifier(e);try{const e=this.getOrInitializeService({instanceIdentifier:n});t.resolve(e)}catch(mD){}}}}clearInstance(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Tu;this.instancesDeferred.delete(e),this.instancesOptions.delete(e),this.instances.delete(e)}async delete(){const e=Array.from(this.instances.values());await Promise.all([...e.filter((e=>"INTERNAL"in e)).map((e=>e.INTERNAL.delete())),...e.filter((e=>"_delete"in e)).map((e=>e._delete()))])}isComponentSet(){return null!=this.component}isInitialized(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Tu;return this.instances.has(e)}getOptions(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Tu;return this.instancesOptions.get(e)||{}}initialize(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{options:t={}}=e,n=this.normalizeInstanceIdentifier(e.instanceIdentifier);if(this.isInitialized(n))throw Error(`${this.name}(${n}) has already been initialized`);if(!this.isComponentSet())throw Error(`Component ${this.name} has not been registered yet`);const r=this.getOrInitializeService({instanceIdentifier:n,options:t});for(const[a,s]of this.instancesDeferred.entries()){n===this.normalizeInstanceIdentifier(a)&&s.resolve(r)}return r}onInit(e,t){var n;const r=this.normalizeInstanceIdentifier(t),a=null!==(n=this.onInitCallbacks.get(r))&&void 0!==n?n:new Set;a.add(e),this.onInitCallbacks.set(r,a);const s=this.instances.get(r);return s&&e(s,r),()=>{a.delete(e)}}invokeOnInitCallbacks(e,t){const n=this.onInitCallbacks.get(t);if(n)for(const r of n)try{r(e,t)}catch(eL){}}getOrInitializeService(e){let{instanceIdentifier:t,options:n={}}=e,r=this.instances.get(t);if(!r&&this.component&&(r=this.component.instanceFactory(this.container,{instanceIdentifier:Au(t),options:n}),this.instances.set(t,r),this.instancesOptions.set(t,n),this.invokeOnInitCallbacks(r,t),this.component.onInstanceCreated))try{this.component.onInstanceCreated(this.container,t,r)}catch(eL){}return r||null}normalizeInstanceIdentifier(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Tu;return this.component?this.component.multipleInstances?e:Tu:e}shouldAutoInitialize(){return!!this.component&&"EXPLICIT"!==this.component.instantiationMode}}function Au(e){return e===Tu?void 0:e}class _u{constructor(e){this.name=e,this.providers=new Map}addComponent(e){const t=this.getProvider(e.name);if(t.isComponentSet())throw new Error(`Component ${e.name} has already been registered with ${this.name}`);t.setComponent(e)}addOrOverwriteComponent(e){this.getProvider(e.name).isComponentSet()&&this.providers.delete(e.name),this.addComponent(e)}getProvider(e){if(this.providers.has(e))return this.providers.get(e);const t=new Eu(e,this);return this.providers.set(e,t),t}getProviders(){return Array.from(this.providers.values())}}const $u=[];var Ru;!function(e){e[e.DEBUG=0]="DEBUG",e[e.VERBOSE=1]="VERBOSE",e[e.INFO=2]="INFO",e[e.WARN=3]="WARN",e[e.ERROR=4]="ERROR",e[e.SILENT=5]="SILENT"}(Ru||(Ru={}));const Du={debug:Ru.DEBUG,verbose:Ru.VERBOSE,info:Ru.INFO,warn:Ru.WARN,error:Ru.ERROR,silent:Ru.SILENT},Mu=Ru.INFO,Fu={[Ru.DEBUG]:"log",[Ru.VERBOSE]:"log",[Ru.INFO]:"info",[Ru.WARN]:"warn",[Ru.ERROR]:"error"},Ou=function(e,t){if(t<e.logLevel)return;const n=(new Date).toISOString(),r=Fu[t];if(!r)throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);for(var a=arguments.length,s=new Array(a>2?a-2:0),i=2;i<a;i++)s[i-2]=arguments[i];console[r](`[${n}]  ${e.name}:`,...s)};class Pu{constructor(e){this.name=e,this._logLevel=Mu,this._logHandler=Ou,this._userLogHandler=null,$u.push(this)}get logLevel(){return this._logLevel}set logLevel(e){if(!(e in Ru))throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);this._logLevel=e}setLogLevel(e){this._logLevel="string"===typeof e?Du[e]:e}get logHandler(){return this._logHandler}set logHandler(e){if("function"!==typeof e)throw new TypeError("Value assigned to `logHandler` must be a function");this._logHandler=e}get userLogHandler(){return this._userLogHandler}set userLogHandler(e){this._userLogHandler=e}debug(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,Ru.DEBUG,...t),this._logHandler(this,Ru.DEBUG,...t)}log(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,Ru.VERBOSE,...t),this._logHandler(this,Ru.VERBOSE,...t)}info(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,Ru.INFO,...t),this._logHandler(this,Ru.INFO,...t)}warn(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,Ru.WARN,...t),this._logHandler(this,Ru.WARN,...t)}error(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,Ru.ERROR,...t),this._logHandler(this,Ru.ERROR,...t)}}const Lu=(e,t)=>t.some((t=>e instanceof t));let zu,Bu;const Wu=new WeakMap,Vu=new WeakMap,Uu=new WeakMap,ju=new WeakMap,Gu=new WeakMap;let Hu={get(e,t,n){if(e instanceof IDBTransaction){if("done"===t)return Vu.get(e);if("objectStoreNames"===t)return e.objectStoreNames||Uu.get(e);if("store"===t)return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return Xu(e[t])},set:(e,t,n)=>(e[t]=n,!0),has:(e,t)=>e instanceof IDBTransaction&&("done"===t||"store"===t)||t in e};function qu(e){return e!==IDBDatabase.prototype.transaction||"objectStoreNames"in IDBTransaction.prototype?(Bu||(Bu=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(e)?function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return e.apply(Yu(this),n),Xu(Wu.get(this))}:function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return Xu(e.apply(Yu(this),n))}:function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];const s=e.call(Yu(this),t,...r);return Uu.set(s,t.sort?t.sort():[t]),Xu(s)}}function Ku(e){return"function"===typeof e?qu(e):(e instanceof IDBTransaction&&function(e){if(Vu.has(e))return;const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("complete",a),e.removeEventListener("error",s),e.removeEventListener("abort",s)},a=()=>{t(),r()},s=()=>{n(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",a),e.addEventListener("error",s),e.addEventListener("abort",s)}));Vu.set(e,t)}(e),Lu(e,zu||(zu=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction]))?new Proxy(e,Hu):e)}function Xu(e){if(e instanceof IDBRequest)return function(e){const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("success",a),e.removeEventListener("error",s)},a=()=>{t(Xu(e.result)),r()},s=()=>{n(e.error),r()};e.addEventListener("success",a),e.addEventListener("error",s)}));return t.then((t=>{t instanceof IDBCursor&&Wu.set(t,e)})).catch((()=>{})),Gu.set(t,e),t}(e);if(ju.has(e))return ju.get(e);const t=Ku(e);return t!==e&&(ju.set(e,t),Gu.set(t,e)),t}const Yu=e=>Gu.get(e);const Qu=["get","getKey","getAll","getAllKeys","count"],Ju=["put","add","delete","clear"],Zu=new Map;function ec(e,t){if(!(e instanceof IDBDatabase)||t in e||"string"!==typeof t)return;if(Zu.get(t))return Zu.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,a=Ju.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!a&&!Qu.includes(n))return;const s=async function(e){const t=this.transaction(e,a?"readwrite":"readonly");let s=t.store;for(var i=arguments.length,o=new Array(i>1?i-1:0),l=1;l<i;l++)o[l-1]=arguments[l];return r&&(s=s.index(o.shift())),(await Promise.all([s[n](...o),a&&t.done]))[0]};return Zu.set(t,s),s}Hu=(e=>({...e,get:(t,n,r)=>ec(t,n)||e.get(t,n,r),has:(t,n)=>!!ec(t,n)||e.has(t,n)}))(Hu);class tc{constructor(e){this.container=e}getPlatformInfoString(){return this.container.getProviders().map((e=>{if(function(e){const t=e.getComponent();return"VERSION"===(null===t||void 0===t?void 0:t.type)}(e)){const t=e.getImmediate();return`${t.library}/${t.version}`}return null})).filter((e=>e)).join(" ")}}const nc="@firebase/app",rc="0.10.10",ac=new Pu("@firebase/app"),sc="@firebase/app-compat",ic="@firebase/analytics-compat",oc="@firebase/analytics",lc="@firebase/app-check-compat",uc="@firebase/app-check",cc="@firebase/auth",dc="@firebase/auth-compat",hc="@firebase/database",pc="@firebase/database-compat",fc="@firebase/functions",mc="@firebase/functions-compat",gc="@firebase/installations",yc="@firebase/installations-compat",bc="@firebase/messaging",vc="@firebase/messaging-compat",xc="@firebase/performance",wc="@firebase/performance-compat",kc="@firebase/remote-config",Sc="@firebase/remote-config-compat",Ic="@firebase/storage",Cc="@firebase/storage-compat",Nc="@firebase/firestore",Tc="@firebase/vertexai-preview",Ec="@firebase/firestore-compat",Ac="firebase",_c="[DEFAULT]",$c={[nc]:"fire-core",[sc]:"fire-core-compat",[oc]:"fire-analytics",[ic]:"fire-analytics-compat",[uc]:"fire-app-check",[lc]:"fire-app-check-compat",[cc]:"fire-auth",[dc]:"fire-auth-compat",[hc]:"fire-rtdb",[pc]:"fire-rtdb-compat",[fc]:"fire-fn",[mc]:"fire-fn-compat",[gc]:"fire-iid",[yc]:"fire-iid-compat",[bc]:"fire-fcm",[vc]:"fire-fcm-compat",[xc]:"fire-perf",[wc]:"fire-perf-compat",[kc]:"fire-rc",[Sc]:"fire-rc-compat",[Ic]:"fire-gcs",[Cc]:"fire-gcs-compat",[Nc]:"fire-fst",[Ec]:"fire-fst-compat",[Tc]:"fire-vertex","fire-js":"fire-js",[Ac]:"fire-js-all"},Rc=new Map,Dc=new Map,Mc=new Map;function Fc(e,t){try{e.container.addComponent(t)}catch(mD){ac.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`,mD)}}function Oc(e){const t=e.name;if(Mc.has(t))return ac.debug(`There were multiple attempts to register component ${t}.`),!1;Mc.set(t,e);for(const n of Rc.values())Fc(n,e);for(const n of Dc.values())Fc(n,e);return!0}function Pc(e,t){const n=e.container.getProvider("heartbeat").getImmediate({optional:!0});return n&&n.triggerHeartbeat(),e.container.getProvider(t)}const Lc=new wu("app","Firebase",{"no-app":"No Firebase App '{$appName}' has been created - call initializeApp() first","bad-app-name":"Illegal App name: '{$appName}'","duplicate-app":"Firebase App named '{$appName}' already exists with different options or config","app-deleted":"Firebase App named '{$appName}' already deleted","server-app-deleted":"Firebase Server App has been deleted","no-options":"Need to provide options, when not being deployed to hosting via source.","invalid-app-argument":"firebase.{$appName}() takes either no argument or a Firebase App instance.","invalid-log-argument":"First argument to `onLog` must be null or a function.","idb-open":"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.","idb-get":"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.","idb-set":"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.","idb-delete":"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.","finalization-registry-not-supported":"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.","invalid-server-app-environment":"FirebaseServerApp is not for use in browser environments."});class zc{constructor(e,t,n){this._isDeleted=!1,this._options=Object.assign({},e),this._config=Object.assign({},t),this._name=t.name,this._automaticDataCollectionEnabled=t.automaticDataCollectionEnabled,this._container=n,this.container.addComponent(new Nu("app",(()=>this),"PUBLIC"))}get automaticDataCollectionEnabled(){return this.checkDestroyed(),this._automaticDataCollectionEnabled}set automaticDataCollectionEnabled(e){this.checkDestroyed(),this._automaticDataCollectionEnabled=e}get name(){return this.checkDestroyed(),this._name}get options(){return this.checkDestroyed(),this._options}get config(){return this.checkDestroyed(),this._config}get container(){return this._container}get isDeleted(){return this._isDeleted}set isDeleted(e){this._isDeleted=e}checkDestroyed(){if(this.isDeleted)throw Lc.create("app-deleted",{appName:this._name})}}function Bc(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e;if("object"!==typeof t){t={name:t}}const r=Object.assign({name:_c,automaticDataCollectionEnabled:!1},t),a=r.name;if("string"!==typeof a||!a)throw Lc.create("bad-app-name",{appName:String(a)});if(n||(n=mu()),!n)throw Lc.create("no-options");const s=Rc.get(a);if(s){if(Su(n,s.options)&&Su(r,s.config))return s;throw Lc.create("duplicate-app",{appName:a})}const i=new _u(a);for(const l of Mc.values())i.addComponent(l);const o=new zc(n,r,i);return Rc.set(a,o),o}function Wc(e,t,n){var r;let a=null!==(r=$c[e])&&void 0!==r?r:e;n&&(a+=`-${n}`);const s=a.match(/\s|\//),i=t.match(/\s|\//);if(s||i){const e=[`Unable to register library "${a}" with version "${t}":`];return s&&e.push(`library name "${a}" contains illegal characters (whitespace or "/")`),s&&i&&e.push("and"),i&&e.push(`version name "${t}" contains illegal characters (whitespace or "/")`),void ac.warn(e.join(" "))}Oc(new Nu(`${a}-version`,(()=>({library:a,version:t})),"VERSION"))}const Vc="firebase-heartbeat-database",Uc=1,jc="firebase-heartbeat-store";let Gc=null;function Hc(){return Gc||(Gc=function(e,t){let{blocked:n,upgrade:r,blocking:a,terminated:s}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=indexedDB.open(e,t),o=Xu(i);return r&&i.addEventListener("upgradeneeded",(e=>{r(Xu(i.result),e.oldVersion,e.newVersion,Xu(i.transaction),e)})),n&&i.addEventListener("blocked",(e=>n(e.oldVersion,e.newVersion,e))),o.then((e=>{s&&e.addEventListener("close",(()=>s())),a&&e.addEventListener("versionchange",(e=>a(e.oldVersion,e.newVersion,e)))})).catch((()=>{})),o}(Vc,Uc,{upgrade:(e,t)=>{if(0===t)try{e.createObjectStore(jc)}catch(mD){console.warn(mD)}}}).catch((e=>{throw Lc.create("idb-open",{originalErrorMessage:e.message})}))),Gc}async function qc(e,t){try{const n=(await Hc()).transaction(jc,"readwrite"),r=n.objectStore(jc);await r.put(t,Kc(e)),await n.done}catch(mD){if(mD instanceof xu)ac.warn(mD.message);else{const t=Lc.create("idb-set",{originalErrorMessage:null===mD||void 0===mD?void 0:mD.message});ac.warn(t.message)}}}function Kc(e){return`${e.name}!${e.options.appId}`}class Xc{constructor(e){this.container=e,this._heartbeatsCache=null;const t=this.container.getProvider("app").getImmediate();this._storage=new Qc(t),this._heartbeatsCachePromise=this._storage.read().then((e=>(this._heartbeatsCache=e,e)))}async triggerHeartbeat(){var e,t;try{const n=this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),r=Yc();if(null==(null===(e=this._heartbeatsCache)||void 0===e?void 0:e.heartbeats)&&(this._heartbeatsCache=await this._heartbeatsCachePromise,null==(null===(t=this._heartbeatsCache)||void 0===t?void 0:t.heartbeats)))return;if(this._heartbeatsCache.lastSentHeartbeatDate===r||this._heartbeatsCache.heartbeats.some((e=>e.date===r)))return;return this._heartbeatsCache.heartbeats.push({date:r,agent:n}),this._heartbeatsCache.heartbeats=this._heartbeatsCache.heartbeats.filter((e=>{const t=new Date(e.date).valueOf();return Date.now()-t<=2592e6})),this._storage.overwrite(this._heartbeatsCache)}catch(mD){ac.warn(mD)}}async getHeartbeatsHeader(){var e;try{if(null===this._heartbeatsCache&&await this._heartbeatsCachePromise,null==(null===(e=this._heartbeatsCache)||void 0===e?void 0:e.heartbeats)||0===this._heartbeatsCache.heartbeats.length)return"";const t=Yc(),{heartbeatsToSend:n,unsentEntries:r}=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1024;const n=[];let r=e.slice();for(const a of e){const e=n.find((e=>e.agent===a.agent));if(e){if(e.dates.push(a.date),Jc(n)>t){e.dates.pop();break}}else if(n.push({agent:a.agent,dates:[a.date]}),Jc(n)>t){n.pop();break}r=r.slice(1)}return{heartbeatsToSend:n,unsentEntries:r}}(this._heartbeatsCache.heartbeats),a=cu(JSON.stringify({version:2,heartbeats:n}));return this._heartbeatsCache.lastSentHeartbeatDate=t,r.length>0?(this._heartbeatsCache.heartbeats=r,await this._storage.overwrite(this._heartbeatsCache)):(this._heartbeatsCache.heartbeats=[],this._storage.overwrite(this._heartbeatsCache)),a}catch(mD){return ac.warn(mD),""}}}function Yc(){return(new Date).toISOString().substring(0,10)}class Qc{constructor(e){this.app=e,this._canUseIndexedDBPromise=this.runIndexedDBEnvironmentCheck()}async runIndexedDBEnvironmentCheck(){return!!vu()&&new Promise(((e,t)=>{try{let n=!0;const r="validate-browser-context-for-indexeddb-analytics-module",a=self.indexedDB.open(r);a.onsuccess=()=>{a.result.close(),n||self.indexedDB.deleteDatabase(r),e(!0)},a.onupgradeneeded=()=>{n=!1},a.onerror=()=>{var e;t((null===(e=a.error)||void 0===e?void 0:e.message)||"")}}catch(n){t(n)}})).then((()=>!0)).catch((()=>!1))}async read(){if(await this._canUseIndexedDBPromise){const e=await async function(e){try{const t=(await Hc()).transaction(jc),n=await t.objectStore(jc).get(Kc(e));return await t.done,n}catch(mD){if(mD instanceof xu)ac.warn(mD.message);else{const t=Lc.create("idb-get",{originalErrorMessage:null===mD||void 0===mD?void 0:mD.message});ac.warn(t.message)}}}(this.app);return(null===e||void 0===e?void 0:e.heartbeats)?e:{heartbeats:[]}}return{heartbeats:[]}}async overwrite(e){var t;if(await this._canUseIndexedDBPromise){const n=await this.read();return qc(this.app,{lastSentHeartbeatDate:null!==(t=e.lastSentHeartbeatDate)&&void 0!==t?t:n.lastSentHeartbeatDate,heartbeats:e.heartbeats})}}async add(e){var t;if(await this._canUseIndexedDBPromise){const n=await this.read();return qc(this.app,{lastSentHeartbeatDate:null!==(t=e.lastSentHeartbeatDate)&&void 0!==t?t:n.lastSentHeartbeatDate,heartbeats:[...n.heartbeats,...e.heartbeats]})}}}function Jc(e){return cu(JSON.stringify({version:2,heartbeats:e})).length}var Zc;Zc="",Oc(new Nu("platform-logger",(e=>new tc(e)),"PRIVATE")),Oc(new Nu("heartbeat",(e=>new Xc(e)),"PRIVATE")),Wc(nc,rc,Zc),Wc(nc,rc,"esm2017"),Wc("fire-js","");var ed,td,nd="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{},rd={};(function(){var e;function t(){this.blockSize=-1,this.blockSize=64,this.g=Array(4),this.B=Array(this.blockSize),this.o=this.h=0,this.s()}function n(e,t,n){n||(n=0);var r=Array(16);if("string"===typeof t)for(var a=0;16>a;++a)r[a]=t.charCodeAt(n++)|t.charCodeAt(n++)<<8|t.charCodeAt(n++)<<16|t.charCodeAt(n++)<<24;else for(a=0;16>a;++a)r[a]=t[n++]|t[n++]<<8|t[n++]<<16|t[n++]<<24;t=e.g[0],n=e.g[1],a=e.g[2];var s=e.g[3],i=t+(s^n&(a^s))+r[0]+3614090360&4294967295;i=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=n+(i<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[1]+3905402710&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[2]+606105819&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[3]+3250441966&4294967295)<<22&4294967295|i>>>10))+((i=t+(s^n&(a^s))+r[4]+4118548399&4294967295)<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[5]+1200080426&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[6]+2821735955&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[7]+4249261313&4294967295)<<22&4294967295|i>>>10))+((i=t+(s^n&(a^s))+r[8]+1770035416&4294967295)<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[9]+2336552879&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[10]+4294925233&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[11]+2304563134&4294967295)<<22&4294967295|i>>>10))+((i=t+(s^n&(a^s))+r[12]+1804603682&4294967295)<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[13]+4254626195&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[14]+2792965006&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[15]+1236535329&4294967295)<<22&4294967295|i>>>10))+((i=t+(a^s&(n^a))+r[1]+4129170786&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[6]+3225465664&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[11]+643717713&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[0]+3921069994&4294967295)<<20&4294967295|i>>>12))+((i=t+(a^s&(n^a))+r[5]+3593408605&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[10]+38016083&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[15]+3634488961&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[4]+3889429448&4294967295)<<20&4294967295|i>>>12))+((i=t+(a^s&(n^a))+r[9]+568446438&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[14]+3275163606&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[3]+4107603335&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[8]+1163531501&4294967295)<<20&4294967295|i>>>12))+((i=t+(a^s&(n^a))+r[13]+2850285829&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[2]+4243563512&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[7]+1735328473&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[12]+2368359562&4294967295)<<20&4294967295|i>>>12))+((i=t+(n^a^s)+r[5]+4294588738&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[8]+2272392833&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[11]+1839030562&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[14]+4259657740&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^a^s)+r[1]+2763975236&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[4]+1272893353&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[7]+4139469664&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[10]+3200236656&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^a^s)+r[13]+681279174&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[0]+3936430074&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[3]+3572445317&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[6]+76029189&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^a^s)+r[9]+3654602809&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[12]+3873151461&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[15]+530742520&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[2]+3299628645&4294967295)<<23&4294967295|i>>>9))+((i=t+(a^(n|~s))+r[0]+4096336452&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[7]+1126891415&4294967295)<<10&4294967295|i>>>22))+((i=a+(t^(s|~n))+r[14]+2878612391&4294967295)<<15&4294967295|i>>>17))+((i=n+(s^(a|~t))+r[5]+4237533241&4294967295)<<21&4294967295|i>>>11))+((i=t+(a^(n|~s))+r[12]+1700485571&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[3]+2399980690&4294967295)<<10&4294967295|i>>>22))+((i=a+(t^(s|~n))+r[10]+4293915773&4294967295)<<15&4294967295|i>>>17))+((i=n+(s^(a|~t))+r[1]+2240044497&4294967295)<<21&4294967295|i>>>11))+((i=t+(a^(n|~s))+r[8]+1873313359&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[15]+4264355552&4294967295)<<10&4294967295|i>>>22))+((i=a+(t^(s|~n))+r[6]+2734768916&4294967295)<<15&4294967295|i>>>17))+((i=n+(s^(a|~t))+r[13]+1309151649&4294967295)<<21&4294967295|i>>>11))+((s=(t=n+((i=t+(a^(n|~s))+r[4]+4149444226&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[11]+3174756917&4294967295)<<10&4294967295|i>>>22))^((a=s+((i=a+(t^(s|~n))+r[2]+718787259&4294967295)<<15&4294967295|i>>>17))|~t))+r[9]+3951481745&4294967295,e.g[0]=e.g[0]+t&4294967295,e.g[1]=e.g[1]+(a+(i<<21&4294967295|i>>>11))&4294967295,e.g[2]=e.g[2]+a&4294967295,e.g[3]=e.g[3]+s&4294967295}function r(e,t){this.h=t;for(var n=[],r=!0,a=e.length-1;0<=a;a--){var s=0|e[a];r&&s==t||(n[a]=s,r=!1)}this.g=n}!function(e,t){function n(){}n.prototype=t.prototype,e.D=t.prototype,e.prototype=new n,e.prototype.constructor=e,e.C=function(e,n,r){for(var a=Array(arguments.length-2),s=2;s<arguments.length;s++)a[s-2]=arguments[s];return t.prototype[n].apply(e,a)}}(t,(function(){this.blockSize=-1})),t.prototype.s=function(){this.g[0]=1732584193,this.g[1]=4023233417,this.g[2]=2562383102,this.g[3]=271733878,this.o=this.h=0},t.prototype.u=function(e,t){void 0===t&&(t=e.length);for(var r=t-this.blockSize,a=this.B,s=this.h,i=0;i<t;){if(0==s)for(;i<=r;)n(this,e,i),i+=this.blockSize;if("string"===typeof e){for(;i<t;)if(a[s++]=e.charCodeAt(i++),s==this.blockSize){n(this,a),s=0;break}}else for(;i<t;)if(a[s++]=e[i++],s==this.blockSize){n(this,a),s=0;break}}this.h=s,this.o+=t},t.prototype.v=function(){var e=Array((56>this.h?this.blockSize:2*this.blockSize)-this.h);e[0]=128;for(var t=1;t<e.length-8;++t)e[t]=0;var n=8*this.o;for(t=e.length-8;t<e.length;++t)e[t]=255&n,n/=256;for(this.u(e),e=Array(16),t=n=0;4>t;++t)for(var r=0;32>r;r+=8)e[n++]=this.g[t]>>>r&255;return e};var a={};function s(e){return-128<=e&&128>e?function(e,t){var n=a;return Object.prototype.hasOwnProperty.call(n,e)?n[e]:n[e]=t(e)}(e,(function(e){return new r([0|e],0>e?-1:0)})):new r([0|e],0>e?-1:0)}function i(e){if(isNaN(e)||!isFinite(e))return o;if(0>e)return h(i(-e));for(var t=[],n=1,a=0;e>=n;a++)t[a]=e/n|0,n*=4294967296;return new r(t,0)}var o=s(0),l=s(1),u=s(16777216);function c(e){if(0!=e.h)return!1;for(var t=0;t<e.g.length;t++)if(0!=e.g[t])return!1;return!0}function d(e){return-1==e.h}function h(e){for(var t=e.g.length,n=[],a=0;a<t;a++)n[a]=~e.g[a];return new r(n,~e.h).add(l)}function p(e,t){return e.add(h(t))}function f(e,t){for(;(65535&e[t])!=e[t];)e[t+1]+=e[t]>>>16,e[t]&=65535,t++}function m(e,t){this.g=e,this.h=t}function g(e,t){if(c(t))throw Error("division by zero");if(c(e))return new m(o,o);if(d(e))return t=g(h(e),t),new m(h(t.g),h(t.h));if(d(t))return t=g(e,h(t)),new m(h(t.g),t.h);if(30<e.g.length){if(d(e)||d(t))throw Error("slowDivide_ only works with positive integers.");for(var n=l,r=t;0>=r.l(e);)n=y(n),r=y(r);var a=b(n,1),s=b(r,1);for(r=b(r,2),n=b(n,2);!c(r);){var u=s.add(r);0>=u.l(e)&&(a=a.add(n),s=u),r=b(r,1),n=b(n,1)}return t=p(e,a.j(t)),new m(a,t)}for(a=o;0<=e.l(t);){for(n=Math.max(1,Math.floor(e.m()/t.m())),r=48>=(r=Math.ceil(Math.log(n)/Math.LN2))?1:Math.pow(2,r-48),u=(s=i(n)).j(t);d(u)||0<u.l(e);)u=(s=i(n-=r)).j(t);c(s)&&(s=l),a=a.add(s),e=p(e,u)}return new m(a,e)}function y(e){for(var t=e.g.length+1,n=[],a=0;a<t;a++)n[a]=e.i(a)<<1|e.i(a-1)>>>31;return new r(n,e.h)}function b(e,t){var n=t>>5;t%=32;for(var a=e.g.length-n,s=[],i=0;i<a;i++)s[i]=0<t?e.i(i+n)>>>t|e.i(i+n+1)<<32-t:e.i(i+n);return new r(s,e.h)}(e=r.prototype).m=function(){if(d(this))return-h(this).m();for(var e=0,t=1,n=0;n<this.g.length;n++){var r=this.i(n);e+=(0<=r?r:4294967296+r)*t,t*=4294967296}return e},e.toString=function(e){if(2>(e=e||10)||36<e)throw Error("radix out of range: "+e);if(c(this))return"0";if(d(this))return"-"+h(this).toString(e);for(var t=i(Math.pow(e,6)),n=this,r="";;){var a=g(n,t).g,s=((0<(n=p(n,a.j(t))).g.length?n.g[0]:n.h)>>>0).toString(e);if(c(n=a))return s+r;for(;6>s.length;)s="0"+s;r=s+r}},e.i=function(e){return 0>e?0:e<this.g.length?this.g[e]:this.h},e.l=function(e){return d(e=p(this,e))?-1:c(e)?0:1},e.abs=function(){return d(this)?h(this):this},e.add=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0,s=0;s<=t;s++){var i=a+(65535&this.i(s))+(65535&e.i(s)),o=(i>>>16)+(this.i(s)>>>16)+(e.i(s)>>>16);a=o>>>16,i&=65535,o&=65535,n[s]=o<<16|i}return new r(n,-2147483648&n[n.length-1]?-1:0)},e.j=function(e){if(c(this)||c(e))return o;if(d(this))return d(e)?h(this).j(h(e)):h(h(this).j(e));if(d(e))return h(this.j(h(e)));if(0>this.l(u)&&0>e.l(u))return i(this.m()*e.m());for(var t=this.g.length+e.g.length,n=[],a=0;a<2*t;a++)n[a]=0;for(a=0;a<this.g.length;a++)for(var s=0;s<e.g.length;s++){var l=this.i(a)>>>16,p=65535&this.i(a),m=e.i(s)>>>16,g=65535&e.i(s);n[2*a+2*s]+=p*g,f(n,2*a+2*s),n[2*a+2*s+1]+=l*g,f(n,2*a+2*s+1),n[2*a+2*s+1]+=p*m,f(n,2*a+2*s+1),n[2*a+2*s+2]+=l*m,f(n,2*a+2*s+2)}for(a=0;a<t;a++)n[a]=n[2*a+1]<<16|n[2*a];for(a=t;a<2*t;a++)n[a]=0;return new r(n,0)},e.A=function(e){return g(this,e).h},e.and=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0;a<t;a++)n[a]=this.i(a)&e.i(a);return new r(n,this.h&e.h)},e.or=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0;a<t;a++)n[a]=this.i(a)|e.i(a);return new r(n,this.h|e.h)},e.xor=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0;a<t;a++)n[a]=this.i(a)^e.i(a);return new r(n,this.h^e.h)},t.prototype.digest=t.prototype.v,t.prototype.reset=t.prototype.s,t.prototype.update=t.prototype.u,td=rd.Md5=t,r.prototype.add=r.prototype.add,r.prototype.multiply=r.prototype.j,r.prototype.modulo=r.prototype.A,r.prototype.compare=r.prototype.l,r.prototype.toNumber=r.prototype.m,r.prototype.toString=r.prototype.toString,r.prototype.getBits=r.prototype.i,r.fromNumber=i,r.fromString=function e(t,n){if(0==t.length)throw Error("number format error: empty string");if(2>(n=n||10)||36<n)throw Error("radix out of range: "+n);if("-"==t.charAt(0))return h(e(t.substring(1),n));if(0<=t.indexOf("-"))throw Error('number format error: interior "-" character');for(var r=i(Math.pow(n,8)),a=o,s=0;s<t.length;s+=8){var l=Math.min(8,t.length-s),u=parseInt(t.substring(s,s+l),n);8>l?(l=i(Math.pow(n,l)),a=a.j(l).add(i(u))):a=(a=a.j(r)).add(i(u))}return a},ed=rd.Integer=r}).apply("undefined"!==typeof nd?nd:"undefined"!==typeof self?self:"undefined"!==typeof window?window:{});var ad,sd,id,od,ld,ud,cd,dd,hd,pd="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{},fd={};(function(){var e,t="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){return e==Array.prototype||e==Object.prototype||(e[t]=n.value),e};var n=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof pd&&pd];for(var t=0;t<e.length;++t){var n=e[t];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);!function(e,r){if(r)e:{var a=n;e=e.split(".");for(var s=0;s<e.length-1;s++){var i=e[s];if(!(i in a))break e;a=a[i]}(r=r(s=a[e=e[e.length-1]]))!=s&&null!=r&&t(a,e,{configurable:!0,writable:!0,value:r})}}("Array.prototype.values",(function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var n=0,r=!1,a={next:function(){if(!r&&n<e.length){var a=n++;return{value:t(a,e[a]),done:!1}}return r=!0,{done:!0,value:void 0}}};return a[Symbol.iterator]=function(){return a},a}(this,(function(e,t){return t}))}}));var r=r||{},a=this||self;function s(e){var t=typeof e;return"array"==(t="object"!=t?t:e?Array.isArray(e)?"array":t:"null")||"object"==t&&"number"==typeof e.length}function i(e){var t=typeof e;return"object"==t&&null!=e||"function"==t}function o(e,t,n){return e.call.apply(e.bind,arguments)}function l(e,t,n){if(!e)throw Error();if(2<arguments.length){var r=Array.prototype.slice.call(arguments,2);return function(){var n=Array.prototype.slice.call(arguments);return Array.prototype.unshift.apply(n,r),e.apply(t,n)}}return function(){return e.apply(t,arguments)}}function u(e,t,n){return(u=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?o:l).apply(null,arguments)}function c(e,t){var n=Array.prototype.slice.call(arguments,1);return function(){var t=n.slice();return t.push.apply(t,arguments),e.apply(this,t)}}function d(e,t){function n(){}n.prototype=t.prototype,e.aa=t.prototype,e.prototype=new n,e.prototype.constructor=e,e.Qb=function(e,n,r){for(var a=Array(arguments.length-2),s=2;s<arguments.length;s++)a[s-2]=arguments[s];return t.prototype[n].apply(e,a)}}function h(e){const t=e.length;if(0<t){const n=Array(t);for(let r=0;r<t;r++)n[r]=e[r];return n}return[]}function p(e,t){for(let n=1;n<arguments.length;n++){const t=arguments[n];if(s(t)){const n=e.length||0,r=t.length||0;e.length=n+r;for(let a=0;a<r;a++)e[n+a]=t[a]}else e.push(t)}}function f(e){return/^[\s\xa0]*$/.test(e)}function m(){var e=a.navigator;return e&&(e=e.userAgent)?e:""}function g(e){return g[" "](e),e}g[" "]=function(){};var y=-1!=m().indexOf("Gecko")&&!(-1!=m().toLowerCase().indexOf("webkit")&&-1==m().indexOf("Edge"))&&!(-1!=m().indexOf("Trident")||-1!=m().indexOf("MSIE"))&&-1==m().indexOf("Edge");function b(e,t,n){for(const r in e)t.call(n,e[r],r,e)}function v(e){const t={};for(const n in e)t[n]=e[n];return t}const x="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function w(e,t){let n,r;for(let a=1;a<arguments.length;a++){for(n in r=arguments[a],r)e[n]=r[n];for(let t=0;t<x.length;t++)n=x[t],Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}}function k(e){var t=1;e=e.split(":");const n=[];for(;0<t&&e.length;)n.push(e.shift()),t--;return e.length&&n.push(e.join(":")),n}function S(e){a.setTimeout((()=>{throw e}),0)}function I(){var e=A;let t=null;return e.g&&(t=e.g,e.g=e.g.next,e.g||(e.h=null),t.next=null),t}var C=new class{constructor(e,t){this.i=e,this.j=t,this.h=0,this.g=null}get(){let e;return 0<this.h?(this.h--,e=this.g,this.g=e.next,e.next=null):e=this.i(),e}}((()=>new N),(e=>e.reset()));class N{constructor(){this.next=this.g=this.h=null}set(e,t){this.h=e,this.g=t,this.next=null}reset(){this.next=this.g=this.h=null}}let T,E=!1,A=new class{constructor(){this.h=this.g=null}add(e,t){const n=C.get();n.set(e,t),this.h?this.h.next=n:this.g=n,this.h=n}},_=()=>{const e=a.Promise.resolve(void 0);T=()=>{e.then($)}};var $=()=>{for(var e;e=I();){try{e.h.call(e.g)}catch(n){S(n)}var t=C;t.j(e),100>t.h&&(t.h++,e.next=t.g,t.g=e)}E=!1};function R(){this.s=this.s,this.C=this.C}function D(e,t){this.type=e,this.g=this.target=t,this.defaultPrevented=!1}R.prototype.s=!1,R.prototype.ma=function(){this.s||(this.s=!0,this.N())},R.prototype.N=function(){if(this.C)for(;this.C.length;)this.C.shift()()},D.prototype.h=function(){this.defaultPrevented=!0};var M=function(){if(!a.addEventListener||!Object.defineProperty)return!1;var e=!1,t=Object.defineProperty({},"passive",{get:function(){e=!0}});try{const e=()=>{};a.addEventListener("test",e,t),a.removeEventListener("test",e,t)}catch(n){}return e}();function F(e,t){if(D.call(this,e?e.type:""),this.relatedTarget=this.g=this.target=null,this.button=this.screenY=this.screenX=this.clientY=this.clientX=0,this.key="",this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1,this.state=null,this.pointerId=0,this.pointerType="",this.i=null,e){var n=this.type=e.type,r=e.changedTouches&&e.changedTouches.length?e.changedTouches[0]:null;if(this.target=e.target||e.srcElement,this.g=t,t=e.relatedTarget){if(y){e:{try{g(t.nodeName);var a=!0;break e}catch(s){}a=!1}a||(t=null)}}else"mouseover"==n?t=e.fromElement:"mouseout"==n&&(t=e.toElement);this.relatedTarget=t,r?(this.clientX=void 0!==r.clientX?r.clientX:r.pageX,this.clientY=void 0!==r.clientY?r.clientY:r.pageY,this.screenX=r.screenX||0,this.screenY=r.screenY||0):(this.clientX=void 0!==e.clientX?e.clientX:e.pageX,this.clientY=void 0!==e.clientY?e.clientY:e.pageY,this.screenX=e.screenX||0,this.screenY=e.screenY||0),this.button=e.button,this.key=e.key||"",this.ctrlKey=e.ctrlKey,this.altKey=e.altKey,this.shiftKey=e.shiftKey,this.metaKey=e.metaKey,this.pointerId=e.pointerId||0,this.pointerType="string"===typeof e.pointerType?e.pointerType:O[e.pointerType]||"",this.state=e.state,this.i=e,e.defaultPrevented&&F.aa.h.call(this)}}d(F,D);var O={2:"touch",3:"pen",4:"mouse"};F.prototype.h=function(){F.aa.h.call(this);var e=this.i;e.preventDefault?e.preventDefault():e.returnValue=!1};var P="closure_listenable_"+(1e6*Math.random()|0),L=0;function z(e,t,n,r,a){this.listener=e,this.proxy=null,this.src=t,this.type=n,this.capture=!!r,this.ha=a,this.key=++L,this.da=this.fa=!1}function B(e){e.da=!0,e.listener=null,e.proxy=null,e.src=null,e.ha=null}function W(e){this.src=e,this.g={},this.h=0}function V(e,t){var n=t.type;if(n in e.g){var r,a=e.g[n],s=Array.prototype.indexOf.call(a,t,void 0);(r=0<=s)&&Array.prototype.splice.call(a,s,1),r&&(B(t),0==e.g[n].length&&(delete e.g[n],e.h--))}}function U(e,t,n,r){for(var a=0;a<e.length;++a){var s=e[a];if(!s.da&&s.listener==t&&s.capture==!!n&&s.ha==r)return a}return-1}W.prototype.add=function(e,t,n,r,a){var s=e.toString();(e=this.g[s])||(e=this.g[s]=[],this.h++);var i=U(e,t,r,a);return-1<i?(t=e[i],n||(t.fa=!1)):((t=new z(t,this.src,s,!!r,a)).fa=n,e.push(t)),t};var j="closure_lm_"+(1e6*Math.random()|0),G={};function H(e,t,n,r,a){if(r&&r.once)return K(e,t,n,r,a);if(Array.isArray(t)){for(var s=0;s<t.length;s++)H(e,t[s],n,r,a);return null}return n=te(n),e&&e[P]?e.K(t,n,i(r)?!!r.capture:!!r,a):q(e,t,n,!1,r,a)}function q(e,t,n,r,a,s){if(!t)throw Error("Invalid event type");var o=i(a)?!!a.capture:!!a,l=Z(e);if(l||(e[j]=l=new W(e)),(n=l.add(t,n,r,o,s)).proxy)return n;if(r=function(){function e(n){return t.call(e.src,e.listener,n)}const t=J;return e}(),n.proxy=r,r.src=e,r.listener=n,e.addEventListener)M||(a=o),void 0===a&&(a=!1),e.addEventListener(t.toString(),r,a);else if(e.attachEvent)e.attachEvent(Q(t.toString()),r);else{if(!e.addListener||!e.removeListener)throw Error("addEventListener and attachEvent are unavailable.");e.addListener(r)}return n}function K(e,t,n,r,a){if(Array.isArray(t)){for(var s=0;s<t.length;s++)K(e,t[s],n,r,a);return null}return n=te(n),e&&e[P]?e.L(t,n,i(r)?!!r.capture:!!r,a):q(e,t,n,!0,r,a)}function X(e,t,n,r,a){if(Array.isArray(t))for(var s=0;s<t.length;s++)X(e,t[s],n,r,a);else r=i(r)?!!r.capture:!!r,n=te(n),e&&e[P]?(e=e.i,(t=String(t).toString())in e.g&&(-1<(n=U(s=e.g[t],n,r,a))&&(B(s[n]),Array.prototype.splice.call(s,n,1),0==s.length&&(delete e.g[t],e.h--)))):e&&(e=Z(e))&&(t=e.g[t.toString()],e=-1,t&&(e=U(t,n,r,a)),(n=-1<e?t[e]:null)&&Y(n))}function Y(e){if("number"!==typeof e&&e&&!e.da){var t=e.src;if(t&&t[P])V(t.i,e);else{var n=e.type,r=e.proxy;t.removeEventListener?t.removeEventListener(n,r,e.capture):t.detachEvent?t.detachEvent(Q(n),r):t.addListener&&t.removeListener&&t.removeListener(r),(n=Z(t))?(V(n,e),0==n.h&&(n.src=null,t[j]=null)):B(e)}}}function Q(e){return e in G?G[e]:G[e]="on"+e}function J(e,t){if(e.da)e=!0;else{t=new F(t,this);var n=e.listener,r=e.ha||e.src;e.fa&&Y(e),e=n.call(r,t)}return e}function Z(e){return(e=e[j])instanceof W?e:null}var ee="__closure_events_fn_"+(1e9*Math.random()>>>0);function te(e){return"function"===typeof e?e:(e[ee]||(e[ee]=function(t){return e.handleEvent(t)}),e[ee])}function ne(){R.call(this),this.i=new W(this),this.M=this,this.F=null}function re(e,t){var n,r=e.F;if(r)for(n=[];r;r=r.F)n.push(r);if(e=e.M,r=t.type||t,"string"===typeof t)t=new D(t,e);else if(t instanceof D)t.target=t.target||e;else{var a=t;w(t=new D(r,e),a)}if(a=!0,n)for(var s=n.length-1;0<=s;s--){var i=t.g=n[s];a=ae(i,r,!0,t)&&a}if(a=ae(i=t.g=e,r,!0,t)&&a,a=ae(i,r,!1,t)&&a,n)for(s=0;s<n.length;s++)a=ae(i=t.g=n[s],r,!1,t)&&a}function ae(e,t,n,r){if(!(t=e.i.g[String(t)]))return!0;t=t.concat();for(var a=!0,s=0;s<t.length;++s){var i=t[s];if(i&&!i.da&&i.capture==n){var o=i.listener,l=i.ha||i.src;i.fa&&V(e.i,i),a=!1!==o.call(l,r)&&a}}return a&&!r.defaultPrevented}function se(e,t,n){if("function"===typeof e)n&&(e=u(e,n));else{if(!e||"function"!=typeof e.handleEvent)throw Error("Invalid listener argument");e=u(e.handleEvent,e)}return 2147483647<Number(t)?-1:a.setTimeout(e,t||0)}function ie(e){e.g=se((()=>{e.g=null,e.i&&(e.i=!1,ie(e))}),e.l);const t=e.h;e.h=null,e.m.apply(null,t)}d(ne,R),ne.prototype[P]=!0,ne.prototype.removeEventListener=function(e,t,n,r){X(this,e,t,n,r)},ne.prototype.N=function(){if(ne.aa.N.call(this),this.i){var e,t=this.i;for(e in t.g){for(var n=t.g[e],r=0;r<n.length;r++)B(n[r]);delete t.g[e],t.h--}}this.F=null},ne.prototype.K=function(e,t,n,r){return this.i.add(String(e),t,!1,n,r)},ne.prototype.L=function(e,t,n,r){return this.i.add(String(e),t,!0,n,r)};class oe extends R{constructor(e,t){super(),this.m=e,this.l=t,this.h=null,this.i=!1,this.g=null}j(e){this.h=arguments,this.g?this.i=!0:ie(this)}N(){super.N(),this.g&&(a.clearTimeout(this.g),this.g=null,this.i=!1,this.h=null)}}function le(e){R.call(this),this.h=e,this.g={}}d(le,R);var ue=[];function ce(e){b(e.g,(function(e,t){this.g.hasOwnProperty(t)&&Y(e)}),e),e.g={}}le.prototype.N=function(){le.aa.N.call(this),ce(this)},le.prototype.handleEvent=function(){throw Error("EventHandler.handleEvent not implemented")};var de=a.JSON.stringify,he=a.JSON.parse,pe=class{stringify(e){return a.JSON.stringify(e,void 0)}parse(e){return a.JSON.parse(e,void 0)}};function fe(){}function me(e){return e.h||(e.h=e.i())}function ge(){}fe.prototype.h=null;var ye={OPEN:"a",kb:"b",Ja:"c",wb:"d"};function be(){D.call(this,"d")}function ve(){D.call(this,"c")}d(be,D),d(ve,D);var xe={},we=null;function ke(){return we=we||new ne}function Se(e){D.call(this,xe.La,e)}function Ie(e){const t=ke();re(t,new Se(t))}function Ce(e,t){D.call(this,xe.STAT_EVENT,e),this.stat=t}function Ne(e){const t=ke();re(t,new Ce(t,e))}function Te(e,t){D.call(this,xe.Ma,e),this.size=t}function Ee(e,t){if("function"!==typeof e)throw Error("Fn must not be null and must be a function");return a.setTimeout((function(){e()}),t)}function Ae(){this.g=!0}function _e(e,t,n,r){e.info((function(){return"XMLHTTP TEXT ("+t+"): "+function(e,t){if(!e.g)return t;if(!t)return null;try{var n=JSON.parse(t);if(n)for(e=0;e<n.length;e++)if(Array.isArray(n[e])){var r=n[e];if(!(2>r.length)){var a=r[1];if(Array.isArray(a)&&!(1>a.length)){var s=a[0];if("noop"!=s&&"stop"!=s&&"close"!=s)for(var i=1;i<a.length;i++)a[i]=""}}}return de(n)}catch(o){return t}}(e,n)+(r?" "+r:"")}))}xe.La="serverreachability",d(Se,D),xe.STAT_EVENT="statevent",d(Ce,D),xe.Ma="timingevent",d(Te,D),Ae.prototype.xa=function(){this.g=!1},Ae.prototype.info=function(){};var $e,Re={NO_ERROR:0,gb:1,tb:2,sb:3,nb:4,rb:5,ub:6,Ia:7,TIMEOUT:8,xb:9},De={lb:"complete",Hb:"success",Ja:"error",Ia:"abort",zb:"ready",Ab:"readystatechange",TIMEOUT:"timeout",vb:"incrementaldata",yb:"progress",ob:"downloadprogress",Pb:"uploadprogress"};function Me(){}function Fe(e,t,n,r){this.j=e,this.i=t,this.l=n,this.R=r||1,this.U=new le(this),this.I=45e3,this.H=null,this.o=!1,this.m=this.A=this.v=this.L=this.F=this.S=this.B=null,this.D=[],this.g=null,this.C=0,this.s=this.u=null,this.X=-1,this.J=!1,this.O=0,this.M=null,this.W=this.K=this.T=this.P=!1,this.h=new Oe}function Oe(){this.i=null,this.g="",this.h=!1}d(Me,fe),Me.prototype.g=function(){return new XMLHttpRequest},Me.prototype.i=function(){return{}},$e=new Me;var Pe={},Le={};function ze(e,t,n){e.L=1,e.v=dt(it(t)),e.m=n,e.P=!0,Be(e,null)}function Be(e,t){e.F=Date.now(),Ue(e),e.A=it(e.v);var n=e.A,r=e.R;Array.isArray(r)||(r=[String(r)]),Ct(n.i,"t",r),e.C=0,n=e.j.J,e.h=new Oe,e.g=pn(e.j,n?t:null,!e.m),0<e.O&&(e.M=new oe(u(e.Y,e,e.g),e.O)),t=e.U,n=e.g,r=e.ca;var a="readystatechange";Array.isArray(a)||(a&&(ue[0]=a.toString()),a=ue);for(var s=0;s<a.length;s++){var i=H(n,a[s],r||t.handleEvent,!1,t.h||t);if(!i)break;t.g[i.key]=i}t=e.H?v(e.H):{},e.m?(e.u||(e.u="POST"),t["Content-Type"]="application/x-www-form-urlencoded",e.g.ea(e.A,e.u,e.m,t)):(e.u="GET",e.g.ea(e.A,e.u,null,t)),Ie(),function(e,t,n,r,a,s){e.info((function(){if(e.g)if(s)for(var i="",o=s.split("&"),l=0;l<o.length;l++){var u=o[l].split("=");if(1<u.length){var c=u[0];u=u[1];var d=c.split("_");i=2<=d.length&&"type"==d[1]?i+(c+"=")+u+"&":i+(c+"=redacted&")}}else i=null;else i=s;return"XMLHTTP REQ ("+r+") [attempt "+a+"]: "+t+"\n"+n+"\n"+i}))}(e.i,e.u,e.A,e.l,e.R,e.m)}function We(e){return!!e.g&&("GET"==e.u&&2!=e.L&&e.j.Ca)}function Ve(e,t){var n=e.C,r=t.indexOf("\n",n);return-1==r?Le:(n=Number(t.substring(n,r)),isNaN(n)?Pe:(r+=1)+n>t.length?Le:(t=t.slice(r,r+n),e.C=r+n,t))}function Ue(e){e.S=Date.now()+e.I,je(e,e.I)}function je(e,t){if(null!=e.B)throw Error("WatchDog timer not null");e.B=Ee(u(e.ba,e),t)}function Ge(e){e.B&&(a.clearTimeout(e.B),e.B=null)}function He(e){0==e.j.G||e.J||ln(e.j,e)}function qe(e){Ge(e);var t=e.M;t&&"function"==typeof t.ma&&t.ma(),e.M=null,ce(e.U),e.g&&(t=e.g,e.g=null,t.abort(),t.ma())}function Ke(e,t){try{var n=e.j;if(0!=n.G&&(n.g==e||Ze(n.h,e)))if(!e.K&&Ze(n.h,e)&&3==n.G){try{var r=n.Da.g.parse(t)}catch(c){r=null}if(Array.isArray(r)&&3==r.length){var a=r;if(0==a[0]){e:if(!n.u){if(n.g){if(!(n.g.F+3e3<e.F))break e;on(n),Yt(n)}rn(n),Ne(18)}}else n.za=a[1],0<n.za-n.T&&37500>a[2]&&n.F&&0==n.v&&!n.C&&(n.C=Ee(u(n.Za,n),6e3));if(1>=Je(n.h)&&n.ca){try{n.ca()}catch(c){}n.ca=void 0}}else cn(n,11)}else if((e.K||n.g==e)&&on(n),!f(t))for(a=n.Da.g.parse(t),t=0;t<a.length;t++){let u=a[t];if(n.T=u[0],u=u[1],2==n.G)if("c"==u[0]){n.K=u[1],n.ia=u[2];const t=u[3];null!=t&&(n.la=t,n.j.info("VER="+n.la));const a=u[4];null!=a&&(n.Aa=a,n.j.info("SVER="+n.Aa));const c=u[5];null!=c&&"number"===typeof c&&0<c&&(r=1.5*c,n.L=r,n.j.info("backChannelRequestTimeoutMs_="+r)),r=n;const d=e.g;if(d){const e=d.g?d.g.getResponseHeader("X-Client-Wire-Protocol"):null;if(e){var s=r.h;s.g||-1==e.indexOf("spdy")&&-1==e.indexOf("quic")&&-1==e.indexOf("h2")||(s.j=s.l,s.g=new Set,s.h&&(et(s,s.h),s.h=null))}if(r.D){const e=d.g?d.g.getResponseHeader("X-HTTP-Session-Id"):null;e&&(r.ya=e,ct(r.I,r.D,e))}}n.G=3,n.l&&n.l.ua(),n.ba&&(n.R=Date.now()-e.F,n.j.info("Handshake RTT: "+n.R+"ms"));var i=e;if((r=n).qa=hn(r,r.J?r.ia:null,r.W),i.K){tt(r.h,i);var o=i,l=r.L;l&&(o.I=l),o.B&&(Ge(o),Ue(o)),r.g=i}else nn(r);0<n.i.length&&Jt(n)}else"stop"!=u[0]&&"close"!=u[0]||cn(n,7);else 3==n.G&&("stop"==u[0]||"close"==u[0]?"stop"==u[0]?cn(n,7):Xt(n):"noop"!=u[0]&&n.l&&n.l.ta(u),n.v=0)}Ie()}catch(c){}}Fe.prototype.ca=function(e){e=e.target;const t=this.M;t&&3==Gt(e)?t.j():this.Y(e)},Fe.prototype.Y=function(e){try{if(e==this.g)e:{const h=Gt(this.g);var t=this.g.Ba();this.g.Z();if(!(3>h)&&(3!=h||this.g&&(this.h.h||this.g.oa()||Ht(this.g)))){this.J||4!=h||7==t||Ie(),Ge(this);var n=this.g.Z();this.X=n;t:if(We(this)){var r=Ht(this.g);e="";var s=r.length,i=4==Gt(this.g);if(!this.h.i){if("undefined"===typeof TextDecoder){qe(this),He(this);var o="";break t}this.h.i=new a.TextDecoder}for(t=0;t<s;t++)this.h.h=!0,e+=this.h.i.decode(r[t],{stream:!(i&&t==s-1)});r.length=0,this.h.g+=e,this.C=0,o=this.h.g}else o=this.g.oa();if(this.o=200==n,function(e,t,n,r,a,s,i){e.info((function(){return"XMLHTTP RESP ("+r+") [ attempt "+a+"]: "+t+"\n"+n+"\n"+s+" "+i}))}(this.i,this.u,this.A,this.l,this.R,h,n),this.o){if(this.T&&!this.K){t:{if(this.g){var l,u=this.g;if((l=u.g?u.g.getResponseHeader("X-HTTP-Initial-Response"):null)&&!f(l)){var c=l;break t}}c=null}if(!(n=c)){this.o=!1,this.s=3,Ne(12),qe(this),He(this);break e}_e(this.i,this.l,n,"Initial handshake response via X-HTTP-Initial-Response"),this.K=!0,Ke(this,n)}if(this.P){let e;for(n=!0;!this.J&&this.C<o.length;){if(e=Ve(this,o),e==Le){4==h&&(this.s=4,Ne(14),n=!1),_e(this.i,this.l,null,"[Incomplete Response]");break}if(e==Pe){this.s=4,Ne(15),_e(this.i,this.l,o,"[Invalid Chunk]"),n=!1;break}_e(this.i,this.l,e,null),Ke(this,e)}if(We(this)&&0!=this.C&&(this.h.g=this.h.g.slice(this.C),this.C=0),4!=h||0!=o.length||this.h.h||(this.s=1,Ne(16),n=!1),this.o=this.o&&n,n){if(0<o.length&&!this.W){this.W=!0;var d=this.j;d.g==this&&d.ba&&!d.M&&(d.j.info("Great, no buffering proxy detected. Bytes received: "+o.length),an(d),d.M=!0,Ne(11))}}else _e(this.i,this.l,o,"[Invalid Chunked Response]"),qe(this),He(this)}else _e(this.i,this.l,o,null),Ke(this,o);4==h&&qe(this),this.o&&!this.J&&(4==h?ln(this.j,this):(this.o=!1,Ue(this)))}else(function(e){const t={};e=(e.g&&2<=Gt(e)&&e.g.getAllResponseHeaders()||"").split("\r\n");for(let r=0;r<e.length;r++){if(f(e[r]))continue;var n=k(e[r]);const a=n[0];if("string"!==typeof(n=n[1]))continue;n=n.trim();const s=t[a]||[];t[a]=s,s.push(n)}!function(e,t){for(const n in e)t.call(void 0,e[n],n,e)}(t,(function(e){return e.join(", ")}))})(this.g),400==n&&0<o.indexOf("Unknown SID")?(this.s=3,Ne(12)):(this.s=0,Ne(13)),qe(this),He(this)}}}catch(TR){}},Fe.prototype.cancel=function(){this.J=!0,qe(this)},Fe.prototype.ba=function(){this.B=null;const e=Date.now();0<=e-this.S?(function(e,t){e.info((function(){return"TIMEOUT: "+t}))}(this.i,this.A),2!=this.L&&(Ie(),Ne(17)),qe(this),this.s=2,He(this)):je(this,this.S-e)};var Xe=class{constructor(e,t){this.g=e,this.map=t}};function Ye(e){this.l=e||10,a.PerformanceNavigationTiming?e=0<(e=a.performance.getEntriesByType("navigation")).length&&("hq"==e[0].nextHopProtocol||"h2"==e[0].nextHopProtocol):e=!!(a.chrome&&a.chrome.loadTimes&&a.chrome.loadTimes()&&a.chrome.loadTimes().wasFetchedViaSpdy),this.j=e?this.l:1,this.g=null,1<this.j&&(this.g=new Set),this.h=null,this.i=[]}function Qe(e){return!!e.h||!!e.g&&e.g.size>=e.j}function Je(e){return e.h?1:e.g?e.g.size:0}function Ze(e,t){return e.h?e.h==t:!!e.g&&e.g.has(t)}function et(e,t){e.g?e.g.add(t):e.h=t}function tt(e,t){e.h&&e.h==t?e.h=null:e.g&&e.g.has(t)&&e.g.delete(t)}function nt(e){if(null!=e.h)return e.i.concat(e.h.D);if(null!=e.g&&0!==e.g.size){let t=e.i;for(const n of e.g.values())t=t.concat(n.D);return t}return h(e.i)}function rt(e,t){if(e.forEach&&"function"==typeof e.forEach)e.forEach(t,void 0);else if(s(e)||"string"===typeof e)Array.prototype.forEach.call(e,t,void 0);else for(var n=function(e){if(e.na&&"function"==typeof e.na)return e.na();if(!e.V||"function"!=typeof e.V){if("undefined"!==typeof Map&&e instanceof Map)return Array.from(e.keys());if(!("undefined"!==typeof Set&&e instanceof Set)){if(s(e)||"string"===typeof e){var t=[];e=e.length;for(var n=0;n<e;n++)t.push(n);return t}t=[],n=0;for(const r in e)t[n++]=r;return t}}}(e),r=function(e){if(e.V&&"function"==typeof e.V)return e.V();if("undefined"!==typeof Map&&e instanceof Map||"undefined"!==typeof Set&&e instanceof Set)return Array.from(e.values());if("string"===typeof e)return e.split("");if(s(e)){for(var t=[],n=e.length,r=0;r<n;r++)t.push(e[r]);return t}for(r in t=[],n=0,e)t[n++]=e[r];return t}(e),a=r.length,i=0;i<a;i++)t.call(void 0,r[i],n&&n[i],e)}Ye.prototype.cancel=function(){if(this.i=nt(this),this.h)this.h.cancel(),this.h=null;else if(this.g&&0!==this.g.size){for(const e of this.g.values())e.cancel();this.g.clear()}};var at=RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");function st(e){if(this.g=this.o=this.j="",this.s=null,this.m=this.l="",this.h=!1,e instanceof st){this.h=e.h,ot(this,e.j),this.o=e.o,this.g=e.g,lt(this,e.s),this.l=e.l;var t=e.i,n=new wt;n.i=t.i,t.g&&(n.g=new Map(t.g),n.h=t.h),ut(this,n),this.m=e.m}else e&&(t=String(e).match(at))?(this.h=!1,ot(this,t[1]||"",!0),this.o=ht(t[2]||""),this.g=ht(t[3]||"",!0),lt(this,t[4]),this.l=ht(t[5]||"",!0),ut(this,t[6]||"",!0),this.m=ht(t[7]||"")):(this.h=!1,this.i=new wt(null,this.h))}function it(e){return new st(e)}function ot(e,t,n){e.j=n?ht(t,!0):t,e.j&&(e.j=e.j.replace(/:$/,""))}function lt(e,t){if(t){if(t=Number(t),isNaN(t)||0>t)throw Error("Bad port number "+t);e.s=t}else e.s=null}function ut(e,t,n){t instanceof wt?(e.i=t,function(e,t){t&&!e.j&&(kt(e),e.i=null,e.g.forEach((function(e,t){var n=t.toLowerCase();t!=n&&(St(this,t),Ct(this,n,e))}),e)),e.j=t}(e.i,e.h)):(n||(t=pt(t,vt)),e.i=new wt(t,e.h))}function ct(e,t,n){e.i.set(t,n)}function dt(e){return ct(e,"zx",Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^Date.now()).toString(36)),e}function ht(e,t){return e?t?decodeURI(e.replace(/%25/g,"%2525")):decodeURIComponent(e):""}function pt(e,t,n){return"string"===typeof e?(e=encodeURI(e).replace(t,ft),n&&(e=e.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),e):null}function ft(e){return"%"+((e=e.charCodeAt(0))>>4&15).toString(16)+(15&e).toString(16)}st.prototype.toString=function(){var e=[],t=this.j;t&&e.push(pt(t,gt,!0),":");var n=this.g;return(n||"file"==t)&&(e.push("//"),(t=this.o)&&e.push(pt(t,gt,!0),"@"),e.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),null!=(n=this.s)&&e.push(":",String(n))),(n=this.l)&&(this.g&&"/"!=n.charAt(0)&&e.push("/"),e.push(pt(n,"/"==n.charAt(0)?bt:yt,!0))),(n=this.i.toString())&&e.push("?",n),(n=this.m)&&e.push("#",pt(n,xt)),e.join("")};var mt,gt=/[#\/\?@]/g,yt=/[#\?:]/g,bt=/[#\?]/g,vt=/[#\?@]/g,xt=/#/g;function wt(e,t){this.h=this.g=null,this.i=e||null,this.j=!!t}function kt(e){e.g||(e.g=new Map,e.h=0,e.i&&function(e,t){if(e){e=e.split("&");for(var n=0;n<e.length;n++){var r=e[n].indexOf("="),a=null;if(0<=r){var s=e[n].substring(0,r);a=e[n].substring(r+1)}else s=e[n];t(s,a?decodeURIComponent(a.replace(/\+/g," ")):"")}}}(e.i,(function(t,n){e.add(decodeURIComponent(t.replace(/\+/g," ")),n)})))}function St(e,t){kt(e),t=Nt(e,t),e.g.has(t)&&(e.i=null,e.h-=e.g.get(t).length,e.g.delete(t))}function It(e,t){return kt(e),t=Nt(e,t),e.g.has(t)}function Ct(e,t,n){St(e,t),0<n.length&&(e.i=null,e.g.set(Nt(e,t),h(n)),e.h+=n.length)}function Nt(e,t){return t=String(t),e.j&&(t=t.toLowerCase()),t}function Tt(e,t,n,r,a){try{a&&(a.onload=null,a.onerror=null,a.onabort=null,a.ontimeout=null),r(n)}catch(s){}}function Et(){this.g=new pe}function At(e,t,n){const r=n||"";try{rt(e,(function(e,n){let a=e;i(e)&&(a=de(e)),t.push(r+n+"="+encodeURIComponent(a))}))}catch(mD){throw t.push(r+"type="+encodeURIComponent("_badmap")),mD}}function _t(e){this.l=e.Ub||null,this.j=e.eb||!1}function $t(e,t){ne.call(this),this.D=e,this.o=t,this.m=void 0,this.status=this.readyState=0,this.responseType=this.responseText=this.response=this.statusText="",this.onreadystatechange=null,this.u=new Headers,this.h=null,this.B="GET",this.A="",this.g=!1,this.v=this.j=this.l=null}function Rt(e){e.j.read().then(e.Pa.bind(e)).catch(e.ga.bind(e))}function Dt(e){e.readyState=4,e.l=null,e.j=null,e.v=null,Mt(e)}function Mt(e){e.onreadystatechange&&e.onreadystatechange.call(e)}function Ft(e){let t="";return b(e,(function(e,n){t+=n,t+=":",t+=e,t+="\r\n"})),t}function Ot(e,t,n){e:{for(r in n){var r=!1;break e}r=!0}r||(n=Ft(n),"string"===typeof e?null!=n&&encodeURIComponent(String(n)):ct(e,t,n))}function Pt(e){ne.call(this),this.headers=new Map,this.o=e||null,this.h=!1,this.v=this.g=null,this.D="",this.m=0,this.l="",this.j=this.B=this.u=this.A=!1,this.I=null,this.H="",this.J=!1}(e=wt.prototype).add=function(e,t){kt(this),this.i=null,e=Nt(this,e);var n=this.g.get(e);return n||this.g.set(e,n=[]),n.push(t),this.h+=1,this},e.forEach=function(e,t){kt(this),this.g.forEach((function(n,r){n.forEach((function(n){e.call(t,n,r,this)}),this)}),this)},e.na=function(){kt(this);const e=Array.from(this.g.values()),t=Array.from(this.g.keys()),n=[];for(let r=0;r<t.length;r++){const a=e[r];for(let e=0;e<a.length;e++)n.push(t[r])}return n},e.V=function(e){kt(this);let t=[];if("string"===typeof e)It(this,e)&&(t=t.concat(this.g.get(Nt(this,e))));else{e=Array.from(this.g.values());for(let n=0;n<e.length;n++)t=t.concat(e[n])}return t},e.set=function(e,t){return kt(this),this.i=null,It(this,e=Nt(this,e))&&(this.h-=this.g.get(e).length),this.g.set(e,[t]),this.h+=1,this},e.get=function(e,t){return e&&0<(e=this.V(e)).length?String(e[0]):t},e.toString=function(){if(this.i)return this.i;if(!this.g)return"";const e=[],t=Array.from(this.g.keys());for(var n=0;n<t.length;n++){var r=t[n];const s=encodeURIComponent(String(r)),i=this.V(r);for(r=0;r<i.length;r++){var a=s;""!==i[r]&&(a+="="+encodeURIComponent(String(i[r]))),e.push(a)}}return this.i=e.join("&")},d(_t,fe),_t.prototype.g=function(){return new $t(this.l,this.j)},_t.prototype.i=(mt={},function(){return mt}),d($t,ne),(e=$t.prototype).open=function(e,t){if(0!=this.readyState)throw this.abort(),Error("Error reopening a connection");this.B=e,this.A=t,this.readyState=1,Mt(this)},e.send=function(e){if(1!=this.readyState)throw this.abort(),Error("need to call open() first. ");this.g=!0;const t={headers:this.u,method:this.B,credentials:this.m,cache:void 0};e&&(t.body=e),(this.D||a).fetch(new Request(this.A,t)).then(this.Sa.bind(this),this.ga.bind(this))},e.abort=function(){this.response=this.responseText="",this.u=new Headers,this.status=0,this.j&&this.j.cancel("Request was aborted.").catch((()=>{})),1<=this.readyState&&this.g&&4!=this.readyState&&(this.g=!1,Dt(this)),this.readyState=0},e.Sa=function(e){if(this.g&&(this.l=e,this.h||(this.status=this.l.status,this.statusText=this.l.statusText,this.h=e.headers,this.readyState=2,Mt(this)),this.g&&(this.readyState=3,Mt(this),this.g)))if("arraybuffer"===this.responseType)e.arrayBuffer().then(this.Qa.bind(this),this.ga.bind(this));else if("undefined"!==typeof a.ReadableStream&&"body"in e){if(this.j=e.body.getReader(),this.o){if(this.responseType)throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');this.response=[]}else this.response=this.responseText="",this.v=new TextDecoder;Rt(this)}else e.text().then(this.Ra.bind(this),this.ga.bind(this))},e.Pa=function(e){if(this.g){if(this.o&&e.value)this.response.push(e.value);else if(!this.o){var t=e.value?e.value:new Uint8Array(0);(t=this.v.decode(t,{stream:!e.done}))&&(this.response=this.responseText+=t)}e.done?Dt(this):Mt(this),3==this.readyState&&Rt(this)}},e.Ra=function(e){this.g&&(this.response=this.responseText=e,Dt(this))},e.Qa=function(e){this.g&&(this.response=e,Dt(this))},e.ga=function(){this.g&&Dt(this)},e.setRequestHeader=function(e,t){this.u.append(e,t)},e.getResponseHeader=function(e){return this.h&&this.h.get(e.toLowerCase())||""},e.getAllResponseHeaders=function(){if(!this.h)return"";const e=[],t=this.h.entries();for(var n=t.next();!n.done;)n=n.value,e.push(n[0]+": "+n[1]),n=t.next();return e.join("\r\n")},Object.defineProperty($t.prototype,"withCredentials",{get:function(){return"include"===this.m},set:function(e){this.m=e?"include":"same-origin"}}),d(Pt,ne);var Lt=/^https?$/i,zt=["POST","PUT"];function Bt(e,t){e.h=!1,e.g&&(e.j=!0,e.g.abort(),e.j=!1),e.l=t,e.m=5,Wt(e),Ut(e)}function Wt(e){e.A||(e.A=!0,re(e,"complete"),re(e,"error"))}function Vt(e){if(e.h&&"undefined"!=typeof r&&(!e.v[1]||4!=Gt(e)||2!=e.Z()))if(e.u&&4==Gt(e))se(e.Ea,0,e);else if(re(e,"readystatechange"),4==Gt(e)){e.h=!1;try{const r=e.Z();e:switch(r){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var t=!0;break e;default:t=!1}var n;if(!(n=t)){var s;if(s=0===r){var i=String(e.D).match(at)[1]||null;!i&&a.self&&a.self.location&&(i=a.self.location.protocol.slice(0,-1)),s=!Lt.test(i?i.toLowerCase():"")}n=s}if(n)re(e,"complete"),re(e,"success");else{e.m=6;try{var o=2<Gt(e)?e.g.statusText:""}catch(l){o=""}e.l=o+" ["+e.Z()+"]",Wt(e)}}finally{Ut(e)}}}function Ut(e,t){if(e.g){jt(e);const n=e.g,r=e.v[0]?()=>{}:null;e.g=null,e.v=null,t||re(e,"ready");try{n.onreadystatechange=r}catch(mD){}}}function jt(e){e.I&&(a.clearTimeout(e.I),e.I=null)}function Gt(e){return e.g?e.g.readyState:0}function Ht(e){try{if(!e.g)return null;if("response"in e.g)return e.g.response;switch(e.H){case"":case"text":return e.g.responseText;case"arraybuffer":if("mozResponseArrayBuffer"in e.g)return e.g.mozResponseArrayBuffer}return null}catch(yd){return null}}function qt(e,t,n){return n&&n.internalChannelParams&&n.internalChannelParams[e]||t}function Kt(e){this.Aa=0,this.i=[],this.j=new Ae,this.ia=this.qa=this.I=this.W=this.g=this.ya=this.D=this.H=this.m=this.S=this.o=null,this.Ya=this.U=0,this.Va=qt("failFast",!1,e),this.F=this.C=this.u=this.s=this.l=null,this.X=!0,this.za=this.T=-1,this.Y=this.v=this.B=0,this.Ta=qt("baseRetryDelayMs",5e3,e),this.cb=qt("retryDelaySeedMs",1e4,e),this.Wa=qt("forwardChannelMaxRetries",2,e),this.wa=qt("forwardChannelRequestTimeoutMs",2e4,e),this.pa=e&&e.xmlHttpFactory||void 0,this.Xa=e&&e.Tb||void 0,this.Ca=e&&e.useFetchStreams||!1,this.L=void 0,this.J=e&&e.supportsCrossDomainXhr||!1,this.K="",this.h=new Ye(e&&e.concurrentRequestLimit),this.Da=new Et,this.P=e&&e.fastHandshake||!1,this.O=e&&e.encodeInitMessageHeaders||!1,this.P&&this.O&&(this.O=!1),this.Ua=e&&e.Rb||!1,e&&e.xa&&this.j.xa(),e&&e.forceLongPolling&&(this.X=!1),this.ba=!this.P&&this.X&&e&&e.detectBufferingProxy||!1,this.ja=void 0,e&&e.longPollingTimeout&&0<e.longPollingTimeout&&(this.ja=e.longPollingTimeout),this.ca=void 0,this.R=0,this.M=!1,this.ka=this.A=null}function Xt(e){if(Qt(e),3==e.G){var t=e.U++,n=it(e.I);if(ct(n,"SID",e.K),ct(n,"RID",t),ct(n,"TYPE","terminate"),en(e,n),(t=new Fe(e,e.j,t)).L=2,t.v=dt(it(n)),n=!1,a.navigator&&a.navigator.sendBeacon)try{n=a.navigator.sendBeacon(t.v.toString(),"")}catch(r){}!n&&a.Image&&((new Image).src=t.v,n=!0),n||(t.g=pn(t.j,null),t.g.ea(t.v)),t.F=Date.now(),Ue(t)}dn(e)}function Yt(e){e.g&&(an(e),e.g.cancel(),e.g=null)}function Qt(e){Yt(e),e.u&&(a.clearTimeout(e.u),e.u=null),on(e),e.h.cancel(),e.s&&("number"===typeof e.s&&a.clearTimeout(e.s),e.s=null)}function Jt(e){if(!Qe(e.h)&&!e.s){e.s=!0;var t=e.Ga;T||_(),E||(T(),E=!0),A.add(t,e),e.B=0}}function Zt(e,t){var n;n=t?t.l:e.U++;const r=it(e.I);ct(r,"SID",e.K),ct(r,"RID",n),ct(r,"AID",e.T),en(e,r),e.m&&e.o&&Ot(r,e.m,e.o),n=new Fe(e,e.j,n,e.B+1),null===e.m&&(n.H=e.o),t&&(e.i=t.D.concat(e.i)),t=tn(e,n,1e3),n.I=Math.round(.5*e.wa)+Math.round(.5*e.wa*Math.random()),et(e.h,n),ze(n,r,t)}function en(e,t){e.H&&b(e.H,(function(e,n){ct(t,n,e)})),e.l&&rt({},(function(e,n){ct(t,n,e)}))}function tn(e,t,n){n=Math.min(e.i.length,n);var r=e.l?u(e.l.Na,e.l,e):null;e:{var a=e.i;let t=-1;for(;;){const e=["count="+n];-1==t?0<n?(t=a[0].g,e.push("ofs="+t)):t=0:e.push("ofs="+t);let s=!0;for(let i=0;i<n;i++){let n=a[i].g;const o=a[i].map;if(n-=t,0>n)t=Math.max(0,a[i].g-100),s=!1;else try{At(o,e,"req"+n+"_")}catch(TR){r&&r(o)}}if(s){r=e.join("&");break e}}}return e=e.i.splice(0,n),t.D=e,r}function nn(e){if(!e.g&&!e.u){e.Y=1;var t=e.Fa;T||_(),E||(T(),E=!0),A.add(t,e),e.v=0}}function rn(e){return!(e.g||e.u||3<=e.v)&&(e.Y++,e.u=Ee(u(e.Fa,e),un(e,e.v)),e.v++,!0)}function an(e){null!=e.A&&(a.clearTimeout(e.A),e.A=null)}function sn(e){e.g=new Fe(e,e.j,"rpc",e.Y),null===e.m&&(e.g.H=e.o),e.g.O=0;var t=it(e.qa);ct(t,"RID","rpc"),ct(t,"SID",e.K),ct(t,"AID",e.T),ct(t,"CI",e.F?"0":"1"),!e.F&&e.ja&&ct(t,"TO",e.ja),ct(t,"TYPE","xmlhttp"),en(e,t),e.m&&e.o&&Ot(t,e.m,e.o),e.L&&(e.g.I=e.L);var n=e.g;e=e.ia,n.L=1,n.v=dt(it(t)),n.m=null,n.P=!0,Be(n,e)}function on(e){null!=e.C&&(a.clearTimeout(e.C),e.C=null)}function ln(e,t){var n=null;if(e.g==t){on(e),an(e),e.g=null;var r=2}else{if(!Ze(e.h,t))return;n=t.D,tt(e.h,t),r=1}if(0!=e.G)if(t.o)if(1==r){n=t.m?t.m.length:0,t=Date.now()-t.F;var a=e.B;re(r=ke(),new Te(r,n)),Jt(e)}else nn(e);else if(3==(a=t.s)||0==a&&0<t.X||!(1==r&&function(e,t){return!(Je(e.h)>=e.h.j-(e.s?1:0))&&(e.s?(e.i=t.D.concat(e.i),!0):!(1==e.G||2==e.G||e.B>=(e.Va?0:e.Wa))&&(e.s=Ee(u(e.Ga,e,t),un(e,e.B)),e.B++,!0))}(e,t)||2==r&&rn(e)))switch(n&&0<n.length&&(t=e.h,t.i=t.i.concat(n)),a){case 1:cn(e,5);break;case 4:cn(e,10);break;case 3:cn(e,6);break;default:cn(e,2)}}function un(e,t){let n=e.Ta+Math.floor(Math.random()*e.cb);return e.isActive()||(n*=2),n*t}function cn(e,t){if(e.j.info("Error code "+t),2==t){var n=u(e.fb,e),r=e.Xa;const t=!r;r=new st(r||"//www.google.com/images/cleardot.gif"),a.location&&"http"==a.location.protocol||ot(r,"https"),dt(r),t?function(e,t){const n=new Ae;if(a.Image){const r=new Image;r.onload=c(Tt,n,"TestLoadImage: loaded",!0,t,r),r.onerror=c(Tt,n,"TestLoadImage: error",!1,t,r),r.onabort=c(Tt,n,"TestLoadImage: abort",!1,t,r),r.ontimeout=c(Tt,n,"TestLoadImage: timeout",!1,t,r),a.setTimeout((function(){r.ontimeout&&r.ontimeout()}),1e4),r.src=e}else t(!1)}(r.toString(),n):function(e,t){new Ae;const n=new AbortController,r=setTimeout((()=>{n.abort(),Tt(0,0,!1,t)}),1e4);fetch(e,{signal:n.signal}).then((e=>{clearTimeout(r),e.ok?Tt(0,0,!0,t):Tt(0,0,!1,t)})).catch((()=>{clearTimeout(r),Tt(0,0,!1,t)}))}(r.toString(),n)}else Ne(2);e.G=0,e.l&&e.l.sa(t),dn(e),Qt(e)}function dn(e){if(e.G=0,e.ka=[],e.l){const t=nt(e.h);0==t.length&&0==e.i.length||(p(e.ka,t),p(e.ka,e.i),e.h.i.length=0,h(e.i),e.i.length=0),e.l.ra()}}function hn(e,t,n){var r=n instanceof st?it(n):new st(n);if(""!=r.g)t&&(r.g=t+"."+r.g),lt(r,r.s);else{var s=a.location;r=s.protocol,t=t?t+"."+s.hostname:s.hostname,s=+s.port;var i=new st(null);r&&ot(i,r),t&&(i.g=t),s&&lt(i,s),n&&(i.l=n),r=i}return n=e.D,t=e.ya,n&&t&&ct(r,n,t),ct(r,"VER",e.la),en(e,r),r}function pn(e,t,n){if(t&&!e.J)throw Error("Can't create secondary domain capable XhrIo object.");return(t=e.Ca&&!e.pa?new Pt(new _t({eb:n})):new Pt(e.pa)).Ha(e.J),t}function fn(){}function mn(){}function gn(e,t){ne.call(this),this.g=new Kt(t),this.l=e,this.h=t&&t.messageUrlParams||null,e=t&&t.messageHeaders||null,t&&t.clientProtocolHeaderRequired&&(e?e["X-Client-Protocol"]="webchannel":e={"X-Client-Protocol":"webchannel"}),this.g.o=e,e=t&&t.initMessageHeaders||null,t&&t.messageContentType&&(e?e["X-WebChannel-Content-Type"]=t.messageContentType:e={"X-WebChannel-Content-Type":t.messageContentType}),t&&t.va&&(e?e["X-WebChannel-Client-Profile"]=t.va:e={"X-WebChannel-Client-Profile":t.va}),this.g.S=e,(e=t&&t.Sb)&&!f(e)&&(this.g.m=e),this.v=t&&t.supportsCrossDomainXhr||!1,this.u=t&&t.sendRawJson||!1,(t=t&&t.httpSessionIdParam)&&!f(t)&&(this.g.D=t,null!==(e=this.h)&&t in e&&(t in(e=this.h)&&delete e[t])),this.j=new vn(this)}function yn(e){be.call(this),e.__headers__&&(this.headers=e.__headers__,this.statusCode=e.__status__,delete e.__headers__,delete e.__status__);var t=e.__sm__;if(t){e:{for(const n in t){e=n;break e}e=void 0}(this.i=e)&&(e=this.i,t=null!==t&&e in t?t[e]:void 0),this.data=t}else this.data=e}function bn(){ve.call(this),this.status=1}function vn(e){this.g=e}(e=Pt.prototype).Ha=function(e){this.J=e},e.ea=function(e,t,n,r){if(this.g)throw Error("[goog.net.XhrIo] Object is active with another request="+this.D+"; newUri="+e);t=t?t.toUpperCase():"GET",this.D=e,this.l="",this.m=0,this.A=!1,this.h=!0,this.g=this.o?this.o.g():$e.g(),this.v=this.o?me(this.o):me($e),this.g.onreadystatechange=u(this.Ea,this);try{this.B=!0,this.g.open(t,String(e),!0),this.B=!1}catch(i){return void Bt(this,i)}if(e=n||"",n=new Map(this.headers),r)if(Object.getPrototypeOf(r)===Object.prototype)for(var s in r)n.set(s,r[s]);else{if("function"!==typeof r.keys||"function"!==typeof r.get)throw Error("Unknown input type for opt_headers: "+String(r));for(const e of r.keys())n.set(e,r.get(e))}r=Array.from(n.keys()).find((e=>"content-type"==e.toLowerCase())),s=a.FormData&&e instanceof a.FormData,!(0<=Array.prototype.indexOf.call(zt,t,void 0))||r||s||n.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");for(const[a,o]of n)this.g.setRequestHeader(a,o);this.H&&(this.g.responseType=this.H),"withCredentials"in this.g&&this.g.withCredentials!==this.J&&(this.g.withCredentials=this.J);try{jt(this),this.u=!0,this.g.send(e),this.u=!1}catch(i){Bt(this,i)}},e.abort=function(e){this.g&&this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1,this.m=e||7,re(this,"complete"),re(this,"abort"),Ut(this))},e.N=function(){this.g&&(this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1),Ut(this,!0)),Pt.aa.N.call(this)},e.Ea=function(){this.s||(this.B||this.u||this.j?Vt(this):this.bb())},e.bb=function(){Vt(this)},e.isActive=function(){return!!this.g},e.Z=function(){try{return 2<Gt(this)?this.g.status:-1}catch(mt){return-1}},e.oa=function(){try{return this.g?this.g.responseText:""}catch(mt){return""}},e.Oa=function(e){if(this.g){var t=this.g.responseText;return e&&0==t.indexOf(e)&&(t=t.substring(e.length)),he(t)}},e.Ba=function(){return this.m},e.Ka=function(){return"string"===typeof this.l?this.l:String(this.l)},(e=Kt.prototype).la=8,e.G=1,e.connect=function(e,t,n,r){Ne(0),this.W=e,this.H=t||{},n&&void 0!==r&&(this.H.OSID=n,this.H.OAID=r),this.F=this.X,this.I=hn(this,null,this.W),Jt(this)},e.Ga=function(e){if(this.s)if(this.s=null,1==this.G){if(!e){this.U=Math.floor(1e5*Math.random()),e=this.U++;const a=new Fe(this,this.j,e);let s=this.o;if(this.S&&(s?(s=v(s),w(s,this.S)):s=this.S),null!==this.m||this.O||(a.H=s,s=null),this.P)e:{for(var t=0,n=0;n<this.i.length;n++){var r=this.i[n];if(void 0===(r="__data__"in r.map&&"string"===typeof(r=r.map.__data__)?r.length:void 0))break;if(4096<(t+=r)){t=n;break e}if(4096===t||n===this.i.length-1){t=n+1;break e}}t=1e3}else t=1e3;t=tn(this,a,t),ct(n=it(this.I),"RID",e),ct(n,"CVER",22),this.D&&ct(n,"X-HTTP-Session-Id",this.D),en(this,n),s&&(this.O?t="headers="+encodeURIComponent(String(Ft(s)))+"&"+t:this.m&&Ot(n,this.m,s)),et(this.h,a),this.Ua&&ct(n,"TYPE","init"),this.P?(ct(n,"$req",t),ct(n,"SID","null"),a.T=!0,ze(a,n,null)):ze(a,n,t),this.G=2}}else 3==this.G&&(e?Zt(this,e):0==this.i.length||Qe(this.h)||Zt(this))},e.Fa=function(){if(this.u=null,sn(this),this.ba&&!(this.M||null==this.g||0>=this.R)){var e=2*this.R;this.j.info("BP detection timer enabled: "+e),this.A=Ee(u(this.ab,this),e)}},e.ab=function(){this.A&&(this.A=null,this.j.info("BP detection timeout reached."),this.j.info("Buffering proxy detected and switch to long-polling!"),this.F=!1,this.M=!0,Ne(10),Yt(this),sn(this))},e.Za=function(){null!=this.C&&(this.C=null,Yt(this),rn(this),Ne(19))},e.fb=function(e){e?(this.j.info("Successfully pinged google.com"),Ne(2)):(this.j.info("Failed to ping google.com"),Ne(1))},e.isActive=function(){return!!this.l&&this.l.isActive(this)},(e=fn.prototype).ua=function(){},e.ta=function(){},e.sa=function(){},e.ra=function(){},e.isActive=function(){return!0},e.Na=function(){},mn.prototype.g=function(e,t){return new gn(e,t)},d(gn,ne),gn.prototype.m=function(){this.g.l=this.j,this.v&&(this.g.J=!0),this.g.connect(this.l,this.h||void 0)},gn.prototype.close=function(){Xt(this.g)},gn.prototype.o=function(e){var t=this.g;if("string"===typeof e){var n={};n.__data__=e,e=n}else this.u&&((n={}).__data__=de(e),e=n);t.i.push(new Xe(t.Ya++,e)),3==t.G&&Jt(t)},gn.prototype.N=function(){this.g.l=null,delete this.j,Xt(this.g),delete this.g,gn.aa.N.call(this)},d(yn,be),d(bn,ve),d(vn,fn),vn.prototype.ua=function(){re(this.g,"a")},vn.prototype.ta=function(e){re(this.g,new yn(e))},vn.prototype.sa=function(e){re(this.g,new bn)},vn.prototype.ra=function(){re(this.g,"b")},mn.prototype.createWebChannel=mn.prototype.g,gn.prototype.send=gn.prototype.o,gn.prototype.open=gn.prototype.m,gn.prototype.close=gn.prototype.close,hd=fd.createWebChannelTransport=function(){return new mn},dd=fd.getStatEventTarget=function(){return ke()},cd=fd.Event=xe,ud=fd.Stat={mb:0,pb:1,qb:2,Jb:3,Ob:4,Lb:5,Mb:6,Kb:7,Ib:8,Nb:9,PROXY:10,NOPROXY:11,Gb:12,Cb:13,Db:14,Bb:15,Eb:16,Fb:17,ib:18,hb:19,jb:20},Re.NO_ERROR=0,Re.TIMEOUT=8,Re.HTTP_ERROR=6,ld=fd.ErrorCode=Re,De.COMPLETE="complete",od=fd.EventType=De,ge.EventType=ye,ye.OPEN="a",ye.CLOSE="b",ye.ERROR="c",ye.MESSAGE="d",ne.prototype.listen=ne.prototype.K,id=fd.WebChannel=ge,sd=fd.FetchXmlHttpFactory=_t,Pt.prototype.listenOnce=Pt.prototype.L,Pt.prototype.getLastError=Pt.prototype.Ka,Pt.prototype.getLastErrorCode=Pt.prototype.Ba,Pt.prototype.getStatus=Pt.prototype.Z,Pt.prototype.getResponseJson=Pt.prototype.Oa,Pt.prototype.getResponseText=Pt.prototype.oa,Pt.prototype.send=Pt.prototype.ea,Pt.prototype.setWithCredentials=Pt.prototype.Ha,ad=fd.XhrIo=Pt}).apply("undefined"!==typeof pd?pd:"undefined"!==typeof self?self:"undefined"!==typeof window?window:{});const md="@firebase/firestore";class gd{constructor(e){this.uid=e}isAuthenticated(){return null!=this.uid}toKey(){return this.isAuthenticated()?"uid:"+this.uid:"anonymous-user"}isEqual(e){return e.uid===this.uid}}gd.UNAUTHENTICATED=new gd(null),gd.GOOGLE_CREDENTIALS=new gd("google-credentials-uid"),gd.FIRST_PARTY=new gd("first-party-uid"),gd.MOCK_USER=new gd("mock-user");let yd="10.13.1";const bd=new Pu("@firebase/firestore");function vd(){return bd.logLevel}function xd(e){if(bd.logLevel<=Ru.DEBUG){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(Sd);bd.debug(`Firestore (${yd}): ${e}`,...a)}}function wd(e){if(bd.logLevel<=Ru.ERROR){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(Sd);bd.error(`Firestore (${yd}): ${e}`,...a)}}function kd(e){if(bd.logLevel<=Ru.WARN){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(Sd);bd.warn(`Firestore (${yd}): ${e}`,...a)}}function Sd(e){if("string"==typeof e)return e;try{return function(e){return JSON.stringify(e)}(e)}catch(t){return e}}function Id(){const e=`FIRESTORE (${yd}) INTERNAL ASSERTION FAILED: `+(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Unexpected state");throw wd(e),new Error(e)}function Cd(e,t){e||Id()}function Nd(e,t){return e}const Td={OK:"ok",CANCELLED:"cancelled",UNKNOWN:"unknown",INVALID_ARGUMENT:"invalid-argument",DEADLINE_EXCEEDED:"deadline-exceeded",NOT_FOUND:"not-found",ALREADY_EXISTS:"already-exists",PERMISSION_DENIED:"permission-denied",UNAUTHENTICATED:"unauthenticated",RESOURCE_EXHAUSTED:"resource-exhausted",FAILED_PRECONDITION:"failed-precondition",ABORTED:"aborted",OUT_OF_RANGE:"out-of-range",UNIMPLEMENTED:"unimplemented",INTERNAL:"internal",UNAVAILABLE:"unavailable",DATA_LOSS:"data-loss"};class Ed extends xu{constructor(e,t){super(e,t),this.code=e,this.message=t,this.toString=()=>`${this.name}: [code=${this.code}]: ${this.message}`}}class Ad{constructor(){this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}}class _d{constructor(e,t){this.user=t,this.type="OAuth",this.headers=new Map,this.headers.set("Authorization",`Bearer ${e}`)}}class $d{getToken(){return Promise.resolve(null)}invalidateToken(){}start(e,t){e.enqueueRetryable((()=>t(gd.UNAUTHENTICATED)))}shutdown(){}}class Rd{constructor(e){this.token=e,this.changeListener=null}getToken(){return Promise.resolve(this.token)}invalidateToken(){}start(e,t){this.changeListener=t,e.enqueueRetryable((()=>t(this.token.user)))}shutdown(){this.changeListener=null}}class Dd{constructor(e){this.t=e,this.currentUser=gd.UNAUTHENTICATED,this.i=0,this.forceRefresh=!1,this.auth=null}start(e,t){let n=this.i;const r=e=>this.i!==n?(n=this.i,t(e)):Promise.resolve();let a=new Ad;this.o=()=>{this.i++,this.currentUser=this.u(),a.resolve(),a=new Ad,e.enqueueRetryable((()=>r(this.currentUser)))};const s=()=>{const t=a;e.enqueueRetryable((async()=>{await t.promise,await r(this.currentUser)}))},i=e=>{xd("FirebaseAuthCredentialsProvider","Auth detected"),this.auth=e,this.auth.addAuthTokenListener(this.o),s()};this.t.onInit((e=>i(e))),setTimeout((()=>{if(!this.auth){const e=this.t.getImmediate({optional:!0});e?i(e):(xd("FirebaseAuthCredentialsProvider","Auth not yet detected"),a.resolve(),a=new Ad)}}),0),s()}getToken(){const e=this.i,t=this.forceRefresh;return this.forceRefresh=!1,this.auth?this.auth.getToken(t).then((t=>this.i!==e?(xd("FirebaseAuthCredentialsProvider","getToken aborted due to token change."),this.getToken()):t?(Cd("string"==typeof t.accessToken),new _d(t.accessToken,this.currentUser)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.auth&&this.auth.removeAuthTokenListener(this.o)}u(){const e=this.auth&&this.auth.getUid();return Cd(null===e||"string"==typeof e),new gd(e)}}class Md{constructor(e,t,n){this.l=e,this.h=t,this.P=n,this.type="FirstParty",this.user=gd.FIRST_PARTY,this.I=new Map}T(){return this.P?this.P():null}get headers(){this.I.set("X-Goog-AuthUser",this.l);const e=this.T();return e&&this.I.set("Authorization",e),this.h&&this.I.set("X-Goog-Iam-Authorization-Token",this.h),this.I}}class Fd{constructor(e,t,n){this.l=e,this.h=t,this.P=n}getToken(){return Promise.resolve(new Md(this.l,this.h,this.P))}start(e,t){e.enqueueRetryable((()=>t(gd.FIRST_PARTY)))}shutdown(){}invalidateToken(){}}class Od{constructor(e){this.value=e,this.type="AppCheck",this.headers=new Map,e&&e.length>0&&this.headers.set("x-firebase-appcheck",this.value)}}class Pd{constructor(e){this.A=e,this.forceRefresh=!1,this.appCheck=null,this.R=null}start(e,t){const n=e=>{null!=e.error&&xd("FirebaseAppCheckTokenProvider",`Error getting App Check token; using placeholder token instead. Error: ${e.error.message}`);const n=e.token!==this.R;return this.R=e.token,xd("FirebaseAppCheckTokenProvider",`Received ${n?"new":"existing"} token.`),n?t(e.token):Promise.resolve()};this.o=t=>{e.enqueueRetryable((()=>n(t)))};const r=e=>{xd("FirebaseAppCheckTokenProvider","AppCheck detected"),this.appCheck=e,this.appCheck.addTokenListener(this.o)};this.A.onInit((e=>r(e))),setTimeout((()=>{if(!this.appCheck){const e=this.A.getImmediate({optional:!0});e?r(e):xd("FirebaseAppCheckTokenProvider","AppCheck not yet detected")}}),0)}getToken(){const e=this.forceRefresh;return this.forceRefresh=!1,this.appCheck?this.appCheck.getToken(e).then((e=>e?(Cd("string"==typeof e.token),this.R=e.token,new Od(e.token)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.appCheck&&this.appCheck.removeTokenListener(this.o)}}function Ld(e){const t="undefined"!=typeof self&&(self.crypto||self.msCrypto),n=new Uint8Array(e);if(t&&"function"==typeof t.getRandomValues)t.getRandomValues(n);else for(let r=0;r<e;r++)n[r]=Math.floor(256*Math.random());return n}class zd{static newId(){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",t=62*Math.floor(256/62);let n="";for(;n.length<20;){const r=Ld(40);for(let a=0;a<r.length;++a)n.length<20&&r[a]<t&&(n+=e.charAt(r[a]%62))}return n}}function Bd(e,t){return e<t?-1:e>t?1:0}function Wd(e,t,n){return e.length===t.length&&e.every(((e,r)=>n(e,t[r])))}class Vd{constructor(e,t){if(this.seconds=e,this.nanoseconds=t,t<0)throw new Ed(Td.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+t);if(t>=1e9)throw new Ed(Td.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+t);if(e<-62135596800)throw new Ed(Td.INVALID_ARGUMENT,"Timestamp seconds out of range: "+e);if(e>=253402300800)throw new Ed(Td.INVALID_ARGUMENT,"Timestamp seconds out of range: "+e)}static now(){return Vd.fromMillis(Date.now())}static fromDate(e){return Vd.fromMillis(e.getTime())}static fromMillis(e){const t=Math.floor(e/1e3),n=Math.floor(1e6*(e-1e3*t));return new Vd(t,n)}toDate(){return new Date(this.toMillis())}toMillis(){return 1e3*this.seconds+this.nanoseconds/1e6}_compareTo(e){return this.seconds===e.seconds?Bd(this.nanoseconds,e.nanoseconds):Bd(this.seconds,e.seconds)}isEqual(e){return e.seconds===this.seconds&&e.nanoseconds===this.nanoseconds}toString(){return"Timestamp(seconds="+this.seconds+", nanoseconds="+this.nanoseconds+")"}toJSON(){return{seconds:this.seconds,nanoseconds:this.nanoseconds}}valueOf(){const e=this.seconds- -62135596800;return String(e).padStart(12,"0")+"."+String(this.nanoseconds).padStart(9,"0")}}class Ud{constructor(e){this.timestamp=e}static fromTimestamp(e){return new Ud(e)}static min(){return new Ud(new Vd(0,0))}static max(){return new Ud(new Vd(253402300799,999999999))}compareTo(e){return this.timestamp._compareTo(e.timestamp)}isEqual(e){return this.timestamp.isEqual(e.timestamp)}toMicroseconds(){return 1e6*this.timestamp.seconds+this.timestamp.nanoseconds/1e3}toString(){return"SnapshotVersion("+this.timestamp.toString()+")"}toTimestamp(){return this.timestamp}}class jd{constructor(e,t,n){void 0===t?t=0:t>e.length&&Id(),void 0===n?n=e.length-t:n>e.length-t&&Id(),this.segments=e,this.offset=t,this.len=n}get length(){return this.len}isEqual(e){return 0===jd.comparator(this,e)}child(e){const t=this.segments.slice(this.offset,this.limit());return e instanceof jd?e.forEach((e=>{t.push(e)})):t.push(e),this.construct(t)}limit(){return this.offset+this.length}popFirst(e){return e=void 0===e?1:e,this.construct(this.segments,this.offset+e,this.length-e)}popLast(){return this.construct(this.segments,this.offset,this.length-1)}firstSegment(){return this.segments[this.offset]}lastSegment(){return this.get(this.length-1)}get(e){return this.segments[this.offset+e]}isEmpty(){return 0===this.length}isPrefixOf(e){if(e.length<this.length)return!1;for(let t=0;t<this.length;t++)if(this.get(t)!==e.get(t))return!1;return!0}isImmediateParentOf(e){if(this.length+1!==e.length)return!1;for(let t=0;t<this.length;t++)if(this.get(t)!==e.get(t))return!1;return!0}forEach(e){for(let t=this.offset,n=this.limit();t<n;t++)e(this.segments[t])}toArray(){return this.segments.slice(this.offset,this.limit())}static comparator(e,t){const n=Math.min(e.length,t.length);for(let r=0;r<n;r++){const n=e.get(r),a=t.get(r);if(n<a)return-1;if(n>a)return 1}return e.length<t.length?-1:e.length>t.length?1:0}}class Gd extends jd{construct(e,t,n){return new Gd(e,t,n)}canonicalString(){return this.toArray().join("/")}toString(){return this.canonicalString()}toUriEncodedString(){return this.toArray().map(encodeURIComponent).join("/")}static fromString(){const e=[];for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const a of n){if(a.indexOf("//")>=0)throw new Ed(Td.INVALID_ARGUMENT,`Invalid segment (${a}). Paths must not contain // in them.`);e.push(...a.split("/").filter((e=>e.length>0)))}return new Gd(e)}static emptyPath(){return new Gd([])}}const Hd=/^[_a-zA-Z][_a-zA-Z0-9]*$/;class qd extends jd{construct(e,t,n){return new qd(e,t,n)}static isValidIdentifier(e){return Hd.test(e)}canonicalString(){return this.toArray().map((e=>(e=e.replace(/\\/g,"\\\\").replace(/`/g,"\\`"),qd.isValidIdentifier(e)||(e="`"+e+"`"),e))).join(".")}toString(){return this.canonicalString()}isKeyField(){return 1===this.length&&"__name__"===this.get(0)}static keyField(){return new qd(["__name__"])}static fromServerFormat(e){const t=[];let n="",r=0;const a=()=>{if(0===n.length)throw new Ed(Td.INVALID_ARGUMENT,`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);t.push(n),n=""};let s=!1;for(;r<e.length;){const t=e[r];if("\\"===t){if(r+1===e.length)throw new Ed(Td.INVALID_ARGUMENT,"Path has trailing escape character: "+e);const t=e[r+1];if("\\"!==t&&"."!==t&&"`"!==t)throw new Ed(Td.INVALID_ARGUMENT,"Path has invalid escape sequence: "+e);n+=t,r+=2}else"`"===t?(s=!s,r++):"."!==t||s?(n+=t,r++):(a(),r++)}if(a(),s)throw new Ed(Td.INVALID_ARGUMENT,"Unterminated ` in path: "+e);return new qd(t)}static emptyPath(){return new qd([])}}class Kd{constructor(e){this.path=e}static fromPath(e){return new Kd(Gd.fromString(e))}static fromName(e){return new Kd(Gd.fromString(e).popFirst(5))}static empty(){return new Kd(Gd.emptyPath())}get collectionGroup(){return this.path.popLast().lastSegment()}hasCollectionId(e){return this.path.length>=2&&this.path.get(this.path.length-2)===e}getCollectionGroup(){return this.path.get(this.path.length-2)}getCollectionPath(){return this.path.popLast()}isEqual(e){return null!==e&&0===Gd.comparator(this.path,e.path)}toString(){return this.path.toString()}static comparator(e,t){return Gd.comparator(e.path,t.path)}static isDocumentKey(e){return e.length%2==0}static fromSegments(e){return new Kd(new Gd(e.slice()))}}class Xd{constructor(e,t,n,r){this.indexId=e,this.collectionGroup=t,this.fields=n,this.indexState=r}}Xd.UNKNOWN_ID=-1;function Yd(e,t){const n=e.toTimestamp().seconds,r=e.toTimestamp().nanoseconds+1,a=Ud.fromTimestamp(1e9===r?new Vd(n+1,0):new Vd(n,r));return new Jd(a,Kd.empty(),t)}function Qd(e){return new Jd(e.readTime,e.key,-1)}class Jd{constructor(e,t,n){this.readTime=e,this.documentKey=t,this.largestBatchId=n}static min(){return new Jd(Ud.min(),Kd.empty(),-1)}static max(){return new Jd(Ud.max(),Kd.empty(),-1)}}function Zd(e,t){let n=e.readTime.compareTo(t.readTime);return 0!==n?n:(n=Kd.comparator(e.documentKey,t.documentKey),0!==n?n:Bd(e.largestBatchId,t.largestBatchId))}const eh="The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";class th{constructor(){this.onCommittedListeners=[]}addOnCommittedListener(e){this.onCommittedListeners.push(e)}raiseOnCommittedEvent(){this.onCommittedListeners.forEach((e=>e()))}}async function nh(e){if(e.code!==Td.FAILED_PRECONDITION||e.message!==eh)throw e;xd("LocalStore","Unexpectedly lost primary lease")}class rh{constructor(e){this.nextCallback=null,this.catchCallback=null,this.result=void 0,this.error=void 0,this.isDone=!1,this.callbackAttached=!1,e((e=>{this.isDone=!0,this.result=e,this.nextCallback&&this.nextCallback(e)}),(e=>{this.isDone=!0,this.error=e,this.catchCallback&&this.catchCallback(e)}))}catch(e){return this.next(void 0,e)}next(e,t){return this.callbackAttached&&Id(),this.callbackAttached=!0,this.isDone?this.error?this.wrapFailure(t,this.error):this.wrapSuccess(e,this.result):new rh(((n,r)=>{this.nextCallback=t=>{this.wrapSuccess(e,t).next(n,r)},this.catchCallback=e=>{this.wrapFailure(t,e).next(n,r)}}))}toPromise(){return new Promise(((e,t)=>{this.next(e,t)}))}wrapUserFunction(e){try{const t=e();return t instanceof rh?t:rh.resolve(t)}catch(e){return rh.reject(e)}}wrapSuccess(e,t){return e?this.wrapUserFunction((()=>e(t))):rh.resolve(t)}wrapFailure(e,t){return e?this.wrapUserFunction((()=>e(t))):rh.reject(t)}static resolve(e){return new rh(((t,n)=>{t(e)}))}static reject(e){return new rh(((t,n)=>{n(e)}))}static waitFor(e){return new rh(((t,n)=>{let r=0,a=0,s=!1;e.forEach((e=>{++r,e.next((()=>{++a,s&&a===r&&t()}),(e=>n(e)))})),s=!0,a===r&&t()}))}static or(e){let t=rh.resolve(!1);for(const n of e)t=t.next((e=>e?rh.resolve(e):n()));return t}static forEach(e,t){const n=[];return e.forEach(((e,r)=>{n.push(t.call(this,e,r))})),this.waitFor(n)}static mapArray(e,t){return new rh(((n,r)=>{const a=e.length,s=new Array(a);let i=0;for(let o=0;o<a;o++){const l=o;t(e[l]).next((e=>{s[l]=e,++i,i===a&&n(s)}),(e=>r(e)))}}))}static doWhile(e,t){return new rh(((n,r)=>{const a=()=>{!0===e()?t().next((()=>{a()}),r):n()};a()}))}}function ah(e){const t=e.match(/Android ([\d.]+)/i),n=t?t[1].split(".").slice(0,2).join("."):"-1";return Number(n)}function sh(e){return"IndexedDbTransactionError"===e.name}class ih{constructor(e,t){this.previousValue=e,t&&(t.sequenceNumberHandler=e=>this.ie(e),this.se=e=>t.writeSequenceNumber(e))}ie(e){return this.previousValue=Math.max(e,this.previousValue),this.previousValue}next(){const e=++this.previousValue;return this.se&&this.se(e),e}}function oh(e){return null==e}function lh(e){return 0===e&&1/e==-1/0}function uh(e){return"number"==typeof e&&Number.isInteger(e)&&!lh(e)&&e<=Number.MAX_SAFE_INTEGER&&e>=Number.MIN_SAFE_INTEGER}ih.oe=-1;const ch=["mutationQueues","mutations","documentMutations","remoteDocuments","targets","owner","targetGlobal","targetDocuments","clientMetadata","remoteDocumentGlobal","collectionParents","bundles","namedQueries"],dh=["mutationQueues","mutations","documentMutations","remoteDocumentsV14","targets","owner","targetGlobal","targetDocuments","clientMetadata","remoteDocumentGlobal","collectionParents","bundles","namedQueries","documentOverlays"],hh=dh,ph=[...hh,"indexConfiguration","indexState","indexEntries"];function fh(e){let t=0;for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t++;return t}function mh(e,t){for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t(n,e[n])}function gh(e){for(const t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!1;return!0}class yh{constructor(e,t){this.comparator=e,this.root=t||vh.EMPTY}insert(e,t){return new yh(this.comparator,this.root.insert(e,t,this.comparator).copy(null,null,vh.BLACK,null,null))}remove(e){return new yh(this.comparator,this.root.remove(e,this.comparator).copy(null,null,vh.BLACK,null,null))}get(e){let t=this.root;for(;!t.isEmpty();){const n=this.comparator(e,t.key);if(0===n)return t.value;n<0?t=t.left:n>0&&(t=t.right)}return null}indexOf(e){let t=0,n=this.root;for(;!n.isEmpty();){const r=this.comparator(e,n.key);if(0===r)return t+n.left.size;r<0?n=n.left:(t+=n.left.size+1,n=n.right)}return-1}isEmpty(){return this.root.isEmpty()}get size(){return this.root.size}minKey(){return this.root.minKey()}maxKey(){return this.root.maxKey()}inorderTraversal(e){return this.root.inorderTraversal(e)}forEach(e){this.inorderTraversal(((t,n)=>(e(t,n),!1)))}toString(){const e=[];return this.inorderTraversal(((t,n)=>(e.push(`${t}:${n}`),!1))),`{${e.join(", ")}}`}reverseTraversal(e){return this.root.reverseTraversal(e)}getIterator(){return new bh(this.root,null,this.comparator,!1)}getIteratorFrom(e){return new bh(this.root,e,this.comparator,!1)}getReverseIterator(){return new bh(this.root,null,this.comparator,!0)}getReverseIteratorFrom(e){return new bh(this.root,e,this.comparator,!0)}}class bh{constructor(e,t,n,r){this.isReverse=r,this.nodeStack=[];let a=1;for(;!e.isEmpty();)if(a=t?n(e.key,t):1,t&&r&&(a*=-1),a<0)e=this.isReverse?e.left:e.right;else{if(0===a){this.nodeStack.push(e);break}this.nodeStack.push(e),e=this.isReverse?e.right:e.left}}getNext(){let e=this.nodeStack.pop();const t={key:e.key,value:e.value};if(this.isReverse)for(e=e.left;!e.isEmpty();)this.nodeStack.push(e),e=e.right;else for(e=e.right;!e.isEmpty();)this.nodeStack.push(e),e=e.left;return t}hasNext(){return this.nodeStack.length>0}peek(){if(0===this.nodeStack.length)return null;const e=this.nodeStack[this.nodeStack.length-1];return{key:e.key,value:e.value}}}class vh{constructor(e,t,n,r,a){this.key=e,this.value=t,this.color=null!=n?n:vh.RED,this.left=null!=r?r:vh.EMPTY,this.right=null!=a?a:vh.EMPTY,this.size=this.left.size+1+this.right.size}copy(e,t,n,r,a){return new vh(null!=e?e:this.key,null!=t?t:this.value,null!=n?n:this.color,null!=r?r:this.left,null!=a?a:this.right)}isEmpty(){return!1}inorderTraversal(e){return this.left.inorderTraversal(e)||e(this.key,this.value)||this.right.inorderTraversal(e)}reverseTraversal(e){return this.right.reverseTraversal(e)||e(this.key,this.value)||this.left.reverseTraversal(e)}min(){return this.left.isEmpty()?this:this.left.min()}minKey(){return this.min().key}maxKey(){return this.right.isEmpty()?this.key:this.right.maxKey()}insert(e,t,n){let r=this;const a=n(e,r.key);return r=a<0?r.copy(null,null,null,r.left.insert(e,t,n),null):0===a?r.copy(null,t,null,null,null):r.copy(null,null,null,null,r.right.insert(e,t,n)),r.fixUp()}removeMin(){if(this.left.isEmpty())return vh.EMPTY;let e=this;return e.left.isRed()||e.left.left.isRed()||(e=e.moveRedLeft()),e=e.copy(null,null,null,e.left.removeMin(),null),e.fixUp()}remove(e,t){let n,r=this;if(t(e,r.key)<0)r.left.isEmpty()||r.left.isRed()||r.left.left.isRed()||(r=r.moveRedLeft()),r=r.copy(null,null,null,r.left.remove(e,t),null);else{if(r.left.isRed()&&(r=r.rotateRight()),r.right.isEmpty()||r.right.isRed()||r.right.left.isRed()||(r=r.moveRedRight()),0===t(e,r.key)){if(r.right.isEmpty())return vh.EMPTY;n=r.right.min(),r=r.copy(n.key,n.value,null,null,r.right.removeMin())}r=r.copy(null,null,null,null,r.right.remove(e,t))}return r.fixUp()}isRed(){return this.color}fixUp(){let e=this;return e.right.isRed()&&!e.left.isRed()&&(e=e.rotateLeft()),e.left.isRed()&&e.left.left.isRed()&&(e=e.rotateRight()),e.left.isRed()&&e.right.isRed()&&(e=e.colorFlip()),e}moveRedLeft(){let e=this.colorFlip();return e.right.left.isRed()&&(e=e.copy(null,null,null,null,e.right.rotateRight()),e=e.rotateLeft(),e=e.colorFlip()),e}moveRedRight(){let e=this.colorFlip();return e.left.left.isRed()&&(e=e.rotateRight(),e=e.colorFlip()),e}rotateLeft(){const e=this.copy(null,null,vh.RED,null,this.right.left);return this.right.copy(null,null,this.color,e,null)}rotateRight(){const e=this.copy(null,null,vh.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,e)}colorFlip(){const e=this.left.copy(null,null,!this.left.color,null,null),t=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,e,t)}checkMaxDepth(){const e=this.check();return Math.pow(2,e)<=this.size+1}check(){if(this.isRed()&&this.left.isRed())throw Id();if(this.right.isRed())throw Id();const e=this.left.check();if(e!==this.right.check())throw Id();return e+(this.isRed()?0:1)}}vh.EMPTY=null,vh.RED=!0,vh.BLACK=!1,vh.EMPTY=new class{constructor(){this.size=0}get key(){throw Id()}get value(){throw Id()}get color(){throw Id()}get left(){throw Id()}get right(){throw Id()}copy(e,t,n,r,a){return this}insert(e,t,n){return new vh(e,t)}remove(e,t){return this}isEmpty(){return!0}inorderTraversal(e){return!1}reverseTraversal(e){return!1}minKey(){return null}maxKey(){return null}isRed(){return!1}checkMaxDepth(){return!0}check(){return 0}};class xh{constructor(e){this.comparator=e,this.data=new yh(this.comparator)}has(e){return null!==this.data.get(e)}first(){return this.data.minKey()}last(){return this.data.maxKey()}get size(){return this.data.size}indexOf(e){return this.data.indexOf(e)}forEach(e){this.data.inorderTraversal(((t,n)=>(e(t),!1)))}forEachInRange(e,t){const n=this.data.getIteratorFrom(e[0]);for(;n.hasNext();){const r=n.getNext();if(this.comparator(r.key,e[1])>=0)return;t(r.key)}}forEachWhile(e,t){let n;for(n=void 0!==t?this.data.getIteratorFrom(t):this.data.getIterator();n.hasNext();)if(!e(n.getNext().key))return}firstAfterOrEqual(e){const t=this.data.getIteratorFrom(e);return t.hasNext()?t.getNext().key:null}getIterator(){return new wh(this.data.getIterator())}getIteratorFrom(e){return new wh(this.data.getIteratorFrom(e))}add(e){return this.copy(this.data.remove(e).insert(e,!0))}delete(e){return this.has(e)?this.copy(this.data.remove(e)):this}isEmpty(){return this.data.isEmpty()}unionWith(e){let t=this;return t.size<e.size&&(t=e,e=this),e.forEach((e=>{t=t.add(e)})),t}isEqual(e){if(!(e instanceof xh))return!1;if(this.size!==e.size)return!1;const t=this.data.getIterator(),n=e.data.getIterator();for(;t.hasNext();){const e=t.getNext().key,r=n.getNext().key;if(0!==this.comparator(e,r))return!1}return!0}toArray(){const e=[];return this.forEach((t=>{e.push(t)})),e}toString(){const e=[];return this.forEach((t=>e.push(t))),"SortedSet("+e.toString()+")"}copy(e){const t=new xh(this.comparator);return t.data=e,t}}class wh{constructor(e){this.iter=e}getNext(){return this.iter.getNext().key}hasNext(){return this.iter.hasNext()}}class kh{constructor(e){this.fields=e,e.sort(qd.comparator)}static empty(){return new kh([])}unionWith(e){let t=new xh(qd.comparator);for(const n of this.fields)t=t.add(n);for(const n of e)t=t.add(n);return new kh(t.toArray())}covers(e){for(const t of this.fields)if(t.isPrefixOf(e))return!0;return!1}isEqual(e){return Wd(this.fields,e.fields,((e,t)=>e.isEqual(t)))}}class Sh extends Error{constructor(){super(...arguments),this.name="Base64DecodeError"}}class Ih{constructor(e){this.binaryString=e}static fromBase64String(e){const t=function(e){try{return atob(e)}catch(e){throw"undefined"!=typeof DOMException&&e instanceof DOMException?new Sh("Invalid base64 string: "+e):e}}(e);return new Ih(t)}static fromUint8Array(e){const t=function(e){let t="";for(let n=0;n<e.length;++n)t+=String.fromCharCode(e[n]);return t}(e);return new Ih(t)}[Symbol.iterator](){let e=0;return{next:()=>e<this.binaryString.length?{value:this.binaryString.charCodeAt(e++),done:!1}:{value:void 0,done:!0}}}toBase64(){return e=this.binaryString,btoa(e);var e}toUint8Array(){return function(e){const t=new Uint8Array(e.length);for(let n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}(this.binaryString)}approximateByteSize(){return 2*this.binaryString.length}compareTo(e){return Bd(this.binaryString,e.binaryString)}isEqual(e){return this.binaryString===e.binaryString}}Ih.EMPTY_BYTE_STRING=new Ih("");const Ch=new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);function Nh(e){if(Cd(!!e),"string"==typeof e){let t=0;const n=Ch.exec(e);if(Cd(!!n),n[1]){let e=n[1];e=(e+"000000000").substr(0,9),t=Number(e)}const r=new Date(e);return{seconds:Math.floor(r.getTime()/1e3),nanos:t}}return{seconds:Th(e.seconds),nanos:Th(e.nanos)}}function Th(e){return"number"==typeof e?e:"string"==typeof e?Number(e):0}function Eh(e){return"string"==typeof e?Ih.fromBase64String(e):Ih.fromUint8Array(e)}function Ah(e){var t,n;return"server_timestamp"===(null===(n=((null===(t=null==e?void 0:e.mapValue)||void 0===t?void 0:t.fields)||{}).__type__)||void 0===n?void 0:n.stringValue)}function _h(e){const t=e.mapValue.fields.__previous_value__;return Ah(t)?_h(t):t}function $h(e){const t=Nh(e.mapValue.fields.__local_write_time__.timestampValue);return new Vd(t.seconds,t.nanos)}class Rh{constructor(e,t,n,r,a,s,i,o,l){this.databaseId=e,this.appId=t,this.persistenceKey=n,this.host=r,this.ssl=a,this.forceLongPolling=s,this.autoDetectLongPolling=i,this.longPollingOptions=o,this.useFetchStreams=l}}class Dh{constructor(e,t){this.projectId=e,this.database=t||"(default)"}static empty(){return new Dh("","")}get isDefaultDatabase(){return"(default)"===this.database}isEqual(e){return e instanceof Dh&&e.projectId===this.projectId&&e.database===this.database}}const Mh={mapValue:{fields:{__type__:{stringValue:"__max__"}}}};function Fh(e){return"nullValue"in e?0:"booleanValue"in e?1:"integerValue"in e||"doubleValue"in e?2:"timestampValue"in e?3:"stringValue"in e?5:"bytesValue"in e?6:"referenceValue"in e?7:"geoPointValue"in e?8:"arrayValue"in e?9:"mapValue"in e?Ah(e)?4:Yh(e)?9007199254740991:Kh(e)?10:11:Id()}function Oh(e,t){if(e===t)return!0;const n=Fh(e);if(n!==Fh(t))return!1;switch(n){case 0:case 9007199254740991:return!0;case 1:return e.booleanValue===t.booleanValue;case 4:return $h(e).isEqual($h(t));case 3:return function(e,t){if("string"==typeof e.timestampValue&&"string"==typeof t.timestampValue&&e.timestampValue.length===t.timestampValue.length)return e.timestampValue===t.timestampValue;const n=Nh(e.timestampValue),r=Nh(t.timestampValue);return n.seconds===r.seconds&&n.nanos===r.nanos}(e,t);case 5:return e.stringValue===t.stringValue;case 6:return function(e,t){return Eh(e.bytesValue).isEqual(Eh(t.bytesValue))}(e,t);case 7:return e.referenceValue===t.referenceValue;case 8:return function(e,t){return Th(e.geoPointValue.latitude)===Th(t.geoPointValue.latitude)&&Th(e.geoPointValue.longitude)===Th(t.geoPointValue.longitude)}(e,t);case 2:return function(e,t){if("integerValue"in e&&"integerValue"in t)return Th(e.integerValue)===Th(t.integerValue);if("doubleValue"in e&&"doubleValue"in t){const n=Th(e.doubleValue),r=Th(t.doubleValue);return n===r?lh(n)===lh(r):isNaN(n)&&isNaN(r)}return!1}(e,t);case 9:return Wd(e.arrayValue.values||[],t.arrayValue.values||[],Oh);case 10:case 11:return function(e,t){const n=e.mapValue.fields||{},r=t.mapValue.fields||{};if(fh(n)!==fh(r))return!1;for(const a in n)if(n.hasOwnProperty(a)&&(void 0===r[a]||!Oh(n[a],r[a])))return!1;return!0}(e,t);default:return Id()}}function Ph(e,t){return void 0!==(e.values||[]).find((e=>Oh(e,t)))}function Lh(e,t){if(e===t)return 0;const n=Fh(e),r=Fh(t);if(n!==r)return Bd(n,r);switch(n){case 0:case 9007199254740991:return 0;case 1:return Bd(e.booleanValue,t.booleanValue);case 2:return function(e,t){const n=Th(e.integerValue||e.doubleValue),r=Th(t.integerValue||t.doubleValue);return n<r?-1:n>r?1:n===r?0:isNaN(n)?isNaN(r)?0:-1:1}(e,t);case 3:return zh(e.timestampValue,t.timestampValue);case 4:return zh($h(e),$h(t));case 5:return Bd(e.stringValue,t.stringValue);case 6:return function(e,t){const n=Eh(e),r=Eh(t);return n.compareTo(r)}(e.bytesValue,t.bytesValue);case 7:return function(e,t){const n=e.split("/"),r=t.split("/");for(let a=0;a<n.length&&a<r.length;a++){const e=Bd(n[a],r[a]);if(0!==e)return e}return Bd(n.length,r.length)}(e.referenceValue,t.referenceValue);case 8:return function(e,t){const n=Bd(Th(e.latitude),Th(t.latitude));return 0!==n?n:Bd(Th(e.longitude),Th(t.longitude))}(e.geoPointValue,t.geoPointValue);case 9:return Bh(e.arrayValue,t.arrayValue);case 10:return function(e,t){var n,r,a,s;const i=e.fields||{},o=t.fields||{},l=null===(n=i.value)||void 0===n?void 0:n.arrayValue,u=null===(r=o.value)||void 0===r?void 0:r.arrayValue,c=Bd((null===(a=null==l?void 0:l.values)||void 0===a?void 0:a.length)||0,(null===(s=null==u?void 0:u.values)||void 0===s?void 0:s.length)||0);return 0!==c?c:Bh(l,u)}(e.mapValue,t.mapValue);case 11:return function(e,t){if(e===Mh.mapValue&&t===Mh.mapValue)return 0;if(e===Mh.mapValue)return 1;if(t===Mh.mapValue)return-1;const n=e.fields||{},r=Object.keys(n),a=t.fields||{},s=Object.keys(a);r.sort(),s.sort();for(let i=0;i<r.length&&i<s.length;++i){const e=Bd(r[i],s[i]);if(0!==e)return e;const t=Lh(n[r[i]],a[s[i]]);if(0!==t)return t}return Bd(r.length,s.length)}(e.mapValue,t.mapValue);default:throw Id()}}function zh(e,t){if("string"==typeof e&&"string"==typeof t&&e.length===t.length)return Bd(e,t);const n=Nh(e),r=Nh(t),a=Bd(n.seconds,r.seconds);return 0!==a?a:Bd(n.nanos,r.nanos)}function Bh(e,t){const n=e.values||[],r=t.values||[];for(let a=0;a<n.length&&a<r.length;++a){const e=Lh(n[a],r[a]);if(e)return e}return Bd(n.length,r.length)}function Wh(e){return Vh(e)}function Vh(e){return"nullValue"in e?"null":"booleanValue"in e?""+e.booleanValue:"integerValue"in e?""+e.integerValue:"doubleValue"in e?""+e.doubleValue:"timestampValue"in e?function(e){const t=Nh(e);return`time(${t.seconds},${t.nanos})`}(e.timestampValue):"stringValue"in e?e.stringValue:"bytesValue"in e?function(e){return Eh(e).toBase64()}(e.bytesValue):"referenceValue"in e?function(e){return Kd.fromName(e).toString()}(e.referenceValue):"geoPointValue"in e?function(e){return`geo(${e.latitude},${e.longitude})`}(e.geoPointValue):"arrayValue"in e?function(e){let t="[",n=!0;for(const r of e.values||[])n?n=!1:t+=",",t+=Vh(r);return t+"]"}(e.arrayValue):"mapValue"in e?function(e){const t=Object.keys(e.fields||{}).sort();let n="{",r=!0;for(const a of t)r?r=!1:n+=",",n+=`${a}:${Vh(e.fields[a])}`;return n+"}"}(e.mapValue):Id()}function Uh(e){return!!e&&"integerValue"in e}function jh(e){return!!e&&"arrayValue"in e}function Gh(e){return!!e&&"nullValue"in e}function Hh(e){return!!e&&"doubleValue"in e&&isNaN(Number(e.doubleValue))}function qh(e){return!!e&&"mapValue"in e}function Kh(e){var t,n;return"__vector__"===(null===(n=((null===(t=null==e?void 0:e.mapValue)||void 0===t?void 0:t.fields)||{}).__type__)||void 0===n?void 0:n.stringValue)}function Xh(e){if(e.geoPointValue)return{geoPointValue:Object.assign({},e.geoPointValue)};if(e.timestampValue&&"object"==typeof e.timestampValue)return{timestampValue:Object.assign({},e.timestampValue)};if(e.mapValue){const t={mapValue:{fields:{}}};return mh(e.mapValue.fields,((e,n)=>t.mapValue.fields[e]=Xh(n))),t}if(e.arrayValue){const t={arrayValue:{values:[]}};for(let n=0;n<(e.arrayValue.values||[]).length;++n)t.arrayValue.values[n]=Xh(e.arrayValue.values[n]);return t}return Object.assign({},e)}function Yh(e){return"__max__"===(((e.mapValue||{}).fields||{}).__type__||{}).stringValue}class Qh{constructor(e){this.value=e}static empty(){return new Qh({mapValue:{}})}field(e){if(e.isEmpty())return this.value;{let t=this.value;for(let n=0;n<e.length-1;++n)if(t=(t.mapValue.fields||{})[e.get(n)],!qh(t))return null;return t=(t.mapValue.fields||{})[e.lastSegment()],t||null}}set(e,t){this.getFieldsMap(e.popLast())[e.lastSegment()]=Xh(t)}setAll(e){let t=qd.emptyPath(),n={},r=[];e.forEach(((e,a)=>{if(!t.isImmediateParentOf(a)){const e=this.getFieldsMap(t);this.applyChanges(e,n,r),n={},r=[],t=a.popLast()}e?n[a.lastSegment()]=Xh(e):r.push(a.lastSegment())}));const a=this.getFieldsMap(t);this.applyChanges(a,n,r)}delete(e){const t=this.field(e.popLast());qh(t)&&t.mapValue.fields&&delete t.mapValue.fields[e.lastSegment()]}isEqual(e){return Oh(this.value,e.value)}getFieldsMap(e){let t=this.value;t.mapValue.fields||(t.mapValue={fields:{}});for(let n=0;n<e.length;++n){let r=t.mapValue.fields[e.get(n)];qh(r)&&r.mapValue.fields||(r={mapValue:{fields:{}}},t.mapValue.fields[e.get(n)]=r),t=r}return t.mapValue.fields}applyChanges(e,t,n){mh(t,((t,n)=>e[t]=n));for(const r of n)delete e[r]}clone(){return new Qh(Xh(this.value))}}function Jh(e){const t=[];return mh(e.fields,((e,n)=>{const r=new qd([e]);if(qh(n)){const e=Jh(n.mapValue).fields;if(0===e.length)t.push(r);else for(const n of e)t.push(r.child(n))}else t.push(r)})),new kh(t)}class Zh{constructor(e,t,n,r,a,s,i){this.key=e,this.documentType=t,this.version=n,this.readTime=r,this.createTime=a,this.data=s,this.documentState=i}static newInvalidDocument(e){return new Zh(e,0,Ud.min(),Ud.min(),Ud.min(),Qh.empty(),0)}static newFoundDocument(e,t,n,r){return new Zh(e,1,t,Ud.min(),n,r,0)}static newNoDocument(e,t){return new Zh(e,2,t,Ud.min(),Ud.min(),Qh.empty(),0)}static newUnknownDocument(e,t){return new Zh(e,3,t,Ud.min(),Ud.min(),Qh.empty(),2)}convertToFoundDocument(e,t){return!this.createTime.isEqual(Ud.min())||2!==this.documentType&&0!==this.documentType||(this.createTime=e),this.version=e,this.documentType=1,this.data=t,this.documentState=0,this}convertToNoDocument(e){return this.version=e,this.documentType=2,this.data=Qh.empty(),this.documentState=0,this}convertToUnknownDocument(e){return this.version=e,this.documentType=3,this.data=Qh.empty(),this.documentState=2,this}setHasCommittedMutations(){return this.documentState=2,this}setHasLocalMutations(){return this.documentState=1,this.version=Ud.min(),this}setReadTime(e){return this.readTime=e,this}get hasLocalMutations(){return 1===this.documentState}get hasCommittedMutations(){return 2===this.documentState}get hasPendingWrites(){return this.hasLocalMutations||this.hasCommittedMutations}isValidDocument(){return 0!==this.documentType}isFoundDocument(){return 1===this.documentType}isNoDocument(){return 2===this.documentType}isUnknownDocument(){return 3===this.documentType}isEqual(e){return e instanceof Zh&&this.key.isEqual(e.key)&&this.version.isEqual(e.version)&&this.documentType===e.documentType&&this.documentState===e.documentState&&this.data.isEqual(e.data)}mutableCopy(){return new Zh(this.key,this.documentType,this.version,this.readTime,this.createTime,this.data.clone(),this.documentState)}toString(){return`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`}}class ep{constructor(e,t){this.position=e,this.inclusive=t}}function tp(e,t,n){let r=0;for(let a=0;a<e.position.length;a++){const s=t[a],i=e.position[a];if(r=s.field.isKeyField()?Kd.comparator(Kd.fromName(i.referenceValue),n.key):Lh(i,n.data.field(s.field)),"desc"===s.dir&&(r*=-1),0!==r)break}return r}function np(e,t){if(null===e)return null===t;if(null===t)return!1;if(e.inclusive!==t.inclusive||e.position.length!==t.position.length)return!1;for(let n=0;n<e.position.length;n++)if(!Oh(e.position[n],t.position[n]))return!1;return!0}class rp{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"asc";this.field=e,this.dir=t}}function ap(e,t){return e.dir===t.dir&&e.field.isEqual(t.field)}class sp{}class ip extends sp{constructor(e,t,n){super(),this.field=e,this.op=t,this.value=n}static create(e,t,n){return e.isKeyField()?"in"===t||"not-in"===t?this.createKeyFieldInFilter(e,t,n):new fp(e,t,n):"array-contains"===t?new bp(e,n):"in"===t?new vp(e,n):"not-in"===t?new xp(e,n):"array-contains-any"===t?new wp(e,n):new ip(e,t,n)}static createKeyFieldInFilter(e,t,n){return"in"===t?new mp(e,n):new gp(e,n)}matches(e){const t=e.data.field(this.field);return"!="===this.op?null!==t&&this.matchesComparison(Lh(t,this.value)):null!==t&&Fh(this.value)===Fh(t)&&this.matchesComparison(Lh(t,this.value))}matchesComparison(e){switch(this.op){case"<":return e<0;case"<=":return e<=0;case"==":return 0===e;case"!=":return 0!==e;case">":return e>0;case">=":return e>=0;default:return Id()}}isInequality(){return["<","<=",">",">=","!=","not-in"].indexOf(this.op)>=0}getFlattenedFilters(){return[this]}getFilters(){return[this]}}class op extends sp{constructor(e,t){super(),this.filters=e,this.op=t,this.ae=null}static create(e,t){return new op(e,t)}matches(e){return lp(this)?void 0===this.filters.find((t=>!t.matches(e))):void 0!==this.filters.find((t=>t.matches(e)))}getFlattenedFilters(){return null!==this.ae||(this.ae=this.filters.reduce(((e,t)=>e.concat(t.getFlattenedFilters())),[])),this.ae}getFilters(){return Object.assign([],this.filters)}}function lp(e){return"and"===e.op}function up(e){return cp(e)&&lp(e)}function cp(e){for(const t of e.filters)if(t instanceof op)return!1;return!0}function dp(e){if(e instanceof ip)return e.field.canonicalString()+e.op.toString()+Wh(e.value);if(up(e))return e.filters.map((e=>dp(e))).join(",");{const t=e.filters.map((e=>dp(e))).join(",");return`${e.op}(${t})`}}function hp(e,t){return e instanceof ip?function(e,t){return t instanceof ip&&e.op===t.op&&e.field.isEqual(t.field)&&Oh(e.value,t.value)}(e,t):e instanceof op?function(e,t){return t instanceof op&&e.op===t.op&&e.filters.length===t.filters.length&&e.filters.reduce(((e,n,r)=>e&&hp(n,t.filters[r])),!0)}(e,t):void Id()}function pp(e){return e instanceof ip?function(e){return`${e.field.canonicalString()} ${e.op} ${Wh(e.value)}`}(e):e instanceof op?function(e){return e.op.toString()+" {"+e.getFilters().map(pp).join(" ,")+"}"}(e):"Filter"}class fp extends ip{constructor(e,t,n){super(e,t,n),this.key=Kd.fromName(n.referenceValue)}matches(e){const t=Kd.comparator(e.key,this.key);return this.matchesComparison(t)}}class mp extends ip{constructor(e,t){super(e,"in",t),this.keys=yp("in",t)}matches(e){return this.keys.some((t=>t.isEqual(e.key)))}}class gp extends ip{constructor(e,t){super(e,"not-in",t),this.keys=yp("not-in",t)}matches(e){return!this.keys.some((t=>t.isEqual(e.key)))}}function yp(e,t){var n;return((null===(n=t.arrayValue)||void 0===n?void 0:n.values)||[]).map((e=>Kd.fromName(e.referenceValue)))}class bp extends ip{constructor(e,t){super(e,"array-contains",t)}matches(e){const t=e.data.field(this.field);return jh(t)&&Ph(t.arrayValue,this.value)}}class vp extends ip{constructor(e,t){super(e,"in",t)}matches(e){const t=e.data.field(this.field);return null!==t&&Ph(this.value.arrayValue,t)}}class xp extends ip{constructor(e,t){super(e,"not-in",t)}matches(e){if(Ph(this.value.arrayValue,{nullValue:"NULL_VALUE"}))return!1;const t=e.data.field(this.field);return null!==t&&!Ph(this.value.arrayValue,t)}}class wp extends ip{constructor(e,t){super(e,"array-contains-any",t)}matches(e){const t=e.data.field(this.field);return!(!jh(t)||!t.arrayValue.values)&&t.arrayValue.values.some((e=>Ph(this.value.arrayValue,e)))}}class kp{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;this.path=e,this.collectionGroup=t,this.orderBy=n,this.filters=r,this.limit=a,this.startAt=s,this.endAt=i,this.ue=null}}function Sp(e){return new kp(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,arguments.length>6&&void 0!==arguments[6]?arguments[6]:null)}function Ip(e){const t=Nd(e);if(null===t.ue){let e=t.path.canonicalString();null!==t.collectionGroup&&(e+="|cg:"+t.collectionGroup),e+="|f:",e+=t.filters.map((e=>dp(e))).join(","),e+="|ob:",e+=t.orderBy.map((e=>function(e){return e.field.canonicalString()+e.dir}(e))).join(","),oh(t.limit)||(e+="|l:",e+=t.limit),t.startAt&&(e+="|lb:",e+=t.startAt.inclusive?"b:":"a:",e+=t.startAt.position.map((e=>Wh(e))).join(",")),t.endAt&&(e+="|ub:",e+=t.endAt.inclusive?"a:":"b:",e+=t.endAt.position.map((e=>Wh(e))).join(",")),t.ue=e}return t.ue}function Cp(e,t){if(e.limit!==t.limit)return!1;if(e.orderBy.length!==t.orderBy.length)return!1;for(let n=0;n<e.orderBy.length;n++)if(!ap(e.orderBy[n],t.orderBy[n]))return!1;if(e.filters.length!==t.filters.length)return!1;for(let n=0;n<e.filters.length;n++)if(!hp(e.filters[n],t.filters[n]))return!1;return e.collectionGroup===t.collectionGroup&&!!e.path.isEqual(t.path)&&!!np(e.startAt,t.startAt)&&np(e.endAt,t.endAt)}function Np(e){return Kd.isDocumentKey(e.path)&&null===e.collectionGroup&&0===e.filters.length}class Tp{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"F",i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;this.path=e,this.collectionGroup=t,this.explicitOrderBy=n,this.filters=r,this.limit=a,this.limitType=s,this.startAt=i,this.endAt=o,this.ce=null,this.le=null,this.he=null,this.startAt,this.endAt}}function Ep(e,t,n,r,a,s,i,o){return new Tp(e,t,n,r,a,s,i,o)}function Ap(e){return new Tp(e)}function _p(e){return 0===e.filters.length&&null===e.limit&&null==e.startAt&&null==e.endAt&&(0===e.explicitOrderBy.length||1===e.explicitOrderBy.length&&e.explicitOrderBy[0].field.isKeyField())}function $p(e){return null!==e.collectionGroup}function Rp(e){const t=Nd(e);if(null===t.ce){t.ce=[];const e=new Set;for(const a of t.explicitOrderBy)t.ce.push(a),e.add(a.field.canonicalString());const n=t.explicitOrderBy.length>0?t.explicitOrderBy[t.explicitOrderBy.length-1].dir:"asc",r=function(e){let t=new xh(qd.comparator);return e.filters.forEach((e=>{e.getFlattenedFilters().forEach((e=>{e.isInequality()&&(t=t.add(e.field))}))})),t}(t);r.forEach((r=>{e.has(r.canonicalString())||r.isKeyField()||t.ce.push(new rp(r,n))})),e.has(qd.keyField().canonicalString())||t.ce.push(new rp(qd.keyField(),n))}return t.ce}function Dp(e){const t=Nd(e);return t.le||(t.le=Mp(t,Rp(e))),t.le}function Mp(e,t){if("F"===e.limitType)return Sp(e.path,e.collectionGroup,t,e.filters,e.limit,e.startAt,e.endAt);{t=t.map((e=>{const t="desc"===e.dir?"asc":"desc";return new rp(e.field,t)}));const n=e.endAt?new ep(e.endAt.position,e.endAt.inclusive):null,r=e.startAt?new ep(e.startAt.position,e.startAt.inclusive):null;return Sp(e.path,e.collectionGroup,t,e.filters,e.limit,n,r)}}function Fp(e,t,n){return new Tp(e.path,e.collectionGroup,e.explicitOrderBy.slice(),e.filters.slice(),t,n,e.startAt,e.endAt)}function Op(e,t){return Cp(Dp(e),Dp(t))&&e.limitType===t.limitType}function Pp(e){return`${Ip(Dp(e))}|lt:${e.limitType}`}function Lp(e){return`Query(target=${function(e){let t=e.path.canonicalString();return null!==e.collectionGroup&&(t+=" collectionGroup="+e.collectionGroup),e.filters.length>0&&(t+=`, filters: [${e.filters.map((e=>pp(e))).join(", ")}]`),oh(e.limit)||(t+=", limit: "+e.limit),e.orderBy.length>0&&(t+=`, orderBy: [${e.orderBy.map((e=>function(e){return`${e.field.canonicalString()} (${e.dir})`}(e))).join(", ")}]`),e.startAt&&(t+=", startAt: ",t+=e.startAt.inclusive?"b:":"a:",t+=e.startAt.position.map((e=>Wh(e))).join(",")),e.endAt&&(t+=", endAt: ",t+=e.endAt.inclusive?"a:":"b:",t+=e.endAt.position.map((e=>Wh(e))).join(",")),`Target(${t})`}(Dp(e))}; limitType=${e.limitType})`}function zp(e,t){return t.isFoundDocument()&&function(e,t){const n=t.key.path;return null!==e.collectionGroup?t.key.hasCollectionId(e.collectionGroup)&&e.path.isPrefixOf(n):Kd.isDocumentKey(e.path)?e.path.isEqual(n):e.path.isImmediateParentOf(n)}(e,t)&&function(e,t){for(const n of Rp(e))if(!n.field.isKeyField()&&null===t.data.field(n.field))return!1;return!0}(e,t)&&function(e,t){for(const n of e.filters)if(!n.matches(t))return!1;return!0}(e,t)&&function(e,t){return!(e.startAt&&!function(e,t,n){const r=tp(e,t,n);return e.inclusive?r<=0:r<0}(e.startAt,Rp(e),t))&&!(e.endAt&&!function(e,t,n){const r=tp(e,t,n);return e.inclusive?r>=0:r>0}(e.endAt,Rp(e),t))}(e,t)}function Bp(e){return e.collectionGroup||(e.path.length%2==1?e.path.lastSegment():e.path.get(e.path.length-2))}function Wp(e){return(t,n)=>{let r=!1;for(const a of Rp(e)){const e=Vp(a,t,n);if(0!==e)return e;r=r||a.field.isKeyField()}return 0}}function Vp(e,t,n){const r=e.field.isKeyField()?Kd.comparator(t.key,n.key):function(e,t,n){const r=t.data.field(e),a=n.data.field(e);return null!==r&&null!==a?Lh(r,a):Id()}(e.field,t,n);switch(e.dir){case"asc":return r;case"desc":return-1*r;default:return Id()}}class Up{constructor(e,t){this.mapKeyFn=e,this.equalsFn=t,this.inner={},this.innerSize=0}get(e){const t=this.mapKeyFn(e),n=this.inner[t];if(void 0!==n)for(const[r,a]of n)if(this.equalsFn(r,e))return a}has(e){return void 0!==this.get(e)}set(e,t){const n=this.mapKeyFn(e),r=this.inner[n];if(void 0===r)return this.inner[n]=[[e,t]],void this.innerSize++;for(let a=0;a<r.length;a++)if(this.equalsFn(r[a][0],e))return void(r[a]=[e,t]);r.push([e,t]),this.innerSize++}delete(e){const t=this.mapKeyFn(e),n=this.inner[t];if(void 0===n)return!1;for(let r=0;r<n.length;r++)if(this.equalsFn(n[r][0],e))return 1===n.length?delete this.inner[t]:n.splice(r,1),this.innerSize--,!0;return!1}forEach(e){mh(this.inner,((t,n)=>{for(const[r,a]of n)e(r,a)}))}isEmpty(){return gh(this.inner)}size(){return this.innerSize}}const jp=new yh(Kd.comparator);function Gp(){return jp}const Hp=new yh(Kd.comparator);function qp(){let e=Hp;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const a of n)e=e.insert(a.key,a);return e}function Kp(e){let t=Hp;return e.forEach(((e,n)=>t=t.insert(e,n.overlayedDocument))),t}function Xp(){return Qp()}function Yp(){return Qp()}function Qp(){return new Up((e=>e.toString()),((e,t)=>e.isEqual(t)))}const Jp=new yh(Kd.comparator),Zp=new xh(Kd.comparator);function ef(){let e=Zp;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const a of n)e=e.add(a);return e}const tf=new xh(Bd);function nf(){return tf}function rf(e,t){if(e.useProto3Json){if(isNaN(t))return{doubleValue:"NaN"};if(t===1/0)return{doubleValue:"Infinity"};if(t===-1/0)return{doubleValue:"-Infinity"}}return{doubleValue:lh(t)?"-0":t}}function af(e){return{integerValue:""+e}}function sf(e,t){return uh(t)?af(t):rf(e,t)}class of{constructor(){this._=void 0}}function lf(e,t,n){return e instanceof df?function(e,t){const n={fields:{__type__:{stringValue:"server_timestamp"},__local_write_time__:{timestampValue:{seconds:e.seconds,nanos:e.nanoseconds}}}};return t&&Ah(t)&&(t=_h(t)),t&&(n.fields.__previous_value__=t),{mapValue:n}}(n,t):e instanceof hf?pf(e,t):e instanceof ff?mf(e,t):function(e,t){const n=cf(e,t),r=yf(n)+yf(e.Pe);return Uh(n)&&Uh(e.Pe)?af(r):rf(e.serializer,r)}(e,t)}function uf(e,t,n){return e instanceof hf?pf(e,t):e instanceof ff?mf(e,t):n}function cf(e,t){return e instanceof gf?function(e){return Uh(e)||function(e){return!!e&&"doubleValue"in e}(e)}(t)?t:{integerValue:0}:null}class df extends of{}class hf extends of{constructor(e){super(),this.elements=e}}function pf(e,t){const n=bf(t);for(const r of e.elements)n.some((e=>Oh(e,r)))||n.push(r);return{arrayValue:{values:n}}}class ff extends of{constructor(e){super(),this.elements=e}}function mf(e,t){let n=bf(t);for(const r of e.elements)n=n.filter((e=>!Oh(e,r)));return{arrayValue:{values:n}}}class gf extends of{constructor(e,t){super(),this.serializer=e,this.Pe=t}}function yf(e){return Th(e.integerValue||e.doubleValue)}function bf(e){return jh(e)&&e.arrayValue.values?e.arrayValue.values.slice():[]}class vf{constructor(e,t){this.version=e,this.transformResults=t}}class xf{constructor(e,t){this.updateTime=e,this.exists=t}static none(){return new xf}static exists(e){return new xf(void 0,e)}static updateTime(e){return new xf(e)}get isNone(){return void 0===this.updateTime&&void 0===this.exists}isEqual(e){return this.exists===e.exists&&(this.updateTime?!!e.updateTime&&this.updateTime.isEqual(e.updateTime):!e.updateTime)}}function wf(e,t){return void 0!==e.updateTime?t.isFoundDocument()&&t.version.isEqual(e.updateTime):void 0===e.exists||e.exists===t.isFoundDocument()}class kf{}function Sf(e,t){if(!e.hasLocalMutations||t&&0===t.fields.length)return null;if(null===t)return e.isNoDocument()?new Df(e.key,xf.none()):new Ef(e.key,e.data,xf.none());{const n=e.data,r=Qh.empty();let a=new xh(qd.comparator);for(let e of t.fields)if(!a.has(e)){let t=n.field(e);null===t&&e.length>1&&(e=e.popLast(),t=n.field(e)),null===t?r.delete(e):r.set(e,t),a=a.add(e)}return new Af(e.key,r,new kh(a.toArray()),xf.none())}}function If(e,t,n){e instanceof Ef?function(e,t,n){const r=e.value.clone(),a=$f(e.fieldTransforms,t,n.transformResults);r.setAll(a),t.convertToFoundDocument(n.version,r).setHasCommittedMutations()}(e,t,n):e instanceof Af?function(e,t,n){if(!wf(e.precondition,t))return void t.convertToUnknownDocument(n.version);const r=$f(e.fieldTransforms,t,n.transformResults),a=t.data;a.setAll(_f(e)),a.setAll(r),t.convertToFoundDocument(n.version,a).setHasCommittedMutations()}(e,t,n):function(e,t,n){t.convertToNoDocument(n.version).setHasCommittedMutations()}(0,t,n)}function Cf(e,t,n,r){return e instanceof Ef?function(e,t,n,r){if(!wf(e.precondition,t))return n;const a=e.value.clone(),s=Rf(e.fieldTransforms,r,t);return a.setAll(s),t.convertToFoundDocument(t.version,a).setHasLocalMutations(),null}(e,t,n,r):e instanceof Af?function(e,t,n,r){if(!wf(e.precondition,t))return n;const a=Rf(e.fieldTransforms,r,t),s=t.data;return s.setAll(_f(e)),s.setAll(a),t.convertToFoundDocument(t.version,s).setHasLocalMutations(),null===n?null:n.unionWith(e.fieldMask.fields).unionWith(e.fieldTransforms.map((e=>e.field)))}(e,t,n,r):function(e,t,n){return wf(e.precondition,t)?(t.convertToNoDocument(t.version).setHasLocalMutations(),null):n}(e,t,n)}function Nf(e,t){let n=null;for(const r of e.fieldTransforms){const e=t.data.field(r.field),a=cf(r.transform,e||null);null!=a&&(null===n&&(n=Qh.empty()),n.set(r.field,a))}return n||null}function Tf(e,t){return e.type===t.type&&!!e.key.isEqual(t.key)&&!!e.precondition.isEqual(t.precondition)&&!!function(e,t){return void 0===e&&void 0===t||!(!e||!t)&&Wd(e,t,((e,t)=>function(e,t){return e.field.isEqual(t.field)&&function(e,t){return e instanceof hf&&t instanceof hf||e instanceof ff&&t instanceof ff?Wd(e.elements,t.elements,Oh):e instanceof gf&&t instanceof gf?Oh(e.Pe,t.Pe):e instanceof df&&t instanceof df}(e.transform,t.transform)}(e,t)))}(e.fieldTransforms,t.fieldTransforms)&&(0===e.type?e.value.isEqual(t.value):1!==e.type||e.data.isEqual(t.data)&&e.fieldMask.isEqual(t.fieldMask))}class Ef extends kf{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];super(),this.key=e,this.value=t,this.precondition=n,this.fieldTransforms=r,this.type=0}getFieldMask(){return null}}class Af extends kf{constructor(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];super(),this.key=e,this.data=t,this.fieldMask=n,this.precondition=r,this.fieldTransforms=a,this.type=1}getFieldMask(){return this.fieldMask}}function _f(e){const t=new Map;return e.fieldMask.fields.forEach((n=>{if(!n.isEmpty()){const r=e.data.field(n);t.set(n,r)}})),t}function $f(e,t,n){const r=new Map;Cd(e.length===n.length);for(let a=0;a<n.length;a++){const s=e[a],i=s.transform,o=t.data.field(s.field);r.set(s.field,uf(i,o,n[a]))}return r}function Rf(e,t,n){const r=new Map;for(const a of e){const e=a.transform,s=n.data.field(a.field);r.set(a.field,lf(e,s,t))}return r}class Df extends kf{constructor(e,t){super(),this.key=e,this.precondition=t,this.type=2,this.fieldTransforms=[]}getFieldMask(){return null}}class Mf extends kf{constructor(e,t){super(),this.key=e,this.precondition=t,this.type=3,this.fieldTransforms=[]}getFieldMask(){return null}}class Ff{constructor(e,t,n,r){this.batchId=e,this.localWriteTime=t,this.baseMutations=n,this.mutations=r}applyToRemoteDocument(e,t){const n=t.mutationResults;for(let r=0;r<this.mutations.length;r++){const t=this.mutations[r];t.key.isEqual(e.key)&&If(t,e,n[r])}}applyToLocalView(e,t){for(const n of this.baseMutations)n.key.isEqual(e.key)&&(t=Cf(n,e,t,this.localWriteTime));for(const n of this.mutations)n.key.isEqual(e.key)&&(t=Cf(n,e,t,this.localWriteTime));return t}applyToLocalDocumentSet(e,t){const n=Yp();return this.mutations.forEach((r=>{const a=e.get(r.key),s=a.overlayedDocument;let i=this.applyToLocalView(s,a.mutatedFields);i=t.has(r.key)?null:i;const o=Sf(s,i);null!==o&&n.set(r.key,o),s.isValidDocument()||s.convertToNoDocument(Ud.min())})),n}keys(){return this.mutations.reduce(((e,t)=>e.add(t.key)),ef())}isEqual(e){return this.batchId===e.batchId&&Wd(this.mutations,e.mutations,((e,t)=>Tf(e,t)))&&Wd(this.baseMutations,e.baseMutations,((e,t)=>Tf(e,t)))}}class Of{constructor(e,t,n,r){this.batch=e,this.commitVersion=t,this.mutationResults=n,this.docVersions=r}static from(e,t,n){Cd(e.mutations.length===n.length);let r=Jp;const a=e.mutations;for(let s=0;s<a.length;s++)r=r.insert(a[s].key,n[s].version);return new Of(e,t,n,r)}}class Pf{constructor(e,t){this.largestBatchId=e,this.mutation=t}getKey(){return this.mutation.key}isEqual(e){return null!==e&&this.mutation===e.mutation}toString(){return`Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`}}class Lf{constructor(e,t){this.count=e,this.unchangedNames=t}}var zf,Bf;function Wf(e){switch(e){default:return Id();case Td.CANCELLED:case Td.UNKNOWN:case Td.DEADLINE_EXCEEDED:case Td.RESOURCE_EXHAUSTED:case Td.INTERNAL:case Td.UNAVAILABLE:case Td.UNAUTHENTICATED:return!1;case Td.INVALID_ARGUMENT:case Td.NOT_FOUND:case Td.ALREADY_EXISTS:case Td.PERMISSION_DENIED:case Td.FAILED_PRECONDITION:case Td.ABORTED:case Td.OUT_OF_RANGE:case Td.UNIMPLEMENTED:case Td.DATA_LOSS:return!0}}function Vf(e){if(void 0===e)return wd("GRPC error has no .code"),Td.UNKNOWN;switch(e){case zf.OK:return Td.OK;case zf.CANCELLED:return Td.CANCELLED;case zf.UNKNOWN:return Td.UNKNOWN;case zf.DEADLINE_EXCEEDED:return Td.DEADLINE_EXCEEDED;case zf.RESOURCE_EXHAUSTED:return Td.RESOURCE_EXHAUSTED;case zf.INTERNAL:return Td.INTERNAL;case zf.UNAVAILABLE:return Td.UNAVAILABLE;case zf.UNAUTHENTICATED:return Td.UNAUTHENTICATED;case zf.INVALID_ARGUMENT:return Td.INVALID_ARGUMENT;case zf.NOT_FOUND:return Td.NOT_FOUND;case zf.ALREADY_EXISTS:return Td.ALREADY_EXISTS;case zf.PERMISSION_DENIED:return Td.PERMISSION_DENIED;case zf.FAILED_PRECONDITION:return Td.FAILED_PRECONDITION;case zf.ABORTED:return Td.ABORTED;case zf.OUT_OF_RANGE:return Td.OUT_OF_RANGE;case zf.UNIMPLEMENTED:return Td.UNIMPLEMENTED;case zf.DATA_LOSS:return Td.DATA_LOSS;default:return Id()}}(Bf=zf||(zf={}))[Bf.OK=0]="OK",Bf[Bf.CANCELLED=1]="CANCELLED",Bf[Bf.UNKNOWN=2]="UNKNOWN",Bf[Bf.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",Bf[Bf.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",Bf[Bf.NOT_FOUND=5]="NOT_FOUND",Bf[Bf.ALREADY_EXISTS=6]="ALREADY_EXISTS",Bf[Bf.PERMISSION_DENIED=7]="PERMISSION_DENIED",Bf[Bf.UNAUTHENTICATED=16]="UNAUTHENTICATED",Bf[Bf.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",Bf[Bf.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",Bf[Bf.ABORTED=10]="ABORTED",Bf[Bf.OUT_OF_RANGE=11]="OUT_OF_RANGE",Bf[Bf.UNIMPLEMENTED=12]="UNIMPLEMENTED",Bf[Bf.INTERNAL=13]="INTERNAL",Bf[Bf.UNAVAILABLE=14]="UNAVAILABLE",Bf[Bf.DATA_LOSS=15]="DATA_LOSS";let Uf=null;function jf(){return new TextEncoder}const Gf=new ed([4294967295,4294967295],0);function Hf(e){const t=jf().encode(e),n=new td;return n.update(t),new Uint8Array(n.digest())}function qf(e){const t=new DataView(e.buffer),n=t.getUint32(0,!0),r=t.getUint32(4,!0),a=t.getUint32(8,!0),s=t.getUint32(12,!0);return[new ed([n,r],0),new ed([a,s],0)]}class Kf{constructor(e,t,n){if(this.bitmap=e,this.padding=t,this.hashCount=n,t<0||t>=8)throw new Xf(`Invalid padding: ${t}`);if(n<0)throw new Xf(`Invalid hash count: ${n}`);if(e.length>0&&0===this.hashCount)throw new Xf(`Invalid hash count: ${n}`);if(0===e.length&&0!==t)throw new Xf(`Invalid padding when bitmap length is 0: ${t}`);this.Ie=8*e.length-t,this.Te=ed.fromNumber(this.Ie)}Ee(e,t,n){let r=e.add(t.multiply(ed.fromNumber(n)));return 1===r.compare(Gf)&&(r=new ed([r.getBits(0),r.getBits(1)],0)),r.modulo(this.Te).toNumber()}de(e){return 0!=(this.bitmap[Math.floor(e/8)]&1<<e%8)}mightContain(e){if(0===this.Ie)return!1;const t=Hf(e),[n,r]=qf(t);for(let a=0;a<this.hashCount;a++){const e=this.Ee(n,r,a);if(!this.de(e))return!1}return!0}static create(e,t,n){const r=e%8==0?0:8-e%8,a=new Uint8Array(Math.ceil(e/8)),s=new Kf(a,r,t);return n.forEach((e=>s.insert(e))),s}insert(e){if(0===this.Ie)return;const t=Hf(e),[n,r]=qf(t);for(let a=0;a<this.hashCount;a++){const e=this.Ee(n,r,a);this.Ae(e)}}Ae(e){const t=Math.floor(e/8),n=e%8;this.bitmap[t]|=1<<n}}class Xf extends Error{constructor(){super(...arguments),this.name="BloomFilterError"}}class Yf{constructor(e,t,n,r,a){this.snapshotVersion=e,this.targetChanges=t,this.targetMismatches=n,this.documentUpdates=r,this.resolvedLimboDocuments=a}static createSynthesizedRemoteEventForCurrentChange(e,t,n){const r=new Map;return r.set(e,Qf.createSynthesizedTargetChangeForCurrentChange(e,t,n)),new Yf(Ud.min(),r,new yh(Bd),Gp(),ef())}}class Qf{constructor(e,t,n,r,a){this.resumeToken=e,this.current=t,this.addedDocuments=n,this.modifiedDocuments=r,this.removedDocuments=a}static createSynthesizedTargetChangeForCurrentChange(e,t,n){return new Qf(n,t,ef(),ef(),ef())}}class Jf{constructor(e,t,n,r){this.Re=e,this.removedTargetIds=t,this.key=n,this.Ve=r}}class Zf{constructor(e,t){this.targetId=e,this.me=t}}class em{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ih.EMPTY_BYTE_STRING,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;this.state=e,this.targetIds=t,this.resumeToken=n,this.cause=r}}class tm{constructor(){this.fe=0,this.ge=am(),this.pe=Ih.EMPTY_BYTE_STRING,this.ye=!1,this.we=!0}get current(){return this.ye}get resumeToken(){return this.pe}get Se(){return 0!==this.fe}get be(){return this.we}De(e){e.approximateByteSize()>0&&(this.we=!0,this.pe=e)}ve(){let e=ef(),t=ef(),n=ef();return this.ge.forEach(((r,a)=>{switch(a){case 0:e=e.add(r);break;case 2:t=t.add(r);break;case 1:n=n.add(r);break;default:Id()}})),new Qf(this.pe,this.ye,e,t,n)}Ce(){this.we=!1,this.ge=am()}Fe(e,t){this.we=!0,this.ge=this.ge.insert(e,t)}Me(e){this.we=!0,this.ge=this.ge.remove(e)}xe(){this.fe+=1}Oe(){this.fe-=1,Cd(this.fe>=0)}Ne(){this.we=!0,this.ye=!0}}class nm{constructor(e){this.Le=e,this.Be=new Map,this.ke=Gp(),this.qe=rm(),this.Qe=new yh(Bd)}Ke(e){for(const t of e.Re)e.Ve&&e.Ve.isFoundDocument()?this.$e(t,e.Ve):this.Ue(t,e.key,e.Ve);for(const t of e.removedTargetIds)this.Ue(t,e.key,e.Ve)}We(e){this.forEachTarget(e,(t=>{const n=this.Ge(t);switch(e.state){case 0:this.ze(t)&&n.De(e.resumeToken);break;case 1:n.Oe(),n.Se||n.Ce(),n.De(e.resumeToken);break;case 2:n.Oe(),n.Se||this.removeTarget(t);break;case 3:this.ze(t)&&(n.Ne(),n.De(e.resumeToken));break;case 4:this.ze(t)&&(this.je(t),n.De(e.resumeToken));break;default:Id()}}))}forEachTarget(e,t){e.targetIds.length>0?e.targetIds.forEach(t):this.Be.forEach(((e,n)=>{this.ze(n)&&t(n)}))}He(e){const t=e.targetId,n=e.me.count,r=this.Je(t);if(r){const a=r.target;if(Np(a))if(0===n){const e=new Kd(a.path);this.Ue(t,e,Zh.newNoDocument(e,Ud.min()))}else Cd(1===n);else{const r=this.Ye(t);if(r!==n){const n=this.Ze(e),a=n?this.Xe(n,e,r):1;if(0!==a){this.je(t);const e=2===a?"TargetPurposeExistenceFilterMismatchBloom":"TargetPurposeExistenceFilterMismatch";this.Qe=this.Qe.insert(t,e)}null==Uf||Uf.et(function(e,t,n,r,a){var s,i,o,l,u,c;const d={localCacheCount:e,existenceFilterCount:t.count,databaseId:n.database,projectId:n.projectId},h=t.unchangedNames;return h&&(d.bloomFilter={applied:0===a,hashCount:null!==(s=null==h?void 0:h.hashCount)&&void 0!==s?s:0,bitmapLength:null!==(l=null===(o=null===(i=null==h?void 0:h.bits)||void 0===i?void 0:i.bitmap)||void 0===o?void 0:o.length)&&void 0!==l?l:0,padding:null!==(c=null===(u=null==h?void 0:h.bits)||void 0===u?void 0:u.padding)&&void 0!==c?c:0,mightContain:e=>{var t;return null!==(t=null==r?void 0:r.mightContain(e))&&void 0!==t&&t}}),d}(r,e.me,this.Le.tt(),n,a))}}}}Ze(e){const t=e.me.unchangedNames;if(!t||!t.bits)return null;const{bits:{bitmap:n="",padding:r=0},hashCount:a=0}=t;let s,i;try{s=Eh(n).toUint8Array()}catch(e){if(e instanceof Sh)return kd("Decoding the base64 bloom filter in existence filter failed ("+e.message+"); ignoring the bloom filter and falling back to full re-query."),null;throw e}try{i=new Kf(s,r,a)}catch(e){return kd(e instanceof Xf?"BloomFilter error: ":"Applying bloom filter failed: ",e),null}return 0===i.Ie?null:i}Xe(e,t,n){return t.me.count===n-this.nt(e,t.targetId)?0:2}nt(e,t){const n=this.Le.getRemoteKeysForTarget(t);let r=0;return n.forEach((n=>{const a=this.Le.tt(),s=`projects/${a.projectId}/databases/${a.database}/documents/${n.path.canonicalString()}`;e.mightContain(s)||(this.Ue(t,n,null),r++)})),r}rt(e){const t=new Map;this.Be.forEach(((n,r)=>{const a=this.Je(r);if(a){if(n.current&&Np(a.target)){const t=new Kd(a.target.path);null!==this.ke.get(t)||this.it(r,t)||this.Ue(r,t,Zh.newNoDocument(t,e))}n.be&&(t.set(r,n.ve()),n.Ce())}}));let n=ef();this.qe.forEach(((e,t)=>{let r=!0;t.forEachWhile((e=>{const t=this.Je(e);return!t||"TargetPurposeLimboResolution"===t.purpose||(r=!1,!1)})),r&&(n=n.add(e))})),this.ke.forEach(((t,n)=>n.setReadTime(e)));const r=new Yf(e,t,this.Qe,this.ke,n);return this.ke=Gp(),this.qe=rm(),this.Qe=new yh(Bd),r}$e(e,t){if(!this.ze(e))return;const n=this.it(e,t.key)?2:0;this.Ge(e).Fe(t.key,n),this.ke=this.ke.insert(t.key,t),this.qe=this.qe.insert(t.key,this.st(t.key).add(e))}Ue(e,t,n){if(!this.ze(e))return;const r=this.Ge(e);this.it(e,t)?r.Fe(t,1):r.Me(t),this.qe=this.qe.insert(t,this.st(t).delete(e)),n&&(this.ke=this.ke.insert(t,n))}removeTarget(e){this.Be.delete(e)}Ye(e){const t=this.Ge(e).ve();return this.Le.getRemoteKeysForTarget(e).size+t.addedDocuments.size-t.removedDocuments.size}xe(e){this.Ge(e).xe()}Ge(e){let t=this.Be.get(e);return t||(t=new tm,this.Be.set(e,t)),t}st(e){let t=this.qe.get(e);return t||(t=new xh(Bd),this.qe=this.qe.insert(e,t)),t}ze(e){const t=null!==this.Je(e);return t||xd("WatchChangeAggregator","Detected inactive target",e),t}Je(e){const t=this.Be.get(e);return t&&t.Se?null:this.Le.ot(e)}je(e){this.Be.set(e,new tm),this.Le.getRemoteKeysForTarget(e).forEach((t=>{this.Ue(e,t,null)}))}it(e,t){return this.Le.getRemoteKeysForTarget(e).has(t)}}function rm(){return new yh(Kd.comparator)}function am(){return new yh(Kd.comparator)}const sm={asc:"ASCENDING",desc:"DESCENDING"},im={"<":"LESS_THAN","<=":"LESS_THAN_OR_EQUAL",">":"GREATER_THAN",">=":"GREATER_THAN_OR_EQUAL","==":"EQUAL","!=":"NOT_EQUAL","array-contains":"ARRAY_CONTAINS",in:"IN","not-in":"NOT_IN","array-contains-any":"ARRAY_CONTAINS_ANY"},om={and:"AND",or:"OR"};class lm{constructor(e,t){this.databaseId=e,this.useProto3Json=t}}function um(e,t){return e.useProto3Json||oh(t)?t:{value:t}}function cm(e,t){return e.useProto3Json?`${new Date(1e3*t.seconds).toISOString().replace(/\.\d*/,"").replace("Z","")}.${("000000000"+t.nanoseconds).slice(-9)}Z`:{seconds:""+t.seconds,nanos:t.nanoseconds}}function dm(e,t){return e.useProto3Json?t.toBase64():t.toUint8Array()}function hm(e,t){return cm(e,t.toTimestamp())}function pm(e){return Cd(!!e),Ud.fromTimestamp(function(e){const t=Nh(e);return new Vd(t.seconds,t.nanos)}(e))}function fm(e,t){return mm(e,t).canonicalString()}function mm(e,t){const n=function(e){return new Gd(["projects",e.projectId,"databases",e.database])}(e).child("documents");return void 0===t?n:n.child(t)}function gm(e){const t=Gd.fromString(e);return Cd(Om(t)),t}function ym(e,t){return fm(e.databaseId,t.path)}function bm(e,t){const n=gm(t);if(n.get(1)!==e.databaseId.projectId)throw new Ed(Td.INVALID_ARGUMENT,"Tried to deserialize key from different project: "+n.get(1)+" vs "+e.databaseId.projectId);if(n.get(3)!==e.databaseId.database)throw new Ed(Td.INVALID_ARGUMENT,"Tried to deserialize key from different database: "+n.get(3)+" vs "+e.databaseId.database);return new Kd(km(n))}function vm(e,t){return fm(e.databaseId,t)}function xm(e){const t=gm(e);return 4===t.length?Gd.emptyPath():km(t)}function wm(e){return new Gd(["projects",e.databaseId.projectId,"databases",e.databaseId.database]).canonicalString()}function km(e){return Cd(e.length>4&&"documents"===e.get(4)),e.popFirst(5)}function Sm(e,t,n){return{name:ym(e,t),fields:n.value.mapValue.fields}}function Im(e,t){let n;if(t instanceof Ef)n={update:Sm(e,t.key,t.value)};else if(t instanceof Df)n={delete:ym(e,t.key)};else if(t instanceof Af)n={update:Sm(e,t.key,t.data),updateMask:Fm(t.fieldMask)};else{if(!(t instanceof Mf))return Id();n={verify:ym(e,t.key)}}return t.fieldTransforms.length>0&&(n.updateTransforms=t.fieldTransforms.map((e=>function(e,t){const n=t.transform;if(n instanceof df)return{fieldPath:t.field.canonicalString(),setToServerValue:"REQUEST_TIME"};if(n instanceof hf)return{fieldPath:t.field.canonicalString(),appendMissingElements:{values:n.elements}};if(n instanceof ff)return{fieldPath:t.field.canonicalString(),removeAllFromArray:{values:n.elements}};if(n instanceof gf)return{fieldPath:t.field.canonicalString(),increment:n.Pe};throw Id()}(0,e)))),t.precondition.isNone||(n.currentDocument=function(e,t){return void 0!==t.updateTime?{updateTime:hm(e,t.updateTime)}:void 0!==t.exists?{exists:t.exists}:Id()}(e,t.precondition)),n}function Cm(e,t){return{documents:[vm(e,t.path)]}}function Nm(e,t){const n={structuredQuery:{}},r=t.path;let a;null!==t.collectionGroup?(a=r,n.structuredQuery.from=[{collectionId:t.collectionGroup,allDescendants:!0}]):(a=r.popLast(),n.structuredQuery.from=[{collectionId:r.lastSegment()}]),n.parent=vm(e,a);const s=function(e){if(0!==e.length)return Mm(op.create(e,"and"))}(t.filters);s&&(n.structuredQuery.where=s);const i=function(e){if(0!==e.length)return e.map((e=>function(e){return{field:Rm(e.field),direction:Am(e.dir)}}(e)))}(t.orderBy);i&&(n.structuredQuery.orderBy=i);const o=um(e,t.limit);return null!==o&&(n.structuredQuery.limit=o),t.startAt&&(n.structuredQuery.startAt=function(e){return{before:e.inclusive,values:e.position}}(t.startAt)),t.endAt&&(n.structuredQuery.endAt=function(e){return{before:!e.inclusive,values:e.position}}(t.endAt)),{_t:n,parent:a}}function Tm(e){let t=xm(e.parent);const n=e.structuredQuery,r=n.from?n.from.length:0;let a=null;if(r>0){Cd(1===r);const e=n.from[0];e.allDescendants?a=e.collectionId:t=t.child(e.collectionId)}let s=[];n.where&&(s=function(e){const t=Em(e);return t instanceof op&&up(t)?t.getFilters():[t]}(n.where));let i=[];n.orderBy&&(i=function(e){return e.map((e=>function(e){return new rp(Dm(e.field),function(e){switch(e){case"ASCENDING":return"asc";case"DESCENDING":return"desc";default:return}}(e.direction))}(e)))}(n.orderBy));let o=null;n.limit&&(o=function(e){let t;return t="object"==typeof e?e.value:e,oh(t)?null:t}(n.limit));let l=null;n.startAt&&(l=function(e){const t=!!e.before,n=e.values||[];return new ep(n,t)}(n.startAt));let u=null;return n.endAt&&(u=function(e){const t=!e.before,n=e.values||[];return new ep(n,t)}(n.endAt)),Ep(t,a,i,s,o,"F",l,u)}function Em(e){return void 0!==e.unaryFilter?function(e){switch(e.unaryFilter.op){case"IS_NAN":const t=Dm(e.unaryFilter.field);return ip.create(t,"==",{doubleValue:NaN});case"IS_NULL":const n=Dm(e.unaryFilter.field);return ip.create(n,"==",{nullValue:"NULL_VALUE"});case"IS_NOT_NAN":const r=Dm(e.unaryFilter.field);return ip.create(r,"!=",{doubleValue:NaN});case"IS_NOT_NULL":const a=Dm(e.unaryFilter.field);return ip.create(a,"!=",{nullValue:"NULL_VALUE"});default:return Id()}}(e):void 0!==e.fieldFilter?function(e){return ip.create(Dm(e.fieldFilter.field),function(e){switch(e){case"EQUAL":return"==";case"NOT_EQUAL":return"!=";case"GREATER_THAN":return">";case"GREATER_THAN_OR_EQUAL":return">=";case"LESS_THAN":return"<";case"LESS_THAN_OR_EQUAL":return"<=";case"ARRAY_CONTAINS":return"array-contains";case"IN":return"in";case"NOT_IN":return"not-in";case"ARRAY_CONTAINS_ANY":return"array-contains-any";default:return Id()}}(e.fieldFilter.op),e.fieldFilter.value)}(e):void 0!==e.compositeFilter?function(e){return op.create(e.compositeFilter.filters.map((e=>Em(e))),function(e){switch(e){case"AND":return"and";case"OR":return"or";default:return Id()}}(e.compositeFilter.op))}(e):Id()}function Am(e){return sm[e]}function _m(e){return im[e]}function $m(e){return om[e]}function Rm(e){return{fieldPath:e.canonicalString()}}function Dm(e){return qd.fromServerFormat(e.fieldPath)}function Mm(e){return e instanceof ip?function(e){if("=="===e.op){if(Hh(e.value))return{unaryFilter:{field:Rm(e.field),op:"IS_NAN"}};if(Gh(e.value))return{unaryFilter:{field:Rm(e.field),op:"IS_NULL"}}}else if("!="===e.op){if(Hh(e.value))return{unaryFilter:{field:Rm(e.field),op:"IS_NOT_NAN"}};if(Gh(e.value))return{unaryFilter:{field:Rm(e.field),op:"IS_NOT_NULL"}}}return{fieldFilter:{field:Rm(e.field),op:_m(e.op),value:e.value}}}(e):e instanceof op?function(e){const t=e.getFilters().map((e=>Mm(e)));return 1===t.length?t[0]:{compositeFilter:{op:$m(e.op),filters:t}}}(e):Id()}function Fm(e){const t=[];return e.fields.forEach((e=>t.push(e.canonicalString()))),{fieldPaths:t}}function Om(e){return e.length>=4&&"projects"===e.get(0)&&"databases"===e.get(2)}class Pm{constructor(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Ud.min(),s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:Ud.min(),i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:Ih.EMPTY_BYTE_STRING,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;this.target=e,this.targetId=t,this.purpose=n,this.sequenceNumber=r,this.snapshotVersion=a,this.lastLimboFreeSnapshotVersion=s,this.resumeToken=i,this.expectedCount=o}withSequenceNumber(e){return new Pm(this.target,this.targetId,this.purpose,e,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,this.expectedCount)}withResumeToken(e,t){return new Pm(this.target,this.targetId,this.purpose,this.sequenceNumber,t,this.lastLimboFreeSnapshotVersion,e,null)}withExpectedCount(e){return new Pm(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,e)}withLastLimboFreeSnapshotVersion(e){return new Pm(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,e,this.resumeToken,this.expectedCount)}}class Lm{constructor(e){this.ct=e}}function zm(e){const t=Tm({parent:e.parent,structuredQuery:e.structuredQuery});return"LAST"===e.limitType?Fp(t,t.limit,"L"):t}class Bm{constructor(){}It(e,t){this.Tt(e,t),t.Et()}Tt(e,t){if("nullValue"in e)this.dt(t,5);else if("booleanValue"in e)this.dt(t,10),t.At(e.booleanValue?1:0);else if("integerValue"in e)this.dt(t,15),t.At(Th(e.integerValue));else if("doubleValue"in e){const n=Th(e.doubleValue);isNaN(n)?this.dt(t,13):(this.dt(t,15),lh(n)?t.At(0):t.At(n))}else if("timestampValue"in e){let n=e.timestampValue;this.dt(t,20),"string"==typeof n&&(n=Nh(n)),t.Rt(`${n.seconds||""}`),t.At(n.nanos||0)}else if("stringValue"in e)this.Vt(e.stringValue,t),this.ft(t);else if("bytesValue"in e)this.dt(t,30),t.gt(Eh(e.bytesValue)),this.ft(t);else if("referenceValue"in e)this.yt(e.referenceValue,t);else if("geoPointValue"in e){const n=e.geoPointValue;this.dt(t,45),t.At(n.latitude||0),t.At(n.longitude||0)}else"mapValue"in e?Yh(e)?this.dt(t,Number.MAX_SAFE_INTEGER):Kh(e)?this.wt(e.mapValue,t):(this.St(e.mapValue,t),this.ft(t)):"arrayValue"in e?(this.bt(e.arrayValue,t),this.ft(t)):Id()}Vt(e,t){this.dt(t,25),this.Dt(e,t)}Dt(e,t){t.Rt(e)}St(e,t){const n=e.fields||{};this.dt(t,55);for(const r of Object.keys(n))this.Vt(r,t),this.Tt(n[r],t)}wt(e,t){var n,r;const a=e.fields||{};this.dt(t,53);const s="value",i=(null===(r=null===(n=a[s].arrayValue)||void 0===n?void 0:n.values)||void 0===r?void 0:r.length)||0;this.dt(t,15),t.At(Th(i)),this.Vt(s,t),this.Tt(a[s],t)}bt(e,t){const n=e.values||[];this.dt(t,50);for(const r of n)this.Tt(r,t)}yt(e,t){this.dt(t,37),Kd.fromName(e).path.forEach((e=>{this.dt(t,60),this.Dt(e,t)}))}dt(e,t){e.At(t)}ft(e){e.At(2)}}Bm.vt=new Bm;class Wm{constructor(){this.un=new Vm}addToCollectionParentIndex(e,t){return this.un.add(t),rh.resolve()}getCollectionParents(e,t){return rh.resolve(this.un.getEntries(t))}addFieldIndex(e,t){return rh.resolve()}deleteFieldIndex(e,t){return rh.resolve()}deleteAllFieldIndexes(e){return rh.resolve()}createTargetIndexes(e,t){return rh.resolve()}getDocumentsMatchingTarget(e,t){return rh.resolve(null)}getIndexType(e,t){return rh.resolve(0)}getFieldIndexes(e,t){return rh.resolve([])}getNextCollectionGroupToUpdate(e){return rh.resolve(null)}getMinOffset(e,t){return rh.resolve(Jd.min())}getMinOffsetFromCollectionGroup(e,t){return rh.resolve(Jd.min())}updateCollectionGroup(e,t,n){return rh.resolve()}updateIndexEntries(e,t){return rh.resolve()}}class Vm{constructor(){this.index={}}add(e){const t=e.lastSegment(),n=e.popLast(),r=this.index[t]||new xh(Gd.comparator),a=!r.has(n);return this.index[t]=r.add(n),a}has(e){const t=e.lastSegment(),n=e.popLast(),r=this.index[t];return r&&r.has(n)}getEntries(e){return(this.index[e]||new xh(Gd.comparator)).toArray()}}new Uint8Array(0);class Um{constructor(e,t,n){this.cacheSizeCollectionThreshold=e,this.percentileToCollect=t,this.maximumSequenceNumbersToCollect=n}static withCacheSize(e){return new Um(e,Um.DEFAULT_COLLECTION_PERCENTILE,Um.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)}}Um.DEFAULT_COLLECTION_PERCENTILE=10,Um.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT=1e3,Um.DEFAULT=new Um(41943040,Um.DEFAULT_COLLECTION_PERCENTILE,Um.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT),Um.DISABLED=new Um(-1,0,0);class jm{constructor(e){this.Ln=e}next(){return this.Ln+=2,this.Ln}static Bn(){return new jm(0)}static kn(){return new jm(-1)}}class Gm{constructor(){this.changes=new Up((e=>e.toString()),((e,t)=>e.isEqual(t))),this.changesApplied=!1}addEntry(e){this.assertNotApplied(),this.changes.set(e.key,e)}removeEntry(e,t){this.assertNotApplied(),this.changes.set(e,Zh.newInvalidDocument(e).setReadTime(t))}getEntry(e,t){this.assertNotApplied();const n=this.changes.get(t);return void 0!==n?rh.resolve(n):this.getFromCache(e,t)}getEntries(e,t){return this.getAllFromCache(e,t)}apply(e){return this.assertNotApplied(),this.changesApplied=!0,this.applyChanges(e)}assertNotApplied(){}}class Hm{constructor(e,t){this.overlayedDocument=e,this.mutatedFields=t}}class qm{constructor(e,t,n,r){this.remoteDocumentCache=e,this.mutationQueue=t,this.documentOverlayCache=n,this.indexManager=r}getDocument(e,t){let n=null;return this.documentOverlayCache.getOverlay(e,t).next((r=>(n=r,this.remoteDocumentCache.getEntry(e,t)))).next((e=>(null!==n&&Cf(n.mutation,e,kh.empty(),Vd.now()),e)))}getDocuments(e,t){return this.remoteDocumentCache.getEntries(e,t).next((t=>this.getLocalViewOfDocuments(e,t,ef()).next((()=>t))))}getLocalViewOfDocuments(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ef();const r=Xp();return this.populateOverlays(e,r,t).next((()=>this.computeViews(e,t,r,n).next((e=>{let t=qp();return e.forEach(((e,n)=>{t=t.insert(e,n.overlayedDocument)})),t}))))}getOverlayedDocuments(e,t){const n=Xp();return this.populateOverlays(e,n,t).next((()=>this.computeViews(e,t,n,ef())))}populateOverlays(e,t,n){const r=[];return n.forEach((e=>{t.has(e)||r.push(e)})),this.documentOverlayCache.getOverlays(e,r).next((e=>{e.forEach(((e,n)=>{t.set(e,n)}))}))}computeViews(e,t,n,r){let a=Gp();const s=Qp(),i=Qp();return t.forEach(((e,t)=>{const i=n.get(t.key);r.has(t.key)&&(void 0===i||i.mutation instanceof Af)?a=a.insert(t.key,t):void 0!==i?(s.set(t.key,i.mutation.getFieldMask()),Cf(i.mutation,t,i.mutation.getFieldMask(),Vd.now())):s.set(t.key,kh.empty())})),this.recalculateAndSaveOverlays(e,a).next((e=>(e.forEach(((e,t)=>s.set(e,t))),t.forEach(((e,t)=>{var n;return i.set(e,new Hm(t,null!==(n=s.get(e))&&void 0!==n?n:null))})),i)))}recalculateAndSaveOverlays(e,t){const n=Qp();let r=new yh(((e,t)=>e-t)),a=ef();return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e,t).next((e=>{for(const a of e)a.keys().forEach((e=>{const s=t.get(e);if(null===s)return;let i=n.get(e)||kh.empty();i=a.applyToLocalView(s,i),n.set(e,i);const o=(r.get(a.batchId)||ef()).add(e);r=r.insert(a.batchId,o)}))})).next((()=>{const s=[],i=r.getReverseIterator();for(;i.hasNext();){const r=i.getNext(),o=r.key,l=r.value,u=Yp();l.forEach((e=>{if(!a.has(e)){const r=Sf(t.get(e),n.get(e));null!==r&&u.set(e,r),a=a.add(e)}})),s.push(this.documentOverlayCache.saveOverlays(e,o,u))}return rh.waitFor(s)})).next((()=>n))}recalculateAndSaveOverlaysForDocumentKeys(e,t){return this.remoteDocumentCache.getEntries(e,t).next((t=>this.recalculateAndSaveOverlays(e,t)))}getDocumentsMatchingQuery(e,t,n,r){return function(e){return Kd.isDocumentKey(e.path)&&null===e.collectionGroup&&0===e.filters.length}(t)?this.getDocumentsMatchingDocumentQuery(e,t.path):$p(t)?this.getDocumentsMatchingCollectionGroupQuery(e,t,n,r):this.getDocumentsMatchingCollectionQuery(e,t,n,r)}getNextDocuments(e,t,n,r){return this.remoteDocumentCache.getAllFromCollectionGroup(e,t,n,r).next((a=>{const s=r-a.size>0?this.documentOverlayCache.getOverlaysForCollectionGroup(e,t,n.largestBatchId,r-a.size):rh.resolve(Xp());let i=-1,o=a;return s.next((t=>rh.forEach(t,((t,n)=>(i<n.largestBatchId&&(i=n.largestBatchId),a.get(t)?rh.resolve():this.remoteDocumentCache.getEntry(e,t).next((e=>{o=o.insert(t,e)}))))).next((()=>this.populateOverlays(e,t,a))).next((()=>this.computeViews(e,o,t,ef()))).next((e=>({batchId:i,changes:Kp(e)})))))}))}getDocumentsMatchingDocumentQuery(e,t){return this.getDocument(e,new Kd(t)).next((e=>{let t=qp();return e.isFoundDocument()&&(t=t.insert(e.key,e)),t}))}getDocumentsMatchingCollectionGroupQuery(e,t,n,r){const a=t.collectionGroup;let s=qp();return this.indexManager.getCollectionParents(e,a).next((i=>rh.forEach(i,(i=>{const o=function(e,t){return new Tp(t,null,e.explicitOrderBy.slice(),e.filters.slice(),e.limit,e.limitType,e.startAt,e.endAt)}(t,i.child(a));return this.getDocumentsMatchingCollectionQuery(e,o,n,r).next((e=>{e.forEach(((e,t)=>{s=s.insert(e,t)}))}))})).next((()=>s))))}getDocumentsMatchingCollectionQuery(e,t,n,r){let a;return this.documentOverlayCache.getOverlaysForCollection(e,t.path,n.largestBatchId).next((s=>(a=s,this.remoteDocumentCache.getDocumentsMatchingQuery(e,t,n,a,r)))).next((e=>{a.forEach(((t,n)=>{const r=n.getKey();null===e.get(r)&&(e=e.insert(r,Zh.newInvalidDocument(r)))}));let n=qp();return e.forEach(((e,r)=>{const s=a.get(e);void 0!==s&&Cf(s.mutation,r,kh.empty(),Vd.now()),zp(t,r)&&(n=n.insert(e,r))})),n}))}}class Km{constructor(e){this.serializer=e,this.hr=new Map,this.Pr=new Map}getBundleMetadata(e,t){return rh.resolve(this.hr.get(t))}saveBundleMetadata(e,t){return this.hr.set(t.id,function(e){return{id:e.id,version:e.version,createTime:pm(e.createTime)}}(t)),rh.resolve()}getNamedQuery(e,t){return rh.resolve(this.Pr.get(t))}saveNamedQuery(e,t){return this.Pr.set(t.name,function(e){return{name:e.name,query:zm(e.bundledQuery),readTime:pm(e.readTime)}}(t)),rh.resolve()}}class Xm{constructor(){this.overlays=new yh(Kd.comparator),this.Ir=new Map}getOverlay(e,t){return rh.resolve(this.overlays.get(t))}getOverlays(e,t){const n=Xp();return rh.forEach(t,(t=>this.getOverlay(e,t).next((e=>{null!==e&&n.set(t,e)})))).next((()=>n))}saveOverlays(e,t,n){return n.forEach(((n,r)=>{this.ht(e,t,r)})),rh.resolve()}removeOverlaysForBatchId(e,t,n){const r=this.Ir.get(n);return void 0!==r&&(r.forEach((e=>this.overlays=this.overlays.remove(e))),this.Ir.delete(n)),rh.resolve()}getOverlaysForCollection(e,t,n){const r=Xp(),a=t.length+1,s=new Kd(t.child("")),i=this.overlays.getIteratorFrom(s);for(;i.hasNext();){const e=i.getNext().value,s=e.getKey();if(!t.isPrefixOf(s.path))break;s.path.length===a&&e.largestBatchId>n&&r.set(e.getKey(),e)}return rh.resolve(r)}getOverlaysForCollectionGroup(e,t,n,r){let a=new yh(((e,t)=>e-t));const s=this.overlays.getIterator();for(;s.hasNext();){const e=s.getNext().value;if(e.getKey().getCollectionGroup()===t&&e.largestBatchId>n){let t=a.get(e.largestBatchId);null===t&&(t=Xp(),a=a.insert(e.largestBatchId,t)),t.set(e.getKey(),e)}}const i=Xp(),o=a.getIterator();for(;o.hasNext()&&(o.getNext().value.forEach(((e,t)=>i.set(e,t))),!(i.size()>=r)););return rh.resolve(i)}ht(e,t,n){const r=this.overlays.get(n.key);if(null!==r){const e=this.Ir.get(r.largestBatchId).delete(n.key);this.Ir.set(r.largestBatchId,e)}this.overlays=this.overlays.insert(n.key,new Pf(t,n));let a=this.Ir.get(t);void 0===a&&(a=ef(),this.Ir.set(t,a)),this.Ir.set(t,a.add(n.key))}}class Ym{constructor(){this.sessionToken=Ih.EMPTY_BYTE_STRING}getSessionToken(e){return rh.resolve(this.sessionToken)}setSessionToken(e,t){return this.sessionToken=t,rh.resolve()}}class Qm{constructor(){this.Tr=new xh(Jm.Er),this.dr=new xh(Jm.Ar)}isEmpty(){return this.Tr.isEmpty()}addReference(e,t){const n=new Jm(e,t);this.Tr=this.Tr.add(n),this.dr=this.dr.add(n)}Rr(e,t){e.forEach((e=>this.addReference(e,t)))}removeReference(e,t){this.Vr(new Jm(e,t))}mr(e,t){e.forEach((e=>this.removeReference(e,t)))}gr(e){const t=new Kd(new Gd([])),n=new Jm(t,e),r=new Jm(t,e+1),a=[];return this.dr.forEachInRange([n,r],(e=>{this.Vr(e),a.push(e.key)})),a}pr(){this.Tr.forEach((e=>this.Vr(e)))}Vr(e){this.Tr=this.Tr.delete(e),this.dr=this.dr.delete(e)}yr(e){const t=new Kd(new Gd([])),n=new Jm(t,e),r=new Jm(t,e+1);let a=ef();return this.dr.forEachInRange([n,r],(e=>{a=a.add(e.key)})),a}containsKey(e){const t=new Jm(e,0),n=this.Tr.firstAfterOrEqual(t);return null!==n&&e.isEqual(n.key)}}class Jm{constructor(e,t){this.key=e,this.wr=t}static Er(e,t){return Kd.comparator(e.key,t.key)||Bd(e.wr,t.wr)}static Ar(e,t){return Bd(e.wr,t.wr)||Kd.comparator(e.key,t.key)}}class Zm{constructor(e,t){this.indexManager=e,this.referenceDelegate=t,this.mutationQueue=[],this.Sr=1,this.br=new xh(Jm.Er)}checkEmpty(e){return rh.resolve(0===this.mutationQueue.length)}addMutationBatch(e,t,n,r){const a=this.Sr;this.Sr++,this.mutationQueue.length>0&&this.mutationQueue[this.mutationQueue.length-1];const s=new Ff(a,t,n,r);this.mutationQueue.push(s);for(const i of r)this.br=this.br.add(new Jm(i.key,a)),this.indexManager.addToCollectionParentIndex(e,i.key.path.popLast());return rh.resolve(s)}lookupMutationBatch(e,t){return rh.resolve(this.Dr(t))}getNextMutationBatchAfterBatchId(e,t){const n=t+1,r=this.vr(n),a=r<0?0:r;return rh.resolve(this.mutationQueue.length>a?this.mutationQueue[a]:null)}getHighestUnacknowledgedBatchId(){return rh.resolve(0===this.mutationQueue.length?-1:this.Sr-1)}getAllMutationBatches(e){return rh.resolve(this.mutationQueue.slice())}getAllMutationBatchesAffectingDocumentKey(e,t){const n=new Jm(t,0),r=new Jm(t,Number.POSITIVE_INFINITY),a=[];return this.br.forEachInRange([n,r],(e=>{const t=this.Dr(e.wr);a.push(t)})),rh.resolve(a)}getAllMutationBatchesAffectingDocumentKeys(e,t){let n=new xh(Bd);return t.forEach((e=>{const t=new Jm(e,0),r=new Jm(e,Number.POSITIVE_INFINITY);this.br.forEachInRange([t,r],(e=>{n=n.add(e.wr)}))})),rh.resolve(this.Cr(n))}getAllMutationBatchesAffectingQuery(e,t){const n=t.path,r=n.length+1;let a=n;Kd.isDocumentKey(a)||(a=a.child(""));const s=new Jm(new Kd(a),0);let i=new xh(Bd);return this.br.forEachWhile((e=>{const t=e.key.path;return!!n.isPrefixOf(t)&&(t.length===r&&(i=i.add(e.wr)),!0)}),s),rh.resolve(this.Cr(i))}Cr(e){const t=[];return e.forEach((e=>{const n=this.Dr(e);null!==n&&t.push(n)})),t}removeMutationBatch(e,t){Cd(0===this.Fr(t.batchId,"removed")),this.mutationQueue.shift();let n=this.br;return rh.forEach(t.mutations,(r=>{const a=new Jm(r.key,t.batchId);return n=n.delete(a),this.referenceDelegate.markPotentiallyOrphaned(e,r.key)})).next((()=>{this.br=n}))}On(e){}containsKey(e,t){const n=new Jm(t,0),r=this.br.firstAfterOrEqual(n);return rh.resolve(t.isEqual(r&&r.key))}performConsistencyCheck(e){return this.mutationQueue.length,rh.resolve()}Fr(e,t){return this.vr(e)}vr(e){return 0===this.mutationQueue.length?0:e-this.mutationQueue[0].batchId}Dr(e){const t=this.vr(e);return t<0||t>=this.mutationQueue.length?null:this.mutationQueue[t]}}class eg{constructor(e){this.Mr=e,this.docs=new yh(Kd.comparator),this.size=0}setIndexManager(e){this.indexManager=e}addEntry(e,t){const n=t.key,r=this.docs.get(n),a=r?r.size:0,s=this.Mr(t);return this.docs=this.docs.insert(n,{document:t.mutableCopy(),size:s}),this.size+=s-a,this.indexManager.addToCollectionParentIndex(e,n.path.popLast())}removeEntry(e){const t=this.docs.get(e);t&&(this.docs=this.docs.remove(e),this.size-=t.size)}getEntry(e,t){const n=this.docs.get(t);return rh.resolve(n?n.document.mutableCopy():Zh.newInvalidDocument(t))}getEntries(e,t){let n=Gp();return t.forEach((e=>{const t=this.docs.get(e);n=n.insert(e,t?t.document.mutableCopy():Zh.newInvalidDocument(e))})),rh.resolve(n)}getDocumentsMatchingQuery(e,t,n,r){let a=Gp();const s=t.path,i=new Kd(s.child("")),o=this.docs.getIteratorFrom(i);for(;o.hasNext();){const{key:e,value:{document:i}}=o.getNext();if(!s.isPrefixOf(e.path))break;e.path.length>s.length+1||Zd(Qd(i),n)<=0||(r.has(i.key)||zp(t,i))&&(a=a.insert(i.key,i.mutableCopy()))}return rh.resolve(a)}getAllFromCollectionGroup(e,t,n,r){Id()}Or(e,t){return rh.forEach(this.docs,(e=>t(e)))}newChangeBuffer(e){return new tg(this)}getSize(e){return rh.resolve(this.size)}}class tg extends Gm{constructor(e){super(),this.cr=e}applyChanges(e){const t=[];return this.changes.forEach(((n,r)=>{r.isValidDocument()?t.push(this.cr.addEntry(e,r)):this.cr.removeEntry(n)})),rh.waitFor(t)}getFromCache(e,t){return this.cr.getEntry(e,t)}getAllFromCache(e,t){return this.cr.getEntries(e,t)}}class ng{constructor(e){this.persistence=e,this.Nr=new Up((e=>Ip(e)),Cp),this.lastRemoteSnapshotVersion=Ud.min(),this.highestTargetId=0,this.Lr=0,this.Br=new Qm,this.targetCount=0,this.kr=jm.Bn()}forEachTarget(e,t){return this.Nr.forEach(((e,n)=>t(n))),rh.resolve()}getLastRemoteSnapshotVersion(e){return rh.resolve(this.lastRemoteSnapshotVersion)}getHighestSequenceNumber(e){return rh.resolve(this.Lr)}allocateTargetId(e){return this.highestTargetId=this.kr.next(),rh.resolve(this.highestTargetId)}setTargetsMetadata(e,t,n){return n&&(this.lastRemoteSnapshotVersion=n),t>this.Lr&&(this.Lr=t),rh.resolve()}Kn(e){this.Nr.set(e.target,e);const t=e.targetId;t>this.highestTargetId&&(this.kr=new jm(t),this.highestTargetId=t),e.sequenceNumber>this.Lr&&(this.Lr=e.sequenceNumber)}addTargetData(e,t){return this.Kn(t),this.targetCount+=1,rh.resolve()}updateTargetData(e,t){return this.Kn(t),rh.resolve()}removeTargetData(e,t){return this.Nr.delete(t.target),this.Br.gr(t.targetId),this.targetCount-=1,rh.resolve()}removeTargets(e,t,n){let r=0;const a=[];return this.Nr.forEach(((s,i)=>{i.sequenceNumber<=t&&null===n.get(i.targetId)&&(this.Nr.delete(s),a.push(this.removeMatchingKeysForTargetId(e,i.targetId)),r++)})),rh.waitFor(a).next((()=>r))}getTargetCount(e){return rh.resolve(this.targetCount)}getTargetData(e,t){const n=this.Nr.get(t)||null;return rh.resolve(n)}addMatchingKeys(e,t,n){return this.Br.Rr(t,n),rh.resolve()}removeMatchingKeys(e,t,n){this.Br.mr(t,n);const r=this.persistence.referenceDelegate,a=[];return r&&t.forEach((t=>{a.push(r.markPotentiallyOrphaned(e,t))})),rh.waitFor(a)}removeMatchingKeysForTargetId(e,t){return this.Br.gr(t),rh.resolve()}getMatchingKeysForTargetId(e,t){const n=this.Br.yr(t);return rh.resolve(n)}containsKey(e,t){return rh.resolve(this.Br.containsKey(t))}}class rg{constructor(e,t){this.qr={},this.overlays={},this.Qr=new ih(0),this.Kr=!1,this.Kr=!0,this.$r=new Ym,this.referenceDelegate=e(this),this.Ur=new ng(this),this.indexManager=new Wm,this.remoteDocumentCache=function(e){return new eg(e)}((e=>this.referenceDelegate.Wr(e))),this.serializer=new Lm(t),this.Gr=new Km(this.serializer)}start(){return Promise.resolve()}shutdown(){return this.Kr=!1,Promise.resolve()}get started(){return this.Kr}setDatabaseDeletedListener(){}setNetworkEnabled(){}getIndexManager(e){return this.indexManager}getDocumentOverlayCache(e){let t=this.overlays[e.toKey()];return t||(t=new Xm,this.overlays[e.toKey()]=t),t}getMutationQueue(e,t){let n=this.qr[e.toKey()];return n||(n=new Zm(t,this.referenceDelegate),this.qr[e.toKey()]=n),n}getGlobalsCache(){return this.$r}getTargetCache(){return this.Ur}getRemoteDocumentCache(){return this.remoteDocumentCache}getBundleCache(){return this.Gr}runTransaction(e,t,n){xd("MemoryPersistence","Starting transaction:",e);const r=new ag(this.Qr.next());return this.referenceDelegate.zr(),n(r).next((e=>this.referenceDelegate.jr(r).next((()=>e)))).toPromise().then((e=>(r.raiseOnCommittedEvent(),e)))}Hr(e,t){return rh.or(Object.values(this.qr).map((n=>()=>n.containsKey(e,t))))}}class ag extends th{constructor(e){super(),this.currentSequenceNumber=e}}class sg{constructor(e){this.persistence=e,this.Jr=new Qm,this.Yr=null}static Zr(e){return new sg(e)}get Xr(){if(this.Yr)return this.Yr;throw Id()}addReference(e,t,n){return this.Jr.addReference(n,t),this.Xr.delete(n.toString()),rh.resolve()}removeReference(e,t,n){return this.Jr.removeReference(n,t),this.Xr.add(n.toString()),rh.resolve()}markPotentiallyOrphaned(e,t){return this.Xr.add(t.toString()),rh.resolve()}removeTarget(e,t){this.Jr.gr(t.targetId).forEach((e=>this.Xr.add(e.toString())));const n=this.persistence.getTargetCache();return n.getMatchingKeysForTargetId(e,t.targetId).next((e=>{e.forEach((e=>this.Xr.add(e.toString())))})).next((()=>n.removeTargetData(e,t)))}zr(){this.Yr=new Set}jr(e){const t=this.persistence.getRemoteDocumentCache().newChangeBuffer();return rh.forEach(this.Xr,(n=>{const r=Kd.fromPath(n);return this.ei(e,r).next((e=>{e||t.removeEntry(r,Ud.min())}))})).next((()=>(this.Yr=null,t.apply(e))))}updateLimboDocument(e,t){return this.ei(e,t).next((e=>{e?this.Xr.delete(t.toString()):this.Xr.add(t.toString())}))}Wr(e){return 0}ei(e,t){return rh.or([()=>rh.resolve(this.Jr.containsKey(t)),()=>this.persistence.getTargetCache().containsKey(e,t),()=>this.persistence.Hr(e,t)])}}class ig{constructor(e,t,n,r){this.targetId=e,this.fromCache=t,this.$i=n,this.Ui=r}static Wi(e,t){let n=ef(),r=ef();for(const a of t.docChanges)switch(a.type){case 0:n=n.add(a.doc.key);break;case 1:r=r.add(a.doc.key)}return new ig(e,t.fromCache,n,r)}}class og{constructor(){this._documentReadCount=0}get documentReadCount(){return this._documentReadCount}incrementDocumentReadCount(e){this._documentReadCount+=e}}class lg{constructor(){this.Gi=!1,this.zi=!1,this.ji=100,this.Hi=bu()?8:ah(yu())>0?6:4}initialize(e,t){this.Ji=e,this.indexManager=t,this.Gi=!0}getDocumentsMatchingQuery(e,t,n,r){const a={result:null};return this.Yi(e,t).next((e=>{a.result=e})).next((()=>{if(!a.result)return this.Zi(e,t,r,n).next((e=>{a.result=e}))})).next((()=>{if(a.result)return;const n=new og;return this.Xi(e,t,n).next((r=>{if(a.result=r,this.zi)return this.es(e,t,n,r.size)}))})).next((()=>a.result))}es(e,t,n,r){return n.documentReadCount<this.ji?(vd()<=Ru.DEBUG&&xd("QueryEngine","SDK will not create cache indexes for query:",Lp(t),"since it only creates cache indexes for collection contains","more than or equal to",this.ji,"documents"),rh.resolve()):(vd()<=Ru.DEBUG&&xd("QueryEngine","Query:",Lp(t),"scans",n.documentReadCount,"local documents and returns",r,"documents as results."),n.documentReadCount>this.Hi*r?(vd()<=Ru.DEBUG&&xd("QueryEngine","The SDK decides to create cache indexes for query:",Lp(t),"as using cache indexes may help improve performance."),this.indexManager.createTargetIndexes(e,Dp(t))):rh.resolve())}Yi(e,t){if(_p(t))return rh.resolve(null);let n=Dp(t);return this.indexManager.getIndexType(e,n).next((r=>0===r?null:(null!==t.limit&&1===r&&(t=Fp(t,null,"F"),n=Dp(t)),this.indexManager.getDocumentsMatchingTarget(e,n).next((r=>{const a=ef(...r);return this.Ji.getDocuments(e,a).next((r=>this.indexManager.getMinOffset(e,n).next((n=>{const s=this.ts(t,r);return this.ns(t,s,a,n.readTime)?this.Yi(e,Fp(t,null,"F")):this.rs(e,s,t,n)}))))})))))}Zi(e,t,n,r){return _p(t)||r.isEqual(Ud.min())?rh.resolve(null):this.Ji.getDocuments(e,n).next((a=>{const s=this.ts(t,a);return this.ns(t,s,n,r)?rh.resolve(null):(vd()<=Ru.DEBUG&&xd("QueryEngine","Re-using previous result from %s to execute query: %s",r.toString(),Lp(t)),this.rs(e,s,t,Yd(r,-1)).next((e=>e)))}))}ts(e,t){let n=new xh(Wp(e));return t.forEach(((t,r)=>{zp(e,r)&&(n=n.add(r))})),n}ns(e,t,n,r){if(null===e.limit)return!1;if(n.size!==t.size)return!0;const a="F"===e.limitType?t.last():t.first();return!!a&&(a.hasPendingWrites||a.version.compareTo(r)>0)}Xi(e,t,n){return vd()<=Ru.DEBUG&&xd("QueryEngine","Using full collection scan to execute query:",Lp(t)),this.Ji.getDocumentsMatchingQuery(e,t,Jd.min(),n)}rs(e,t,n,r){return this.Ji.getDocumentsMatchingQuery(e,n,r).next((e=>(t.forEach((t=>{e=e.insert(t.key,t)})),e)))}}class ug{constructor(e,t,n,r){this.persistence=e,this.ss=t,this.serializer=r,this.os=new yh(Bd),this._s=new Up((e=>Ip(e)),Cp),this.us=new Map,this.cs=e.getRemoteDocumentCache(),this.Ur=e.getTargetCache(),this.Gr=e.getBundleCache(),this.ls(n)}ls(e){this.documentOverlayCache=this.persistence.getDocumentOverlayCache(e),this.indexManager=this.persistence.getIndexManager(e),this.mutationQueue=this.persistence.getMutationQueue(e,this.indexManager),this.localDocuments=new qm(this.cs,this.mutationQueue,this.documentOverlayCache,this.indexManager),this.cs.setIndexManager(this.indexManager),this.ss.initialize(this.localDocuments,this.indexManager)}collectGarbage(e){return this.persistence.runTransaction("Collect garbage","readwrite-primary",(t=>e.collect(t,this.os)))}}function cg(e,t,n,r){return new ug(e,t,n,r)}async function dg(e,t){const n=Nd(e);return await n.persistence.runTransaction("Handle user change","readonly",(e=>{let r;return n.mutationQueue.getAllMutationBatches(e).next((a=>(r=a,n.ls(t),n.mutationQueue.getAllMutationBatches(e)))).next((t=>{const a=[],s=[];let i=ef();for(const e of r){a.push(e.batchId);for(const t of e.mutations)i=i.add(t.key)}for(const e of t){s.push(e.batchId);for(const t of e.mutations)i=i.add(t.key)}return n.localDocuments.getDocuments(e,i).next((e=>({hs:e,removedBatchIds:a,addedBatchIds:s})))}))}))}function hg(e){const t=Nd(e);return t.persistence.runTransaction("Get last remote snapshot version","readonly",(e=>t.Ur.getLastRemoteSnapshotVersion(e)))}function pg(e,t,n){let r=ef(),a=ef();return n.forEach((e=>r=r.add(e))),t.getEntries(e,r).next((e=>{let r=Gp();return n.forEach(((n,s)=>{const i=e.get(n);s.isFoundDocument()!==i.isFoundDocument()&&(a=a.add(n)),s.isNoDocument()&&s.version.isEqual(Ud.min())?(t.removeEntry(n,s.readTime),r=r.insert(n,s)):!i.isValidDocument()||s.version.compareTo(i.version)>0||0===s.version.compareTo(i.version)&&i.hasPendingWrites?(t.addEntry(s),r=r.insert(n,s)):xd("LocalStore","Ignoring outdated watch update for ",n,". Current version:",i.version," Watch version:",s.version)})),{Ps:r,Is:a}}))}function fg(e,t){const n=Nd(e);return n.persistence.runTransaction("Get next mutation batch","readonly",(e=>(void 0===t&&(t=-1),n.mutationQueue.getNextMutationBatchAfterBatchId(e,t))))}function mg(e,t){const n=Nd(e);return n.persistence.runTransaction("Allocate target","readwrite",(e=>{let r;return n.Ur.getTargetData(e,t).next((a=>a?(r=a,rh.resolve(r)):n.Ur.allocateTargetId(e).next((a=>(r=new Pm(t,a,"TargetPurposeListen",e.currentSequenceNumber),n.Ur.addTargetData(e,r).next((()=>r)))))))})).then((e=>{const r=n.os.get(e.targetId);return(null===r||e.snapshotVersion.compareTo(r.snapshotVersion)>0)&&(n.os=n.os.insert(e.targetId,e),n._s.set(t,e.targetId)),e}))}async function gg(e,t,n){const r=Nd(e),a=r.os.get(t),s=n?"readwrite":"readwrite-primary";try{n||await r.persistence.runTransaction("Release target",s,(e=>r.persistence.referenceDelegate.removeTarget(e,a)))}catch(e){if(!sh(e))throw e;xd("LocalStore",`Failed to update sequence numbers for target ${t}: ${e}`)}r.os=r.os.remove(t),r._s.delete(a.target)}function yg(e,t,n){const r=Nd(e);let a=Ud.min(),s=ef();return r.persistence.runTransaction("Execute query","readwrite",(e=>function(e,t,n){const r=Nd(e),a=r._s.get(n);return void 0!==a?rh.resolve(r.os.get(a)):r.Ur.getTargetData(t,n)}(r,e,Dp(t)).next((t=>{if(t)return a=t.lastLimboFreeSnapshotVersion,r.Ur.getMatchingKeysForTargetId(e,t.targetId).next((e=>{s=e}))})).next((()=>r.ss.getDocumentsMatchingQuery(e,t,n?a:Ud.min(),n?s:ef()))).next((e=>(bg(r,Bp(t),e),{documents:e,Ts:s})))))}function bg(e,t,n){let r=e.us.get(t)||Ud.min();n.forEach(((e,t)=>{t.readTime.compareTo(r)>0&&(r=t.readTime)})),e.us.set(t,r)}class vg{constructor(){this.activeTargetIds=nf()}fs(e){this.activeTargetIds=this.activeTargetIds.add(e)}gs(e){this.activeTargetIds=this.activeTargetIds.delete(e)}Vs(){const e={activeTargetIds:this.activeTargetIds.toArray(),updateTimeMs:Date.now()};return JSON.stringify(e)}}class xg{constructor(){this.so=new vg,this.oo={},this.onlineStateHandler=null,this.sequenceNumberHandler=null}addPendingMutation(e){}updateMutationState(e,t,n){}addLocalQueryTarget(e){return this.so.fs(e),this.oo[e]||"not-current"}updateQueryState(e,t,n){this.oo[e]=t}removeLocalQueryTarget(e){this.so.gs(e)}isLocalQueryTarget(e){return this.so.activeTargetIds.has(e)}clearQueryState(e){delete this.oo[e]}getAllActiveQueryTargets(){return this.so.activeTargetIds}isActiveQueryTarget(e){return this.so.activeTargetIds.has(e)}start(){return this.so=new vg,Promise.resolve()}handleUserChange(e,t,n){}setOnlineState(e){}shutdown(){}writeSequenceNumber(e){}notifyBundleLoaded(e){}}class wg{_o(e){}shutdown(){}}class kg{constructor(){this.ao=()=>this.uo(),this.co=()=>this.lo(),this.ho=[],this.Po()}_o(e){this.ho.push(e)}shutdown(){window.removeEventListener("online",this.ao),window.removeEventListener("offline",this.co)}Po(){window.addEventListener("online",this.ao),window.addEventListener("offline",this.co)}uo(){xd("ConnectivityMonitor","Network connectivity changed: AVAILABLE");for(const e of this.ho)e(0)}lo(){xd("ConnectivityMonitor","Network connectivity changed: UNAVAILABLE");for(const e of this.ho)e(1)}static D(){return"undefined"!=typeof window&&void 0!==window.addEventListener&&void 0!==window.removeEventListener}}let Sg=null;function Ig(){return null===Sg?Sg=268435456+Math.round(2147483648*Math.random()):Sg++,"0x"+Sg.toString(16)}const Cg={BatchGetDocuments:"batchGet",Commit:"commit",RunQuery:"runQuery",RunAggregationQuery:"runAggregationQuery"};class Ng{constructor(e){this.Io=e.Io,this.To=e.To}Eo(e){this.Ao=e}Ro(e){this.Vo=e}mo(e){this.fo=e}onMessage(e){this.po=e}close(){this.To()}send(e){this.Io(e)}yo(){this.Ao()}wo(){this.Vo()}So(e){this.fo(e)}bo(e){this.po(e)}}const Tg="WebChannelConnection";class Eg extends class{constructor(e){this.databaseInfo=e,this.databaseId=e.databaseId;const t=e.ssl?"https":"http",n=encodeURIComponent(this.databaseId.projectId),r=encodeURIComponent(this.databaseId.database);this.Do=t+"://"+e.host,this.vo=`projects/${n}/databases/${r}`,this.Co="(default)"===this.databaseId.database?`project_id=${n}`:`project_id=${n}&database_id=${r}`}get Fo(){return!1}Mo(e,t,n,r,a){const s=Ig(),i=this.xo(e,t.toUriEncodedString());xd("RestConnection",`Sending RPC '${e}' ${s}:`,i,n);const o={"google-cloud-resource-prefix":this.vo,"x-goog-request-params":this.Co};return this.Oo(o,r,a),this.No(e,i,o,n).then((t=>(xd("RestConnection",`Received RPC '${e}' ${s}: `,t),t)),(t=>{throw kd("RestConnection",`RPC '${e}' ${s} failed with error: `,t,"url: ",i,"request:",n),t}))}Lo(e,t,n,r,a,s){return this.Mo(e,t,n,r,a)}Oo(e,t,n){e["X-Goog-Api-Client"]="gl-js/ fire/"+yd,e["Content-Type"]="text/plain",this.databaseInfo.appId&&(e["X-Firebase-GMPID"]=this.databaseInfo.appId),t&&t.headers.forEach(((t,n)=>e[n]=t)),n&&n.headers.forEach(((t,n)=>e[n]=t))}xo(e,t){const n=Cg[e];return`${this.Do}/v1/${t}:${n}`}terminate(){}}{constructor(e){super(e),this.forceLongPolling=e.forceLongPolling,this.autoDetectLongPolling=e.autoDetectLongPolling,this.useFetchStreams=e.useFetchStreams,this.longPollingOptions=e.longPollingOptions}No(e,t,n,r){const a=Ig();return new Promise(((s,i)=>{const o=new ad;o.setWithCredentials(!0),o.listenOnce(od.COMPLETE,(()=>{try{switch(o.getLastErrorCode()){case ld.NO_ERROR:const t=o.getResponseJson();xd(Tg,`XHR for RPC '${e}' ${a} received:`,JSON.stringify(t)),s(t);break;case ld.TIMEOUT:xd(Tg,`RPC '${e}' ${a} timed out`),i(new Ed(Td.DEADLINE_EXCEEDED,"Request time out"));break;case ld.HTTP_ERROR:const n=o.getStatus();if(xd(Tg,`RPC '${e}' ${a} failed with status:`,n,"response text:",o.getResponseText()),n>0){let e=o.getResponseJson();Array.isArray(e)&&(e=e[0]);const t=null==e?void 0:e.error;if(t&&t.status&&t.message){const e=function(e){const t=e.toLowerCase().replace(/_/g,"-");return Object.values(Td).indexOf(t)>=0?t:Td.UNKNOWN}(t.status);i(new Ed(e,t.message))}else i(new Ed(Td.UNKNOWN,"Server responded with status "+o.getStatus()))}else i(new Ed(Td.UNAVAILABLE,"Connection failed."));break;default:Id()}}finally{xd(Tg,`RPC '${e}' ${a} completed.`)}}));const l=JSON.stringify(r);xd(Tg,`RPC '${e}' ${a} sending request:`,r),o.send(t,"POST",l,n,15)}))}Bo(e,t,n){const r=Ig(),a=[this.Do,"/","google.firestore.v1.Firestore","/",e,"/channel"],s=hd(),i=dd(),o={httpSessionIdParam:"gsessionid",initMessageHeaders:{},messageUrlParams:{database:`projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`},sendRawJson:!0,supportsCrossDomainXhr:!0,internalChannelParams:{forwardChannelRequestTimeoutMs:6e5},forceLongPolling:this.forceLongPolling,detectBufferingProxy:this.autoDetectLongPolling},l=this.longPollingOptions.timeoutSeconds;void 0!==l&&(o.longPollingTimeout=Math.round(1e3*l)),this.useFetchStreams&&(o.xmlHttpFactory=new sd({})),this.Oo(o.initMessageHeaders,t,n),o.encodeInitMessageHeaders=!0;const u=a.join("");xd(Tg,`Creating RPC '${e}' stream ${r}: ${u}`,o);const c=s.createWebChannel(u,o);let d=!1,h=!1;const p=new Ng({Io:t=>{h?xd(Tg,`Not sending because RPC '${e}' stream ${r} is closed:`,t):(d||(xd(Tg,`Opening RPC '${e}' stream ${r} transport.`),c.open(),d=!0),xd(Tg,`RPC '${e}' stream ${r} sending:`,t),c.send(t))},To:()=>c.close()}),f=(e,t,n)=>{e.listen(t,(e=>{try{n(e)}catch(e){setTimeout((()=>{throw e}),0)}}))};return f(c,id.EventType.OPEN,(()=>{h||(xd(Tg,`RPC '${e}' stream ${r} transport opened.`),p.yo())})),f(c,id.EventType.CLOSE,(()=>{h||(h=!0,xd(Tg,`RPC '${e}' stream ${r} transport closed`),p.So())})),f(c,id.EventType.ERROR,(t=>{h||(h=!0,kd(Tg,`RPC '${e}' stream ${r} transport errored:`,t),p.So(new Ed(Td.UNAVAILABLE,"The operation could not be completed")))})),f(c,id.EventType.MESSAGE,(t=>{var n;if(!h){const a=t.data[0];Cd(!!a);const s=a,i=s.error||(null===(n=s[0])||void 0===n?void 0:n.error);if(i){xd(Tg,`RPC '${e}' stream ${r} received error:`,i);const t=i.status;let n=function(e){const t=zf[e];if(void 0!==t)return Vf(t)}(t),a=i.message;void 0===n&&(n=Td.INTERNAL,a="Unknown error status: "+t+" with message "+i.message),h=!0,p.So(new Ed(n,a)),c.close()}else xd(Tg,`RPC '${e}' stream ${r} received:`,a),p.bo(a)}})),f(i,cd.STAT_EVENT,(t=>{t.stat===ud.PROXY?xd(Tg,`RPC '${e}' stream ${r} detected buffering proxy`):t.stat===ud.NOPROXY&&xd(Tg,`RPC '${e}' stream ${r} detected no buffering proxy`)})),setTimeout((()=>{p.wo()}),0),p}}function Ag(){return"undefined"!=typeof document?document:null}function _g(e){return new lm(e,!0)}class $g{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:6e4;this.ui=e,this.timerId=t,this.ko=n,this.qo=r,this.Qo=a,this.Ko=0,this.$o=null,this.Uo=Date.now(),this.reset()}reset(){this.Ko=0}Wo(){this.Ko=this.Qo}Go(e){this.cancel();const t=Math.floor(this.Ko+this.zo()),n=Math.max(0,Date.now()-this.Uo),r=Math.max(0,t-n);r>0&&xd("ExponentialBackoff",`Backing off for ${r} ms (base delay: ${this.Ko} ms, delay with jitter: ${t} ms, last attempt: ${n} ms ago)`),this.$o=this.ui.enqueueAfterDelay(this.timerId,r,(()=>(this.Uo=Date.now(),e()))),this.Ko*=this.qo,this.Ko<this.ko&&(this.Ko=this.ko),this.Ko>this.Qo&&(this.Ko=this.Qo)}jo(){null!==this.$o&&(this.$o.skipDelay(),this.$o=null)}cancel(){null!==this.$o&&(this.$o.cancel(),this.$o=null)}zo(){return(Math.random()-.5)*this.Ko}}class Rg{constructor(e,t,n,r,a,s,i,o){this.ui=e,this.Ho=n,this.Jo=r,this.connection=a,this.authCredentialsProvider=s,this.appCheckCredentialsProvider=i,this.listener=o,this.state=0,this.Yo=0,this.Zo=null,this.Xo=null,this.stream=null,this.e_=0,this.t_=new $g(e,t)}n_(){return 1===this.state||5===this.state||this.r_()}r_(){return 2===this.state||3===this.state}start(){this.e_=0,4!==this.state?this.auth():this.i_()}async stop(){this.n_()&&await this.close(0)}s_(){this.state=0,this.t_.reset()}o_(){this.r_()&&null===this.Zo&&(this.Zo=this.ui.enqueueAfterDelay(this.Ho,6e4,(()=>this.__())))}a_(e){this.u_(),this.stream.send(e)}async __(){if(this.r_())return this.close(0)}u_(){this.Zo&&(this.Zo.cancel(),this.Zo=null)}c_(){this.Xo&&(this.Xo.cancel(),this.Xo=null)}async close(e,t){this.u_(),this.c_(),this.t_.cancel(),this.Yo++,4!==e?this.t_.reset():t&&t.code===Td.RESOURCE_EXHAUSTED?(wd(t.toString()),wd("Using maximum backoff delay to prevent overloading the backend."),this.t_.Wo()):t&&t.code===Td.UNAUTHENTICATED&&3!==this.state&&(this.authCredentialsProvider.invalidateToken(),this.appCheckCredentialsProvider.invalidateToken()),null!==this.stream&&(this.l_(),this.stream.close(),this.stream=null),this.state=e,await this.listener.mo(t)}l_(){}auth(){this.state=1;const e=this.h_(this.Yo),t=this.Yo;Promise.all([this.authCredentialsProvider.getToken(),this.appCheckCredentialsProvider.getToken()]).then((e=>{let[n,r]=e;this.Yo===t&&this.P_(n,r)}),(t=>{e((()=>{const e=new Ed(Td.UNKNOWN,"Fetching auth token failed: "+t.message);return this.I_(e)}))}))}P_(e,t){const n=this.h_(this.Yo);this.stream=this.T_(e,t),this.stream.Eo((()=>{n((()=>this.listener.Eo()))})),this.stream.Ro((()=>{n((()=>(this.state=2,this.Xo=this.ui.enqueueAfterDelay(this.Jo,1e4,(()=>(this.r_()&&(this.state=3),Promise.resolve()))),this.listener.Ro())))})),this.stream.mo((e=>{n((()=>this.I_(e)))})),this.stream.onMessage((e=>{n((()=>1==++this.e_?this.E_(e):this.onNext(e)))}))}i_(){this.state=5,this.t_.Go((async()=>{this.state=0,this.start()}))}I_(e){return xd("PersistentStream",`close with error: ${e}`),this.stream=null,this.close(4,e)}h_(e){return t=>{this.ui.enqueueAndForget((()=>this.Yo===e?t():(xd("PersistentStream","stream callback skipped by getCloseGuardedDispatcher."),Promise.resolve())))}}}class Dg extends Rg{constructor(e,t,n,r,a,s){super(e,"listen_stream_connection_backoff","listen_stream_idle","health_check_timeout",t,n,r,s),this.serializer=a}T_(e,t){return this.connection.Bo("Listen",e,t)}E_(e){return this.onNext(e)}onNext(e){this.t_.reset();const t=function(e,t){let n;if("targetChange"in t){t.targetChange;const r=function(e){return"NO_CHANGE"===e?0:"ADD"===e?1:"REMOVE"===e?2:"CURRENT"===e?3:"RESET"===e?4:Id()}(t.targetChange.targetChangeType||"NO_CHANGE"),a=t.targetChange.targetIds||[],s=function(e,t){return e.useProto3Json?(Cd(void 0===t||"string"==typeof t),Ih.fromBase64String(t||"")):(Cd(void 0===t||t instanceof Buffer||t instanceof Uint8Array),Ih.fromUint8Array(t||new Uint8Array))}(e,t.targetChange.resumeToken),i=t.targetChange.cause,o=i&&function(e){const t=void 0===e.code?Td.UNKNOWN:Vf(e.code);return new Ed(t,e.message||"")}(i);n=new em(r,a,s,o||null)}else if("documentChange"in t){t.documentChange;const r=t.documentChange;r.document,r.document.name,r.document.updateTime;const a=bm(e,r.document.name),s=pm(r.document.updateTime),i=r.document.createTime?pm(r.document.createTime):Ud.min(),o=new Qh({mapValue:{fields:r.document.fields}}),l=Zh.newFoundDocument(a,s,i,o),u=r.targetIds||[],c=r.removedTargetIds||[];n=new Jf(u,c,l.key,l)}else if("documentDelete"in t){t.documentDelete;const r=t.documentDelete;r.document;const a=bm(e,r.document),s=r.readTime?pm(r.readTime):Ud.min(),i=Zh.newNoDocument(a,s),o=r.removedTargetIds||[];n=new Jf([],o,i.key,i)}else if("documentRemove"in t){t.documentRemove;const r=t.documentRemove;r.document;const a=bm(e,r.document),s=r.removedTargetIds||[];n=new Jf([],s,a,null)}else{if(!("filter"in t))return Id();{t.filter;const e=t.filter;e.targetId;const{count:r=0,unchangedNames:a}=e,s=new Lf(r,a),i=e.targetId;n=new Zf(i,s)}}return n}(this.serializer,e),n=function(e){if(!("targetChange"in e))return Ud.min();const t=e.targetChange;return t.targetIds&&t.targetIds.length?Ud.min():t.readTime?pm(t.readTime):Ud.min()}(e);return this.listener.d_(t,n)}A_(e){const t={};t.database=wm(this.serializer),t.addTarget=function(e,t){let n;const r=t.target;if(n=Np(r)?{documents:Cm(e,r)}:{query:Nm(e,r)._t},n.targetId=t.targetId,t.resumeToken.approximateByteSize()>0){n.resumeToken=dm(e,t.resumeToken);const r=um(e,t.expectedCount);null!==r&&(n.expectedCount=r)}else if(t.snapshotVersion.compareTo(Ud.min())>0){n.readTime=cm(e,t.snapshotVersion.toTimestamp());const r=um(e,t.expectedCount);null!==r&&(n.expectedCount=r)}return n}(this.serializer,e);const n=function(e,t){const n=function(e){switch(e){case"TargetPurposeListen":return null;case"TargetPurposeExistenceFilterMismatch":return"existence-filter-mismatch";case"TargetPurposeExistenceFilterMismatchBloom":return"existence-filter-mismatch-bloom";case"TargetPurposeLimboResolution":return"limbo-document";default:return Id()}}(t.purpose);return null==n?null:{"goog-listen-tags":n}}(this.serializer,e);n&&(t.labels=n),this.a_(t)}R_(e){const t={};t.database=wm(this.serializer),t.removeTarget=e,this.a_(t)}}class Mg extends Rg{constructor(e,t,n,r,a,s){super(e,"write_stream_connection_backoff","write_stream_idle","health_check_timeout",t,n,r,s),this.serializer=a}get V_(){return this.e_>0}start(){this.lastStreamToken=void 0,super.start()}l_(){this.V_&&this.m_([])}T_(e,t){return this.connection.Bo("Write",e,t)}E_(e){return Cd(!!e.streamToken),this.lastStreamToken=e.streamToken,Cd(!e.writeResults||0===e.writeResults.length),this.listener.f_()}onNext(e){Cd(!!e.streamToken),this.lastStreamToken=e.streamToken,this.t_.reset();const t=function(e,t){return e&&e.length>0?(Cd(void 0!==t),e.map((e=>function(e,t){let n=e.updateTime?pm(e.updateTime):pm(t);return n.isEqual(Ud.min())&&(n=pm(t)),new vf(n,e.transformResults||[])}(e,t)))):[]}(e.writeResults,e.commitTime),n=pm(e.commitTime);return this.listener.g_(n,t)}p_(){const e={};e.database=wm(this.serializer),this.a_(e)}m_(e){const t={streamToken:this.lastStreamToken,writes:e.map((e=>Im(this.serializer,e)))};this.a_(t)}}class Fg extends class{}{constructor(e,t,n,r){super(),this.authCredentials=e,this.appCheckCredentials=t,this.connection=n,this.serializer=r,this.y_=!1}w_(){if(this.y_)throw new Ed(Td.FAILED_PRECONDITION,"The client has already been terminated.")}Mo(e,t,n,r){return this.w_(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((a=>{let[s,i]=a;return this.connection.Mo(e,mm(t,n),r,s,i)})).catch((e=>{throw"FirebaseError"===e.name?(e.code===Td.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),e):new Ed(Td.UNKNOWN,e.toString())}))}Lo(e,t,n,r,a){return this.w_(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((s=>{let[i,o]=s;return this.connection.Lo(e,mm(t,n),r,i,o,a)})).catch((e=>{throw"FirebaseError"===e.name?(e.code===Td.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),e):new Ed(Td.UNKNOWN,e.toString())}))}terminate(){this.y_=!0,this.connection.terminate()}}class Og{constructor(e,t){this.asyncQueue=e,this.onlineStateHandler=t,this.state="Unknown",this.S_=0,this.b_=null,this.D_=!0}v_(){0===this.S_&&(this.C_("Unknown"),this.b_=this.asyncQueue.enqueueAfterDelay("online_state_timeout",1e4,(()=>(this.b_=null,this.F_("Backend didn't respond within 10 seconds."),this.C_("Offline"),Promise.resolve()))))}M_(e){"Online"===this.state?this.C_("Unknown"):(this.S_++,this.S_>=1&&(this.x_(),this.F_(`Connection failed 1 times. Most recent error: ${e.toString()}`),this.C_("Offline")))}set(e){this.x_(),this.S_=0,"Online"===e&&(this.D_=!1),this.C_(e)}C_(e){e!==this.state&&(this.state=e,this.onlineStateHandler(e))}F_(e){const t=`Could not reach Cloud Firestore backend. ${e}\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;this.D_?(wd(t),this.D_=!1):xd("OnlineStateTracker",t)}x_(){null!==this.b_&&(this.b_.cancel(),this.b_=null)}}class Pg{constructor(e,t,n,r,a){this.localStore=e,this.datastore=t,this.asyncQueue=n,this.remoteSyncer={},this.O_=[],this.N_=new Map,this.L_=new Set,this.B_=[],this.k_=a,this.k_._o((e=>{n.enqueueAndForget((async()=>{Hg(this)&&(xd("RemoteStore","Restarting streams for network reachability change."),await async function(e){const t=Nd(e);t.L_.add(4),await zg(t),t.q_.set("Unknown"),t.L_.delete(4),await Lg(t)}(this))}))})),this.q_=new Og(n,r)}}async function Lg(e){if(Hg(e))for(const t of e.B_)await t(!0)}async function zg(e){for(const t of e.B_)await t(!1)}function Bg(e,t){const n=Nd(e);n.N_.has(t.targetId)||(n.N_.set(t.targetId,t),Gg(n)?jg(n):dy(n).r_()&&Vg(n,t))}function Wg(e,t){const n=Nd(e),r=dy(n);n.N_.delete(t),r.r_()&&Ug(n,t),0===n.N_.size&&(r.r_()?r.o_():Hg(n)&&n.q_.set("Unknown"))}function Vg(e,t){if(e.Q_.xe(t.targetId),t.resumeToken.approximateByteSize()>0||t.snapshotVersion.compareTo(Ud.min())>0){const n=e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size;t=t.withExpectedCount(n)}dy(e).A_(t)}function Ug(e,t){e.Q_.xe(t),dy(e).R_(t)}function jg(e){e.Q_=new nm({getRemoteKeysForTarget:t=>e.remoteSyncer.getRemoteKeysForTarget(t),ot:t=>e.N_.get(t)||null,tt:()=>e.datastore.serializer.databaseId}),dy(e).start(),e.q_.v_()}function Gg(e){return Hg(e)&&!dy(e).n_()&&e.N_.size>0}function Hg(e){return 0===Nd(e).L_.size}function qg(e){e.Q_=void 0}async function Kg(e){e.q_.set("Online")}async function Xg(e){e.N_.forEach(((t,n)=>{Vg(e,t)}))}async function Yg(e,t){qg(e),Gg(e)?(e.q_.M_(t),jg(e)):e.q_.set("Unknown")}async function Qg(e,t,n){if(e.q_.set("Online"),t instanceof em&&2===t.state&&t.cause)try{await async function(e,t){const n=t.cause;for(const r of t.targetIds)e.N_.has(r)&&(await e.remoteSyncer.rejectListen(r,n),e.N_.delete(r),e.Q_.removeTarget(r))}(e,t)}catch(n){xd("RemoteStore","Failed to remove targets %s: %s ",t.targetIds.join(","),n),await Jg(e,n)}else if(t instanceof Jf?e.Q_.Ke(t):t instanceof Zf?e.Q_.He(t):e.Q_.We(t),!n.isEqual(Ud.min()))try{const t=await hg(e.localStore);n.compareTo(t)>=0&&await function(e,t){const n=e.Q_.rt(t);return n.targetChanges.forEach(((n,r)=>{if(n.resumeToken.approximateByteSize()>0){const a=e.N_.get(r);a&&e.N_.set(r,a.withResumeToken(n.resumeToken,t))}})),n.targetMismatches.forEach(((t,n)=>{const r=e.N_.get(t);if(!r)return;e.N_.set(t,r.withResumeToken(Ih.EMPTY_BYTE_STRING,r.snapshotVersion)),Ug(e,t);const a=new Pm(r.target,t,n,r.sequenceNumber);Vg(e,a)})),e.remoteSyncer.applyRemoteEvent(n)}(e,n)}catch(t){xd("RemoteStore","Failed to raise snapshot:",t),await Jg(e,t)}}async function Jg(e,t,n){if(!sh(t))throw t;e.L_.add(1),await zg(e),e.q_.set("Offline"),n||(n=()=>hg(e.localStore)),e.asyncQueue.enqueueRetryable((async()=>{xd("RemoteStore","Retrying IndexedDB access"),await n(),e.L_.delete(1),await Lg(e)}))}function Zg(e,t){return t().catch((n=>Jg(e,n,t)))}async function ey(e){const t=Nd(e),n=hy(t);let r=t.O_.length>0?t.O_[t.O_.length-1].batchId:-1;for(;ty(t);)try{const e=await fg(t.localStore,r);if(null===e){0===t.O_.length&&n.o_();break}r=e.batchId,ny(t,e)}catch(e){await Jg(t,e)}ry(t)&&ay(t)}function ty(e){return Hg(e)&&e.O_.length<10}function ny(e,t){e.O_.push(t);const n=hy(e);n.r_()&&n.V_&&n.m_(t.mutations)}function ry(e){return Hg(e)&&!hy(e).n_()&&e.O_.length>0}function ay(e){hy(e).start()}async function sy(e){hy(e).p_()}async function iy(e){const t=hy(e);for(const n of e.O_)t.m_(n.mutations)}async function oy(e,t,n){const r=e.O_.shift(),a=Of.from(r,t,n);await Zg(e,(()=>e.remoteSyncer.applySuccessfulWrite(a))),await ey(e)}async function ly(e,t){t&&hy(e).V_&&await async function(e,t){if(function(e){return Wf(e)&&e!==Td.ABORTED}(t.code)){const n=e.O_.shift();hy(e).s_(),await Zg(e,(()=>e.remoteSyncer.rejectFailedWrite(n.batchId,t))),await ey(e)}}(e,t),ry(e)&&ay(e)}async function uy(e,t){const n=Nd(e);n.asyncQueue.verifyOperationInProgress(),xd("RemoteStore","RemoteStore received new credentials");const r=Hg(n);n.L_.add(3),await zg(n),r&&n.q_.set("Unknown"),await n.remoteSyncer.handleCredentialChange(t),n.L_.delete(3),await Lg(n)}async function cy(e,t){const n=Nd(e);t?(n.L_.delete(2),await Lg(n)):t||(n.L_.add(2),await zg(n),n.q_.set("Unknown"))}function dy(e){return e.K_||(e.K_=function(e,t,n){const r=Nd(e);return r.w_(),new Dg(t,r.connection,r.authCredentials,r.appCheckCredentials,r.serializer,n)}(e.datastore,e.asyncQueue,{Eo:Kg.bind(null,e),Ro:Xg.bind(null,e),mo:Yg.bind(null,e),d_:Qg.bind(null,e)}),e.B_.push((async t=>{t?(e.K_.s_(),Gg(e)?jg(e):e.q_.set("Unknown")):(await e.K_.stop(),qg(e))}))),e.K_}function hy(e){return e.U_||(e.U_=function(e,t,n){const r=Nd(e);return r.w_(),new Mg(t,r.connection,r.authCredentials,r.appCheckCredentials,r.serializer,n)}(e.datastore,e.asyncQueue,{Eo:()=>Promise.resolve(),Ro:sy.bind(null,e),mo:ly.bind(null,e),f_:iy.bind(null,e),g_:oy.bind(null,e)}),e.B_.push((async t=>{t?(e.U_.s_(),await ey(e)):(await e.U_.stop(),e.O_.length>0&&(xd("RemoteStore",`Stopping write stream with ${e.O_.length} pending writes`),e.O_=[]))}))),e.U_}class py{constructor(e,t,n,r,a){this.asyncQueue=e,this.timerId=t,this.targetTimeMs=n,this.op=r,this.removalCallback=a,this.deferred=new Ad,this.then=this.deferred.promise.then.bind(this.deferred.promise),this.deferred.promise.catch((e=>{}))}get promise(){return this.deferred.promise}static createAndSchedule(e,t,n,r,a){const s=Date.now()+n,i=new py(e,t,s,r,a);return i.start(n),i}start(e){this.timerHandle=setTimeout((()=>this.handleDelayElapsed()),e)}skipDelay(){return this.handleDelayElapsed()}cancel(e){null!==this.timerHandle&&(this.clearTimeout(),this.deferred.reject(new Ed(Td.CANCELLED,"Operation cancelled"+(e?": "+e:""))))}handleDelayElapsed(){this.asyncQueue.enqueueAndForget((()=>null!==this.timerHandle?(this.clearTimeout(),this.op().then((e=>this.deferred.resolve(e)))):Promise.resolve()))}clearTimeout(){null!==this.timerHandle&&(this.removalCallback(this),clearTimeout(this.timerHandle),this.timerHandle=null)}}function fy(e,t){if(wd("AsyncQueue",`${t}: ${e}`),sh(e))return new Ed(Td.UNAVAILABLE,`${t}: ${e}`);throw e}class my{constructor(e){this.comparator=e?(t,n)=>e(t,n)||Kd.comparator(t.key,n.key):(e,t)=>Kd.comparator(e.key,t.key),this.keyedMap=qp(),this.sortedSet=new yh(this.comparator)}static emptySet(e){return new my(e.comparator)}has(e){return null!=this.keyedMap.get(e)}get(e){return this.keyedMap.get(e)}first(){return this.sortedSet.minKey()}last(){return this.sortedSet.maxKey()}isEmpty(){return this.sortedSet.isEmpty()}indexOf(e){const t=this.keyedMap.get(e);return t?this.sortedSet.indexOf(t):-1}get size(){return this.sortedSet.size}forEach(e){this.sortedSet.inorderTraversal(((t,n)=>(e(t),!1)))}add(e){const t=this.delete(e.key);return t.copy(t.keyedMap.insert(e.key,e),t.sortedSet.insert(e,null))}delete(e){const t=this.get(e);return t?this.copy(this.keyedMap.remove(e),this.sortedSet.remove(t)):this}isEqual(e){if(!(e instanceof my))return!1;if(this.size!==e.size)return!1;const t=this.sortedSet.getIterator(),n=e.sortedSet.getIterator();for(;t.hasNext();){const e=t.getNext().key,r=n.getNext().key;if(!e.isEqual(r))return!1}return!0}toString(){const e=[];return this.forEach((t=>{e.push(t.toString())})),0===e.length?"DocumentSet ()":"DocumentSet (\n  "+e.join("  \n")+"\n)"}copy(e,t){const n=new my;return n.comparator=this.comparator,n.keyedMap=e,n.sortedSet=t,n}}class gy{constructor(){this.W_=new yh(Kd.comparator)}track(e){const t=e.doc.key,n=this.W_.get(t);n?0!==e.type&&3===n.type?this.W_=this.W_.insert(t,e):3===e.type&&1!==n.type?this.W_=this.W_.insert(t,{type:n.type,doc:e.doc}):2===e.type&&2===n.type?this.W_=this.W_.insert(t,{type:2,doc:e.doc}):2===e.type&&0===n.type?this.W_=this.W_.insert(t,{type:0,doc:e.doc}):1===e.type&&0===n.type?this.W_=this.W_.remove(t):1===e.type&&2===n.type?this.W_=this.W_.insert(t,{type:1,doc:n.doc}):0===e.type&&1===n.type?this.W_=this.W_.insert(t,{type:2,doc:e.doc}):Id():this.W_=this.W_.insert(t,e)}G_(){const e=[];return this.W_.inorderTraversal(((t,n)=>{e.push(n)})),e}}class yy{constructor(e,t,n,r,a,s,i,o,l){this.query=e,this.docs=t,this.oldDocs=n,this.docChanges=r,this.mutatedKeys=a,this.fromCache=s,this.syncStateChanged=i,this.excludesMetadataChanges=o,this.hasCachedResults=l}static fromInitialDocuments(e,t,n,r,a){const s=[];return t.forEach((e=>{s.push({type:0,doc:e})})),new yy(e,t,my.emptySet(t),s,n,r,!0,!1,a)}get hasPendingWrites(){return!this.mutatedKeys.isEmpty()}isEqual(e){if(!(this.fromCache===e.fromCache&&this.hasCachedResults===e.hasCachedResults&&this.syncStateChanged===e.syncStateChanged&&this.mutatedKeys.isEqual(e.mutatedKeys)&&Op(this.query,e.query)&&this.docs.isEqual(e.docs)&&this.oldDocs.isEqual(e.oldDocs)))return!1;const t=this.docChanges,n=e.docChanges;if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++)if(t[r].type!==n[r].type||!t[r].doc.isEqual(n[r].doc))return!1;return!0}}class by{constructor(){this.z_=void 0,this.j_=[]}H_(){return this.j_.some((e=>e.J_()))}}class vy{constructor(){this.queries=xy(),this.onlineState="Unknown",this.Y_=new Set}terminate(){!function(e,t){const n=Nd(e),r=n.queries;n.queries=xy(),r.forEach(((e,n)=>{for(const r of n.j_)r.onError(t)}))}(this,new Ed(Td.ABORTED,"Firestore shutting down"))}}function xy(){return new Up((e=>Pp(e)),Op)}async function wy(e,t){const n=Nd(e);let r=3;const a=t.query;let s=n.queries.get(a);s?!s.H_()&&t.J_()&&(r=2):(s=new by,r=t.J_()?0:1);try{switch(r){case 0:s.z_=await n.onListen(a,!0);break;case 1:s.z_=await n.onListen(a,!1);break;case 2:await n.onFirstRemoteStoreListen(a)}}catch(e){const n=fy(e,`Initialization of query '${Lp(t.query)}' failed`);return void t.onError(n)}n.queries.set(a,s),s.j_.push(t),t.Z_(n.onlineState),s.z_&&t.X_(s.z_)&&Cy(n)}async function ky(e,t){const n=Nd(e),r=t.query;let a=3;const s=n.queries.get(r);if(s){const e=s.j_.indexOf(t);e>=0&&(s.j_.splice(e,1),0===s.j_.length?a=t.J_()?0:1:!s.H_()&&t.J_()&&(a=2))}switch(a){case 0:return n.queries.delete(r),n.onUnlisten(r,!0);case 1:return n.queries.delete(r),n.onUnlisten(r,!1);case 2:return n.onLastRemoteStoreUnlisten(r);default:return}}function Sy(e,t){const n=Nd(e);let r=!1;for(const a of t){const e=a.query,t=n.queries.get(e);if(t){for(const e of t.j_)e.X_(a)&&(r=!0);t.z_=a}}r&&Cy(n)}function Iy(e,t,n){const r=Nd(e),a=r.queries.get(t);if(a)for(const s of a.j_)s.onError(n);r.queries.delete(t)}function Cy(e){e.Y_.forEach((e=>{e.next()}))}var Ny,Ty;(Ty=Ny||(Ny={})).ea="default",Ty.Cache="cache";class Ey{constructor(e,t,n){this.query=e,this.ta=t,this.na=!1,this.ra=null,this.onlineState="Unknown",this.options=n||{}}X_(e){if(!this.options.includeMetadataChanges){const t=[];for(const n of e.docChanges)3!==n.type&&t.push(n);e=new yy(e.query,e.docs,e.oldDocs,t,e.mutatedKeys,e.fromCache,e.syncStateChanged,!0,e.hasCachedResults)}let t=!1;return this.na?this.ia(e)&&(this.ta.next(e),t=!0):this.sa(e,this.onlineState)&&(this.oa(e),t=!0),this.ra=e,t}onError(e){this.ta.error(e)}Z_(e){this.onlineState=e;let t=!1;return this.ra&&!this.na&&this.sa(this.ra,e)&&(this.oa(this.ra),t=!0),t}sa(e,t){if(!e.fromCache)return!0;if(!this.J_())return!0;const n="Offline"!==t;return(!this.options._a||!n)&&(!e.docs.isEmpty()||e.hasCachedResults||"Offline"===t)}ia(e){if(e.docChanges.length>0)return!0;const t=this.ra&&this.ra.hasPendingWrites!==e.hasPendingWrites;return!(!e.syncStateChanged&&!t)&&!0===this.options.includeMetadataChanges}oa(e){e=yy.fromInitialDocuments(e.query,e.docs,e.mutatedKeys,e.fromCache,e.hasCachedResults),this.na=!0,this.ta.next(e)}J_(){return this.options.source!==Ny.Cache}}class Ay{constructor(e){this.key=e}}class _y{constructor(e){this.key=e}}class $y{constructor(e,t){this.query=e,this.Ta=t,this.Ea=null,this.hasCachedResults=!1,this.current=!1,this.da=ef(),this.mutatedKeys=ef(),this.Aa=Wp(e),this.Ra=new my(this.Aa)}get Va(){return this.Ta}ma(e,t){const n=t?t.fa:new gy,r=t?t.Ra:this.Ra;let a=t?t.mutatedKeys:this.mutatedKeys,s=r,i=!1;const o="F"===this.query.limitType&&r.size===this.query.limit?r.last():null,l="L"===this.query.limitType&&r.size===this.query.limit?r.first():null;if(e.inorderTraversal(((e,t)=>{const u=r.get(e),c=zp(this.query,t)?t:null,d=!!u&&this.mutatedKeys.has(u.key),h=!!c&&(c.hasLocalMutations||this.mutatedKeys.has(c.key)&&c.hasCommittedMutations);let p=!1;u&&c?u.data.isEqual(c.data)?d!==h&&(n.track({type:3,doc:c}),p=!0):this.ga(u,c)||(n.track({type:2,doc:c}),p=!0,(o&&this.Aa(c,o)>0||l&&this.Aa(c,l)<0)&&(i=!0)):!u&&c?(n.track({type:0,doc:c}),p=!0):u&&!c&&(n.track({type:1,doc:u}),p=!0,(o||l)&&(i=!0)),p&&(c?(s=s.add(c),a=h?a.add(e):a.delete(e)):(s=s.delete(e),a=a.delete(e)))})),null!==this.query.limit)for(;s.size>this.query.limit;){const e="F"===this.query.limitType?s.last():s.first();s=s.delete(e.key),a=a.delete(e.key),n.track({type:1,doc:e})}return{Ra:s,fa:n,ns:i,mutatedKeys:a}}ga(e,t){return e.hasLocalMutations&&t.hasCommittedMutations&&!t.hasLocalMutations}applyChanges(e,t,n,r){const a=this.Ra;this.Ra=e.Ra,this.mutatedKeys=e.mutatedKeys;const s=e.fa.G_();s.sort(((e,t)=>function(e,t){const n=e=>{switch(e){case 0:return 1;case 2:case 3:return 2;case 1:return 0;default:return Id()}};return n(e)-n(t)}(e.type,t.type)||this.Aa(e.doc,t.doc))),this.pa(n),r=null!=r&&r;const i=t&&!r?this.ya():[],o=0===this.da.size&&this.current&&!r?1:0,l=o!==this.Ea;return this.Ea=o,0!==s.length||l?{snapshot:new yy(this.query,e.Ra,a,s,e.mutatedKeys,0===o,l,!1,!!n&&n.resumeToken.approximateByteSize()>0),wa:i}:{wa:i}}Z_(e){return this.current&&"Offline"===e?(this.current=!1,this.applyChanges({Ra:this.Ra,fa:new gy,mutatedKeys:this.mutatedKeys,ns:!1},!1)):{wa:[]}}Sa(e){return!this.Ta.has(e)&&!!this.Ra.has(e)&&!this.Ra.get(e).hasLocalMutations}pa(e){e&&(e.addedDocuments.forEach((e=>this.Ta=this.Ta.add(e))),e.modifiedDocuments.forEach((e=>{})),e.removedDocuments.forEach((e=>this.Ta=this.Ta.delete(e))),this.current=e.current)}ya(){if(!this.current)return[];const e=this.da;this.da=ef(),this.Ra.forEach((e=>{this.Sa(e.key)&&(this.da=this.da.add(e.key))}));const t=[];return e.forEach((e=>{this.da.has(e)||t.push(new _y(e))})),this.da.forEach((n=>{e.has(n)||t.push(new Ay(n))})),t}ba(e){this.Ta=e.Ts,this.da=ef();const t=this.ma(e.documents);return this.applyChanges(t,!0)}Da(){return yy.fromInitialDocuments(this.query,this.Ra,this.mutatedKeys,0===this.Ea,this.hasCachedResults)}}class Ry{constructor(e,t,n){this.query=e,this.targetId=t,this.view=n}}class Dy{constructor(e){this.key=e,this.va=!1}}class My{constructor(e,t,n,r,a,s){this.localStore=e,this.remoteStore=t,this.eventManager=n,this.sharedClientState=r,this.currentUser=a,this.maxConcurrentLimboResolutions=s,this.Ca={},this.Fa=new Up((e=>Pp(e)),Op),this.Ma=new Map,this.xa=new Set,this.Oa=new yh(Kd.comparator),this.Na=new Map,this.La=new Qm,this.Ba={},this.ka=new Map,this.qa=jm.kn(),this.onlineState="Unknown",this.Qa=void 0}get isPrimaryClient(){return!0===this.Qa}}async function Fy(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=nb(e);let a;const s=r.Fa.get(t);return s?(r.sharedClientState.addLocalQueryTarget(s.targetId),a=s.view.Da()):a=await Py(r,t,n,!0),a}async function Oy(e,t){const n=nb(e);await Py(n,t,!0,!1)}async function Py(e,t,n,r){const a=await mg(e.localStore,Dp(t)),s=a.targetId,i=n?e.sharedClientState.addLocalQueryTarget(s):"not-current";let o;return r&&(o=await Ly(e,t,s,"current"===i,a.resumeToken)),e.isPrimaryClient&&n&&Bg(e.remoteStore,a),o}async function Ly(e,t,n,r,a){e.Ka=(t,n,r)=>async function(e,t,n,r){let a=t.view.ma(n);a.ns&&(a=await yg(e.localStore,t.query,!1).then((e=>{let{documents:n}=e;return t.view.ma(n,a)})));const s=r&&r.targetChanges.get(t.targetId),i=r&&null!=r.targetMismatches.get(t.targetId),o=t.view.applyChanges(a,e.isPrimaryClient,s,i);return Yy(e,t.targetId,o.wa),o.snapshot}(e,t,n,r);const s=await yg(e.localStore,t,!0),i=new $y(t,s.Ts),o=i.ma(s.documents),l=Qf.createSynthesizedTargetChangeForCurrentChange(n,r&&"Offline"!==e.onlineState,a),u=i.applyChanges(o,e.isPrimaryClient,l);Yy(e,n,u.wa);const c=new Ry(t,n,i);return e.Fa.set(t,c),e.Ma.has(n)?e.Ma.get(n).push(t):e.Ma.set(n,[t]),u.snapshot}async function zy(e,t,n){const r=Nd(e),a=r.Fa.get(t),s=r.Ma.get(a.targetId);if(s.length>1)return r.Ma.set(a.targetId,s.filter((e=>!Op(e,t)))),void r.Fa.delete(t);r.isPrimaryClient?(r.sharedClientState.removeLocalQueryTarget(a.targetId),r.sharedClientState.isActiveQueryTarget(a.targetId)||await gg(r.localStore,a.targetId,!1).then((()=>{r.sharedClientState.clearQueryState(a.targetId),n&&Wg(r.remoteStore,a.targetId),Ky(r,a.targetId)})).catch(nh)):(Ky(r,a.targetId),await gg(r.localStore,a.targetId,!0))}async function By(e,t){const n=Nd(e),r=n.Fa.get(t),a=n.Ma.get(r.targetId);n.isPrimaryClient&&1===a.length&&(n.sharedClientState.removeLocalQueryTarget(r.targetId),Wg(n.remoteStore,r.targetId))}async function Wy(e,t){const n=Nd(e);try{const e=await function(e,t){const n=Nd(e),r=t.snapshotVersion;let a=n.os;return n.persistence.runTransaction("Apply remote event","readwrite-primary",(e=>{const s=n.cs.newChangeBuffer({trackRemovals:!0});a=n.os;const i=[];t.targetChanges.forEach(((s,o)=>{const l=a.get(o);if(!l)return;i.push(n.Ur.removeMatchingKeys(e,s.removedDocuments,o).next((()=>n.Ur.addMatchingKeys(e,s.addedDocuments,o))));let u=l.withSequenceNumber(e.currentSequenceNumber);null!==t.targetMismatches.get(o)?u=u.withResumeToken(Ih.EMPTY_BYTE_STRING,Ud.min()).withLastLimboFreeSnapshotVersion(Ud.min()):s.resumeToken.approximateByteSize()>0&&(u=u.withResumeToken(s.resumeToken,r)),a=a.insert(o,u),function(e,t,n){return 0===e.resumeToken.approximateByteSize()||t.snapshotVersion.toMicroseconds()-e.snapshotVersion.toMicroseconds()>=3e8||n.addedDocuments.size+n.modifiedDocuments.size+n.removedDocuments.size>0}(l,u,s)&&i.push(n.Ur.updateTargetData(e,u))}));let o=Gp(),l=ef();if(t.documentUpdates.forEach((r=>{t.resolvedLimboDocuments.has(r)&&i.push(n.persistence.referenceDelegate.updateLimboDocument(e,r))})),i.push(pg(e,s,t.documentUpdates).next((e=>{o=e.Ps,l=e.Is}))),!r.isEqual(Ud.min())){const t=n.Ur.getLastRemoteSnapshotVersion(e).next((t=>n.Ur.setTargetsMetadata(e,e.currentSequenceNumber,r)));i.push(t)}return rh.waitFor(i).next((()=>s.apply(e))).next((()=>n.localDocuments.getLocalViewOfDocuments(e,o,l))).next((()=>o))})).then((e=>(n.os=a,e)))}(n.localStore,t);t.targetChanges.forEach(((e,t)=>{const r=n.Na.get(t);r&&(Cd(e.addedDocuments.size+e.modifiedDocuments.size+e.removedDocuments.size<=1),e.addedDocuments.size>0?r.va=!0:e.modifiedDocuments.size>0?Cd(r.va):e.removedDocuments.size>0&&(Cd(r.va),r.va=!1))})),await Zy(n,e,t)}catch(e){await nh(e)}}function Vy(e,t,n){const r=Nd(e);if(r.isPrimaryClient&&0===n||!r.isPrimaryClient&&1===n){const e=[];r.Fa.forEach(((n,r)=>{const a=r.view.Z_(t);a.snapshot&&e.push(a.snapshot)})),function(e,t){const n=Nd(e);n.onlineState=t;let r=!1;n.queries.forEach(((e,n)=>{for(const a of n.j_)a.Z_(t)&&(r=!0)})),r&&Cy(n)}(r.eventManager,t),e.length&&r.Ca.d_(e),r.onlineState=t,r.isPrimaryClient&&r.sharedClientState.setOnlineState(t)}}async function Uy(e,t,n){const r=Nd(e);r.sharedClientState.updateQueryState(t,"rejected",n);const a=r.Na.get(t),s=a&&a.key;if(s){let e=new yh(Kd.comparator);e=e.insert(s,Zh.newNoDocument(s,Ud.min()));const n=ef().add(s),a=new Yf(Ud.min(),new Map,new yh(Bd),e,n);await Wy(r,a),r.Oa=r.Oa.remove(s),r.Na.delete(t),Jy(r)}else await gg(r.localStore,t,!1).then((()=>Ky(r,t,n))).catch(nh)}async function jy(e,t){const n=Nd(e),r=t.batch.batchId;try{const e=await function(e,t){const n=Nd(e);return n.persistence.runTransaction("Acknowledge batch","readwrite-primary",(e=>{const r=t.batch.keys(),a=n.cs.newChangeBuffer({trackRemovals:!0});return function(e,t,n,r){const a=n.batch,s=a.keys();let i=rh.resolve();return s.forEach((e=>{i=i.next((()=>r.getEntry(t,e))).next((t=>{const s=n.docVersions.get(e);Cd(null!==s),t.version.compareTo(s)<0&&(a.applyToRemoteDocument(t,n),t.isValidDocument()&&(t.setReadTime(n.commitVersion),r.addEntry(t)))}))})),i.next((()=>e.mutationQueue.removeMutationBatch(t,a)))}(n,e,t,a).next((()=>a.apply(e))).next((()=>n.mutationQueue.performConsistencyCheck(e))).next((()=>n.documentOverlayCache.removeOverlaysForBatchId(e,r,t.batch.batchId))).next((()=>n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e,function(e){let t=ef();for(let n=0;n<e.mutationResults.length;++n)e.mutationResults[n].transformResults.length>0&&(t=t.add(e.batch.mutations[n].key));return t}(t)))).next((()=>n.localDocuments.getDocuments(e,r)))}))}(n.localStore,t);qy(n,r,null),Hy(n,r),n.sharedClientState.updateMutationState(r,"acknowledged"),await Zy(n,e)}catch(e){await nh(e)}}async function Gy(e,t,n){const r=Nd(e);try{const e=await function(e,t){const n=Nd(e);return n.persistence.runTransaction("Reject batch","readwrite-primary",(e=>{let r;return n.mutationQueue.lookupMutationBatch(e,t).next((t=>(Cd(null!==t),r=t.keys(),n.mutationQueue.removeMutationBatch(e,t)))).next((()=>n.mutationQueue.performConsistencyCheck(e))).next((()=>n.documentOverlayCache.removeOverlaysForBatchId(e,r,t))).next((()=>n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e,r))).next((()=>n.localDocuments.getDocuments(e,r)))}))}(r.localStore,t);qy(r,t,n),Hy(r,t),r.sharedClientState.updateMutationState(t,"rejected",n),await Zy(r,e)}catch(n){await nh(n)}}function Hy(e,t){(e.ka.get(t)||[]).forEach((e=>{e.resolve()})),e.ka.delete(t)}function qy(e,t,n){const r=Nd(e);let a=r.Ba[r.currentUser.toKey()];if(a){const e=a.get(t);e&&(n?e.reject(n):e.resolve(),a=a.remove(t)),r.Ba[r.currentUser.toKey()]=a}}function Ky(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;e.sharedClientState.removeLocalQueryTarget(t);for(const r of e.Ma.get(t))e.Fa.delete(r),n&&e.Ca.$a(r,n);e.Ma.delete(t),e.isPrimaryClient&&e.La.gr(t).forEach((t=>{e.La.containsKey(t)||Xy(e,t)}))}function Xy(e,t){e.xa.delete(t.path.canonicalString());const n=e.Oa.get(t);null!==n&&(Wg(e.remoteStore,n),e.Oa=e.Oa.remove(t),e.Na.delete(n),Jy(e))}function Yy(e,t,n){for(const r of n)r instanceof Ay?(e.La.addReference(r.key,t),Qy(e,r)):r instanceof _y?(xd("SyncEngine","Document no longer in limbo: "+r.key),e.La.removeReference(r.key,t),e.La.containsKey(r.key)||Xy(e,r.key)):Id()}function Qy(e,t){const n=t.key,r=n.path.canonicalString();e.Oa.get(n)||e.xa.has(r)||(xd("SyncEngine","New document in limbo: "+n),e.xa.add(r),Jy(e))}function Jy(e){for(;e.xa.size>0&&e.Oa.size<e.maxConcurrentLimboResolutions;){const t=e.xa.values().next().value;e.xa.delete(t);const n=new Kd(Gd.fromString(t)),r=e.qa.next();e.Na.set(r,new Dy(n)),e.Oa=e.Oa.insert(n,r),Bg(e.remoteStore,new Pm(Dp(Ap(n.path)),r,"TargetPurposeLimboResolution",ih.oe))}}async function Zy(e,t,n){const r=Nd(e),a=[],s=[],i=[];r.Fa.isEmpty()||(r.Fa.forEach(((e,o)=>{i.push(r.Ka(o,t,n).then((e=>{var t;if((e||n)&&r.isPrimaryClient){const a=e?!e.fromCache:null===(t=null==n?void 0:n.targetChanges.get(o.targetId))||void 0===t?void 0:t.current;r.sharedClientState.updateQueryState(o.targetId,a?"current":"not-current")}if(e){a.push(e);const t=ig.Wi(o.targetId,e);s.push(t)}})))})),await Promise.all(i),r.Ca.d_(a),await async function(e,t){const n=Nd(e);try{await n.persistence.runTransaction("notifyLocalViewChanges","readwrite",(e=>rh.forEach(t,(t=>rh.forEach(t.$i,(r=>n.persistence.referenceDelegate.addReference(e,t.targetId,r))).next((()=>rh.forEach(t.Ui,(r=>n.persistence.referenceDelegate.removeReference(e,t.targetId,r)))))))))}catch(e){if(!sh(e))throw e;xd("LocalStore","Failed to update sequence numbers: "+e)}for(const r of t){const e=r.targetId;if(!r.fromCache){const t=n.os.get(e),r=t.snapshotVersion,a=t.withLastLimboFreeSnapshotVersion(r);n.os=n.os.insert(e,a)}}}(r.localStore,s))}async function eb(e,t){const n=Nd(e);if(!n.currentUser.isEqual(t)){xd("SyncEngine","User change. New user:",t.toKey());const e=await dg(n.localStore,t);n.currentUser=t,function(e,t){e.ka.forEach((e=>{e.forEach((e=>{e.reject(new Ed(Td.CANCELLED,t))}))})),e.ka.clear()}(n,"'waitForPendingWrites' promise is rejected due to a user change."),n.sharedClientState.handleUserChange(t,e.removedBatchIds,e.addedBatchIds),await Zy(n,e.hs)}}function tb(e,t){const n=Nd(e),r=n.Na.get(t);if(r&&r.va)return ef().add(r.key);{let e=ef();const r=n.Ma.get(t);if(!r)return e;for(const t of r){const r=n.Fa.get(t);e=e.unionWith(r.view.Va)}return e}}function nb(e){const t=Nd(e);return t.remoteStore.remoteSyncer.applyRemoteEvent=Wy.bind(null,t),t.remoteStore.remoteSyncer.getRemoteKeysForTarget=tb.bind(null,t),t.remoteStore.remoteSyncer.rejectListen=Uy.bind(null,t),t.Ca.d_=Sy.bind(null,t.eventManager),t.Ca.$a=Iy.bind(null,t.eventManager),t}function rb(e){const t=Nd(e);return t.remoteStore.remoteSyncer.applySuccessfulWrite=jy.bind(null,t),t.remoteStore.remoteSyncer.rejectFailedWrite=Gy.bind(null,t),t}class ab{constructor(){this.synchronizeTabs=!1}async initialize(e){this.serializer=_g(e.databaseInfo.databaseId),this.sharedClientState=this.createSharedClientState(e),this.persistence=this.createPersistence(e),await this.persistence.start(),this.localStore=this.createLocalStore(e),this.gcScheduler=this.createGarbageCollectionScheduler(e,this.localStore),this.indexBackfillerScheduler=this.createIndexBackfillerScheduler(e,this.localStore)}createGarbageCollectionScheduler(e,t){return null}createIndexBackfillerScheduler(e,t){return null}createLocalStore(e){return cg(this.persistence,new lg,e.initialUser,this.serializer)}createPersistence(e){return new rg(sg.Zr,this.serializer)}createSharedClientState(e){return new xg}async terminate(){var e,t;null===(e=this.gcScheduler)||void 0===e||e.stop(),null===(t=this.indexBackfillerScheduler)||void 0===t||t.stop(),this.sharedClientState.shutdown(),await this.persistence.shutdown()}}class sb{async initialize(e,t){this.localStore||(this.localStore=e.localStore,this.sharedClientState=e.sharedClientState,this.datastore=this.createDatastore(t),this.remoteStore=this.createRemoteStore(t),this.eventManager=this.createEventManager(t),this.syncEngine=this.createSyncEngine(t,!e.synchronizeTabs),this.sharedClientState.onlineStateHandler=e=>Vy(this.syncEngine,e,1),this.remoteStore.remoteSyncer.handleCredentialChange=eb.bind(null,this.syncEngine),await cy(this.remoteStore,this.syncEngine.isPrimaryClient))}createEventManager(e){return new vy}createDatastore(e){const t=_g(e.databaseInfo.databaseId),n=function(e){return new Eg(e)}(e.databaseInfo);return function(e,t,n,r){return new Fg(e,t,n,r)}(e.authCredentials,e.appCheckCredentials,n,t)}createRemoteStore(e){return function(e,t,n,r,a){return new Pg(e,t,n,r,a)}(this.localStore,this.datastore,e.asyncQueue,(e=>Vy(this.syncEngine,e,0)),kg.D()?new kg:new wg)}createSyncEngine(e,t){return function(e,t,n,r,a,s,i){const o=new My(e,t,n,r,a,s);return i&&(o.Qa=!0),o}(this.localStore,this.remoteStore,this.eventManager,this.sharedClientState,e.initialUser,e.maxConcurrentLimboResolutions,t)}async terminate(){var e,t;await async function(e){const t=Nd(e);xd("RemoteStore","RemoteStore shutting down."),t.L_.add(5),await zg(t),t.k_.shutdown(),t.q_.set("Unknown")}(this.remoteStore),null===(e=this.datastore)||void 0===e||e.terminate(),null===(t=this.eventManager)||void 0===t||t.terminate()}}class ib{constructor(e){this.observer=e,this.muted=!1}next(e){this.observer.next&&this.Ga(this.observer.next,e)}error(e){this.observer.error?this.Ga(this.observer.error,e):wd("Uncaught Error in snapshot listener:",e.toString())}za(){this.muted=!0}Ga(e,t){this.muted||setTimeout((()=>{this.muted||e(t)}),0)}}class ob{constructor(e,t,n,r){this.authCredentials=e,this.appCheckCredentials=t,this.asyncQueue=n,this.databaseInfo=r,this.user=gd.UNAUTHENTICATED,this.clientId=zd.newId(),this.authCredentialListener=()=>Promise.resolve(),this.appCheckCredentialListener=()=>Promise.resolve(),this.authCredentials.start(n,(async e=>{xd("FirestoreClient","Received user=",e.uid),await this.authCredentialListener(e),this.user=e})),this.appCheckCredentials.start(n,(e=>(xd("FirestoreClient","Received new app check token=",e),this.appCheckCredentialListener(e,this.user))))}get configuration(){return{asyncQueue:this.asyncQueue,databaseInfo:this.databaseInfo,clientId:this.clientId,authCredentials:this.authCredentials,appCheckCredentials:this.appCheckCredentials,initialUser:this.user,maxConcurrentLimboResolutions:100}}setCredentialChangeListener(e){this.authCredentialListener=e}setAppCheckTokenChangeListener(e){this.appCheckCredentialListener=e}verifyNotTerminated(){if(this.asyncQueue.isShuttingDown)throw new Ed(Td.FAILED_PRECONDITION,"The client has already been terminated.")}terminate(){this.asyncQueue.enterRestrictedMode();const e=new Ad;return this.asyncQueue.enqueueAndForgetEvenWhileRestricted((async()=>{try{this._onlineComponents&&await this._onlineComponents.terminate(),this._offlineComponents&&await this._offlineComponents.terminate(),this.authCredentials.shutdown(),this.appCheckCredentials.shutdown(),e.resolve()}catch(t){const n=fy(t,"Failed to shutdown persistence");e.reject(n)}})),e.promise}}async function lb(e,t){e.asyncQueue.verifyOperationInProgress(),xd("FirestoreClient","Initializing OfflineComponentProvider");const n=e.configuration;await t.initialize(n);let r=n.initialUser;e.setCredentialChangeListener((async e=>{r.isEqual(e)||(await dg(t.localStore,e),r=e)})),t.persistence.setDatabaseDeletedListener((()=>e.terminate())),e._offlineComponents=t}async function ub(e,t){e.asyncQueue.verifyOperationInProgress();const n=await db(e);xd("FirestoreClient","Initializing OnlineComponentProvider"),await t.initialize(n,e.configuration),e.setCredentialChangeListener((e=>uy(t.remoteStore,e))),e.setAppCheckTokenChangeListener(((e,n)=>uy(t.remoteStore,n))),e._onlineComponents=t}function cb(e){return"FirebaseError"===e.name?e.code===Td.FAILED_PRECONDITION||e.code===Td.UNIMPLEMENTED:!("undefined"!=typeof DOMException&&e instanceof DOMException)||22===e.code||20===e.code||11===e.code}async function db(e){if(!e._offlineComponents)if(e._uninitializedComponentsProvider){xd("FirestoreClient","Using user provided OfflineComponentProvider");try{await lb(e,e._uninitializedComponentsProvider._offline)}catch(t){const n=t;if(!cb(n))throw n;kd("Error using user provided cache. Falling back to memory cache: "+n),await lb(e,new ab)}}else xd("FirestoreClient","Using default OfflineComponentProvider"),await lb(e,new ab);return e._offlineComponents}async function hb(e){return e._onlineComponents||(e._uninitializedComponentsProvider?(xd("FirestoreClient","Using user provided OnlineComponentProvider"),await ub(e,e._uninitializedComponentsProvider._online)):(xd("FirestoreClient","Using default OnlineComponentProvider"),await ub(e,new sb))),e._onlineComponents}function pb(e){return hb(e).then((e=>e.syncEngine))}async function fb(e){const t=await hb(e),n=t.eventManager;return n.onListen=Fy.bind(null,t.syncEngine),n.onUnlisten=zy.bind(null,t.syncEngine),n.onFirstRemoteStoreListen=Oy.bind(null,t.syncEngine),n.onLastRemoteStoreUnlisten=By.bind(null,t.syncEngine),n}function mb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new Ad;return e.asyncQueue.enqueueAndForget((async()=>function(e,t,n,r,a){const s=new ib({next:s=>{t.enqueueAndForget((()=>ky(e,i)));const o=s.docs.has(n);!o&&s.fromCache?a.reject(new Ed(Td.UNAVAILABLE,"Failed to get document because the client is offline.")):o&&s.fromCache&&r&&"server"===r.source?a.reject(new Ed(Td.UNAVAILABLE,'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')):a.resolve(s)},error:e=>a.reject(e)}),i=new Ey(Ap(n.path),s,{includeMetadataChanges:!0,_a:!0});return wy(e,i)}(await fb(e),e.asyncQueue,t,n,r))),r.promise}function gb(e){const t={};return void 0!==e.timeoutSeconds&&(t.timeoutSeconds=e.timeoutSeconds),t}const yb=new Map;function bb(e,t,n){if(!n)throw new Ed(Td.INVALID_ARGUMENT,`Function ${e}() cannot be called with an empty ${t}.`)}function vb(e){if(!Kd.isDocumentKey(e))throw new Ed(Td.INVALID_ARGUMENT,`Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`)}function xb(e){if(Kd.isDocumentKey(e))throw new Ed(Td.INVALID_ARGUMENT,`Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`)}function wb(e){if(void 0===e)return"undefined";if(null===e)return"null";if("string"==typeof e)return e.length>20&&(e=`${e.substring(0,20)}...`),JSON.stringify(e);if("number"==typeof e||"boolean"==typeof e)return""+e;if("object"==typeof e){if(e instanceof Array)return"an array";{const t=function(e){return e.constructor?e.constructor.name:null}(e);return t?`a custom ${t} object`:"an object"}}return"function"==typeof e?"a function":Id()}function kb(e,t){if("_delegate"in e&&(e=e._delegate),!(e instanceof t)){if(t.name===e.constructor.name)throw new Ed(Td.INVALID_ARGUMENT,"Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");{const n=wb(e);throw new Ed(Td.INVALID_ARGUMENT,`Expected type '${t.name}', but it was: ${n}`)}}return e}class Sb{constructor(e){var t,n;if(void 0===e.host){if(void 0!==e.ssl)throw new Ed(Td.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");this.host="firestore.googleapis.com",this.ssl=!0}else this.host=e.host,this.ssl=null===(t=e.ssl)||void 0===t||t;if(this.credentials=e.credentials,this.ignoreUndefinedProperties=!!e.ignoreUndefinedProperties,this.localCache=e.localCache,void 0===e.cacheSizeBytes)this.cacheSizeBytes=41943040;else{if(-1!==e.cacheSizeBytes&&e.cacheSizeBytes<1048576)throw new Ed(Td.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");this.cacheSizeBytes=e.cacheSizeBytes}(function(e,t,n,r){if(!0===t&&!0===r)throw new Ed(Td.INVALID_ARGUMENT,`${e} and ${n} cannot be used together.`)})("experimentalForceLongPolling",e.experimentalForceLongPolling,"experimentalAutoDetectLongPolling",e.experimentalAutoDetectLongPolling),this.experimentalForceLongPolling=!!e.experimentalForceLongPolling,this.experimentalForceLongPolling?this.experimentalAutoDetectLongPolling=!1:void 0===e.experimentalAutoDetectLongPolling?this.experimentalAutoDetectLongPolling=!0:this.experimentalAutoDetectLongPolling=!!e.experimentalAutoDetectLongPolling,this.experimentalLongPollingOptions=gb(null!==(n=e.experimentalLongPollingOptions)&&void 0!==n?n:{}),function(e){if(void 0!==e.timeoutSeconds){if(isNaN(e.timeoutSeconds))throw new Ed(Td.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (must not be NaN)`);if(e.timeoutSeconds<5)throw new Ed(Td.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (minimum allowed value is 5)`);if(e.timeoutSeconds>30)throw new Ed(Td.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (maximum allowed value is 30)`)}}(this.experimentalLongPollingOptions),this.useFetchStreams=!!e.useFetchStreams}isEqual(e){return this.host===e.host&&this.ssl===e.ssl&&this.credentials===e.credentials&&this.cacheSizeBytes===e.cacheSizeBytes&&this.experimentalForceLongPolling===e.experimentalForceLongPolling&&this.experimentalAutoDetectLongPolling===e.experimentalAutoDetectLongPolling&&function(e,t){return e.timeoutSeconds===t.timeoutSeconds}(this.experimentalLongPollingOptions,e.experimentalLongPollingOptions)&&this.ignoreUndefinedProperties===e.ignoreUndefinedProperties&&this.useFetchStreams===e.useFetchStreams}}class Ib{constructor(e,t,n,r){this._authCredentials=e,this._appCheckCredentials=t,this._databaseId=n,this._app=r,this.type="firestore-lite",this._persistenceKey="(lite)",this._settings=new Sb({}),this._settingsFrozen=!1}get app(){if(!this._app)throw new Ed(Td.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is not available");return this._app}get _initialized(){return this._settingsFrozen}get _terminated(){return void 0!==this._terminateTask}_setSettings(e){if(this._settingsFrozen)throw new Ed(Td.FAILED_PRECONDITION,"Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");this._settings=new Sb(e),void 0!==e.credentials&&(this._authCredentials=function(e){if(!e)return new $d;switch(e.type){case"firstParty":return new Fd(e.sessionIndex||"0",e.iamToken||null,e.authTokenFactory||null);case"provider":return e.client;default:throw new Ed(Td.INVALID_ARGUMENT,"makeAuthCredentialsProvider failed due to invalid credential type")}}(e.credentials))}_getSettings(){return this._settings}_freezeSettings(){return this._settingsFrozen=!0,this._settings}_delete(){return this._terminateTask||(this._terminateTask=this._terminate()),this._terminateTask}toJSON(){return{app:this._app,databaseId:this._databaseId,settings:this._settings}}_terminate(){return function(e){const t=yb.get(e);t&&(xd("ComponentProvider","Removing Datastore"),yb.delete(e),t.terminate())}(this),Promise.resolve()}}function Cb(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};var a;const s=(e=kb(e,Ib))._getSettings(),i=`${t}:${n}`;if("firestore.googleapis.com"!==s.host&&s.host!==i&&kd("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."),e._setSettings(Object.assign(Object.assign({},s),{host:i,ssl:!1})),r.mockUserToken){let t,n;if("string"==typeof r.mockUserToken)t=r.mockUserToken,n=gd.MOCK_USER;else{t=function(e,t){if(e.uid)throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');const n=t||"demo-project",r=e.iat||0,a=e.sub||e.user_id;if(!a)throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");const s=Object.assign({iss:`https://securetoken.google.com/${n}`,aud:n,iat:r,exp:r+3600,auth_time:r,sub:a,user_id:a,firebase:{sign_in_provider:"custom",identities:{}}},e);return[cu(JSON.stringify({alg:"none",type:"JWT"})),cu(JSON.stringify(s)),""].join(".")}(r.mockUserToken,null===(a=e._app)||void 0===a?void 0:a.options.projectId);const s=r.mockUserToken.sub||r.mockUserToken.user_id;if(!s)throw new Ed(Td.INVALID_ARGUMENT,"mockUserToken must contain 'sub' or 'user_id' field!");n=new gd(s)}e._authCredentials=new Rd(new _d(t,n))}}class Nb{constructor(e,t,n){this.converter=t,this._query=n,this.type="query",this.firestore=e}withConverter(e){return new Nb(this.firestore,e,this._query)}}class Tb{constructor(e,t,n){this.converter=t,this._key=n,this.type="document",this.firestore=e}get _path(){return this._key.path}get id(){return this._key.path.lastSegment()}get path(){return this._key.path.canonicalString()}get parent(){return new Eb(this.firestore,this.converter,this._key.path.popLast())}withConverter(e){return new Tb(this.firestore,e,this._key)}}class Eb extends Nb{constructor(e,t,n){super(e,t,Ap(n)),this._path=n,this.type="collection"}get id(){return this._query.path.lastSegment()}get path(){return this._query.path.canonicalString()}get parent(){const e=this._path.popLast();return e.isEmpty()?null:new Tb(this.firestore,null,new Kd(e))}withConverter(e){return new Eb(this.firestore,e,this._path)}}function Ab(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),a=2;a<n;a++)r[a-2]=arguments[a];if(e=Cu(e),bb("collection","path",t),e instanceof Ib){const n=Gd.fromString(t,...r);return xb(n),new Eb(e,null,n)}{if(!(e instanceof Tb||e instanceof Eb))throw new Ed(Td.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const n=e._path.child(Gd.fromString(t,...r));return xb(n),new Eb(e.firestore,null,n)}}function _b(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),a=2;a<n;a++)r[a-2]=arguments[a];if(e=Cu(e),1===arguments.length&&(t=zd.newId()),bb("doc","path",t),e instanceof Ib){const n=Gd.fromString(t,...r);return vb(n),new Tb(e,null,new Kd(n))}{if(!(e instanceof Tb||e instanceof Eb))throw new Ed(Td.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const n=e._path.child(Gd.fromString(t,...r));return vb(n),new Tb(e.firestore,e instanceof Eb?e.converter:null,new Kd(n))}}class $b{constructor(){this.au=Promise.resolve(),this.uu=[],this.cu=!1,this.lu=[],this.hu=null,this.Pu=!1,this.Iu=!1,this.Tu=[],this.t_=new $g(this,"async_queue_retry"),this.Eu=()=>{const e=Ag();e&&xd("AsyncQueue","Visibility state changed to "+e.visibilityState),this.t_.jo()};const e=Ag();e&&"function"==typeof e.addEventListener&&e.addEventListener("visibilitychange",this.Eu)}get isShuttingDown(){return this.cu}enqueueAndForget(e){this.enqueue(e)}enqueueAndForgetEvenWhileRestricted(e){this.du(),this.Au(e)}enterRestrictedMode(e){if(!this.cu){this.cu=!0,this.Iu=e||!1;const t=Ag();t&&"function"==typeof t.removeEventListener&&t.removeEventListener("visibilitychange",this.Eu)}}enqueue(e){if(this.du(),this.cu)return new Promise((()=>{}));const t=new Ad;return this.Au((()=>this.cu&&this.Iu?Promise.resolve():(e().then(t.resolve,t.reject),t.promise))).then((()=>t.promise))}enqueueRetryable(e){this.enqueueAndForget((()=>(this.uu.push(e),this.Ru())))}async Ru(){if(0!==this.uu.length){try{await this.uu[0](),this.uu.shift(),this.t_.reset()}catch(mD){if(!sh(mD))throw mD;xd("AsyncQueue","Operation failed with retryable error: "+mD)}this.uu.length>0&&this.t_.Go((()=>this.Ru()))}}Au(e){const t=this.au.then((()=>(this.Pu=!0,e().catch((e=>{this.hu=e,this.Pu=!1;const t=function(e){let t=e.message||"";return e.stack&&(t=e.stack.includes(e.message)?e.stack:e.message+"\n"+e.stack),t}(e);throw wd("INTERNAL UNHANDLED ERROR: ",t),e})).then((e=>(this.Pu=!1,e))))));return this.au=t,t}enqueueAfterDelay(e,t,n){this.du(),this.Tu.indexOf(e)>-1&&(t=0);const r=py.createAndSchedule(this,e,t,n,(e=>this.Vu(e)));return this.lu.push(r),r}du(){this.hu&&Id()}verifyOperationInProgress(){}async mu(){let e;do{e=this.au,await e}while(e!==this.au)}fu(e){for(const t of this.lu)if(t.timerId===e)return!0;return!1}gu(e){return this.mu().then((()=>{this.lu.sort(((e,t)=>e.targetTimeMs-t.targetTimeMs));for(const t of this.lu)if(t.skipDelay(),"all"!==e&&t.timerId===e)break;return this.mu()}))}pu(e){this.Tu.push(e)}Vu(e){const t=this.lu.indexOf(e);this.lu.splice(t,1)}}class Rb extends Ib{constructor(e,t,n,r){super(e,t,n,r),this.type="firestore",this._queue=new $b,this._persistenceKey=(null==r?void 0:r.name)||"[DEFAULT]"}_terminate(){return this._firestoreClient||Mb(this),this._firestoreClient.terminate()}}function Db(e){return e._firestoreClient||Mb(e),e._firestoreClient.verifyNotTerminated(),e._firestoreClient}function Mb(e){var t,n,r;const a=e._freezeSettings(),s=function(e,t,n,r){return new Rh(e,t,n,r.host,r.ssl,r.experimentalForceLongPolling,r.experimentalAutoDetectLongPolling,gb(r.experimentalLongPollingOptions),r.useFetchStreams)}(e._databaseId,(null===(t=e._app)||void 0===t?void 0:t.options.appId)||"",e._persistenceKey,a);e._firestoreClient=new ob(e._authCredentials,e._appCheckCredentials,e._queue,s),(null===(n=a.localCache)||void 0===n?void 0:n._offlineComponentProvider)&&(null===(r=a.localCache)||void 0===r?void 0:r._onlineComponentProvider)&&(e._firestoreClient._uninitializedComponentsProvider={_offlineKind:a.localCache.kind,_offline:a.localCache._offlineComponentProvider,_online:a.localCache._onlineComponentProvider})}class Fb{constructor(e){this._byteString=e}static fromBase64String(e){try{return new Fb(Ih.fromBase64String(e))}catch(e){throw new Ed(Td.INVALID_ARGUMENT,"Failed to construct data from Base64 string: "+e)}}static fromUint8Array(e){return new Fb(Ih.fromUint8Array(e))}toBase64(){return this._byteString.toBase64()}toUint8Array(){return this._byteString.toUint8Array()}toString(){return"Bytes(base64: "+this.toBase64()+")"}isEqual(e){return this._byteString.isEqual(e._byteString)}}class Ob{constructor(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];for(let r=0;r<t.length;++r)if(0===t[r].length)throw new Ed(Td.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). Field names must not be empty.");this._internalPath=new qd(t)}isEqual(e){return this._internalPath.isEqual(e._internalPath)}}class Pb{constructor(e){this._methodName=e}}class Lb{constructor(e,t){if(!isFinite(e)||e<-90||e>90)throw new Ed(Td.INVALID_ARGUMENT,"Latitude must be a number between -90 and 90, but was: "+e);if(!isFinite(t)||t<-180||t>180)throw new Ed(Td.INVALID_ARGUMENT,"Longitude must be a number between -180 and 180, but was: "+t);this._lat=e,this._long=t}get latitude(){return this._lat}get longitude(){return this._long}isEqual(e){return this._lat===e._lat&&this._long===e._long}toJSON(){return{latitude:this._lat,longitude:this._long}}_compareTo(e){return Bd(this._lat,e._lat)||Bd(this._long,e._long)}}class zb{constructor(e){this._values=(e||[]).map((e=>e))}toArray(){return this._values.map((e=>e))}isEqual(e){return function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(this._values,e._values)}}const Bb=/^__.*__$/;class Wb{constructor(e,t,n){this.data=e,this.fieldMask=t,this.fieldTransforms=n}toMutation(e,t){return null!==this.fieldMask?new Af(e,this.data,this.fieldMask,t,this.fieldTransforms):new Ef(e,this.data,t,this.fieldTransforms)}}function Vb(e){switch(e){case 0:case 2:case 1:return!0;case 3:case 4:return!1;default:throw Id()}}class Ub{constructor(e,t,n,r,a,s){this.settings=e,this.databaseId=t,this.serializer=n,this.ignoreUndefinedProperties=r,void 0===a&&this.yu(),this.fieldTransforms=a||[],this.fieldMask=s||[]}get path(){return this.settings.path}get wu(){return this.settings.wu}Su(e){return new Ub(Object.assign(Object.assign({},this.settings),e),this.databaseId,this.serializer,this.ignoreUndefinedProperties,this.fieldTransforms,this.fieldMask)}bu(e){var t;const n=null===(t=this.path)||void 0===t?void 0:t.child(e),r=this.Su({path:n,Du:!1});return r.vu(e),r}Cu(e){var t;const n=null===(t=this.path)||void 0===t?void 0:t.child(e),r=this.Su({path:n,Du:!1});return r.yu(),r}Fu(e){return this.Su({path:void 0,Du:!0})}Mu(e){return ev(e,this.settings.methodName,this.settings.xu||!1,this.path,this.settings.Ou)}contains(e){return void 0!==this.fieldMask.find((t=>e.isPrefixOf(t)))||void 0!==this.fieldTransforms.find((t=>e.isPrefixOf(t.field)))}yu(){if(this.path)for(let e=0;e<this.path.length;e++)this.vu(this.path.get(e))}vu(e){if(0===e.length)throw this.Mu("Document fields must not be empty");if(Vb(this.wu)&&Bb.test(e))throw this.Mu('Document fields cannot begin and end with "__"')}}class jb{constructor(e,t,n){this.databaseId=e,this.ignoreUndefinedProperties=t,this.serializer=n||_g(e)}Nu(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return new Ub({wu:e,methodName:t,Ou:n,path:qd.emptyPath(),Du:!1,xu:r},this.databaseId,this.serializer,this.ignoreUndefinedProperties)}}function Gb(e){const t=e._freezeSettings(),n=_g(e._databaseId);return new jb(e._databaseId,!!t.ignoreUndefinedProperties,n)}function Hb(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};const i=e.Nu(s.merge||s.mergeFields?2:0,t,n,a);Yb("Data must be an object, but it was:",i,r);const o=Kb(r,i);let l,u;if(s.merge)l=new kh(i.fieldMask),u=i.fieldTransforms;else if(s.mergeFields){const e=[];for(const r of s.mergeFields){const a=Qb(t,r,n);if(!i.contains(a))throw new Ed(Td.INVALID_ARGUMENT,`Field '${a}' is specified in your field mask but missing from your input data.`);tv(e,a)||e.push(a)}l=new kh(e),u=i.fieldTransforms.filter((e=>l.covers(e.field)))}else l=null,u=i.fieldTransforms;return new Wb(new Qh(o),l,u)}function qb(e,t){if(Xb(e=Cu(e)))return Yb("Unsupported field value:",t,e),Kb(e,t);if(e instanceof Pb)return function(e,t){if(!Vb(t.wu))throw t.Mu(`${e._methodName}() can only be used with update() and set()`);if(!t.path)throw t.Mu(`${e._methodName}() is not currently supported inside arrays`);const n=e._toFieldTransform(t);n&&t.fieldTransforms.push(n)}(e,t),null;if(void 0===e&&t.ignoreUndefinedProperties)return null;if(t.path&&t.fieldMask.push(t.path),e instanceof Array){if(t.settings.Du&&4!==t.wu)throw t.Mu("Nested arrays are not supported");return function(e,t){const n=[];let r=0;for(const a of e){let e=qb(a,t.Fu(r));null==e&&(e={nullValue:"NULL_VALUE"}),n.push(e),r++}return{arrayValue:{values:n}}}(e,t)}return function(e,t){if(null===(e=Cu(e)))return{nullValue:"NULL_VALUE"};if("number"==typeof e)return sf(t.serializer,e);if("boolean"==typeof e)return{booleanValue:e};if("string"==typeof e)return{stringValue:e};if(e instanceof Date){const n=Vd.fromDate(e);return{timestampValue:cm(t.serializer,n)}}if(e instanceof Vd){const n=new Vd(e.seconds,1e3*Math.floor(e.nanoseconds/1e3));return{timestampValue:cm(t.serializer,n)}}if(e instanceof Lb)return{geoPointValue:{latitude:e.latitude,longitude:e.longitude}};if(e instanceof Fb)return{bytesValue:dm(t.serializer,e._byteString)};if(e instanceof Tb){const n=t.databaseId,r=e.firestore._databaseId;if(!r.isEqual(n))throw t.Mu(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`);return{referenceValue:fm(e.firestore._databaseId||t.databaseId,e._key.path)}}if(e instanceof zb)return function(e,t){return{mapValue:{fields:{__type__:{stringValue:"__vector__"},value:{arrayValue:{values:e.toArray().map((e=>{if("number"!=typeof e)throw t.Mu("VectorValues must only contain numeric values.");return rf(t.serializer,e)}))}}}}}}(e,t);throw t.Mu(`Unsupported field value: ${wb(e)}`)}(e,t)}function Kb(e,t){const n={};return gh(e)?t.path&&t.path.length>0&&t.fieldMask.push(t.path):mh(e,((e,r)=>{const a=qb(r,t.bu(e));null!=a&&(n[e]=a)})),{mapValue:{fields:n}}}function Xb(e){return!("object"!=typeof e||null===e||e instanceof Array||e instanceof Date||e instanceof Vd||e instanceof Lb||e instanceof Fb||e instanceof Tb||e instanceof Pb||e instanceof zb)}function Yb(e,t,n){if(!Xb(n)||!function(e){return"object"==typeof e&&null!==e&&(Object.getPrototypeOf(e)===Object.prototype||null===Object.getPrototypeOf(e))}(n)){const r=wb(n);throw"an object"===r?t.Mu(e+" a custom object"):t.Mu(e+" "+r)}}function Qb(e,t,n){if((t=Cu(t))instanceof Ob)return t._internalPath;if("string"==typeof t)return Zb(e,t);throw ev("Field path arguments must be of type string or ",e,!1,void 0,n)}const Jb=new RegExp("[~\\*/\\[\\]]");function Zb(e,t,n){if(t.search(Jb)>=0)throw ev(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`,e,!1,void 0,n);try{return new Ob(...t.split("."))._internalPath}catch(Lge){throw ev(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,e,!1,void 0,n)}}function ev(e,t,n,r,a){const s=r&&!r.isEmpty(),i=void 0!==a;let o=`Function ${t}() called with invalid data`;n&&(o+=" (via `toFirestore()`)"),o+=". ";let l="";return(s||i)&&(l+=" (found",s&&(l+=` in field ${r}`),i&&(l+=` in document ${a}`),l+=")"),new Ed(Td.INVALID_ARGUMENT,o+e+l)}function tv(e,t){return e.some((e=>e.isEqual(t)))}class nv{constructor(e,t,n,r,a){this._firestore=e,this._userDataWriter=t,this._key=n,this._document=r,this._converter=a}get id(){return this._key.path.lastSegment()}get ref(){return new Tb(this._firestore,this._converter,this._key)}exists(){return null!==this._document}data(){if(this._document){if(this._converter){const e=new rv(this._firestore,this._userDataWriter,this._key,this._document,null);return this._converter.fromFirestore(e)}return this._userDataWriter.convertValue(this._document.data.value)}}get(e){if(this._document){const t=this._document.data.field(av("DocumentSnapshot.get",e));if(null!==t)return this._userDataWriter.convertValue(t)}}}class rv extends nv{data(){return super.data()}}function av(e,t){return"string"==typeof t?Zb(e,t):t instanceof Ob?t._internalPath:t._delegate._internalPath}class sv{convertValue(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"none";switch(Fh(e)){case 0:return null;case 1:return e.booleanValue;case 2:return Th(e.integerValue||e.doubleValue);case 3:return this.convertTimestamp(e.timestampValue);case 4:return this.convertServerTimestamp(e,t);case 5:return e.stringValue;case 6:return this.convertBytes(Eh(e.bytesValue));case 7:return this.convertReference(e.referenceValue);case 8:return this.convertGeoPoint(e.geoPointValue);case 9:return this.convertArray(e.arrayValue,t);case 11:return this.convertObject(e.mapValue,t);case 10:return this.convertVectorValue(e.mapValue);default:throw Id()}}convertObject(e,t){return this.convertObjectMap(e.fields,t)}convertObjectMap(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"none";const n={};return mh(e,((e,r)=>{n[e]=this.convertValue(r,t)})),n}convertVectorValue(e){var t,n,r;const a=null===(r=null===(n=null===(t=e.fields)||void 0===t?void 0:t.value.arrayValue)||void 0===n?void 0:n.values)||void 0===r?void 0:r.map((e=>Th(e.doubleValue)));return new zb(a)}convertGeoPoint(e){return new Lb(Th(e.latitude),Th(e.longitude))}convertArray(e,t){return(e.values||[]).map((e=>this.convertValue(e,t)))}convertServerTimestamp(e,t){switch(t){case"previous":const n=_h(e);return null==n?null:this.convertValue(n,t);case"estimate":return this.convertTimestamp($h(e));default:return null}}convertTimestamp(e){const t=Nh(e);return new Vd(t.seconds,t.nanos)}convertDocumentKey(e,t){const n=Gd.fromString(e);Cd(Om(n));const r=new Dh(n.get(1),n.get(3)),a=new Kd(n.popFirst(5));return r.isEqual(t)||wd(`Document ${a} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`),a}}function iv(e,t,n){let r;return r=e?n&&(n.merge||n.mergeFields)?e.toFirestore(t,n):e.toFirestore(t):t,r}class ov{constructor(e,t){this.hasPendingWrites=e,this.fromCache=t}isEqual(e){return this.hasPendingWrites===e.hasPendingWrites&&this.fromCache===e.fromCache}}class lv extends nv{constructor(e,t,n,r,a,s){super(e,t,n,r,s),this._firestore=e,this._firestoreImpl=e,this.metadata=a}exists(){return super.exists()}data(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._document){if(this._converter){const t=new uv(this._firestore,this._userDataWriter,this._key,this._document,this.metadata,null);return this._converter.fromFirestore(t,e)}return this._userDataWriter.convertValue(this._document.data.value,e.serverTimestamps)}}get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(this._document){const n=this._document.data.field(av("DocumentSnapshot.get",e));if(null!==n)return this._userDataWriter.convertValue(n,t.serverTimestamps)}}}class uv extends lv{data(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return super.data(e)}}class cv extends sv{constructor(e){super(),this.firestore=e}convertBytes(e){return new Fb(e)}convertReference(e){const t=this.convertDocumentKey(e,this.firestore._databaseId);return new Tb(this.firestore,null,t)}}function dv(e,t){const n=kb(e.firestore,Rb),r=_b(e),a=iv(e.converter,t);return hv(n,[Hb(Gb(e.firestore),"addDoc",r._key,a,null!==e.converter,{}).toMutation(r._key,xf.exists(!1))]).then((()=>r))}function hv(e,t){return function(e,t){const n=new Ad;return e.asyncQueue.enqueueAndForget((async()=>async function(e,t,n){const r=rb(e);try{const e=await function(e,t){const n=Nd(e),r=Vd.now(),a=t.reduce(((e,t)=>e.add(t.key)),ef());let s,i;return n.persistence.runTransaction("Locally write mutations","readwrite",(e=>{let o=Gp(),l=ef();return n.cs.getEntries(e,a).next((e=>{o=e,o.forEach(((e,t)=>{t.isValidDocument()||(l=l.add(e))}))})).next((()=>n.localDocuments.getOverlayedDocuments(e,o))).next((a=>{s=a;const i=[];for(const e of t){const t=Nf(e,s.get(e.key).overlayedDocument);null!=t&&i.push(new Af(e.key,t,Jh(t.value.mapValue),xf.exists(!0)))}return n.mutationQueue.addMutationBatch(e,r,i,t)})).next((t=>{i=t;const r=t.applyToLocalDocumentSet(s,l);return n.documentOverlayCache.saveOverlays(e,t.batchId,r)}))})).then((()=>({batchId:i.batchId,changes:Kp(s)})))}(r.localStore,t);r.sharedClientState.addPendingMutation(e.batchId),function(e,t,n){let r=e.Ba[e.currentUser.toKey()];r||(r=new yh(Bd)),r=r.insert(t,n),e.Ba[e.currentUser.toKey()]=r}(r,e.batchId,n),await Zy(r,e.changes),await ey(r.remoteStore)}catch(e){const t=fy(e,"Failed to persist write");n.reject(t)}}(await pb(e),t,n))),n.promise}(Db(e),t)}function pv(e,t,n){const r=n.docs.get(t._key),a=new cv(e);return new lv(e,a,t._key,r,new ov(n.hasPendingWrites,n.fromCache),t.converter)}new WeakMap;!function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];!function(e){yd=e}("10.13.1"),Oc(new Nu("firestore",((e,n)=>{let{instanceIdentifier:r,options:a}=n;const s=e.getProvider("app").getImmediate(),i=new Rb(new Dd(e.getProvider("auth-internal")),new Pd(e.getProvider("app-check-internal")),function(e,t){if(!Object.prototype.hasOwnProperty.apply(e.options,["projectId"]))throw new Ed(Td.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');return new Dh(e.options.projectId,t)}(s,r),s);return a=Object.assign({useFetchStreams:t},a),i._setSettings(a),i}),"PUBLIC").setMultipleInstances(!0)),Wc(md,"4.7.1",e),Wc(md,"4.7.1","esm2017")}();Wc("firebase","10.13.1","app");const fv={NODE_ENV:"production",PUBLIC_URL:"/auth-tfjs",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0,REACT_APP_API_KEY:"'AIzaSyCMm9VBymR43tOkkv4wQ6szA2yGfH3j3RE';",REACT_APP_APP_ID:"1:1021363670094:web:252b1088a0266e0573c71f",REACT_APP_ENV_SENDER_ID:"1021363670094",REACT_APP_TOKEN:"d891e715-d5ab-49ee-8c4c-d14c25d7fb7a"},mv=function(e,t){const n="object"==typeof e?e:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:_c;const t=Rc.get(e);if(!t&&e===_c&&mu())return Bc();if(!t)throw Lc.create("no-app",{appName:e});return t}(),r="string"==typeof e?e:t||"(default)",a=Pc(n,"firestore").getImmediate({identifier:r});if(!a._initialized){const e=fu("firestore");e&&Cb(a,...e)}return a}(Bc({apiKey:fv.REACT_APP_API_KEY,authDomain:"auth-tfjs.firebaseapp.com",projectId:"auth-tfjs",storageBucket:"auth-tfjs.appspot.com",messagingSenderId:fv.REACT_APP_SENDER_ID,appId:fv.REACT_APP_APP_ID})),gv=async e=>{const t=_b(mv,"users",e);return await function(e){e=kb(e,Tb);const t=kb(e.firestore,Rb);return mb(Db(t),e._key).then((n=>pv(t,e,n)))}(t)},yv=async e=>{const t=_b(mv,"users",e);var n;await(n=t,hv(kb(n.firestore,Rb),[new Df(n._key,xf.none())]))},bv=()=>{const e=U((e=>e.user)),t=ee(),n=vn(),[r,a]=(0,T.useState)(!1),[s,i]=(0,T.useState)(""),[o,l]=(0,T.useState)(!1),u=()=>{a(!1),i("")},c=()=>{l(!1),n("/")};return(0,hr.jsxs)(Bl,{maxWidth:"sm",children:[(0,hr.jsx)(Br,{sx:{mt:8,mb:4},children:(0,hr.jsxs)(Gr,{elevation:3,sx:{p:4,textAlign:"center"},children:[e.name?(0,hr.jsxs)(hr.Fragment,{children:[(0,hr.jsx)(su.A,{color:"success",sx:{fontSize:60,mb:2}}),(0,hr.jsxs)(Ir,{variant:"h5",gutterBottom:!0,children:["Welcome, ",e.name,"!"]}),(0,hr.jsx)(Ir,{variant:"body1",sx:{mb:3},children:"You are successfully logged in."}),(0,hr.jsxs)(Ir,{variant:"body2",sx:{mb:3},children:["Email: ",e.email]}),(0,hr.jsxs)(Ir,{variant:"body2",sx:{mb:3},children:["Date of Birth: ",(e=>{const t=new Date(e);return`${String(t.getDate()).padStart(2,"0")}/${String(t.getMonth()+1).padStart(2,"0")}/${t.getFullYear()}`})(e.dateOfBirth)," "]}),(0,hr.jsx)(hl,{variant:"contained",color:"error",onClick:()=>{a(!0)},children:"Delete Account"})]}):(0,hr.jsxs)(hr.Fragment,{children:[(0,hr.jsx)(iu.A,{color:"error",sx:{fontSize:60,mb:2}}),(0,hr.jsx)(Ir,{variant:"h5",gutterBottom:!0,children:"Authentication Error"}),(0,hr.jsx)(Ir,{variant:"body1",sx:{mb:3},children:"The user ID doesn't match our records. Please try again."})]}),!o&&(0,hr.jsx)(Br,{sx:{mt:2},children:(0,hr.jsx)(hl,{variant:"contained",color:"primary",onClick:()=>n("/login"),children:"Login Again"})})]})}),(0,hr.jsxs)(Kl,{open:r,onClose:u,children:[(0,hr.jsx)(Jl,{children:"Delete Account"}),(0,hr.jsxs)(tu,{children:[(0,hr.jsx)(Ir,{children:"Please type your email to confirm account deletion:"}),(0,hr.jsx)(Mo,{autoFocus:!0,margin:"dense",label:"Email",type:"email",fullWidth:!0,variant:"outlined",value:s,onChange:e=>i(e.target.value)})]}),(0,hr.jsxs)(au,{children:[(0,hr.jsx)(hl,{onClick:u,color:"primary",children:"Cancel"}),(0,hr.jsx)(hl,{onClick:async()=>{if(s===e.email)try{await yv(e.userId),t(wt()),l(!0)}catch(n){console.error("Error deleting user data: ",n)}u()},color:"error",children:"Delete"})]})]}),(0,hr.jsxs)(Kl,{open:o,onClose:c,children:[(0,hr.jsx)(Jl,{children:"Account Deleted"}),(0,hr.jsx)(tu,{children:(0,hr.jsx)(Ir,{children:"Your account has been deleted successfully. Please note that your biometric is also been deleted."})}),(0,hr.jsx)(au,{children:(0,hr.jsx)(hl,{onClick:c,color:"primary",children:"OK"})})]})]})};function vv(e){return(0,yr.Ay)("MuiCard",e)}(0,gr.A)("MuiCard",["root"]);const xv=(0,Gn.Ay)(Gr,{name:"MuiCard",slot:"Root",overridesResolver:(e,t)=>t.root})({overflow:"hidden"}),wv=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiCard"}),{className:r,raised:a=!1,...s}=n,i={...n,raised:a},o=(e=>{const{classes:t}=e;return(0,Vn.A)({root:["root"]},vv,t)})(i);return(0,hr.jsx)(xv,{className:(0,Bn.A)(o.root,r),elevation:a?8:void 0,ref:t,ownerState:i,...s})}));function kv(e){return(0,yr.Ay)("MuiCardContent",e)}(0,gr.A)("MuiCardContent",["root"]);const Sv=(0,Gn.Ay)("div",{name:"MuiCardContent",slot:"Root",overridesResolver:(e,t)=>t.root})({padding:16,"&:last-child":{paddingBottom:24}}),Iv=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiCardContent"}),{className:r,component:a="div",...s}=n,i={...n,component:a},o=(e=>{const{classes:t}=e;return(0,Vn.A)({root:["root"]},kv,t)})(i);return(0,hr.jsx)(Sv,{as:a,className:(0,Bn.A)(o.root,r),ownerState:i,ref:t,...s})})),Cv=["localeText"],Nv=T.createContext(null);const Tv=function(e){const{localeText:t}=e,n=zs(e,Cv),{utils:r,localeText:a}=T.useContext(Nv)??{utils:void 0,localeText:void 0},s=So({props:n,name:"MuiLocalizationProvider"}),{children:i,dateAdapter:o,dateFormats:l,dateLibInstance:u,adapterLocale:c,localeText:d}=s,h=T.useMemo((()=>(0,Po.A)({},d,a,t)),[d,a,t]),p=T.useMemo((()=>{if(!o)return r||null;const e=new o({locale:c,formats:l,instance:u});if(!e.isMUIAdapter)throw new Error(["MUI X: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`","For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`","More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join("\n"));return e}),[o,c,l,u,r]),f=T.useMemo((()=>p?{minDate:p.date("1900-01-01T00:00:00.000"),maxDate:p.date("2099-12-31T00:00:00.000")}:null),[p]),m=T.useMemo((()=>({utils:p,defaultDates:f,localeText:h})),[f,p,h]);return(0,hr.jsx)(Nv.Provider,{value:m,children:i})};function Ev(e,t,n,r,a){const[s,i]=T.useState((()=>a&&n?n(e).matches:r?r(e).matches:t));return(0,Yr.A)((()=>{if(!n)return;const t=n(e),r=()=>{i(t.matches)};return r(),t.addEventListener("change",r),()=>{t.removeEventListener("change",r)}}),[e,n]),s}const Av=E.useSyncExternalStore;function _v(e,t,n,r,a){const s=T.useCallback((()=>t),[t]),i=T.useMemo((()=>{if(a&&n)return()=>n(e).matches;if(null!==r){const{matches:t}=r(e);return()=>t}return s}),[s,e,r,a,n]),[o,l]=T.useMemo((()=>{if(null===n)return[s,()=>()=>{}];const t=n(e);return[()=>t.matches,e=>(t.addEventListener("change",e),()=>{t.removeEventListener("change",e)})]}),[s,n,e]);return Av(l,o,i)}function $v(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Kn(),r="undefined"!==typeof window&&"undefined"!==typeof window.matchMedia,{defaultMatches:a=!1,matchMedia:s=(r?window.matchMedia:null),ssrMatchMedia:i=null,noSsr:o=!1}=wo({name:"MuiUseMediaQuery",props:t,theme:n});let l="function"===typeof e?e(n):e;l=l.replace(/^@media( ?)/m,"");return(void 0!==Av?_v:Ev)(l,a,s,i,o)}var Rv=n(5173),Dv=n.n(Rv);const Mv=function(e,t,n){return"function"===typeof e?e(t,n):e},Fv=Dv().oneOfType([Dv().func,Dv().object]),Ov=(e,t)=>e.length===t.length&&t.every((t=>e.includes(t))),Pv=(e,t,n)=>{let r=t;return r=e.setHours(r,e.getHours(n)),r=e.setMinutes(r,e.getMinutes(n)),r=e.setSeconds(r,e.getSeconds(n)),r=e.setMilliseconds(r,e.getMilliseconds(n)),r},Lv=e=>{let{date:t,disableFuture:n,disablePast:r,maxDate:a,minDate:s,isDateDisabled:i,utils:o,timezone:l}=e;const u=Pv(o,o.date(void 0,l),t);r&&o.isBefore(s,u)&&(s=u),n&&o.isAfter(a,u)&&(a=u);let c=t,d=t;for(o.isBefore(t,s)&&(c=s,d=null),o.isAfter(t,a)&&(d&&(d=a),c=null);c||d;){if(c&&o.isAfter(c,a)&&(c=null),d&&o.isBefore(d,s)&&(d=null),c){if(!i(c))return c;c=o.addDays(c,1)}if(d){if(!i(d))return d;d=o.addDays(d,-1)}}return null},zv=(e,t,n)=>null!=t&&e.isValid(t)?t:n,Bv=(e,t)=>{const n=[e.startOfYear(t)];for(;n.length<12;){const t=n[n.length-1];n.push(e.addMonths(t,1))}return n},Wv=(e,t,n)=>"date"===n?e.startOfDay(e.date(void 0,t)):e.date(void 0,t),Vv=["year","month","day"],Uv=e=>Vv.includes(e),jv=(e,t,n)=>{let{format:r,views:a}=t;if(null!=r)return r;const s=e.formats;return Ov(a,["year"])?s.year:Ov(a,["month"])?s.month:Ov(a,["day"])?s.dayOfMonth:Ov(a,["month","year"])?`${s.month} ${s.year}`:Ov(a,["day","month"])?`${s.month} ${s.dayOfMonth}`:n?/en/.test(e.getCurrentLocaleCode())?s.normalDateWithWeekday:s.normalDate:s.keyboardDate},Gv=(e,t)=>{const n=e.startOfWeek(t);return[0,1,2,3,4,5,6].map((t=>e.addDays(n,t)))},Hv=["hours","minutes","seconds"],qv=(e,t)=>3600*t.getHours(e)+60*t.getMinutes(e)+t.getSeconds(e),Kv={year:1,month:2,day:3,hours:4,minutes:5,seconds:6,milliseconds:7},Xv=(e,t,n)=>{if(t===Kv.year)return e.startOfYear(n);if(t===Kv.month)return e.startOfMonth(n);if(t===Kv.day)return e.startOfDay(n);let r=n;return t<Kv.minutes&&(r=e.setMinutes(r,0)),t<Kv.seconds&&(r=e.setSeconds(r,0)),t<Kv.milliseconds&&(r=e.setMilliseconds(r,0)),r},Yv=e=>{let{props:t,utils:n,granularity:r,timezone:a,getTodayDate:s}=e,i=s?s():Xv(n,r,Wv(n,a));null!=t.minDate&&n.isAfterDay(t.minDate,i)&&(i=Xv(n,r,t.minDate)),null!=t.maxDate&&n.isBeforeDay(t.maxDate,i)&&(i=Xv(n,r,t.maxDate));const o=((e,t)=>(n,r)=>e?t.isAfter(n,r):qv(n,t)>qv(r,t))(t.disableIgnoringDatePartForTimeValidation??!1,n);return null!=t.minTime&&o(t.minTime,i)&&(i=Xv(n,r,t.disableIgnoringDatePartForTimeValidation?t.minTime:Pv(n,i,t.minTime))),null!=t.maxTime&&o(i,t.maxTime)&&(i=Xv(n,r,t.disableIgnoringDatePartForTimeValidation?t.maxTime:Pv(n,i,t.maxTime))),i},Qv=(e,t)=>{const n=e.formatTokenMap[t];if(null==n)throw new Error([`MUI X: The token "${t}" is not supported by the Date and Time Pickers.`,"Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));return"string"===typeof n?{type:n,contentType:"meridiem"===n?"letter":"digit",maxLength:void 0}:{type:n.sectionType,contentType:n.contentType,maxLength:n.maxLength}},Jv=(e,t,n)=>{const r=[],a=e.date(void 0,t),s=e.startOfWeek(a),i=e.endOfWeek(a);let o=s;for(;e.isBefore(o,i);)r.push(o),o=e.addDays(o,1);return r.map((t=>e.formatByString(t,n)))},Zv=(e,t,n,r)=>{switch(n){case"month":return Bv(e,e.date(void 0,t)).map((t=>e.formatByString(t,r)));case"weekDay":return Jv(e,t,r);case"meridiem":{const n=e.date(void 0,t);return[e.startOfDay(n),e.endOfDay(n)].map((t=>e.formatByString(t,r)))}default:return[]}},ex=["0","1","2","3","4","5","6","7","8","9"],tx=(e,t)=>{if("0"===t[0])return e;const n=[];let r="";for(let a=0;a<e.length;a+=1){r+=e[a];const s=t.indexOf(r);s>-1&&(n.push(s.toString()),r="")}return n.join("")},nx=(e,t)=>"0"===t[0]?e:e.split("").map((e=>t[Number(e)])).join(""),rx=(e,t)=>{const n=tx(e,t);return" "!==n&&!Number.isNaN(Number(n))},ax=(e,t)=>{let n=e;for(n=Number(n).toString();n.length<t;)n=`0${n}`;return n},sx=(e,t,n,r,a)=>{if("day"===a.type&&"digit-with-letter"===a.contentType){const r=e.setDate(n.longestMonth,t);return e.formatByString(r,a.format)}let s=t.toString();return a.hasLeadingZerosInInput&&(s=ax(s,a.maxLength)),nx(s,r)},ix=(e,t,n,r,a,s,i,o)=>{const l=(e=>{switch(e){case"ArrowUp":return 1;case"ArrowDown":return-1;case"PageUp":return 5;case"PageDown":return-5;default:return 0}})(r),u="Home"===r,c="End"===r,d=""===n.value||u||c;return"digit"===n.contentType||"digit-with-letter"===n.contentType?(()=>{const r=a[n.type]({currentDate:i,format:n.format,contentType:n.contentType}),h=t=>sx(e,t,r,s,n),p="minutes"===n.type&&o?.minutesStep?o.minutesStep:1;let f=parseInt(tx(n.value,s),10)+l*p;if(d){if("year"===n.type&&!c&&!u)return e.formatByString(e.date(void 0,t),n.format);f=l>0||u?r.minimum:r.maximum}return f%p!==0&&((l<0||u)&&(f+=p-(p+f)%p),(l>0||c)&&(f-=f%p)),f>r.maximum?h(r.minimum+(f-r.maximum-1)%(r.maximum-r.minimum+1)):f<r.minimum?h(r.maximum-(r.minimum-f-1)%(r.maximum-r.minimum+1)):h(f)})():(()=>{const r=Zv(e,t,n.type,n.format);if(0===r.length)return n.value;if(d)return l>0||u?r[0]:r[r.length-1];const a=r.indexOf(n.value);return r[((a+l)%r.length+r.length)%r.length]})()},ox=(e,t,n)=>{let r=e.value||e.placeholder;const a="non-input"===t?e.hasLeadingZerosInFormat:e.hasLeadingZerosInInput;"non-input"===t&&e.hasLeadingZerosInInput&&!e.hasLeadingZerosInFormat&&(r=Number(tx(r,n)).toString());return["input-rtl","input-ltr"].includes(t)&&"digit"===e.contentType&&!a&&1===r.length&&(r=`${r}\u200e`),"input-rtl"===t&&(r=`\u2068${r}\u2069`),r},lx=(e,t,n,r)=>e.formatByString(e.parse(t,n),r),ux=(e,t,n)=>4===e.formatByString(e.date(void 0,t),n).length,cx=(e,t,n,r,a)=>{if("digit"!==n)return!1;const s=e.date(void 0,t);switch(r){case"year":if(ux(e,t,a)){return"0001"===e.formatByString(e.setYear(s,1),a)}return"01"===e.formatByString(e.setYear(s,2001),a);case"month":return e.formatByString(e.startOfYear(s),a).length>1;case"day":return e.formatByString(e.startOfMonth(s),a).length>1;case"weekDay":return e.formatByString(e.startOfWeek(s),a).length>1;case"hours":return e.formatByString(e.setHours(s,1),a).length>1;case"minutes":return e.formatByString(e.setMinutes(s,1),a).length>1;case"seconds":return e.formatByString(e.setSeconds(s,1),a).length>1;default:throw new Error("Invalid section type")}};const dx=(e,t)=>{0},hx={year:1,month:2,day:3,weekDay:4,hours:5,minutes:6,seconds:7,meridiem:8,empty:9},px=(e,t,n,r,a,s)=>[...r].sort(((e,t)=>hx[e.type]-hx[t.type])).reduce(((r,a)=>!s||a.modified?((e,t,n,r,a)=>{switch(n.type){case"year":return e.setYear(a,e.getYear(r));case"month":return e.setMonth(a,e.getMonth(r));case"weekDay":{const a=Jv(e,t,n.format),s=e.formatByString(r,n.format),i=a.indexOf(s),o=a.indexOf(n.value)-i;return e.addDays(r,o)}case"day":return e.setDate(a,e.getDate(r));case"meridiem":{const t=e.getHours(r)<12,n=e.getHours(a);return t&&n>=12?e.addHours(a,-12):!t&&n<12?e.addHours(a,12):a}case"hours":return e.setHours(a,e.getHours(r));case"minutes":return e.setMinutes(a,e.getMinutes(r));case"seconds":return e.setSeconds(a,e.getSeconds(r));default:return a}})(e,t,a,n,r):r),a),fx=(e,t)=>null==e?null:"all"===e?"all":"string"===typeof e?t.findIndex((t=>t.type===e)):e,mx=(e,t)=>{if(e.value)switch(e.type){case"month":{if("digit"===e.contentType)return t.format(t.setMonth(t.date(),Number(e.value)-1),"month");const n=t.parse(e.value,e.format);return n?t.format(n,"month"):void 0}case"day":return"digit"===e.contentType?t.format(t.setDate(t.startOfYear(t.date()),Number(e.value)),"dayOfMonthFull"):e.value;default:return}},gx=(e,t)=>{if(e.value)switch(e.type){case"weekDay":if("letter"===e.contentType)return;return Number(e.value);case"meridiem":{const n=t.parse(`01:00 ${e.value}`,`${t.formats.hours12h}:${t.formats.minutes} ${e.format}`);return n?t.getHours(n)>=12?1:0:void 0}case"day":return"digit-with-letter"===e.contentType?parseInt(e.value,10):Number(e.value);case"month":{if("digit"===e.contentType)return Number(e.value);const n=t.parse(e.value,e.format);return n?t.getMonth(n)+1:void 0}default:return"letter"!==e.contentType?Number(e.value):void 0}},yx=["value","referenceDate"],bx={emptyValue:null,getTodayValue:Wv,getInitialReferenceValue:e=>{let{value:t,referenceDate:n}=e,r=zs(e,yx);return null!=t&&r.utils.isValid(t)?t:null!=n?n:Yv(r)},cleanValue:(e,t)=>null!=t&&e.isValid(t)?t:null,areValuesEqual:(e,t,n)=>!e.isValid(t)&&null!=t&&!e.isValid(n)&&null!=n||e.isEqual(t,n),isSameError:(e,t)=>e===t,hasError:e=>null!=e,defaultErrorState:null,getTimezone:(e,t)=>null!=t&&e.isValid(t)?e.getTimezone(t):null,setTimezone:(e,t,n)=>null==n?null:e.setTimezone(n,t)},vx={updateReferenceValue:(e,t,n)=>null!=t&&e.isValid(t)?t:n,getSectionsFromValue:(e,t,n,r)=>!e.isValid(t)&&!!n?n:r(t),getV7HiddenInputValueFromSections:e=>e.map((e=>`${e.startSeparator}${e.value||e.placeholder}${e.endSeparator}`)).join(""),getV6InputValueFromSections:(e,t,n)=>{const r=e.map((e=>{const r=ox(e,n?"input-rtl":"input-ltr",t);return`${e.startSeparator}${r}${e.endSeparator}`})).join("");return n?`\u2066${r}\u2069`:r},getActiveDateManager:(e,t)=>({date:t.value,referenceDate:t.referenceValue,getSections:e=>e,getNewValuesFromNewActiveDate:n=>({value:n,referenceValue:null!=n&&e.isValid(n)?n:t.referenceValue})}),parseValueStr:(e,t,n)=>n(e.trim(),t)},xx={previousMonth:"Previous month",nextMonth:"Next month",openPreviousView:"Open previous view",openNextView:"Open next view",calendarViewSwitchingButtonAriaLabel:e=>"year"===e?"year view is open, switch to calendar view":"calendar view is open, switch to year view",start:"Start",end:"End",startDate:"Start date",startTime:"Start time",endDate:"End date",endTime:"End time",cancelButtonLabel:"Cancel",clearButtonLabel:"Clear",okButtonLabel:"OK",todayButtonLabel:"Today",datePickerToolbarTitle:"Select date",dateTimePickerToolbarTitle:"Select date & time",timePickerToolbarTitle:"Select time",dateRangePickerToolbarTitle:"Select date range",clockLabelText:(e,t,n)=>`Select ${e}. ${null===t?"No time selected":`Selected time is ${n.format(t,"fullTime")}`}`,hoursClockNumberText:e=>`${e} hours`,minutesClockNumberText:e=>`${e} minutes`,secondsClockNumberText:e=>`${e} seconds`,selectViewText:e=>`Select ${e}`,calendarWeekNumberHeaderLabel:"Week number",calendarWeekNumberHeaderText:"#",calendarWeekNumberAriaLabelText:e=>`Week ${e}`,calendarWeekNumberText:e=>`${e}`,openDatePickerDialogue:(e,t)=>null!==e&&t.isValid(e)?`Choose date, selected date is ${t.format(e,"fullDate")}`:"Choose date",openTimePickerDialogue:(e,t)=>null!==e&&t.isValid(e)?`Choose time, selected time is ${t.format(e,"fullTime")}`:"Choose time",fieldClearLabel:"Clear value",timeTableLabel:"pick time",dateTableLabel:"pick date",fieldYearPlaceholder:e=>"Y".repeat(e.digitAmount),fieldMonthPlaceholder:e=>"letter"===e.contentType?"MMMM":"MM",fieldDayPlaceholder:()=>"DD",fieldWeekDayPlaceholder:e=>"letter"===e.contentType?"EEEE":"EE",fieldHoursPlaceholder:()=>"hh",fieldMinutesPlaceholder:()=>"mm",fieldSecondsPlaceholder:()=>"ss",fieldMeridiemPlaceholder:()=>"aa",year:"Year",month:"Month",day:"Day",weekDay:"Week day",hours:"Hours",minutes:"Minutes",seconds:"Seconds",meridiem:"Meridiem",empty:"Empty"},wx=xx;kx=xx,(0,Po.A)({},kx);var kx;const Sx=()=>{const e=T.useContext(Nv);if(null===e)throw new Error(["MUI X: Can not find the date and time pickers localization context.","It looks like you forgot to wrap your component in LocalizationProvider.","This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join("\n"));if(null===e.utils)throw new Error(["MUI X: Can not find the date and time pickers adapter from its localization context.","It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join("\n"));const t=T.useMemo((()=>(0,Po.A)({},wx,e.localeText)),[e.localeText]);return T.useMemo((()=>(0,Po.A)({},e,{localeText:t})),[e,t])},Ix=()=>Sx().utils,Cx=()=>Sx().defaultDates,Nx=e=>{const t=Ix(),n=T.useRef();return void 0===n.current&&(n.current=t.date(void 0,e)),n.current};function Tx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;const r={};return Object.keys(e).forEach((a=>{r[a]=e[a].reduce(((e,r)=>{if(r){const a=t(r);""!==a&&e.push(a),n&&n[r]&&e.push(n[r])}return e}),[]).join(" ")})),r}const Ex=e=>e,Ax=(()=>{let e=Ex;return{configure(t){e=t},generate:t=>e(t),reset(){e=Ex}}})(),_x=Ax,$x={active:"active",checked:"checked",completed:"completed",disabled:"disabled",error:"error",expanded:"expanded",focused:"focused",focusVisible:"focusVisible",open:"open",readOnly:"readOnly",required:"required",selected:"selected"};function Rx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const r=$x[t];return r?`${n}-${r}`:`${_x.generate(e)}-${t}`}function Dx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const r={};return t.forEach((t=>{r[t]=Rx(e,t,n)})),r}function Mx(e){return Rx("MuiPickersToolbar",e)}Dx("MuiPickersToolbar",["root","content"]);const Fx=["children","className","toolbarTitle","hidden","titleId","isLandscape","classes","landscapeDirection"],Ox=(0,Gn.Ay)("div",{name:"MuiPickersToolbar",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;return{display:"flex",flexDirection:"column",alignItems:"flex-start",justifyContent:"space-between",padding:t.spacing(2,3),variants:[{props:{isLandscape:!0},style:{height:"auto",maxWidth:160,padding:16,justifyContent:"flex-start",flexWrap:"wrap"}}]}})),Px=(0,Gn.Ay)("div",{name:"MuiPickersToolbar",slot:"Content",overridesResolver:(e,t)=>t.content})({display:"flex",flexWrap:"wrap",width:"100%",flex:1,justifyContent:"space-between",alignItems:"center",flexDirection:"row",variants:[{props:{isLandscape:!0},style:{justifyContent:"flex-start",alignItems:"flex-start",flexDirection:"column"}},{props:{isLandscape:!0,landscapeDirection:"row"},style:{flexDirection:"row"}}]}),Lx=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiPickersToolbar"}),{children:r,className:a,toolbarTitle:s,hidden:i,titleId:o}=n,l=zs(n,Fx),u=n,c=(e=>{const{classes:t,isLandscape:n}=e;return Tx({root:["root"],content:["content"],penIconButton:["penIconButton",n&&"penIconButtonLandscape"]},Mx,t)})(u);return i?null:(0,hr.jsxs)(Ox,(0,Po.A)({ref:t,className:(0,Bn.A)(c.root,a),ownerState:u},l,{children:[(0,hr.jsx)(Ir,{color:"text.secondary",variant:"overline",id:o,children:s}),(0,hr.jsx)(Px,{className:c.content,ownerState:u,children:r})]}))})),zx=()=>Sx().localeText;function Bx(e){return Rx("MuiDatePickerToolbar",e)}Dx("MuiDatePickerToolbar",["root","title"]);const Wx=["value","isLandscape","onChange","toolbarFormat","toolbarPlaceholder","views","className","onViewChange","view"],Vx=(0,Gn.Ay)(Lx,{name:"MuiDatePickerToolbar",slot:"Root",overridesResolver:(e,t)=>t.root})({}),Ux=(0,Gn.Ay)(Ir,{name:"MuiDatePickerToolbar",slot:"Title",overridesResolver:(e,t)=>t.title})({variants:[{props:{isLandscape:!0},style:{margin:"auto 16px auto auto"}}]}),jx=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiDatePickerToolbar"}),{value:r,isLandscape:a,toolbarFormat:s,toolbarPlaceholder:i="\u2013\u2013",views:o,className:l}=n,u=zs(n,Wx),c=Ix(),d=zx(),h=(e=>{const{classes:t}=e;return Tx({root:["root"],title:["title"]},Bx,t)})(n),p=T.useMemo((()=>{if(!r)return i;const e=jv(c,{format:s,views:o},!0);return c.formatByString(r,e)}),[r,s,i,c,o]),f=n;return(0,hr.jsx)(Vx,(0,Po.A)({ref:t,toolbarTitle:d.datePickerToolbarTitle,isLandscape:a,className:(0,Bn.A)(h.root,l)},u,{children:(0,hr.jsx)(Ux,{variant:"h4",align:a?"left":"center",ownerState:f,className:h.title,children:p})}))}));function Gx(e,t){const n=Ix(),r=Cx(),a=So({props:e,name:t}),s=T.useMemo((()=>null==a.localeText?.toolbarTitle?a.localeText:(0,Po.A)({},a.localeText,{datePickerToolbarTitle:a.localeText.toolbarTitle})),[a.localeText]);return(0,Po.A)({},a,{localeText:s},(e=>{let{openTo:t,defaultOpenTo:n,views:r,defaultViews:a}=e;const s=r??a;let i;if(null!=t)i=t;else if(s.includes(n))i=n;else{if(!(s.length>0))throw new Error("MUI X: The `views` prop must contain at least one view.");i=s[0]}return{views:s,openTo:i}})({views:a.views,openTo:a.openTo,defaultViews:["year","day"],defaultOpenTo:"day"}),{disableFuture:a.disableFuture??!1,disablePast:a.disablePast??!1,minDate:zv(n,a.minDate,r.minDate),maxDate:zv(n,a.maxDate,r.maxDate),slots:(0,Po.A)({toolbar:jx},a.slots)})}const Hx=e=>{let{props:t,value:n,adapter:r}=e;if(null===n)return null;const{shouldDisableDate:a,shouldDisableMonth:s,shouldDisableYear:i,disablePast:o,disableFuture:l,timezone:u}=t,c=r.utils.date(void 0,u),d=zv(r.utils,t.minDate,r.defaultDates.minDate),h=zv(r.utils,t.maxDate,r.defaultDates.maxDate);switch(!0){case!r.utils.isValid(n):return"invalidDate";case Boolean(a&&a(n)):return"shouldDisableDate";case Boolean(s&&s(n)):return"shouldDisableMonth";case Boolean(i&&i(n)):return"shouldDisableYear";case Boolean(l&&r.utils.isAfterDay(n,c)):return"disableFuture";case Boolean(o&&r.utils.isBeforeDay(n,c)):return"disablePast";case Boolean(d&&r.utils.isBeforeDay(n,d)):return"minDate";case Boolean(h&&r.utils.isAfterDay(n,h)):return"maxDate";default:return null}};function qx(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return T.useMemo((()=>t.every((e=>null==e))?null:e=>{t.forEach((t=>{!function(e,t){"function"===typeof e?e(t):e&&(e.current=t)}(t,e)}))}),t)}const Kx=function(e){return"string"===typeof e};const Xx=function(e,t,n){return void 0===e||Kx(e)?t:(0,Po.A)({},t,{ownerState:(0,Po.A)({},t.ownerState,n)})};const Yx=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];if(void 0===e)return{};const n={};return Object.keys(e).filter((n=>n.match(/^on[A-Z]/)&&"function"===typeof e[n]&&!t.includes(n))).forEach((t=>{n[t]=e[t]})),n};const Qx=function(e){if(void 0===e)return{};const t={};return Object.keys(e).filter((t=>!(t.match(/^on[A-Z]/)&&"function"===typeof e[t]))).forEach((n=>{t[n]=e[n]})),t};const Jx=function(e){const{getSlotProps:t,additionalProps:n,externalSlotProps:r,externalForwardedProps:a,className:s}=e;if(!t){const e=(0,Bn.A)(null==n?void 0:n.className,s,null==a?void 0:a.className,null==r?void 0:r.className),t=(0,Po.A)({},null==n?void 0:n.style,null==a?void 0:a.style,null==r?void 0:r.style),i=(0,Po.A)({},n,a,r);return e.length>0&&(i.className=e),Object.keys(t).length>0&&(i.style=t),{props:i,internalRef:void 0}}const i=Yx((0,Po.A)({},a,r)),o=Qx(r),l=Qx(a),u=t(i),c=(0,Bn.A)(null==u?void 0:u.className,null==n?void 0:n.className,s,null==a?void 0:a.className,null==r?void 0:r.className),d=(0,Po.A)({},null==u?void 0:u.style,null==n?void 0:n.style,null==a?void 0:a.style,null==r?void 0:r.style),h=(0,Po.A)({},u,n,l,o);return c.length>0&&(h.className=c),Object.keys(d).length>0&&(h.style=d),{props:h,internalRef:u.ref}},Zx=["elementType","externalSlotProps","ownerState","skipResolvingSlotProps"];const ew=function(e){var t;const{elementType:n,externalSlotProps:r,ownerState:a,skipResolvingSlotProps:s=!1}=e,i=zs(e,Zx),o=s?{}:Mv(r,a),{props:l,internalRef:u}=Jx((0,Po.A)({},i,{externalSlotProps:o})),c=qx(u,null==o?void 0:o.ref,null==(t=e.additionalProps)?void 0:t.ref);return Xx(n,(0,Po.A)({},l,{ref:c}),a)};function tw(e){return(0,yr.Ay)("MuiInputAdornment",e)}const nw=(0,gr.A)("MuiInputAdornment",["root","filled","standard","outlined","positionStart","positionEnd","disablePointerEvents","hiddenLabel","sizeSmall"]);var rw;const aw=(0,Gn.Ay)("div",{name:"MuiInputAdornment",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`position${(0,jn.A)(n.position)}`],!0===n.disablePointerEvents&&t.disablePointerEvents,t[n.variant]]}})((0,er.A)((e=>{let{theme:t}=e;return{display:"flex",maxHeight:"2em",alignItems:"center",whiteSpace:"nowrap",color:(t.vars||t).palette.action.active,variants:[{props:{variant:"filled"},style:{[`&.${nw.positionStart}&:not(.${nw.hiddenLabel})`]:{marginTop:16}}},{props:{position:"start"},style:{marginRight:8}},{props:{position:"end"},style:{marginLeft:8}},{props:{disablePointerEvents:!0},style:{pointerEvents:"none"}}]}}))),sw=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiInputAdornment"}),{children:r,className:a,component:s="div",disablePointerEvents:i=!1,disableTypography:o=!1,position:l,variant:u,...c}=n,d=sa()||{};let h=u;u&&d.variant,d&&!h&&(h=d.variant);const p={...n,hiddenLabel:d.hiddenLabel,size:d.size,disablePointerEvents:i,position:l,variant:h},f=(e=>{const{classes:t,disablePointerEvents:n,hiddenLabel:r,position:a,size:s,variant:i}=e,o={root:["root",n&&"disablePointerEvents",a&&`position${(0,jn.A)(a)}`,i,r&&"hiddenLabel",s&&`size${(0,jn.A)(s)}`]};return(0,Vn.A)(o,tw,t)})(p);return(0,hr.jsx)(aa.Provider,{value:null,children:(0,hr.jsx)(aw,{as:s,ownerState:p,className:(0,Bn.A)(f.root,a),ref:t,...c,children:"string"!==typeof r||o?(0,hr.jsxs)(T.Fragment,{children:["start"===l?rw||(rw=(0,hr.jsx)("span",{className:"notranslate",children:"\u200b"})):null,r]}):(0,hr.jsx)(Ir,{color:"textSecondary",children:r})})})})),iw=sw;let ow=0;const lw=E["useId".toString()];function uw(e){if(void 0!==lw){const t=lw();return null!=e?e:t}return function(e){const[t,n]=T.useState(e),r=e||t;return T.useEffect((()=>{null==t&&(ow+=1,n(`mui-${ow}`))}),[t]),r}(e)}function cw(e){if(null==e)return window;if("[object Window]"!==e.toString()){var t=e.ownerDocument;return t&&t.defaultView||window}return e}function dw(e){return e instanceof cw(e).Element||e instanceof Element}function hw(e){return e instanceof cw(e).HTMLElement||e instanceof HTMLElement}function pw(e){return"undefined"!==typeof ShadowRoot&&(e instanceof cw(e).ShadowRoot||e instanceof ShadowRoot)}var fw=Math.max,mw=Math.min,gw=Math.round;function yw(){var e=navigator.userAgentData;return null!=e&&e.brands&&Array.isArray(e.brands)?e.brands.map((function(e){return e.brand+"/"+e.version})).join(" "):navigator.userAgent}function bw(){return!/^((?!chrome|android).)*safari/i.test(yw())}function vw(e,t,n){void 0===t&&(t=!1),void 0===n&&(n=!1);var r=e.getBoundingClientRect(),a=1,s=1;t&&hw(e)&&(a=e.offsetWidth>0&&gw(r.width)/e.offsetWidth||1,s=e.offsetHeight>0&&gw(r.height)/e.offsetHeight||1);var i=(dw(e)?cw(e):window).visualViewport,o=!bw()&&n,l=(r.left+(o&&i?i.offsetLeft:0))/a,u=(r.top+(o&&i?i.offsetTop:0))/s,c=r.width/a,d=r.height/s;return{width:c,height:d,top:u,right:l+c,bottom:u+d,left:l,x:l,y:u}}function xw(e){var t=cw(e);return{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function ww(e){return e?(e.nodeName||"").toLowerCase():null}function kw(e){return((dw(e)?e.ownerDocument:e.document)||window.document).documentElement}function Sw(e){return vw(kw(e)).left+xw(e).scrollLeft}function Iw(e){return cw(e).getComputedStyle(e)}function Cw(e){var t=Iw(e),n=t.overflow,r=t.overflowX,a=t.overflowY;return/auto|scroll|overlay|hidden/.test(n+a+r)}function Nw(e,t,n){void 0===n&&(n=!1);var r=hw(t),a=hw(t)&&function(e){var t=e.getBoundingClientRect(),n=gw(t.width)/e.offsetWidth||1,r=gw(t.height)/e.offsetHeight||1;return 1!==n||1!==r}(t),s=kw(t),i=vw(e,a,n),o={scrollLeft:0,scrollTop:0},l={x:0,y:0};return(r||!r&&!n)&&(("body"!==ww(t)||Cw(s))&&(o=function(e){return e!==cw(e)&&hw(e)?{scrollLeft:(t=e).scrollLeft,scrollTop:t.scrollTop}:xw(e);var t}(t)),hw(t)?((l=vw(t,!0)).x+=t.clientLeft,l.y+=t.clientTop):s&&(l.x=Sw(s))),{x:i.left+o.scrollLeft-l.x,y:i.top+o.scrollTop-l.y,width:i.width,height:i.height}}function Tw(e){var t=vw(e),n=e.offsetWidth,r=e.offsetHeight;return Math.abs(t.width-n)<=1&&(n=t.width),Math.abs(t.height-r)<=1&&(r=t.height),{x:e.offsetLeft,y:e.offsetTop,width:n,height:r}}function Ew(e){return"html"===ww(e)?e:e.assignedSlot||e.parentNode||(pw(e)?e.host:null)||kw(e)}function Aw(e){return["html","body","#document"].indexOf(ww(e))>=0?e.ownerDocument.body:hw(e)&&Cw(e)?e:Aw(Ew(e))}function _w(e,t){var n;void 0===t&&(t=[]);var r=Aw(e),a=r===(null==(n=e.ownerDocument)?void 0:n.body),s=cw(r),i=a?[s].concat(s.visualViewport||[],Cw(r)?r:[]):r,o=t.concat(i);return a?o:o.concat(_w(Ew(i)))}function $w(e){return["table","td","th"].indexOf(ww(e))>=0}function Rw(e){return hw(e)&&"fixed"!==Iw(e).position?e.offsetParent:null}function Dw(e){for(var t=cw(e),n=Rw(e);n&&$w(n)&&"static"===Iw(n).position;)n=Rw(n);return n&&("html"===ww(n)||"body"===ww(n)&&"static"===Iw(n).position)?t:n||function(e){var t=/firefox/i.test(yw());if(/Trident/i.test(yw())&&hw(e)&&"fixed"===Iw(e).position)return null;var n=Ew(e);for(pw(n)&&(n=n.host);hw(n)&&["html","body"].indexOf(ww(n))<0;){var r=Iw(n);if("none"!==r.transform||"none"!==r.perspective||"paint"===r.contain||-1!==["transform","perspective"].indexOf(r.willChange)||t&&"filter"===r.willChange||t&&r.filter&&"none"!==r.filter)return n;n=n.parentNode}return null}(e)||t}var Mw="top",Fw="bottom",Ow="right",Pw="left",Lw="auto",zw=[Mw,Fw,Ow,Pw],Bw="start",Ww="end",Vw="clippingParents",Uw="viewport",jw="popper",Gw="reference",Hw=zw.reduce((function(e,t){return e.concat([t+"-"+Bw,t+"-"+Ww])}),[]),qw=[].concat(zw,[Lw]).reduce((function(e,t){return e.concat([t,t+"-"+Bw,t+"-"+Ww])}),[]),Kw=["beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite"];function Xw(e){var t=new Map,n=new Set,r=[];function a(e){n.add(e.name),[].concat(e.requires||[],e.requiresIfExists||[]).forEach((function(e){if(!n.has(e)){var r=t.get(e);r&&a(r)}})),r.push(e)}return e.forEach((function(e){t.set(e.name,e)})),e.forEach((function(e){n.has(e.name)||a(e)})),r}function Yw(e){var t;return function(){return t||(t=new Promise((function(n){Promise.resolve().then((function(){t=void 0,n(e())}))}))),t}}var Qw={placement:"bottom",modifiers:[],strategy:"absolute"};function Jw(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return!t.some((function(e){return!(e&&"function"===typeof e.getBoundingClientRect)}))}function Zw(e){void 0===e&&(e={});var t=e,n=t.defaultModifiers,r=void 0===n?[]:n,a=t.defaultOptions,s=void 0===a?Qw:a;return function(e,t,n){void 0===n&&(n=s);var a={placement:"bottom",orderedModifiers:[],options:Object.assign({},Qw,s),modifiersData:{},elements:{reference:e,popper:t},attributes:{},styles:{}},i=[],o=!1,l={state:a,setOptions:function(n){var o="function"===typeof n?n(a.options):n;u(),a.options=Object.assign({},s,a.options,o),a.scrollParents={reference:dw(e)?_w(e):e.contextElement?_w(e.contextElement):[],popper:_w(t)};var c=function(e){var t=Xw(e);return Kw.reduce((function(e,n){return e.concat(t.filter((function(e){return e.phase===n})))}),[])}(function(e){var t=e.reduce((function(e,t){var n=e[t.name];return e[t.name]=n?Object.assign({},n,t,{options:Object.assign({},n.options,t.options),data:Object.assign({},n.data,t.data)}):t,e}),{});return Object.keys(t).map((function(e){return t[e]}))}([].concat(r,a.options.modifiers)));return a.orderedModifiers=c.filter((function(e){return e.enabled})),a.orderedModifiers.forEach((function(e){var t=e.name,n=e.options,r=void 0===n?{}:n,s=e.effect;if("function"===typeof s){var o=s({state:a,name:t,instance:l,options:r}),u=function(){};i.push(o||u)}})),l.update()},forceUpdate:function(){if(!o){var e=a.elements,t=e.reference,n=e.popper;if(Jw(t,n)){a.rects={reference:Nw(t,Dw(n),"fixed"===a.options.strategy),popper:Tw(n)},a.reset=!1,a.placement=a.options.placement,a.orderedModifiers.forEach((function(e){return a.modifiersData[e.name]=Object.assign({},e.data)}));for(var r=0;r<a.orderedModifiers.length;r++)if(!0!==a.reset){var s=a.orderedModifiers[r],i=s.fn,u=s.options,c=void 0===u?{}:u,d=s.name;"function"===typeof i&&(a=i({state:a,options:c,name:d,instance:l})||a)}else a.reset=!1,r=-1}}},update:Yw((function(){return new Promise((function(e){l.forceUpdate(),e(a)}))})),destroy:function(){u(),o=!0}};if(!Jw(e,t))return l;function u(){i.forEach((function(e){return e()})),i=[]}return l.setOptions(n).then((function(e){!o&&n.onFirstUpdate&&n.onFirstUpdate(e)})),l}}var ek={passive:!0};function tk(e){return e.split("-")[0]}function nk(e){return e.split("-")[1]}function rk(e){return["top","bottom"].indexOf(e)>=0?"x":"y"}function ak(e){var t,n=e.reference,r=e.element,a=e.placement,s=a?tk(a):null,i=a?nk(a):null,o=n.x+n.width/2-r.width/2,l=n.y+n.height/2-r.height/2;switch(s){case Mw:t={x:o,y:n.y-r.height};break;case Fw:t={x:o,y:n.y+n.height};break;case Ow:t={x:n.x+n.width,y:l};break;case Pw:t={x:n.x-r.width,y:l};break;default:t={x:n.x,y:n.y}}var u=s?rk(s):null;if(null!=u){var c="y"===u?"height":"width";switch(i){case Bw:t[u]=t[u]-(n[c]/2-r[c]/2);break;case Ww:t[u]=t[u]+(n[c]/2-r[c]/2)}}return t}var sk={top:"auto",right:"auto",bottom:"auto",left:"auto"};function ik(e){var t,n=e.popper,r=e.popperRect,a=e.placement,s=e.variation,i=e.offsets,o=e.position,l=e.gpuAcceleration,u=e.adaptive,c=e.roundOffsets,d=e.isFixed,h=i.x,p=void 0===h?0:h,f=i.y,m=void 0===f?0:f,g="function"===typeof c?c({x:p,y:m}):{x:p,y:m};p=g.x,m=g.y;var y=i.hasOwnProperty("x"),b=i.hasOwnProperty("y"),v=Pw,x=Mw,w=window;if(u){var k=Dw(n),S="clientHeight",I="clientWidth";if(k===cw(n)&&"static"!==Iw(k=kw(n)).position&&"absolute"===o&&(S="scrollHeight",I="scrollWidth"),a===Mw||(a===Pw||a===Ow)&&s===Ww)x=Fw,m-=(d&&k===w&&w.visualViewport?w.visualViewport.height:k[S])-r.height,m*=l?1:-1;if(a===Pw||(a===Mw||a===Fw)&&s===Ww)v=Ow,p-=(d&&k===w&&w.visualViewport?w.visualViewport.width:k[I])-r.width,p*=l?1:-1}var C,N=Object.assign({position:o},u&&sk),T=!0===c?function(e,t){var n=e.x,r=e.y,a=t.devicePixelRatio||1;return{x:gw(n*a)/a||0,y:gw(r*a)/a||0}}({x:p,y:m},cw(n)):{x:p,y:m};return p=T.x,m=T.y,l?Object.assign({},N,((C={})[x]=b?"0":"",C[v]=y?"0":"",C.transform=(w.devicePixelRatio||1)<=1?"translate("+p+"px, "+m+"px)":"translate3d("+p+"px, "+m+"px, 0)",C)):Object.assign({},N,((t={})[x]=b?m+"px":"",t[v]=y?p+"px":"",t.transform="",t))}const ok={name:"applyStyles",enabled:!0,phase:"write",fn:function(e){var t=e.state;Object.keys(t.elements).forEach((function(e){var n=t.styles[e]||{},r=t.attributes[e]||{},a=t.elements[e];hw(a)&&ww(a)&&(Object.assign(a.style,n),Object.keys(r).forEach((function(e){var t=r[e];!1===t?a.removeAttribute(e):a.setAttribute(e,!0===t?"":t)})))}))},effect:function(e){var t=e.state,n={popper:{position:t.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(t.elements.popper.style,n.popper),t.styles=n,t.elements.arrow&&Object.assign(t.elements.arrow.style,n.arrow),function(){Object.keys(t.elements).forEach((function(e){var r=t.elements[e],a=t.attributes[e]||{},s=Object.keys(t.styles.hasOwnProperty(e)?t.styles[e]:n[e]).reduce((function(e,t){return e[t]="",e}),{});hw(r)&&ww(r)&&(Object.assign(r.style,s),Object.keys(a).forEach((function(e){r.removeAttribute(e)})))}))}},requires:["computeStyles"]};const lk={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(e){var t=e.state,n=e.options,r=e.name,a=n.offset,s=void 0===a?[0,0]:a,i=qw.reduce((function(e,n){return e[n]=function(e,t,n){var r=tk(e),a=[Pw,Mw].indexOf(r)>=0?-1:1,s="function"===typeof n?n(Object.assign({},t,{placement:e})):n,i=s[0],o=s[1];return i=i||0,o=(o||0)*a,[Pw,Ow].indexOf(r)>=0?{x:o,y:i}:{x:i,y:o}}(n,t.rects,s),e}),{}),o=i[t.placement],l=o.x,u=o.y;null!=t.modifiersData.popperOffsets&&(t.modifiersData.popperOffsets.x+=l,t.modifiersData.popperOffsets.y+=u),t.modifiersData[r]=i}};var uk={left:"right",right:"left",bottom:"top",top:"bottom"};function ck(e){return e.replace(/left|right|bottom|top/g,(function(e){return uk[e]}))}var dk={start:"end",end:"start"};function hk(e){return e.replace(/start|end/g,(function(e){return dk[e]}))}function pk(e,t){var n=t.getRootNode&&t.getRootNode();if(e.contains(t))return!0;if(n&&pw(n)){var r=t;do{if(r&&e.isSameNode(r))return!0;r=r.parentNode||r.host}while(r)}return!1}function fk(e){return Object.assign({},e,{left:e.x,top:e.y,right:e.x+e.width,bottom:e.y+e.height})}function mk(e,t,n){return t===Uw?fk(function(e,t){var n=cw(e),r=kw(e),a=n.visualViewport,s=r.clientWidth,i=r.clientHeight,o=0,l=0;if(a){s=a.width,i=a.height;var u=bw();(u||!u&&"fixed"===t)&&(o=a.offsetLeft,l=a.offsetTop)}return{width:s,height:i,x:o+Sw(e),y:l}}(e,n)):dw(t)?function(e,t){var n=vw(e,!1,"fixed"===t);return n.top=n.top+e.clientTop,n.left=n.left+e.clientLeft,n.bottom=n.top+e.clientHeight,n.right=n.left+e.clientWidth,n.width=e.clientWidth,n.height=e.clientHeight,n.x=n.left,n.y=n.top,n}(t,n):fk(function(e){var t,n=kw(e),r=xw(e),a=null==(t=e.ownerDocument)?void 0:t.body,s=fw(n.scrollWidth,n.clientWidth,a?a.scrollWidth:0,a?a.clientWidth:0),i=fw(n.scrollHeight,n.clientHeight,a?a.scrollHeight:0,a?a.clientHeight:0),o=-r.scrollLeft+Sw(e),l=-r.scrollTop;return"rtl"===Iw(a||n).direction&&(o+=fw(n.clientWidth,a?a.clientWidth:0)-s),{width:s,height:i,x:o,y:l}}(kw(e)))}function gk(e,t,n,r){var a="clippingParents"===t?function(e){var t=_w(Ew(e)),n=["absolute","fixed"].indexOf(Iw(e).position)>=0&&hw(e)?Dw(e):e;return dw(n)?t.filter((function(e){return dw(e)&&pk(e,n)&&"body"!==ww(e)})):[]}(e):[].concat(t),s=[].concat(a,[n]),i=s[0],o=s.reduce((function(t,n){var a=mk(e,n,r);return t.top=fw(a.top,t.top),t.right=mw(a.right,t.right),t.bottom=mw(a.bottom,t.bottom),t.left=fw(a.left,t.left),t}),mk(e,i,r));return o.width=o.right-o.left,o.height=o.bottom-o.top,o.x=o.left,o.y=o.top,o}function yk(e){return Object.assign({},{top:0,right:0,bottom:0,left:0},e)}function bk(e,t){return t.reduce((function(t,n){return t[n]=e,t}),{})}function vk(e,t){void 0===t&&(t={});var n=t,r=n.placement,a=void 0===r?e.placement:r,s=n.strategy,i=void 0===s?e.strategy:s,o=n.boundary,l=void 0===o?Vw:o,u=n.rootBoundary,c=void 0===u?Uw:u,d=n.elementContext,h=void 0===d?jw:d,p=n.altBoundary,f=void 0!==p&&p,m=n.padding,g=void 0===m?0:m,y=yk("number"!==typeof g?g:bk(g,zw)),b=h===jw?Gw:jw,v=e.rects.popper,x=e.elements[f?b:h],w=gk(dw(x)?x:x.contextElement||kw(e.elements.popper),l,c,i),k=vw(e.elements.reference),S=ak({reference:k,element:v,strategy:"absolute",placement:a}),I=fk(Object.assign({},v,S)),C=h===jw?I:k,N={top:w.top-C.top+y.top,bottom:C.bottom-w.bottom+y.bottom,left:w.left-C.left+y.left,right:C.right-w.right+y.right},T=e.modifiersData.offset;if(h===jw&&T){var E=T[a];Object.keys(N).forEach((function(e){var t=[Ow,Fw].indexOf(e)>=0?1:-1,n=[Mw,Fw].indexOf(e)>=0?"y":"x";N[e]+=E[n]*t}))}return N}const xk={name:"flip",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name;if(!t.modifiersData[r]._skip){for(var a=n.mainAxis,s=void 0===a||a,i=n.altAxis,o=void 0===i||i,l=n.fallbackPlacements,u=n.padding,c=n.boundary,d=n.rootBoundary,h=n.altBoundary,p=n.flipVariations,f=void 0===p||p,m=n.allowedAutoPlacements,g=t.options.placement,y=tk(g),b=l||(y===g||!f?[ck(g)]:function(e){if(tk(e)===Lw)return[];var t=ck(e);return[hk(e),t,hk(t)]}(g)),v=[g].concat(b).reduce((function(e,n){return e.concat(tk(n)===Lw?function(e,t){void 0===t&&(t={});var n=t,r=n.placement,a=n.boundary,s=n.rootBoundary,i=n.padding,o=n.flipVariations,l=n.allowedAutoPlacements,u=void 0===l?qw:l,c=nk(r),d=c?o?Hw:Hw.filter((function(e){return nk(e)===c})):zw,h=d.filter((function(e){return u.indexOf(e)>=0}));0===h.length&&(h=d);var p=h.reduce((function(t,n){return t[n]=vk(e,{placement:n,boundary:a,rootBoundary:s,padding:i})[tk(n)],t}),{});return Object.keys(p).sort((function(e,t){return p[e]-p[t]}))}(t,{placement:n,boundary:c,rootBoundary:d,padding:u,flipVariations:f,allowedAutoPlacements:m}):n)}),[]),x=t.rects.reference,w=t.rects.popper,k=new Map,S=!0,I=v[0],C=0;C<v.length;C++){var N=v[C],T=tk(N),E=nk(N)===Bw,A=[Mw,Fw].indexOf(T)>=0,_=A?"width":"height",$=vk(t,{placement:N,boundary:c,rootBoundary:d,altBoundary:h,padding:u}),R=A?E?Ow:Pw:E?Fw:Mw;x[_]>w[_]&&(R=ck(R));var D=ck(R),M=[];if(s&&M.push($[T]<=0),o&&M.push($[R]<=0,$[D]<=0),M.every((function(e){return e}))){I=N,S=!1;break}k.set(N,M)}if(S)for(var F=function(e){var t=v.find((function(t){var n=k.get(t);if(n)return n.slice(0,e).every((function(e){return e}))}));if(t)return I=t,"break"},O=f?3:1;O>0;O--){if("break"===F(O))break}t.placement!==I&&(t.modifiersData[r]._skip=!0,t.placement=I,t.reset=!0)}},requiresIfExists:["offset"],data:{_skip:!1}};function wk(e,t,n){return fw(e,mw(t,n))}const kk={name:"preventOverflow",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name,a=n.mainAxis,s=void 0===a||a,i=n.altAxis,o=void 0!==i&&i,l=n.boundary,u=n.rootBoundary,c=n.altBoundary,d=n.padding,h=n.tether,p=void 0===h||h,f=n.tetherOffset,m=void 0===f?0:f,g=vk(t,{boundary:l,rootBoundary:u,padding:d,altBoundary:c}),y=tk(t.placement),b=nk(t.placement),v=!b,x=rk(y),w="x"===x?"y":"x",k=t.modifiersData.popperOffsets,S=t.rects.reference,I=t.rects.popper,C="function"===typeof m?m(Object.assign({},t.rects,{placement:t.placement})):m,N="number"===typeof C?{mainAxis:C,altAxis:C}:Object.assign({mainAxis:0,altAxis:0},C),T=t.modifiersData.offset?t.modifiersData.offset[t.placement]:null,E={x:0,y:0};if(k){if(s){var A,_="y"===x?Mw:Pw,$="y"===x?Fw:Ow,R="y"===x?"height":"width",D=k[x],M=D+g[_],F=D-g[$],O=p?-I[R]/2:0,P=b===Bw?S[R]:I[R],L=b===Bw?-I[R]:-S[R],z=t.elements.arrow,B=p&&z?Tw(z):{width:0,height:0},W=t.modifiersData["arrow#persistent"]?t.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},V=W[_],U=W[$],j=wk(0,S[R],B[R]),G=v?S[R]/2-O-j-V-N.mainAxis:P-j-V-N.mainAxis,H=v?-S[R]/2+O+j+U+N.mainAxis:L+j+U+N.mainAxis,q=t.elements.arrow&&Dw(t.elements.arrow),K=q?"y"===x?q.clientTop||0:q.clientLeft||0:0,X=null!=(A=null==T?void 0:T[x])?A:0,Y=D+H-X,Q=wk(p?mw(M,D+G-X-K):M,D,p?fw(F,Y):F);k[x]=Q,E[x]=Q-D}if(o){var J,Z="x"===x?Mw:Pw,ee="x"===x?Fw:Ow,te=k[w],ne="y"===w?"height":"width",re=te+g[Z],ae=te-g[ee],se=-1!==[Mw,Pw].indexOf(y),ie=null!=(J=null==T?void 0:T[w])?J:0,oe=se?re:te-S[ne]-I[ne]-ie+N.altAxis,le=se?te+S[ne]+I[ne]-ie-N.altAxis:ae,ue=p&&se?function(e,t,n){var r=wk(e,t,n);return r>n?n:r}(oe,te,le):wk(p?oe:re,te,p?le:ae);k[w]=ue,E[w]=ue-te}t.modifiersData[r]=E}},requiresIfExists:["offset"]};const Sk={name:"arrow",enabled:!0,phase:"main",fn:function(e){var t,n=e.state,r=e.name,a=e.options,s=n.elements.arrow,i=n.modifiersData.popperOffsets,o=tk(n.placement),l=rk(o),u=[Pw,Ow].indexOf(o)>=0?"height":"width";if(s&&i){var c=function(e,t){return yk("number"!==typeof(e="function"===typeof e?e(Object.assign({},t.rects,{placement:t.placement})):e)?e:bk(e,zw))}(a.padding,n),d=Tw(s),h="y"===l?Mw:Pw,p="y"===l?Fw:Ow,f=n.rects.reference[u]+n.rects.reference[l]-i[l]-n.rects.popper[u],m=i[l]-n.rects.reference[l],g=Dw(s),y=g?"y"===l?g.clientHeight||0:g.clientWidth||0:0,b=f/2-m/2,v=c[h],x=y-d[u]-c[p],w=y/2-d[u]/2+b,k=wk(v,w,x),S=l;n.modifiersData[r]=((t={})[S]=k,t.centerOffset=k-w,t)}},effect:function(e){var t=e.state,n=e.options.element,r=void 0===n?"[data-popper-arrow]":n;null!=r&&("string"!==typeof r||(r=t.elements.popper.querySelector(r)))&&pk(t.elements.popper,r)&&(t.elements.arrow=r)},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function Ik(e,t,n){return void 0===n&&(n={x:0,y:0}),{top:e.top-t.height-n.y,right:e.right-t.width+n.x,bottom:e.bottom-t.height+n.y,left:e.left-t.width-n.x}}function Ck(e){return[Mw,Ow,Fw,Pw].some((function(t){return e[t]>=0}))}var Nk=Zw({defaultModifiers:[{name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(e){var t=e.state,n=e.instance,r=e.options,a=r.scroll,s=void 0===a||a,i=r.resize,o=void 0===i||i,l=cw(t.elements.popper),u=[].concat(t.scrollParents.reference,t.scrollParents.popper);return s&&u.forEach((function(e){e.addEventListener("scroll",n.update,ek)})),o&&l.addEventListener("resize",n.update,ek),function(){s&&u.forEach((function(e){e.removeEventListener("scroll",n.update,ek)})),o&&l.removeEventListener("resize",n.update,ek)}},data:{}},{name:"popperOffsets",enabled:!0,phase:"read",fn:function(e){var t=e.state,n=e.name;t.modifiersData[n]=ak({reference:t.rects.reference,element:t.rects.popper,strategy:"absolute",placement:t.placement})},data:{}},{name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(e){var t=e.state,n=e.options,r=n.gpuAcceleration,a=void 0===r||r,s=n.adaptive,i=void 0===s||s,o=n.roundOffsets,l=void 0===o||o,u={placement:tk(t.placement),variation:nk(t.placement),popper:t.elements.popper,popperRect:t.rects.popper,gpuAcceleration:a,isFixed:"fixed"===t.options.strategy};null!=t.modifiersData.popperOffsets&&(t.styles.popper=Object.assign({},t.styles.popper,ik(Object.assign({},u,{offsets:t.modifiersData.popperOffsets,position:t.options.strategy,adaptive:i,roundOffsets:l})))),null!=t.modifiersData.arrow&&(t.styles.arrow=Object.assign({},t.styles.arrow,ik(Object.assign({},u,{offsets:t.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:l})))),t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-placement":t.placement})},data:{}},ok,lk,xk,kk,Sk,{name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(e){var t=e.state,n=e.name,r=t.rects.reference,a=t.rects.popper,s=t.modifiersData.preventOverflow,i=vk(t,{elementContext:"reference"}),o=vk(t,{altBoundary:!0}),l=Ik(i,r),u=Ik(o,a,s),c=Ck(l),d=Ck(u);t.modifiersData[n]={referenceClippingOffsets:l,popperEscapeOffsets:u,isReferenceHidden:c,hasPopperEscaped:d},t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-reference-hidden":c,"data-popper-escaped":d})}}]});function Tk(e){return(0,yr.Ay)("MuiPopper",e)}(0,gr.A)("MuiPopper",["root"]);function Ek(e){return"function"===typeof e?e():e}function Ak(e){return void 0!==e.nodeType}const _k={},$k=T.forwardRef((function(e,t){const{anchorEl:n,children:r,direction:a,disablePortal:s,modifiers:i,open:o,placement:l,popperOptions:u,popperRef:c,slotProps:d={},slots:h={},TransitionProps:p,ownerState:f,...m}=e,g=T.useRef(null),y=(0,Kr.A)(g,t),b=T.useRef(null),v=(0,Kr.A)(b,c),x=T.useRef(v);(0,Yr.A)((()=>{x.current=v}),[v]),T.useImperativeHandle(c,(()=>b.current),[]);const w=function(e,t){if("ltr"===t)return e;switch(e){case"bottom-end":return"bottom-start";case"bottom-start":return"bottom-end";case"top-end":return"top-start";case"top-start":return"top-end";default:return e}}(l,a),[k,S]=T.useState(w),[I,C]=T.useState(Ek(n));T.useEffect((()=>{b.current&&b.current.forceUpdate()})),T.useEffect((()=>{n&&C(Ek(n))}),[n]),(0,Yr.A)((()=>{if(!I||!o)return;let e=[{name:"preventOverflow",options:{altBoundary:s}},{name:"flip",options:{altBoundary:s}},{name:"onUpdate",enabled:!0,phase:"afterWrite",fn:e=>{let{state:t}=e;(e=>{S(e.placement)})(t)}}];null!=i&&(e=e.concat(i)),u&&null!=u.modifiers&&(e=e.concat(u.modifiers));const t=Nk(I,g.current,{placement:w,...u,modifiers:e});return x.current(t),()=>{t.destroy(),x.current(null)}}),[I,s,i,o,u,w]);const N={placement:k};null!==p&&(N.TransitionProps=p);const E=(e=>{const{classes:t}=e;return(0,Vn.A)({root:["root"]},Tk,t)})(e),A=h.root??"div",_=bs({elementType:A,externalSlotProps:d.root,externalForwardedProps:m,additionalProps:{role:"tooltip",ref:y},ownerState:e,className:E.root});return(0,hr.jsx)(A,{..._,children:"function"===typeof r?r(N):r})})),Rk=T.forwardRef((function(e,t){const{anchorEl:n,children:r,container:a,direction:s="ltr",disablePortal:i=!1,keepMounted:o=!1,modifiers:l,open:u,placement:c="bottom",popperOptions:d=_k,popperRef:h,style:p,transition:f=!1,slotProps:m={},slots:g={},...y}=e,[b,v]=T.useState(!0);if(!o&&!u&&(!f||b))return null;let x;if(a)x=a;else if(n){const e=Ek(n);x=e&&Ak(e)?(0,ii.A)(e).body:(0,ii.A)(null).body}const w=u||!o||f&&!b?void 0:"none",k=f?{in:u,onEnter:()=>{v(!1)},onExited:()=>{v(!0)}}:void 0;return(0,hr.jsx)(hi,{disablePortal:i,container:x,children:(0,hr.jsx)($k,{anchorEl:n,direction:s,disablePortal:i,modifiers:l,ref:t,open:f?!b:u,placement:c,popperOptions:d,popperRef:h,slotProps:m,slots:g,...y,style:{position:"fixed",top:0,left:0,display:w,...p},TransitionProps:k,children:r})})})),Dk=Rk,Mk=(0,Gn.Ay)(Dk,{name:"MuiPopper",slot:"Root",overridesResolver:(e,t)=>t.root})({}),Fk=T.forwardRef((function(e,t){const n=ds(),r=(0,tr.b)({props:e,name:"MuiPopper"}),{anchorEl:a,component:s,components:i,componentsProps:o,container:l,disablePortal:u,keepMounted:c,modifiers:d,open:h,placement:p,popperOptions:f,popperRef:m,transition:g,slots:y,slotProps:b,...v}=r,x=y?.root??i?.Root,w={anchorEl:a,container:l,disablePortal:u,keepMounted:c,modifiers:d,open:h,placement:p,popperOptions:f,popperRef:m,transition:g,...v};return(0,hr.jsx)(Mk,{as:s,direction:n?"rtl":"ltr",slots:{root:x},slotProps:b??o,...w,ref:t})})),Ok="undefined"!==typeof window?T.useLayoutEffect:T.useEffect;const Pk=function(e){const t=T.useRef(e);return Ok((()=>{t.current=e})),T.useRef((function(){return(0,t.current)(...arguments)})).current};function Lk(e){return e&&e.ownerDocument||document}function zk(e){return Rx("MuiPickersPopper",e)}Dx("MuiPickersPopper",["root","paper"]);const Bk=function(){const e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:document).activeElement;return e?e.shadowRoot?Bk(e.shadowRoot):e:null},Wk="@media (pointer: fine)",Vk="undefined"!==typeof navigator&&navigator.userAgent.match(/android\s(\d+)|OS\s(\d+)/i),Uk=Vk&&Vk[1]?parseInt(Vk[1],10):null,jk=Vk&&Vk[2]?parseInt(Vk[2],10):null,Gk=Uk&&Uk<10||jk&&jk<13||!1,Hk=()=>$v("@media (prefers-reduced-motion: reduce)",{defaultMatches:!1})||Gk,qk=["PaperComponent","popperPlacement","ownerState","children","paperSlotProps","paperClasses","onPaperClick","onPaperTouchStart"],Kk=(0,Gn.Ay)(Fk,{name:"MuiPickersPopper",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;return{zIndex:t.zIndex.modal}})),Xk=(0,Gn.Ay)(Gr,{name:"MuiPickersPopper",slot:"Paper",overridesResolver:(e,t)=>t.paper})({outline:0,transformOrigin:"top center",variants:[{props:e=>{let{placement:t}=e;return["top","top-start","top-end"].includes(t)},style:{transformOrigin:"bottom center"}}]});const Yk=T.forwardRef(((e,t)=>{const{PaperComponent:n,popperPlacement:r,ownerState:a,children:s,paperSlotProps:i,paperClasses:o,onPaperClick:l,onPaperTouchStart:u}=e,c=zs(e,qk),d=(0,Po.A)({},a,{placement:r}),h=ew({elementType:n,externalSlotProps:i,additionalProps:{tabIndex:-1,elevation:8,ref:t},className:o,ownerState:d});return(0,hr.jsx)(n,(0,Po.A)({},c,h,{onClick:e=>{l(e),h.onClick?.(e)},onTouchStart:e=>{u(e),h.onTouchStart?.(e)},ownerState:d,children:s}))}));function Qk(e){const t=So({props:e,name:"MuiPickersPopper"}),{anchorEl:n,children:r,containerRef:a=null,shouldRestoreFocus:s,onBlur:i,onDismiss:o,open:l,role:u,placement:c,slots:d,slotProps:h,reduceAnimations:p}=t;T.useEffect((()=>{function e(e){l&&"Escape"===e.key&&o()}return document.addEventListener("keydown",e),()=>{document.removeEventListener("keydown",e)}}),[o,l]);const f=T.useRef(null);T.useEffect((()=>{"tooltip"===u||s&&!s()||(l?f.current=Bk(document):f.current&&f.current instanceof HTMLElement&&setTimeout((()=>{f.current instanceof HTMLElement&&f.current.focus()})))}),[l,u,s]);const[m,g,y]=function(e,t){const n=T.useRef(!1),r=T.useRef(!1),a=T.useRef(null),s=T.useRef(!1);T.useEffect((()=>{if(e)return document.addEventListener("mousedown",t,!0),document.addEventListener("touchstart",t,!0),()=>{document.removeEventListener("mousedown",t,!0),document.removeEventListener("touchstart",t,!0),s.current=!1};function t(){s.current=!0}}),[e]);const i=Pk((e=>{if(!s.current)return;const i=r.current;r.current=!1;const o=Lk(a.current);if(!a.current||"clientX"in e&&function(e,t){return t.documentElement.clientWidth<e.clientX||t.documentElement.clientHeight<e.clientY}(e,o))return;if(n.current)return void(n.current=!1);let l;l=e.composedPath?e.composedPath().indexOf(a.current)>-1:!o.documentElement.contains(e.target)||a.current.contains(e.target),l||i||t(e)})),o=()=>{r.current=!0};return T.useEffect((()=>{if(e){const e=Lk(a.current),t=()=>{n.current=!0};return e.addEventListener("touchstart",i),e.addEventListener("touchmove",t),()=>{e.removeEventListener("touchstart",i),e.removeEventListener("touchmove",t)}}}),[e,i]),T.useEffect((()=>{if(e){const e=Lk(a.current);return e.addEventListener("click",i),()=>{e.removeEventListener("click",i),r.current=!1}}}),[e,i]),[a,o,o]}(l,i??o),b=qx(T.useRef(null),a),v=qx(b,m),x=t,w=(e=>{const{classes:t}=e;return Tx({root:["root"],paper:["paper"]},zk,t)})(x),k=Hk(),S=p??k,I=d?.desktopTransition??S?gi:si,C=d?.desktopTrapFocus??ci,N=d?.desktopPaper??Xk,E=d?.popper??Kk,A=ew({elementType:E,externalSlotProps:h?.popper,additionalProps:{transition:!0,role:u,open:l,anchorEl:n,placement:c,onKeyDown:e=>{"Escape"===e.key&&(e.stopPropagation(),o())}},className:w.root,ownerState:t});return(0,hr.jsx)(E,(0,Po.A)({},A,{children:e=>{let{TransitionProps:t,placement:n}=e;return(0,hr.jsx)(C,(0,Po.A)({open:l,disableAutoFocus:!0,disableRestoreFocus:!0,disableEnforceFocus:"tooltip"===u,isEnabled:()=>!0},h?.desktopTrapFocus,{children:(0,hr.jsx)(I,(0,Po.A)({},t,h?.desktopTransition,{children:(0,hr.jsx)(Yk,{PaperComponent:N,ownerState:x,popperPlacement:n,ref:v,onPaperClick:g,onPaperTouchStart:y,paperClasses:w.paper,paperSlotProps:h?.desktopPaper,children:r})}))}))}}))}function Jk(e,t,n,r){const{value:a,onError:s}=e,i=Sx(),o=T.useRef(r),l=t({adapter:i,value:a,props:e});return T.useEffect((()=>{s&&!n(l,o.current)&&s(l,a),o.current=l}),[n,s,o,l,a]),l}function Zk(e){let{controlled:t,default:n,name:r,state:a="value"}=e;const{current:s}=T.useRef(void 0!==t),[i,o]=T.useState(n);return[s?t:i,T.useCallback((e=>{s||o(e)}),[])]}const eS=e=>{let{timezone:t,value:n,defaultValue:r,onChange:a,valueManager:s}=e;const i=Ix(),o=T.useRef(r),l=n??o.current??s.emptyValue,u=T.useMemo((()=>s.getTimezone(i,l)),[i,s,l]),c=Pk((e=>null==u?e:s.setTimezone(i,u,e))),d=t??u??"default";return{value:T.useMemo((()=>s.setTimezone(i,d,l)),[s,i,d,l]),handleValueChange:Pk((function(e){const t=c(e);for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];a?.(t,...r)})),timezone:d}},tS=e=>{let{name:t,timezone:n,value:r,defaultValue:a,onChange:s,valueManager:i}=e;const[o,l]=Zk({name:t,state:"value",controlled:r,default:a??i.emptyValue}),u=Pk((function(e){l(e);for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];s?.(e,...n)}));return eS({timezone:n,value:o,defaultValue:void 0,onChange:u,valueManager:i})},nS=e=>{let{props:t,valueManager:n,valueType:r,wrapperVariant:a,validator:s}=e;const{onAccept:i,onChange:o,value:l,defaultValue:u,closeOnSelect:c="desktop"===a,timezone:d}=t,{current:h}=T.useRef(u),{current:p}=T.useRef(void 0!==l);const f=Ix(),m=Sx(),{isOpen:g,setIsOpen:y}=(e=>{let{open:t,onOpen:n,onClose:r}=e;const a=T.useRef("boolean"===typeof t).current,[s,i]=T.useState(!1);return T.useEffect((()=>{if(a){if("boolean"!==typeof t)throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");i(t)}}),[a,t]),{isOpen:s,setIsOpen:T.useCallback((e=>{a||i(e),e&&n&&n(),!e&&r&&r()}),[a,n,r])}})(t),{timezone:b,value:v,handleValueChange:x}=eS({timezone:d,value:l,defaultValue:h,onChange:o,valueManager:n}),[w,k]=T.useState((()=>{let e;return e=void 0!==v?v:void 0!==h?h:n.emptyValue,{draft:e,lastPublishedValue:e,lastCommittedValue:e,lastControlledValue:v,hasBeenModifiedSinceMount:!1}}));Jk((0,Po.A)({},t,{value:w.draft,timezone:b}),s,n.isSameError,n.defaultErrorState);const S=Pk((e=>{const r={action:e,dateState:w,hasChanged:t=>!n.areValuesEqual(f,e.value,t),isControlled:p,closeOnSelect:c},a=(e=>{const{action:t,hasChanged:n,dateState:r,isControlled:a}=e,s=!a&&!r.hasBeenModifiedSinceMount;return"setValueFromField"===t.name||("setValueFromAction"===t.name?!(!s||!["accept","today","clear"].includes(t.pickerAction))||n(r.lastPublishedValue):("setValueFromView"===t.name&&"shallow"!==t.selectionState||"setValueFromShortcut"===t.name)&&(!!s||n(r.lastPublishedValue)))})(r),o=(e=>{const{action:t,hasChanged:n,dateState:r,isControlled:a,closeOnSelect:s}=e,i=!a&&!r.hasBeenModifiedSinceMount;return"setValueFromAction"===t.name?!(!i||!["accept","today","clear"].includes(t.pickerAction))||n(r.lastCommittedValue):"setValueFromView"===t.name&&"finish"===t.selectionState&&s?!!i||n(r.lastCommittedValue):"setValueFromShortcut"===t.name&&"accept"===t.changeImportance&&n(r.lastCommittedValue)})(r),l=(e=>{const{action:t,closeOnSelect:n}=e;return"setValueFromAction"===t.name||("setValueFromView"===t.name?"finish"===t.selectionState&&n:"setValueFromShortcut"===t.name&&"accept"===t.changeImportance)})(r);k((t=>(0,Po.A)({},t,{draft:e.value,lastPublishedValue:a?e.value:t.lastPublishedValue,lastCommittedValue:o?e.value:t.lastCommittedValue,hasBeenModifiedSinceMount:!0})));let u=null;const d=()=>{if(!u){const n="setValueFromField"===e.name?e.context.validationError:s({adapter:m,value:e.value,props:(0,Po.A)({},t,{value:e.value,timezone:b})});u={validationError:n},"setValueFromShortcut"===e.name&&(u.shortcut=e.shortcut)}return u};a&&x(e.value,d()),o&&i&&i(e.value,d()),l&&y(!1)}));if(void 0!==v&&(void 0===w.lastControlledValue||!n.areValuesEqual(f,w.lastControlledValue,v))){const e=n.areValuesEqual(f,w.draft,v);k((t=>(0,Po.A)({},t,{lastControlledValue:v},e?{}:{lastCommittedValue:v,lastPublishedValue:v,draft:v,hasBeenModifiedSinceMount:!0})))}const I=Pk((()=>{S({value:n.emptyValue,name:"setValueFromAction",pickerAction:"clear"})})),C=Pk((()=>{S({value:w.lastPublishedValue,name:"setValueFromAction",pickerAction:"accept"})})),N=Pk((()=>{S({value:w.lastPublishedValue,name:"setValueFromAction",pickerAction:"dismiss"})})),E=Pk((()=>{S({value:w.lastCommittedValue,name:"setValueFromAction",pickerAction:"cancel"})})),A=Pk((()=>{S({value:n.getTodayValue(f,b,r),name:"setValueFromAction",pickerAction:"today"})})),_=Pk((e=>{e.preventDefault(),y(!0)})),$=Pk((e=>{e?.preventDefault(),y(!1)})),R=Pk((function(e){return S({name:"setValueFromView",value:e,selectionState:arguments.length>1&&void 0!==arguments[1]?arguments[1]:"partial"})})),D=Pk(((e,t,n)=>S({name:"setValueFromShortcut",value:e,changeImportance:t,shortcut:n}))),M=Pk(((e,t)=>S({name:"setValueFromField",value:e,context:t}))),F={onClear:I,onAccept:C,onDismiss:N,onCancel:E,onSetToday:A,onOpen:_,onClose:$},O={value:w.draft,onChange:M},P=T.useMemo((()=>n.cleanValue(f,w.draft)),[f,n,w.draft]);return{open:g,fieldProps:O,viewProps:{value:P,onChange:R,onClose:$,open:g},layoutProps:(0,Po.A)({},F,{value:P,onChange:R,onSelectShortcut:D,isValid:e=>{const r=s({adapter:m,value:e,props:(0,Po.A)({},t,{value:e,timezone:b})});return!n.hasError(r)}}),actions:F}};function rS(e){let{onChange:t,onViewChange:n,openTo:r,view:a,views:s,autoFocus:i,focusedView:o,onFocusedViewChange:l}=e;const u=T.useRef(r),c=T.useRef(s),d=T.useRef(s.includes(r)?r:s[0]),[h,p]=Zk({name:"useViews",state:"view",controlled:a,default:d.current}),f=T.useRef(i?h:null),[m,g]=Zk({name:"useViews",state:"focusedView",controlled:o,default:f.current});T.useEffect((()=>{(u.current&&u.current!==r||c.current&&c.current.some((e=>!s.includes(e))))&&(p(s.includes(r)?r:s[0]),c.current=s,u.current=r)}),[r,p,h,s]);const y=s.indexOf(h),b=s[y-1]??null,v=s[y+1]??null,x=Pk(((e,t)=>{g(t?e:t=>e===t?null:t),l?.(e,t)})),w=Pk((e=>{x(e,!0),e!==h&&(p(e),n&&n(e))})),k=Pk((()=>{v&&w(v)})),S=Pk(((e,n,r)=>{const a="finish"===n,i=r?s.indexOf(r)<s.length-1:Boolean(v);if(t(e,a&&i?"partial":n,r),r&&r!==h){const e=s[s.indexOf(r)+1];e&&w(e)}else a&&k()}));return{view:h,setView:w,focusedView:m,setFocusedView:x,nextView:v,previousView:b,defaultView:s.includes(r)?r:s[0],goToNextView:k,setValueAndGoToNextView:S}}const aS=["className","sx"],sS=e=>{let{props:t,propsFromPickerValue:n,additionalViewProps:r,autoFocusView:a,rendererInterceptor:s,fieldRef:i}=e;const{onChange:o,open:l,onClose:u}=n,{view:c,views:d,openTo:h,onViewChange:p,viewRenderers:f,timezone:m}=t,g=zs(t,aS),{view:y,setView:b,defaultView:v,focusedView:x,setFocusedView:w,setValueAndGoToNextView:k}=rS({view:c,views:d,openTo:h,onChange:o,onViewChange:p,autoFocus:a}),{hasUIView:S,viewModeLookup:I}=T.useMemo((()=>d.reduce(((e,t)=>{let n;return n=null!=f[t]?"UI":"field",e.viewModeLookup[t]=n,"UI"===n&&(e.hasUIView=!0),e}),{hasUIView:!1,viewModeLookup:{}})),[f,d]),C=T.useMemo((()=>d.reduce(((e,t)=>null!=f[t]&&(e=>Hv.includes(e))(t)?e+1:e),0)),[f,d]),N=I[y],E=Pk((()=>"UI"===N)),[A,_]=T.useState("UI"===N?y:null);A!==y&&"UI"===I[y]&&_(y),Ok((()=>{"field"===N&&l&&(u(),setTimeout((()=>{i?.current?.setSelectedSections(y),i?.current?.focusField(y)})))}),[y]),Ok((()=>{if(!l)return;let e=y;"field"===N&&null!=A&&(e=A),e!==v&&"UI"===I[e]&&"UI"===I[v]&&(e=v),e!==y&&b(e),w(e,!0)}),[l]);return{hasUIView:S,shouldRestoreFocus:E,layoutProps:{views:d,view:A,onViewChange:b},renderCurrentView:()=>{if(null==A)return null;const e=f[A];if(null==e)return null;const t=(0,Po.A)({},g,r,n,{views:d,timezone:m,onChange:k,view:A,onViewChange:b,focusedView:x,onFocusedViewChange:w,showViewSwitcher:C>1,timeViewsCount:C});return s?s(f,A,t):e(t)}}};function iS(){return"undefined"===typeof window?"portrait":window.screen&&window.screen.orientation&&window.screen.orientation.angle?90===Math.abs(window.screen.orientation.angle)?"landscape":"portrait":window.orientation&&90===Math.abs(Number(window.orientation))?"landscape":"portrait"}const oS=(e,t)=>{const[n,r]=T.useState(iS);if(Ok((()=>{const e=()=>{r(iS())};return window.addEventListener("orientationchange",e),()=>{window.removeEventListener("orientationchange",e)}}),[]),function(e,t){return Array.isArray(t)?t.every((t=>-1!==e.indexOf(t))):-1!==e.indexOf(t)}(e,["hours","minutes","seconds"]))return!1;return"landscape"===(t||n)},lS=e=>{let{props:t,valueManager:n,valueType:r,wrapperVariant:a,additionalViewProps:s,validator:i,autoFocusView:o,rendererInterceptor:l,fieldRef:u}=e;const c=nS({props:t,valueManager:n,valueType:r,wrapperVariant:a,validator:i}),d=sS({props:t,additionalViewProps:s,autoFocusView:o,fieldRef:u,propsFromPickerValue:c.viewProps,rendererInterceptor:l}),h=(e=>{let{props:t,propsFromPickerValue:n,propsFromPickerViews:r,wrapperVariant:a}=e;const{orientation:s}=t,i=oS(r.views,s),o=ds();return{layoutProps:(0,Po.A)({},r,n,{isLandscape:i,isRtl:o,wrapperVariant:a,disabled:t.disabled,readOnly:t.readOnly})}})({props:t,wrapperVariant:a,propsFromPickerValue:c.layoutProps,propsFromPickerViews:d.layoutProps});return{open:c.open,actions:c.actions,fieldProps:c.fieldProps,renderCurrentView:d.renderCurrentView,hasUIView:d.hasUIView,shouldRestoreFocus:d.shouldRestoreFocus,layoutProps:h.layoutProps}};function uS(e){return Rx("MuiPickersLayout",e)}const cS=Dx("MuiPickersLayout",["root","landscape","contentWrapper","toolbar","actionBar","tabs","shortcuts"]),dS=["onAccept","onClear","onCancel","onSetToday","actions"];function hS(e){const{onAccept:t,onClear:n,onCancel:r,onSetToday:a,actions:s}=e,i=zs(e,dS),o=zx();if(null==s||0===s.length)return null;const l=s?.map((e=>{switch(e){case"clear":return(0,hr.jsx)(hl,{onClick:n,children:o.clearButtonLabel},e);case"cancel":return(0,hr.jsx)(hl,{onClick:r,children:o.cancelButtonLabel},e);case"accept":return(0,hr.jsx)(hl,{onClick:t,children:o.okButtonLabel},e);case"today":return(0,hr.jsx)(hl,{onClick:a,children:o.todayButtonLabel},e);default:return null}}));return(0,hr.jsx)(au,(0,Po.A)({},i,{children:l}))}function pS(e){return(0,yr.Ay)("MuiListItem",e)}(0,gr.A)("MuiListItem",["root","container","dense","alignItemsFlexStart","divider","gutters","padding","secondaryAction"]);const fS=(0,gr.A)("MuiListItemButton",["root","focusVisible","dense","alignItemsFlexStart","disabled","divider","gutters","selected"]);function mS(e){return(0,yr.Ay)("MuiListItemSecondaryAction",e)}(0,gr.A)("MuiListItemSecondaryAction",["root","disableGutters"]);const gS=(0,Gn.Ay)("div",{name:"MuiListItemSecondaryAction",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.disableGutters&&t.disableGutters]}})({position:"absolute",right:16,top:"50%",transform:"translateY(-50%)",variants:[{props:e=>{let{ownerState:t}=e;return t.disableGutters},style:{right:0}}]}),yS=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiListItemSecondaryAction"}),{className:r,...a}=n,s=T.useContext(vs),i={...n,disableGutters:s.disableGutters},o=(e=>{const{disableGutters:t,classes:n}=e,r={root:["root",t&&"disableGutters"]};return(0,Vn.A)(r,mS,n)})(i);return(0,hr.jsx)(gS,{className:(0,Bn.A)(o.root,r),ownerState:i,ref:t,...a})}));yS.muiName="ListItemSecondaryAction";const bS=yS,vS=(0,Gn.Ay)("div",{name:"MuiListItem",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.dense&&t.dense,"flex-start"===n.alignItems&&t.alignItemsFlexStart,n.divider&&t.divider,!n.disableGutters&&t.gutters,!n.disablePadding&&t.padding,n.hasSecondaryAction&&t.secondaryAction]}})((0,er.A)((e=>{let{theme:t}=e;return{display:"flex",justifyContent:"flex-start",alignItems:"center",position:"relative",textDecoration:"none",width:"100%",boxSizing:"border-box",textAlign:"left",variants:[{props:e=>{let{ownerState:t}=e;return!t.disablePadding},style:{paddingTop:8,paddingBottom:8}},{props:e=>{let{ownerState:t}=e;return!t.disablePadding&&t.dense},style:{paddingTop:4,paddingBottom:4}},{props:e=>{let{ownerState:t}=e;return!t.disablePadding&&!t.disableGutters},style:{paddingLeft:16,paddingRight:16}},{props:e=>{let{ownerState:t}=e;return!t.disablePadding&&!!t.secondaryAction},style:{paddingRight:48}},{props:e=>{let{ownerState:t}=e;return!!t.secondaryAction},style:{[`& > .${fS.root}`]:{paddingRight:48}}},{props:{alignItems:"flex-start"},style:{alignItems:"flex-start"}},{props:e=>{let{ownerState:t}=e;return t.divider},style:{borderBottom:`1px solid ${(t.vars||t).palette.divider}`,backgroundClip:"padding-box"}},{props:e=>{let{ownerState:t}=e;return t.button},style:{transition:t.transitions.create("background-color",{duration:t.transitions.duration.shortest}),"&:hover":{textDecoration:"none",backgroundColor:(t.vars||t).palette.action.hover,"@media (hover: none)":{backgroundColor:"transparent"}}}},{props:e=>{let{ownerState:t}=e;return t.hasSecondaryAction},style:{paddingRight:48}}]}}))),xS=(0,Gn.Ay)("li",{name:"MuiListItem",slot:"Container",overridesResolver:(e,t)=>t.container})({position:"relative"}),wS=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiListItem"}),{alignItems:r="center",children:a,className:s,component:i,components:o={},componentsProps:l={},ContainerComponent:u="li",ContainerProps:{className:c,...d}={},dense:h=!1,disableGutters:p=!1,disablePadding:f=!1,divider:m=!1,secondaryAction:g,slotProps:y={},slots:b={},...v}=n,x=T.useContext(vs),w=T.useMemo((()=>({dense:h||x.dense||!1,alignItems:r,disableGutters:p})),[r,x.dense,h,p]),k=T.useRef(null),S=T.Children.toArray(a),I=S.length&&(0,Ja.A)(S[S.length-1],["ListItemSecondaryAction"]),C={...n,alignItems:r,dense:w.dense,disableGutters:p,disablePadding:f,divider:m,hasSecondaryAction:I},N=(e=>{const{alignItems:t,classes:n,dense:r,disableGutters:a,disablePadding:s,divider:i,hasSecondaryAction:o}=e,l={root:["root",r&&"dense",!a&&"gutters",!s&&"padding",i&&"divider","flex-start"===t&&"alignItemsFlexStart",o&&"secondaryAction"],container:["container"]};return(0,Vn.A)(l,pS,n)})(C),E=(0,ia.A)(k,t),A=b.root||o.Root||vS,_=y.root||l.root||{},$={className:(0,Bn.A)(N.root,_.className,s),...v};let R=i||"li";return I?(R=$.component||i?R:"div","li"===u&&("li"===R?R="div":"li"===$.component&&($.component="div")),(0,hr.jsx)(vs.Provider,{value:w,children:(0,hr.jsxs)(xS,{as:u,className:(0,Bn.A)(N.container,c),ref:E,ownerState:C,...d,children:[(0,hr.jsx)(A,{..._,...!na(A)&&{as:R,ownerState:{...C,..._.ownerState}},...$,children:S}),S.pop()]})})):(0,hr.jsx)(vs.Provider,{value:w,children:(0,hr.jsxs)(A,{..._,as:R,ref:E,...!na(A)&&{ownerState:{...C,..._.ownerState}},...$,children:[S,g&&(0,hr.jsx)(bS,{children:g})]})})})),kS=wS,SS=(0,bo.A)((0,hr.jsx)("path",{d:"M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"}),"Cancel");function IS(e){return(0,yr.Ay)("MuiChip",e)}const CS=(0,gr.A)("MuiChip",["root","sizeSmall","sizeMedium","colorDefault","colorError","colorInfo","colorPrimary","colorSecondary","colorSuccess","colorWarning","disabled","clickable","clickableColorPrimary","clickableColorSecondary","deletable","deletableColorPrimary","deletableColorSecondary","outlined","filled","outlinedPrimary","outlinedSecondary","filledPrimary","filledSecondary","avatar","avatarSmall","avatarMedium","avatarColorPrimary","avatarColorSecondary","icon","iconSmall","iconMedium","iconColorPrimary","iconColorSecondary","label","labelSmall","labelMedium","deleteIcon","deleteIconSmall","deleteIconMedium","deleteIconColorPrimary","deleteIconColorSecondary","deleteIconOutlinedColorPrimary","deleteIconOutlinedColorSecondary","deleteIconFilledColorPrimary","deleteIconFilledColorSecondary","focusVisible"]),NS=(0,Gn.Ay)("div",{name:"MuiChip",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e,{color:r,iconColor:a,clickable:s,onDelete:i,size:o,variant:l}=n;return[{[`& .${CS.avatar}`]:t.avatar},{[`& .${CS.avatar}`]:t[`avatar${(0,jn.A)(o)}`]},{[`& .${CS.avatar}`]:t[`avatarColor${(0,jn.A)(r)}`]},{[`& .${CS.icon}`]:t.icon},{[`& .${CS.icon}`]:t[`icon${(0,jn.A)(o)}`]},{[`& .${CS.icon}`]:t[`iconColor${(0,jn.A)(a)}`]},{[`& .${CS.deleteIcon}`]:t.deleteIcon},{[`& .${CS.deleteIcon}`]:t[`deleteIcon${(0,jn.A)(o)}`]},{[`& .${CS.deleteIcon}`]:t[`deleteIconColor${(0,jn.A)(r)}`]},{[`& .${CS.deleteIcon}`]:t[`deleteIcon${(0,jn.A)(l)}Color${(0,jn.A)(r)}`]},t.root,t[`size${(0,jn.A)(o)}`],t[`color${(0,jn.A)(r)}`],s&&t.clickable,s&&"default"!==r&&t[`clickableColor${(0,jn.A)(r)})`],i&&t.deletable,i&&"default"!==r&&t[`deletableColor${(0,jn.A)(r)}`],t[l],t[`${l}${(0,jn.A)(r)}`]]}})((0,er.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?t.palette.grey[700]:t.palette.grey[300];return{maxWidth:"100%",fontFamily:t.typography.fontFamily,fontSize:t.typography.pxToRem(13),display:"inline-flex",alignItems:"center",justifyContent:"center",height:32,color:(t.vars||t).palette.text.primary,backgroundColor:(t.vars||t).palette.action.selected,borderRadius:16,whiteSpace:"nowrap",transition:t.transitions.create(["background-color","box-shadow"]),cursor:"unset",outline:0,textDecoration:"none",border:0,padding:0,verticalAlign:"middle",boxSizing:"border-box",[`&.${CS.disabled}`]:{opacity:(t.vars||t).palette.action.disabledOpacity,pointerEvents:"none"},[`& .${CS.avatar}`]:{marginLeft:5,marginRight:-6,width:24,height:24,color:t.vars?t.vars.palette.Chip.defaultAvatarColor:n,fontSize:t.typography.pxToRem(12)},[`& .${CS.avatarColorPrimary}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.dark},[`& .${CS.avatarColorSecondary}`]:{color:(t.vars||t).palette.secondary.contrastText,backgroundColor:(t.vars||t).palette.secondary.dark},[`& .${CS.avatarSmall}`]:{marginLeft:4,marginRight:-4,width:18,height:18,fontSize:t.typography.pxToRem(10)},[`& .${CS.icon}`]:{marginLeft:5,marginRight:-6},[`& .${CS.deleteIcon}`]:{WebkitTapHighlightColor:"transparent",color:t.vars?`rgba(${t.vars.palette.text.primaryChannel} / 0.26)`:(0,Wn.X4)(t.palette.text.primary,.26),fontSize:22,cursor:"pointer",margin:"0 5px 0 -6px","&:hover":{color:t.vars?`rgba(${t.vars.palette.text.primaryChannel} / 0.4)`:(0,Wn.X4)(t.palette.text.primary,.4)}},variants:[{props:{size:"small"},style:{height:24,[`& .${CS.icon}`]:{fontSize:18,marginLeft:4,marginRight:-4},[`& .${CS.deleteIcon}`]:{fontSize:16,marginRight:4,marginLeft:-4}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.contrastText})).map((e=>{let[n]=e;return{props:{color:n},style:{backgroundColor:(t.vars||t).palette[n].main,color:(t.vars||t).palette[n].contrastText,[`& .${CS.deleteIcon}`]:{color:t.vars?`rgba(${t.vars.palette[n].contrastTextChannel} / 0.7)`:(0,Wn.X4)(t.palette[n].contrastText,.7),"&:hover, &:active":{color:(t.vars||t).palette[n].contrastText}}}}})),{props:e=>e.iconColor===e.color,style:{[`& .${CS.icon}`]:{color:t.vars?t.vars.palette.Chip.defaultIconColor:n}}},{props:e=>e.iconColor===e.color&&"default"!==e.color,style:{[`& .${CS.icon}`]:{color:"inherit"}}},{props:{onDelete:!0},style:{[`&.${CS.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.focusOpacity}))`:(0,Wn.X4)(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.focusOpacity)}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.dark})).map((e=>{let[n]=e;return{props:{color:n,onDelete:!0},style:{[`&.${CS.focusVisible}`]:{background:(t.vars||t).palette[n].dark}}}})),{props:{clickable:!0},style:{userSelect:"none",WebkitTapHighlightColor:"transparent",cursor:"pointer","&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.hoverOpacity}))`:(0,Wn.X4)(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.hoverOpacity)},[`&.${CS.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.focusOpacity}))`:(0,Wn.X4)(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.focusOpacity)},"&:active":{boxShadow:(t.vars||t).shadows[1]}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.dark})).map((e=>{let[n]=e;return{props:{color:n,clickable:!0},style:{[`&:hover, &.${CS.focusVisible}`]:{backgroundColor:(t.vars||t).palette[n].dark}}}})),{props:{variant:"outlined"},style:{backgroundColor:"transparent",border:t.vars?`1px solid ${t.vars.palette.Chip.defaultBorder}`:`1px solid ${"light"===t.palette.mode?t.palette.grey[400]:t.palette.grey[700]}`,[`&.${CS.clickable}:hover`]:{backgroundColor:(t.vars||t).palette.action.hover},[`&.${CS.focusVisible}`]:{backgroundColor:(t.vars||t).palette.action.focus},[`& .${CS.avatar}`]:{marginLeft:4},[`& .${CS.avatarSmall}`]:{marginLeft:2},[`& .${CS.icon}`]:{marginLeft:4},[`& .${CS.iconSmall}`]:{marginLeft:2},[`& .${CS.deleteIcon}`]:{marginRight:5},[`& .${CS.deleteIconSmall}`]:{marginRight:3}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{variant:"outlined",color:n},style:{color:(t.vars||t).palette[n].main,border:`1px solid ${t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.7)`:(0,Wn.X4)(t.palette[n].main,.7)}`,[`&.${CS.clickable}:hover`]:{backgroundColor:t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Wn.X4)(t.palette[n].main,t.palette.action.hoverOpacity)},[`&.${CS.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.focusOpacity})`:(0,Wn.X4)(t.palette[n].main,t.palette.action.focusOpacity)},[`& .${CS.deleteIcon}`]:{color:t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.7)`:(0,Wn.X4)(t.palette[n].main,.7),"&:hover, &:active":{color:(t.vars||t).palette[n].main}}}}}))]}}))),TS=(0,Gn.Ay)("span",{name:"MuiChip",slot:"Label",overridesResolver:(e,t)=>{const{ownerState:n}=e,{size:r}=n;return[t.label,t[`label${(0,jn.A)(r)}`]]}})({overflow:"hidden",textOverflow:"ellipsis",paddingLeft:12,paddingRight:12,whiteSpace:"nowrap",variants:[{props:{variant:"outlined"},style:{paddingLeft:11,paddingRight:11}},{props:{size:"small"},style:{paddingLeft:8,paddingRight:8}},{props:{size:"small",variant:"outlined"},style:{paddingLeft:7,paddingRight:7}}]});function ES(e){return"Backspace"===e.key||"Delete"===e.key}const AS=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiChip"}),{avatar:r,className:a,clickable:s,color:i="default",component:o,deleteIcon:l,disabled:u=!1,icon:c,label:d,onClick:h,onDelete:p,onKeyDown:f,onKeyUp:m,size:g="medium",variant:y="filled",tabIndex:b,skipFocusWhenDisabled:v=!1,...x}=n,w=T.useRef(null),k=(0,ia.A)(w,t),S=e=>{e.stopPropagation(),p&&p(e)},I=!(!1===s||!h)||s,C=I||p?nl:o||"div",N={...n,component:C,disabled:u,size:g,color:i,iconColor:T.isValidElement(c)&&c.props.color||i,onDelete:!!p,clickable:I,variant:y},E=(e=>{const{classes:t,disabled:n,size:r,color:a,iconColor:s,onDelete:i,clickable:o,variant:l}=e,u={root:["root",l,n&&"disabled",`size${(0,jn.A)(r)}`,`color${(0,jn.A)(a)}`,o&&"clickable",o&&`clickableColor${(0,jn.A)(a)}`,i&&"deletable",i&&`deletableColor${(0,jn.A)(a)}`,`${l}${(0,jn.A)(a)}`],label:["label",`label${(0,jn.A)(r)}`],avatar:["avatar",`avatar${(0,jn.A)(r)}`,`avatarColor${(0,jn.A)(a)}`],icon:["icon",`icon${(0,jn.A)(r)}`,`iconColor${(0,jn.A)(s)}`],deleteIcon:["deleteIcon",`deleteIcon${(0,jn.A)(r)}`,`deleteIconColor${(0,jn.A)(a)}`,`deleteIcon${(0,jn.A)(l)}Color${(0,jn.A)(a)}`]};return(0,Vn.A)(u,IS,t)})(N),A=C===nl?{component:o||"div",focusVisibleClassName:E.focusVisible,...p&&{disableRipple:!0}}:{};let _=null;p&&(_=l&&T.isValidElement(l)?T.cloneElement(l,{className:(0,Bn.A)(l.props.className,E.deleteIcon),onClick:S}):(0,hr.jsx)(SS,{className:(0,Bn.A)(E.deleteIcon),onClick:S}));let $=null;r&&T.isValidElement(r)&&($=T.cloneElement(r,{className:(0,Bn.A)(E.avatar,r.props.className)}));let R=null;return c&&T.isValidElement(c)&&(R=T.cloneElement(c,{className:(0,Bn.A)(E.icon,c.props.className)})),(0,hr.jsxs)(NS,{as:C,className:(0,Bn.A)(E.root,a),disabled:!(!I||!u)||void 0,onClick:h,onKeyDown:e=>{e.currentTarget===e.target&&ES(e)&&e.preventDefault(),f&&f(e)},onKeyUp:e=>{e.currentTarget===e.target&&p&&ES(e)&&p(e),m&&m(e)},ref:k,tabIndex:v&&u?-1:b,ownerState:N,...A,...x,children:[$||R,(0,hr.jsx)(TS,{className:(0,Bn.A)(E.label),ownerState:N,children:d}),_]})})),_S=AS,$S=320,RS=["items","changeImportance","isLandscape","onChange","isValid"],DS=["getValue"];function MS(e){const{items:t,changeImportance:n="accept",onChange:r,isValid:a}=e,s=zs(e,RS);if(null==t||0===t.length)return null;const i=t.map((e=>{let{getValue:t}=e,s=zs(e,DS);const i=t({isValid:a});return(0,Po.A)({},s,{label:s.label,onClick:()=>{r(i,n,s)},disabled:!a(i)})}));return(0,hr.jsx)(Ss,(0,Po.A)({dense:!0,sx:[{maxHeight:336,maxWidth:200,overflow:"auto"},...Array.isArray(s.sx)?s.sx:[s.sx]]},s,{children:i.map((e=>(0,hr.jsx)(kS,{children:(0,hr.jsx)(_S,(0,Po.A)({},e))},e.id??e.label)))}))}const FS=e=>{const{wrapperVariant:t,onAccept:n,onClear:r,onCancel:a,onSetToday:s,view:i,views:o,onViewChange:l,value:u,onChange:c,onSelectShortcut:d,isValid:h,isLandscape:p,disabled:f,readOnly:m,children:g,slots:y,slotProps:b}=e,v=(e=>{const{classes:t,isLandscape:n}=e;return Tx({root:["root",n&&"landscape"],contentWrapper:["contentWrapper"],toolbar:["toolbar"],actionBar:["actionBar"],tabs:["tabs"],landscape:["landscape"],shortcuts:["shortcuts"]},uS,t)})(e),x=y?.actionBar??hS,w=ew({elementType:x,externalSlotProps:b?.actionBar,additionalProps:{onAccept:n,onClear:r,onCancel:a,onSetToday:s,actions:"desktop"===t?[]:["cancel","accept"]},className:v.actionBar,ownerState:(0,Po.A)({},e,{wrapperVariant:t})}),k=(0,hr.jsx)(x,(0,Po.A)({},w)),S=y?.toolbar,I=ew({elementType:S,externalSlotProps:b?.toolbar,additionalProps:{isLandscape:p,onChange:c,value:u,view:i,onViewChange:l,views:o,disabled:f,readOnly:m},className:v.toolbar,ownerState:(0,Po.A)({},e,{wrapperVariant:t})}),C=function(e){return null!==e.view}(I)&&S?(0,hr.jsx)(S,(0,Po.A)({},I)):null,N=g,T=y?.tabs,E=i&&T?(0,hr.jsx)(T,(0,Po.A)({view:i,onViewChange:l,className:v.tabs},b?.tabs)):null,A=y?.shortcuts??MS,_=ew({elementType:A,externalSlotProps:b?.shortcuts,additionalProps:{isValid:h,isLandscape:p,onChange:d},className:v.shortcuts,ownerState:{isValid:h,isLandscape:p,onChange:d,wrapperVariant:t}});return{toolbar:C,content:N,tabs:E,actionBar:k,shortcuts:i&&A?(0,hr.jsx)(A,(0,Po.A)({},_)):null}},OS=(0,Gn.Ay)("div",{name:"MuiPickersLayout",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"grid",gridAutoColumns:"max-content auto max-content",gridAutoRows:"max-content auto max-content",[`& .${cS.actionBar}`]:{gridColumn:"1 / 4",gridRow:3},variants:[{props:{isLandscape:!0},style:{[`& .${cS.toolbar}`]:{gridColumn:1,gridRow:"2 / 3"},[`.${cS.shortcuts}`]:{gridColumn:"2 / 4",gridRow:1}}},{props:{isLandscape:!0,isRtl:!0},style:{[`& .${cS.toolbar}`]:{gridColumn:3}}},{props:{isLandscape:!1},style:{[`& .${cS.toolbar}`]:{gridColumn:"2 / 4",gridRow:1},[`& .${cS.shortcuts}`]:{gridColumn:1,gridRow:"2 / 3"}}},{props:{isLandscape:!1,isRtl:!0},style:{[`& .${cS.shortcuts}`]:{gridColumn:3}}}]}),PS=(0,Gn.Ay)("div",{name:"MuiPickersLayout",slot:"ContentWrapper",overridesResolver:(e,t)=>t.contentWrapper})({gridColumn:2,gridRow:2,display:"flex",flexDirection:"column"}),LS=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiPickersLayout"}),{toolbar:r,content:a,tabs:s,actionBar:i,shortcuts:o}=FS(n),{sx:l,className:u,isLandscape:c,wrapperVariant:d}=n,h=(e=>{const{isLandscape:t,classes:n}=e;return Tx({root:["root",t&&"landscape"],contentWrapper:["contentWrapper"]},uS,n)})(n);return(0,hr.jsxs)(OS,{ref:t,sx:l,className:(0,Bn.A)(u,h.root),ownerState:n,children:[c?o:r,c?r:o,(0,hr.jsx)(PS,{className:h.contentWrapper,children:"desktop"===d?(0,hr.jsxs)(T.Fragment,{children:[a,s]}):(0,hr.jsxs)(T.Fragment,{children:[s,a]})}),i]})})),zS=["props","getOpenDialogAriaText"],BS=["ownerState"],WS=["ownerState"],VS=(0,bo.A)((0,hr.jsx)("path",{d:"M7 10l5 5 5-5z"}),"ArrowDropDown"),US=(0,bo.A)((0,hr.jsx)("path",{d:"M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"}),"ArrowLeft"),jS=(0,bo.A)((0,hr.jsx)("path",{d:"M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"}),"ArrowRight"),GS=(0,bo.A)((0,hr.jsx)("path",{d:"M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"}),"Calendar"),HS=((0,bo.A)((0,hr.jsxs)(T.Fragment,{children:[(0,hr.jsx)("path",{d:"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"}),(0,hr.jsx)("path",{d:"M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"})]}),"Clock"),(0,bo.A)((0,hr.jsx)("path",{d:"M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"}),"DateRange"),(0,bo.A)((0,hr.jsxs)(T.Fragment,{children:[(0,hr.jsx)("path",{d:"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"}),(0,hr.jsx)("path",{d:"M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"})]}),"Time"),(0,bo.A)((0,hr.jsx)("path",{d:"M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"}),"Clear")),qS=(e,t,n,r,a)=>{switch(r.type){case"year":return n.fieldYearPlaceholder({digitAmount:e.formatByString(e.date(void 0,t),a).length,format:a});case"month":return n.fieldMonthPlaceholder({contentType:r.contentType,format:a});case"day":return n.fieldDayPlaceholder({format:a});case"weekDay":return n.fieldWeekDayPlaceholder({contentType:r.contentType,format:a});case"hours":return n.fieldHoursPlaceholder({format:a});case"minutes":return n.fieldMinutesPlaceholder({format:a});case"seconds":return n.fieldSecondsPlaceholder({format:a});case"meridiem":return n.fieldMeridiemPlaceholder({format:a});default:return a}},KS=e=>{let{utils:t,timezone:n,date:r,shouldRespectLeadingZeros:a,localeText:s,localizedDigits:i,now:o,token:l,startSeparator:u}=e;if(""===l)throw new Error("MUI X: Should not call `commitToken` with an empty token");const c=Qv(t,l),d=cx(t,n,c.contentType,c.type,l),h=a?d:"digit"===c.contentType,p=null!=r&&t.isValid(r);let f=p?t.formatByString(r,l):"",m=null;if(h)if(d)m=""===f?t.formatByString(o,l).length:f.length;else{if(null==c.maxLength)throw new Error(`MUI X: The token ${l} should have a 'maxDigitNumber' property on it's adapter`);m=c.maxLength,p&&(f=nx(ax(tx(f,i),m),i))}return(0,Po.A)({},c,{format:l,maxLength:m,value:f,placeholder:qS(t,n,s,c,l),hasLeadingZerosInFormat:d,hasLeadingZerosInInput:h,startSeparator:u,endSeparator:"",modified:!1})},XS=e=>{let t=(e=>{let{utils:t,format:n}=e,r=10,a=n,s=t.expandFormat(n);for(;s!==a;)if(a=s,s=t.expandFormat(a),r-=1,r<0)throw new Error("MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.");return s})(e);e.isRtl&&e.enableAccessibleFieldDOMStructure&&(t=t.split(" ").reverse().join(" "));const n=(e=>{let{utils:t,expandedFormat:n}=e;const r=[],{start:a,end:s}=t.escapedCharacters,i=new RegExp(`(\\${a}[^\\${s}]*\\${s})+`,"g");let o=null;for(;o=i.exec(n);)r.push({start:o.index,end:i.lastIndex-1});return r})((0,Po.A)({},e,{expandedFormat:t})),r=(e=>{const{utils:t,expandedFormat:n,escapedParts:r}=e,a=t.date(void 0),s=[];let i="";const o=Object.keys(t.formatTokenMap).sort(((e,t)=>t.length-e.length)),l=/^([a-zA-Z]+)/,u=new RegExp(`^(${o.join("|")})*$`),c=new RegExp(`^(${o.join("|")})`),d=e=>r.find((t=>t.start<=e&&t.end>=e));let h=0;for(;h<n.length;){const t=d(h),r=null!=t,o=l.exec(n.slice(h))?.[1];if(!r&&null!=o&&u.test(o)){let t=o;for(;t.length>0;){const n=c.exec(t)[1];t=t.slice(n.length),s.push(KS((0,Po.A)({},e,{now:a,token:n,startSeparator:i}))),i=""}h+=o.length}else{const e=n[h];r&&t?.start===h||t?.end===h||(0===s.length?i+=e:s[s.length-1].endSeparator+=e),h+=1}}return 0===s.length&&i.length>0&&s.push({type:"empty",contentType:"letter",maxLength:null,format:"",value:"",placeholder:"",hasLeadingZerosInFormat:!1,hasLeadingZerosInInput:!1,startSeparator:i,endSeparator:"",modified:!1}),s})((0,Po.A)({},e,{expandedFormat:t,escapedParts:n}));return(e=>{let{isRtl:t,formatDensity:n,sections:r}=e;return r.map((e=>{const r=e=>{let r=e;return t&&null!==r&&r.includes(" ")&&(r=`\u2069${r}\u2066`),"spacious"===n&&["/",".","-"].includes(r)&&(r=` ${r} `),r};return e.startSeparator=r(e.startSeparator),e.endSeparator=r(e.endSeparator),e}))})((0,Po.A)({},e,{sections:r}))},YS=e=>{const t=Ix(),n=zx(),r=Sx(),a=ds(),{valueManager:s,fieldValueManager:i,valueType:o,validator:l,internalProps:u,internalProps:{value:c,defaultValue:d,referenceDate:h,onChange:p,format:f,formatDensity:m="dense",selectedSections:g,onSelectedSectionsChange:y,shouldRespectLeadingZeros:b=!1,timezone:v,enableAccessibleFieldDOMStructure:x=!1}}=e,{timezone:w,value:k,handleValueChange:S}=eS({timezone:v,value:c,defaultValue:d,onChange:p,valueManager:s}),I=T.useMemo((()=>(e=>{const t=e.date(void 0);return"0"===e.formatByString(e.setSeconds(t,0),"s")?ex:Array.from({length:10}).map(((n,r)=>e.formatByString(e.setSeconds(t,r),"s")))})(t)),[t]),C=T.useMemo((()=>((e,t,n)=>{const r=e.date(void 0,n),a=e.endOfYear(r),s=e.endOfDay(r),{maxDaysInMonth:i,longestMonth:o}=Bv(e,r).reduce(((t,n)=>{const r=e.getDaysInMonth(n);return r>t.maxDaysInMonth?{maxDaysInMonth:r,longestMonth:n}:t}),{maxDaysInMonth:0,longestMonth:null});return{year:t=>{let{format:r}=t;return{minimum:0,maximum:ux(e,n,r)?9999:99}},month:()=>({minimum:1,maximum:e.getMonth(a)+1}),day:t=>{let{currentDate:n}=t;return{minimum:1,maximum:null!=n&&e.isValid(n)?e.getDaysInMonth(n):i,longestMonth:o}},weekDay:t=>{let{format:r,contentType:a}=t;if("digit"===a){const t=Jv(e,n,r).map(Number);return{minimum:Math.min(...t),maximum:Math.max(...t)}}return{minimum:1,maximum:7}},hours:n=>{let{format:a}=n;const i=e.getHours(s);return tx(e.formatByString(e.endOfDay(r),a),t)!==i.toString()?{minimum:1,maximum:Number(tx(e.formatByString(e.startOfDay(r),a),t))}:{minimum:0,maximum:i}},minutes:()=>({minimum:0,maximum:e.getMinutes(s)}),seconds:()=>({minimum:0,maximum:e.getSeconds(s)}),meridiem:()=>({minimum:0,maximum:1}),empty:()=>({minimum:0,maximum:0})}})(t,I,w)),[t,I,w]),N=T.useCallback((function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return i.getSectionsFromValue(t,e,r,(e=>XS({utils:t,timezone:w,localeText:n,localizedDigits:I,format:f,date:e,formatDensity:m,shouldRespectLeadingZeros:b,enableAccessibleFieldDOMStructure:x,isRtl:a})))}),[i,f,n,I,a,b,t,m,w,x]),[E,A]=T.useState((()=>{const e=N(k);dx();const n={sections:e,value:k,referenceValue:s.emptyValue,tempValueStrAndroid:null},r=(e=>Math.max(...e.map((e=>Kv[e.type]??1))))(e),a=s.getInitialReferenceValue({referenceDate:h,value:k,utils:t,props:u,granularity:r,timezone:w});return(0,Po.A)({},n,{referenceValue:a})})),[_,$]=Zk({controlled:g,default:null,name:"useField",state:"selectedSections"}),R=e=>{$(e),y?.(e)},D=T.useMemo((()=>fx(_,E.sections)),[_,E.sections]),M="all"===D?0:D,F=e=>{let{value:n,referenceValue:a,sections:i}=e;if(A((e=>(0,Po.A)({},e,{sections:i,value:n,referenceValue:a,tempValueStrAndroid:null}))),s.areValuesEqual(t,E.value,n))return;const o={validationError:l({adapter:r,value:n,props:(0,Po.A)({},u,{value:n,timezone:w})})};S(n,o)},O=(e,t)=>{const n=[...E.sections];return n[e]=(0,Po.A)({},n[e],{value:t,modified:!0}),n};return T.useEffect((()=>{const e=N(E.value);dx(),A((t=>(0,Po.A)({},t,{sections:e})))}),[f,t.locale,a]),T.useEffect((()=>{let e;e=!s.areValuesEqual(t,E.value,k)||s.getTimezone(t,E.value)!==s.getTimezone(t,k),e&&A((e=>(0,Po.A)({},e,{value:k,referenceValue:i.updateReferenceValue(t,k,e.referenceValue),sections:N(k)})))}),[k]),{state:E,activeSectionIndex:M,parsedSelectedSections:D,setSelectedSections:R,clearValue:()=>{F({value:s.emptyValue,referenceValue:E.referenceValue,sections:N(s.emptyValue)})},clearActiveSection:()=>{if(null==M)return;const e=E.sections[M],n=i.getActiveDateManager(t,E,e),r=n.getSections(E.sections).filter((e=>""!==e.value)).length===(""===e.value?0:1),a=O(M,""),s=r?null:t.getInvalidDate(),o=n.getNewValuesFromNewActiveDate(s);F((0,Po.A)({},o,{sections:a}))},updateSectionValue:e=>{let{activeSection:n,newSectionValue:r,shouldGoToNextSection:a}=e;a&&M<E.sections.length-1&&R(M+1);const s=i.getActiveDateManager(t,E,n),o=O(M,r),l=s.getSections(o),u=((e,t,n)=>{const r=t.some((e=>"day"===e.type)),a=[],s=[];for(let l=0;l<t.length;l+=1){const e=t[l];r&&"weekDay"===e.type||(a.push(e.format),s.push(ox(e,"non-input",n)))}const i=a.join(" "),o=s.join(" ");return e.parse(o,i)})(t,l,I);let c,d;if(null!=u&&t.isValid(u)){const e=px(t,w,u,l,s.referenceDate,!0);c=s.getNewValuesFromNewActiveDate(e),d=!0}else c=s.getNewValuesFromNewActiveDate(u),d=(null!=u&&!t.isValid(u))!==(null!=s.date&&!t.isValid(s.date));return d?F((0,Po.A)({},c,{sections:o})):A((e=>(0,Po.A)({},e,c,{sections:o,tempValueStrAndroid:null})))},updateValueFromValueStr:e=>{const r=i.parseValueStr(e,E.referenceValue,((e,r)=>{const s=t.parse(e,f);if(null==s||!t.isValid(s))return null;const i=XS({utils:t,timezone:w,localeText:n,localizedDigits:I,format:f,date:s,formatDensity:m,shouldRespectLeadingZeros:b,enableAccessibleFieldDOMStructure:x,isRtl:a});return px(t,w,s,i,r,!1)})),s=i.updateReferenceValue(t,r,E.referenceValue);F({value:r,referenceValue:s,sections:N(r,E.sections)})},setTempAndroidValueStr:e=>A((t=>(0,Po.A)({},t,{tempValueStrAndroid:e}))),getSectionsFromValue:N,sectionsValueBoundaries:C,localizedDigits:I,timezone:w}},QS=e=>null!=e.saveQuery,JS=e=>{let{sections:t,updateSectionValue:n,sectionsValueBoundaries:r,localizedDigits:a,setTempAndroidValueStr:s,timezone:i}=e;const o=Ix(),[l,u]=T.useState(null),c=Pk((()=>u(null)));T.useEffect((()=>{null!=l&&t[l.sectionIndex]?.type!==l.sectionType&&c()}),[t,l,c]),T.useEffect((()=>{if(null!=l){const e=setTimeout((()=>c()),5e3);return()=>{clearTimeout(e)}}return()=>{}}),[l,c]);const d=(e,n,r)=>{let{keyPressed:a,sectionIndex:s}=e;const i=a.toLowerCase(),o=t[s];if(null!=l&&(!r||r(l.value))&&l.sectionIndex===s){const e=`${l.value}${i}`,t=n(e,o);if(!QS(t))return u({sectionIndex:s,value:e,sectionType:o.type}),t}const d=n(i,o);return QS(d)&&!d.saveQuery?(c(),null):(u({sectionIndex:s,value:i,sectionType:o.type}),QS(d)?null:d)};return{applyCharacterEditing:Pk((e=>{const l=t[e.sectionIndex],u=rx(e.keyPressed,a)?(e=>{const t=(e,t)=>{const n=tx(e,a),s=Number(n),i=r[t.type]({currentDate:null,format:t.format,contentType:t.contentType});if(s>i.maximum)return{saveQuery:!1};if(s<i.minimum)return{saveQuery:!0};const l=10*s>i.maximum||n.length===i.maximum.toString().length;return{sectionValue:sx(o,s,i,a,t),shouldGoToNextSection:l}};return d(e,((e,n)=>{if("digit"===n.contentType||"digit-with-letter"===n.contentType)return t(e,n);if("month"===n.type){const r=cx(o,i,"digit","month","MM"),a=t(e,{type:n.type,format:"MM",hasLeadingZerosInFormat:r,hasLeadingZerosInInput:!0,contentType:"digit",maxLength:2});if(QS(a))return a;const s=lx(o,a.sectionValue,"MM",n.format);return(0,Po.A)({},a,{sectionValue:s})}if("weekDay"===n.type){const r=t(e,n);if(QS(r))return r;const a=Jv(o,i,n.format)[Number(r.sectionValue)-1];return(0,Po.A)({},r,{sectionValue:a})}return{saveQuery:!1}}),(e=>rx(e,a)))})((0,Po.A)({},e,{keyPressed:nx(e.keyPressed,a)})):(e=>{const t=(e,t,n)=>{const r=t.filter((e=>e.toLowerCase().startsWith(n)));return 0===r.length?{saveQuery:!1}:{sectionValue:r[0],shouldGoToNextSection:1===r.length}},n=(e,n,r,a)=>{const s=e=>Zv(o,i,n.type,e);if("letter"===n.contentType)return t(n.format,s(n.format),e);if(r&&null!=a&&"letter"===Qv(o,r).contentType){const n=s(r),i=t(0,n,e);return QS(i)?{saveQuery:!1}:(0,Po.A)({},i,{sectionValue:a(i.sectionValue,n)})}return{saveQuery:!1}};return d(e,((e,t)=>{switch(t.type){case"month":{const r=e=>lx(o,e,o.formats.month,t.format);return n(e,t,o.formats.month,r)}case"weekDay":{const r=(e,t)=>t.indexOf(e).toString();return n(e,t,o.formats.weekday,r)}case"meridiem":return n(e,t);default:return{saveQuery:!1}}}))})(e);null!=u?n({activeSection:l,newSectionValue:u.sectionValue,shouldGoToNextSection:u.shouldGoToNextSection}):s(null)})),resetCharacterQuery:c}},ZS=e=>{const{internalProps:{disabled:t,readOnly:n=!1},forwardedProps:{sectionListRef:r,onBlur:a,onClick:s,onFocus:i,onInput:o,onPaste:l,focused:u,autoFocus:c=!1},fieldValueManager:d,applyCharacterEditing:h,resetCharacterQuery:p,setSelectedSections:f,parsedSelectedSections:m,state:g,clearActiveSection:y,clearValue:b,updateSectionValue:v,updateValueFromValueStr:x,sectionOrder:w,areAllSectionsEmpty:k,sectionsValueBoundaries:S}=e,I=T.useRef(null),C=qx(r,I),N=zx(),E=Ix(),A=uw(),[_,$]=T.useState(!1),R=T.useMemo((()=>({syncSelectionToDOM:()=>{if(!I.current)return;const e=document.getSelection();if(!e)return;if(null==m)return e.rangeCount>0&&I.current.getRoot().contains(e.getRangeAt(0).startContainer)&&e.removeAllRanges(),void(_&&I.current.getRoot().blur());if(!I.current.getRoot().contains(Bk(document)))return;const t=new window.Range;let n;if("all"===m)n=I.current.getRoot();else{n="empty"===g.sections[m].type?I.current.getSectionContainer(m):I.current.getSectionContent(m)}t.selectNodeContents(n),n.focus(),e.removeAllRanges(),e.addRange(t)},getActiveSectionIndexFromDOM:()=>{const e=Bk(document);return e&&I.current&&I.current.getRoot().contains(e)?I.current.getSectionIndexFromDOMElement(e):null},focusField:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(!I.current)return;const t=fx(e,g.sections);$(!0),I.current.getSectionContent(t).focus()},setSelectedSections:e=>{if(!I.current)return;const t=fx(e,g.sections);$(null!==("all"===t?0:t)),f(e)},isFieldFocused:()=>{const e=Bk(document);return!!I.current&&I.current.getRoot().contains(e)}})),[m,f,g.sections,_]),D=Pk((e=>{if(!I.current)return;const t=g.sections[e];I.current.getSectionContent(e).innerHTML=t.value||t.placeholder,R.syncSelectionToDOM()})),M=Pk((function(e){if(!e.isDefaultPrevented()&&I.current){$(!0);for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];if(s?.(e,...n),"all"===m)setTimeout((()=>{const e=document.getSelection().getRangeAt(0).startOffset;if(0===e)return void f(w.startIndex);let t=0,n=0;for(;n<e&&t<g.sections.length;){const e=g.sections[t];t+=1,n+=`${e.startSeparator}${e.value||e.placeholder}${e.endSeparator}`.length}f(t-1)}));else if(_){I.current.getRoot().contains(e.target)||f(w.startIndex)}else $(!0),f(w.startIndex)}})),F=Pk((e=>{if(o?.(e),!I.current||"all"!==m)return;const t=e.target.textContent??"";I.current.getRoot().innerHTML=g.sections.map((e=>`${e.startSeparator}${e.value||e.placeholder}${e.endSeparator}`)).join(""),R.syncSelectionToDOM(),0===t.length||10===t.charCodeAt(0)?(p(),b(),f("all")):t.length>1?x(t):h({keyPressed:t,sectionIndex:0})})),O=Pk((e=>{if(l?.(e),n||"all"!==m)return void e.preventDefault();const t=e.clipboardData.getData("text");e.preventDefault(),p(),x(t)})),P=Pk((function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(i?.(...t),_||!I.current)return;$(!0);null!=I.current.getSectionIndexFromDOMElement(Bk(document))||f(w.startIndex)})),L=Pk((function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];a?.(...t),setTimeout((()=>{if(!I.current)return;const e=Bk(document);!I.current.getRoot().contains(e)&&($(!1),f(null))}))})),z=Pk((e=>t=>{t.isDefaultPrevented()||f(e)})),B=Pk((e=>{e.preventDefault()})),W=Pk((e=>()=>{f(e)})),V=Pk((e=>{if(e.preventDefault(),n||t||"number"!==typeof m)return;const r=g.sections[m],a=e.clipboardData.getData("text"),s=/^[a-zA-Z]+$/.test(a),i=/^[0-9]+$/.test(a),o=/^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(a);"letter"===r.contentType&&s||"digit"===r.contentType&&i||"digit-with-letter"===r.contentType&&o?(p(),v({activeSection:r,newSectionValue:a,shouldGoToNextSection:!0})):s||i||(p(),x(a))})),U=Pk((e=>{e.preventDefault(),e.dataTransfer.dropEffect="none"})),j=Pk((e=>{if(!I.current)return;const t=e.target,r=t.textContent??"",a=I.current.getSectionIndexFromDOMElement(t),s=g.sections[a];if(!n&&I.current){if(0===r.length){if(""===s.value)return void D(a);const t=e.nativeEvent.inputType;return"insertParagraph"===t||"insertLineBreak"===t?void D(a):(p(),void y())}h({keyPressed:r,sectionIndex:a}),D(a)}else D(a)}));Ok((()=>{if(_&&I.current)if("all"===m)I.current.getRoot().focus();else if("number"===typeof m){const e=I.current.getSectionContent(m);e&&e.focus()}}),[m,_]);const G=T.useMemo((()=>g.sections.reduce(((e,t)=>(e[t.type]=S[t.type]({currentDate:null,contentType:t.contentType,format:t.format}),e)),{})),[S,g.sections]),H="all"===m,q=T.useMemo((()=>g.sections.map(((e,r)=>{const a=!H&&!t&&!n;return{container:{"data-sectionindex":r,onClick:z(r)},content:{tabIndex:H||r>0?-1:0,contentEditable:!H&&!t&&!n,role:"spinbutton",id:`${A}-${e.type}`,"aria-labelledby":`${A}-${e.type}`,"aria-readonly":n,"aria-valuenow":gx(e,E),"aria-valuemin":G[e.type].minimum,"aria-valuemax":G[e.type].maximum,"aria-valuetext":e.value?mx(e,E):N.empty,"aria-label":N[e.type],"aria-disabled":t,spellCheck:!a&&void 0,autoCapitalize:a?"off":void 0,autoCorrect:a?"off":void 0,[parseInt(T.version,10)>=17?"enterKeyHint":"enterkeyhint"]:a?"next":void 0,children:e.value||e.placeholder,onInput:j,onPaste:V,onFocus:W(r),onDragOver:U,onMouseUp:B,inputMode:"letter"===e.contentType?"text":"numeric"},before:{children:e.startSeparator},after:{children:e.endSeparator}}}))),[g.sections,W,V,U,j,z,B,t,n,H,N,E,G,A]),K=Pk((e=>{x(e.target.value)})),X=T.useMemo((()=>k?"":d.getV7HiddenInputValueFromSections(g.sections)),[k,g.sections,d]);return T.useEffect((()=>{if(null==I.current)throw new Error(["MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`","You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.","","If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:","","<DatePicker slots={{ textField: MyCustomTextField }} />","","Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element"].join("\n"));c&&I.current&&I.current.getSectionContent(w.startIndex).focus()}),[]),{interactions:R,returnedValue:{autoFocus:c,readOnly:n,focused:u??_,sectionListRef:C,onBlur:L,onClick:M,onFocus:P,onInput:F,onPaste:O,enableAccessibleFieldDOMStructure:!0,elements:q,tabIndex:0===m?-1:0,contentEditable:H,value:X,onChange:K,areAllSectionsEmpty:k}}},eI=e=>e.replace(/[\u2066\u2067\u2068\u2069]/g,""),tI=e=>{const t=ds(),n=T.useRef(),r=T.useRef(),{forwardedProps:{onFocus:a,onClick:s,onPaste:i,onBlur:o,inputRef:l,placeholder:u},internalProps:{readOnly:c=!1,disabled:d=!1},parsedSelectedSections:h,activeSectionIndex:p,state:f,fieldValueManager:m,valueManager:g,applyCharacterEditing:y,resetCharacterQuery:b,updateSectionValue:v,updateValueFromValueStr:x,clearActiveSection:w,clearValue:k,setTempAndroidValueStr:S,setSelectedSections:I,getSectionsFromValue:C,areAllSectionsEmpty:N,localizedDigits:E}=e,A=T.useRef(null),_=qx(l,A),$=T.useMemo((()=>((e,t,n)=>{let r=0,a=n?1:0;const s=[];for(let i=0;i<e.length;i+=1){const o=e[i],l=ox(o,n?"input-rtl":"input-ltr",t),u=`${o.startSeparator}${l}${o.endSeparator}`,c=eI(u).length,d=u.length,h=eI(l),p=a+(""===h?0:l.indexOf(h[0]))+o.startSeparator.length,f=p+h.length;s.push((0,Po.A)({},o,{start:r,end:r+c,startInInput:p,endInInput:f})),r+=c,a+=d}return s})(f.sections,E,t)),[f.sections,E,t]),R=T.useMemo((()=>({syncSelectionToDOM:()=>{if(!A.current)return;if(null==h)return void(A.current.scrollLeft&&(A.current.scrollLeft=0));if(A.current!==Bk(document))return;const e=A.current.scrollTop;if("all"===h)A.current.select();else{const e=$[h],t="empty"===e.type?e.startInInput-e.startSeparator.length:e.startInInput,n="empty"===e.type?e.endInInput+e.endSeparator.length:e.endInInput;t===A.current.selectionStart&&n===A.current.selectionEnd||A.current===Bk(document)&&A.current.setSelectionRange(t,n),clearTimeout(r.current),r.current=setTimeout((()=>{!A.current||A.current!==Bk(document)||A.current.selectionStart!==A.current.selectionEnd||A.current.selectionStart===t&&A.current.selectionEnd===n||R.syncSelectionToDOM()}))}A.current.scrollTop=e},getActiveSectionIndexFromDOM:()=>{const e=A.current.selectionStart??0,t=A.current.selectionEnd??0;if(0===e&&0===t)return null;const n=e<=$[0].startInInput?1:$.findIndex((t=>t.startInInput-t.startSeparator.length>e));return-1===n?$.length-1:n-1},focusField:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;A.current?.focus(),I(e)},setSelectedSections:e=>I(e),isFieldFocused:()=>A.current===Bk(document)})),[A,h,$,I]),D=()=>{const e=A.current.selectionStart??0;let t;t=e<=$[0].startInInput||e>=$[$.length-1].endInInput?1:$.findIndex((t=>t.startInInput-t.startSeparator.length>e));const n=-1===t?$.length-1:t-1;I(n)},M=Pk((function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];a?.(...t);const s=A.current;clearTimeout(n.current),n.current=setTimeout((()=>{s&&s===A.current&&null==p&&(s.value.length&&Number(s.selectionEnd)-Number(s.selectionStart)===s.value.length?I("all"):D())}))})),F=Pk((function(e){if(!e.isDefaultPrevented()){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];s?.(e,...n),D()}})),O=Pk((e=>{if(i?.(e),e.preventDefault(),c||d)return;const t=e.clipboardData.getData("text");if("number"===typeof h){const e=f.sections[h],n=/^[a-zA-Z]+$/.test(t),r=/^[0-9]+$/.test(t),a=/^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(t);if("letter"===e.contentType&&n||"digit"===e.contentType&&r||"digit-with-letter"===e.contentType&&a)return b(),void v({activeSection:e,newSectionValue:t,shouldGoToNextSection:!0});if(n||r)return}b(),x(t)})),P=Pk((function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];o?.(...t),I(null)})),L=Pk((e=>{if(c)return;const n=e.target.value;if(""===n)return b(),void k();const r=e.nativeEvent.data,a=r&&r.length>1,s=a?r:n,i=eI(s);if(null==p||a)return void x(a?r:i);let o;if("all"===h&&1===i.length)o=i;else{const e=eI(m.getV6InputValueFromSections($,E,t));let n=-1,r=-1;for(let t=0;t<e.length;t+=1)-1===n&&e[t]!==i[t]&&(n=t),-1===r&&e[e.length-t-1]!==i[i.length-t-1]&&(r=t);const a=$[p];if(n<a.start||e.length-r-1>a.end)return;const s=i.length-e.length+a.end-eI(a.endSeparator||"").length;o=i.slice(a.start+eI(a.startSeparator||"").length,s)}if(0===o.length)return navigator.userAgent.toLowerCase().includes("android")&&S(s),b(),void w();y({keyPressed:o,sectionIndex:p})})),z=T.useMemo((()=>void 0!==u?u:m.getV6InputValueFromSections(C(g.emptyValue),E,t)),[u,m,C,g.emptyValue,E,t]),B=T.useMemo((()=>f.tempValueStrAndroid??m.getV6InputValueFromSections(f.sections,E,t)),[f.sections,m,f.tempValueStrAndroid,E,t]);T.useEffect((()=>(A.current&&A.current===Bk(document)&&I("all"),()=>{clearTimeout(n.current),clearTimeout(r.current)})),[]);const W=T.useMemo((()=>null==p||"letter"===f.sections[p].contentType?"text":"numeric"),[p,f.sections]),V=A.current&&A.current===Bk(document);return{interactions:R,returnedValue:{readOnly:c,onBlur:P,onClick:F,onFocus:M,onPaste:O,inputRef:_,enableAccessibleFieldDOMStructure:!1,placeholder:z,inputMode:W,autoComplete:"off",value:!V&&N?"":B,onChange:L}}},nI=["disablePast","disableFuture","minDate","maxDate","shouldDisableDate","shouldDisableMonth","shouldDisableYear"],rI=["disablePast","disableFuture","minTime","maxTime","shouldDisableTime","minutesStep","ampm","disableIgnoringDatePartForTimeValidation"],aI=["minDateTime","maxDateTime"],sI=[...nI,...rI,...aI],iI=e=>sI.reduce(((t,n)=>(e.hasOwnProperty(n)&&(t[n]=e[n]),t)),{}),oI=["value","defaultValue","referenceDate","format","formatDensity","onChange","timezone","onError","shouldRespectLeadingZeros","selectedSections","onSelectedSectionsChange","unstableFieldRef","enableAccessibleFieldDOMStructure","disabled","readOnly","dateSeparator"],lI=e=>{const t=(e=>{const t=Ix(),n=Cx();return(0,Po.A)({},e,{disablePast:e.disablePast??!1,disableFuture:e.disableFuture??!1,format:e.format??t.formats.keyboardDate,minDate:zv(t,e.minDate,n.minDate),maxDate:zv(t,e.maxDate,n.maxDate)})})(e),{forwardedProps:n,internalProps:r}=((e,t)=>{const n=(0,Po.A)({},e),r={},a=e=>{n.hasOwnProperty(e)&&(r[e]=n[e],delete n[e])};return oI.forEach(a),"date"===t?nI.forEach(a):"time"===t?rI.forEach(a):"date-time"===t&&(nI.forEach(a),rI.forEach(a),aI.forEach(a)),{forwardedProps:n,internalProps:r}})(t,"date");return(e=>{const t=Ix(),{internalProps:n,internalProps:{unstableFieldRef:r,minutesStep:a,enableAccessibleFieldDOMStructure:s=!1,disabled:i=!1,readOnly:o=!1},forwardedProps:{onKeyDown:l,error:u,clearable:c,onClear:d},fieldValueManager:h,valueManager:p,validator:f}=e,m=ds(),g=YS(e),{state:y,activeSectionIndex:b,parsedSelectedSections:v,setSelectedSections:x,clearValue:w,clearActiveSection:k,updateSectionValue:S,setTempAndroidValueStr:I,sectionsValueBoundaries:C,localizedDigits:N,timezone:E}=g,A=JS({sections:y.sections,updateSectionValue:S,sectionsValueBoundaries:C,localizedDigits:N,setTempAndroidValueStr:I,timezone:E}),{resetCharacterQuery:_}=A,$=p.areValuesEqual(t,y.value,p.emptyValue),R=s?ZS:tI,D=T.useMemo((()=>((e,t)=>{const n={};if(!t)return e.forEach(((t,r)=>{const a=0===r?null:r-1,s=r===e.length-1?null:r+1;n[r]={leftIndex:a,rightIndex:s}})),{neighbors:n,startIndex:0,endIndex:e.length-1};const r={},a={};let s=0,i=0,o=e.length-1;for(;o>=0;){i=e.findIndex(((e,t)=>t>=s&&e.endSeparator?.includes(" ")&&" / "!==e.endSeparator)),-1===i&&(i=e.length-1);for(let e=i;e>=s;e-=1)a[e]=o,r[o]=e,o-=1;s=i+1}return e.forEach(((t,s)=>{const i=a[s],o=0===i?null:r[i-1],l=i===e.length-1?null:r[i+1];n[s]={leftIndex:o,rightIndex:l}})),{neighbors:n,startIndex:r[0],endIndex:r[e.length-1]}})(y.sections,m&&!s)),[y.sections,m,s]),{returnedValue:M,interactions:F}=R((0,Po.A)({},e,g,A,{areAllSectionsEmpty:$,sectionOrder:D})),O=Pk((e=>{if(l?.(e),!i)switch(!0){case(e.ctrlKey||e.metaKey)&&"a"===e.key.toLowerCase()&&!e.shiftKey&&!e.altKey:e.preventDefault(),x("all");break;case"ArrowRight"===e.key:if(e.preventDefault(),null==v)x(D.startIndex);else if("all"===v)x(D.endIndex);else{const e=D.neighbors[v].rightIndex;null!==e&&x(e)}break;case"ArrowLeft"===e.key:if(e.preventDefault(),null==v)x(D.endIndex);else if("all"===v)x(D.startIndex);else{const e=D.neighbors[v].leftIndex;null!==e&&x(e)}break;case"Delete"===e.key:if(e.preventDefault(),o)break;null==v||"all"===v?w():k(),_();break;case["ArrowUp","ArrowDown","Home","End","PageUp","PageDown"].includes(e.key):{if(e.preventDefault(),o||null==b)break;const n=y.sections[b],r=h.getActiveDateManager(t,y,n),s=ix(t,E,n,e.key,C,N,r.date,{minutesStep:a});S({activeSection:n,newSectionValue:s,shouldGoToNextSection:!1});break}}}));Ok((()=>{F.syncSelectionToDOM()}));const P=Jk((0,Po.A)({},n,{value:y.value,timezone:E}),f,p.isSameError,p.defaultErrorState),L=T.useMemo((()=>void 0!==u?u:p.hasError(P)),[p,P,u]);T.useEffect((()=>{L||null!=b||_()}),[y.referenceValue,b,L]),T.useEffect((()=>{null!=y.tempValueStrAndroid&&null!=b&&(_(),k())}),[y.sections]),T.useImperativeHandle(r,(()=>({getSections:()=>y.sections,getActiveSectionIndex:F.getActiveSectionIndexFromDOM,setSelectedSections:F.setSelectedSections,focusField:F.focusField,isFieldFocused:F.isFieldFocused})));const z={onKeyDown:O,onClear:Pk((function(e){e.preventDefault();for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];d?.(e,...n),w(),F.isFieldFocused()?x(D.startIndex):F.focusField(0)})),error:L,clearable:Boolean(c&&!$&&!o&&!i)},B={disabled:i,readOnly:o};return(0,Po.A)({},e.forwardedProps,z,B,M)})({forwardedProps:n,internalProps:r,valueManager:bx,fieldValueManager:vx,validator:Hx,valueType:"date"})},uI=["clearable","onClear","InputProps","sx","slots","slotProps"],cI=["ownerState"];function dI(e){return Rx("MuiPickersTextField",e)}Dx("MuiPickersTextField",["root","focused","disabled","error","required"]);function hI(e){return Rx("MuiPickersInputBase",e)}const pI=Dx("MuiPickersInputBase",["root","focused","disabled","error","notchedOutline","sectionContent","sectionBefore","sectionAfter","adornedStart","adornedEnd","input"]);function fI(e){return Rx("MuiPickersOutlinedInput",e)}const mI=(0,Po.A)({},pI,Dx("MuiPickersOutlinedInput",["root","notchedOutline","input"])),gI=["children","className","label","notched","shrink"],yI=(0,Gn.Ay)("fieldset",{name:"MuiPickersOutlinedInput",slot:"NotchedOutline",overridesResolver:(e,t)=>t.notchedOutline})((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{textAlign:"left",position:"absolute",bottom:0,right:0,top:-5,left:0,margin:0,padding:"0 8px",pointerEvents:"none",borderRadius:"inherit",borderStyle:"solid",borderWidth:1,overflow:"hidden",minWidth:"0%",borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}})),bI=(0,Gn.Ay)("span")((e=>{let{theme:t}=e;return{fontFamily:t.typography.fontFamily,fontSize:"inherit"}})),vI=(0,Gn.Ay)("legend")((e=>{let{theme:t}=e;return{float:"unset",width:"auto",overflow:"hidden",variants:[{props:{withLabel:!1},style:{padding:0,lineHeight:"11px",transition:t.transitions.create("width",{duration:150,easing:t.transitions.easing.easeOut})}},{props:{withLabel:!0},style:{display:"block",padding:0,height:11,fontSize:"0.75em",visibility:"hidden",maxWidth:.01,transition:t.transitions.create("max-width",{duration:50,easing:t.transitions.easing.easeOut}),whiteSpace:"nowrap","& > span":{paddingLeft:5,paddingRight:5,display:"inline-block",opacity:0,visibility:"visible"}}},{props:{withLabel:!0,notched:!0},style:{maxWidth:"100%",transition:t.transitions.create("max-width",{duration:100,easing:t.transitions.easing.easeOut,delay:50})}}]}}));function xI(e){const{className:t,label:n}=e,r=zs(e,gI),a=null!=n&&""!==n,s=(0,Po.A)({},e,{withLabel:a});return(0,hr.jsx)(yI,(0,Po.A)({"aria-hidden":!0,className:t},r,{ownerState:s,children:(0,hr.jsx)(vI,{ownerState:s,children:a?(0,hr.jsx)(bI,{children:n}):(0,hr.jsx)(bI,{className:"notranslate",children:"\u200b"})})}))}function wI(e){if("string"!==typeof e)throw new Error(function(e){let t="https://mui.com/production-error/?code="+e;for(let n=1;n<arguments.length;n+=1)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified MUI error #"+e+"; visit "+t+" for the full message."}(7));return e.charAt(0).toUpperCase()+e.slice(1)}const kI={border:0,clip:"rect(0 0 0 0)",height:"1px",margin:"-1px",overflow:"hidden",padding:0,position:"absolute",whiteSpace:"nowrap",width:"1px"};function SI(e){return Rx("MuiPickersSectionList",e)}const II=Dx("MuiPickersSectionList",["root","section","sectionContent"]),CI=["slots","slotProps","elements","sectionListRef"],NI=(0,Gn.Ay)("div",{name:"MuiPickersSectionList",slot:"Root",overridesResolver:(e,t)=>t.root})({direction:"ltr /*! @noflip */",outline:"none"}),TI=(0,Gn.Ay)("span",{name:"MuiPickersSectionList",slot:"Section",overridesResolver:(e,t)=>t.section})({}),EI=(0,Gn.Ay)("span",{name:"MuiPickersSectionList",slot:"SectionSeparator",overridesResolver:(e,t)=>t.sectionSeparator})({whiteSpace:"pre"}),AI=(0,Gn.Ay)("span",{name:"MuiPickersSectionList",slot:"SectionContent",overridesResolver:(e,t)=>t.sectionContent})({outline:"none"});function _I(e){const{slots:t,slotProps:n,element:r,classes:a}=e,s=t?.section??TI,i=ew({elementType:s,externalSlotProps:n?.section,externalForwardedProps:r.container,className:a.section,ownerState:{}}),o=t?.sectionContent??AI,l=ew({elementType:o,externalSlotProps:n?.sectionContent,externalForwardedProps:r.content,additionalProps:{suppressContentEditableWarning:!0},className:a.sectionContent,ownerState:{}}),u=t?.sectionSeparator??EI,c=ew({elementType:u,externalSlotProps:n?.sectionSeparator,externalForwardedProps:r.before,ownerState:{position:"before"}}),d=ew({elementType:u,externalSlotProps:n?.sectionSeparator,externalForwardedProps:r.after,ownerState:{position:"after"}});return(0,hr.jsxs)(s,(0,Po.A)({},i,{children:[(0,hr.jsx)(u,(0,Po.A)({},c)),(0,hr.jsx)(o,(0,Po.A)({},l)),(0,hr.jsx)(u,(0,Po.A)({},d))]}))}const $I=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiPickersSectionList"}),{slots:r,slotProps:a,elements:s,sectionListRef:i}=n,o=zs(n,CI),l=(e=>{const{classes:t}=e;return Tx({root:["root"],section:["section"],sectionContent:["sectionContent"]},SI,t)})(n),u=T.useRef(null),c=qx(t,u),d=e=>{if(!u.current)throw new Error(`MUI X: Cannot call sectionListRef.${e} before the mount of the component.`);return u.current};T.useImperativeHandle(i,(()=>({getRoot:()=>d("getRoot"),getSectionContainer:e=>d("getSectionContainer").querySelector(`.${II.section}[data-sectionindex="${e}"]`),getSectionContent:e=>d("getSectionContent").querySelector(`.${II.section}[data-sectionindex="${e}"] .${II.sectionContent}`),getSectionIndexFromDOMElement(e){const t=d("getSectionIndexFromDOMElement");if(null==e||!t.contains(e))return null;let n=null;return e.classList.contains(II.section)?n=e:e.classList.contains(II.sectionContent)&&(n=e.parentElement),null==n?null:Number(n.dataset.sectionindex)}})));const h=r?.root??NI,p=ew({elementType:h,externalSlotProps:a?.root,externalForwardedProps:o,additionalProps:{ref:c,suppressContentEditableWarning:!0},className:l.root,ownerState:{}});return(0,hr.jsx)(h,(0,Po.A)({},p,{children:p.contentEditable?s.map((e=>{let{content:t,before:n,after:r}=e;return`${n.children}${t.children}${r.children}`})).join(""):(0,hr.jsx)(T.Fragment,{children:s.map(((e,t)=>(0,hr.jsx)(_I,{slots:r,slotProps:a,element:e,classes:l},t)))})}))})),RI=["elements","areAllSectionsEmpty","defaultValue","label","value","onChange","id","autoFocus","endAdornment","startAdornment","renderSuffix","slots","slotProps","contentEditable","tabIndex","onInput","onPaste","onKeyDown","fullWidth","name","readOnly","inputProps","inputRef","sectionListRef"],DI=(0,Gn.Ay)("div",{name:"MuiPickersInputBase",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;return(0,Po.A)({},t.typography.body1,{color:(t.vars||t).palette.text.primary,cursor:"text",padding:0,display:"flex",justifyContent:"flex-start",alignItems:"center",position:"relative",boxSizing:"border-box",letterSpacing:(n=.15/16,Math.round(1e5*n)/1e5)+"em",variants:[{props:{fullWidth:!0},style:{width:"100%"}}]});var n})),MI=(0,Gn.Ay)(NI,{name:"MuiPickersInputBase",slot:"SectionsContainer",overridesResolver:(e,t)=>t.sectionsContainer})((e=>{let{theme:t}=e;return{padding:"4px 0 5px",fontFamily:t.typography.fontFamily,fontSize:"inherit",lineHeight:"1.4375em",flexGrow:1,outline:"none",display:"flex",flexWrap:"nowrap",overflow:"hidden",letterSpacing:"inherit",width:"182px",variants:[{props:{isRtl:!0},style:{textAlign:"right /*! @noflip */"}},{props:{size:"small"},style:{paddingTop:1}},{props:{adornedStart:!1,focused:!1,filled:!1},style:{color:"currentColor",opacity:0}},{props:e=>{let{adornedStart:t,focused:n,filled:r,label:a}=e;return!t&&!n&&!r&&null==a},style:t.vars?{opacity:t.vars.opacity.inputPlaceholder}:{opacity:"light"===t.palette.mode?.42:.5}}]}})),FI=(0,Gn.Ay)(TI,{name:"MuiPickersInputBase",slot:"Section",overridesResolver:(e,t)=>t.section})((e=>{let{theme:t}=e;return{fontFamily:t.typography.fontFamily,fontSize:"inherit",letterSpacing:"inherit",lineHeight:"1.4375em",display:"flex"}})),OI=(0,Gn.Ay)(AI,{name:"MuiPickersInputBase",slot:"SectionContent",overridesResolver:(e,t)=>t.content})((e=>{let{theme:t}=e;return{fontFamily:t.typography.fontFamily,lineHeight:"1.4375em",letterSpacing:"inherit",width:"fit-content",outline:"none"}})),PI=(0,Gn.Ay)(EI,{name:"MuiPickersInputBase",slot:"Separator",overridesResolver:(e,t)=>t.separator})((()=>({whiteSpace:"pre",letterSpacing:"inherit"}))),LI=(0,Gn.Ay)("input",{name:"MuiPickersInputBase",slot:"Input",overridesResolver:(e,t)=>t.hiddenInput})((0,Po.A)({},kI)),zI=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiPickersInputBase"}),{elements:r,areAllSectionsEmpty:a,value:s,onChange:i,id:o,endAdornment:l,startAdornment:u,renderSuffix:c,slots:d,slotProps:h,contentEditable:p,tabIndex:f,onInput:m,onPaste:g,onKeyDown:y,name:b,readOnly:v,inputProps:x,inputRef:w,sectionListRef:k}=n,S=zs(n,RI),I=qx(t,T.useRef(null)),C=qx(x?.ref,w),N=ds(),E=sa();if(!E)throw new Error("MUI X: PickersInputBase should always be used inside a PickersTextField component");T.useEffect((()=>{E&&E.setAdornedStart(Boolean(u))}),[E,u]),T.useEffect((()=>{E&&(a?E.onEmpty():E.onFilled())}),[E,a]);const A=(0,Po.A)({},n,E,{isRtl:N}),_=(e=>{const{focused:t,disabled:n,error:r,classes:a,fullWidth:s,readOnly:i,color:o,size:l,endAdornment:u,startAdornment:c}=e;return Tx({root:["root",t&&!n&&"focused",n&&"disabled",i&&"readOnly",r&&"error",s&&"fullWidth",`color${wI(o)}`,"small"===l&&"inputSizeSmall",Boolean(c)&&"adornedStart",Boolean(u)&&"adornedEnd"],notchedOutline:["notchedOutline"],input:["input"],sectionsContainer:["sectionsContainer"],sectionContent:["sectionContent"],sectionBefore:["sectionBefore"],sectionAfter:["sectionAfter"]},hI,a)})(A),$=d?.root||DI,R=ew({elementType:$,externalSlotProps:h?.root,externalForwardedProps:S,additionalProps:{"aria-invalid":E.error,ref:I},className:_.root,ownerState:A}),D=d?.input||MI;return(0,hr.jsxs)($,(0,Po.A)({},R,{children:[u,(0,hr.jsx)($I,{sectionListRef:k,elements:r,contentEditable:p,tabIndex:f,className:_.sectionsContainer,onFocus:e=>{E.disabled?e.stopPropagation():E.onFocus?.(e)},onBlur:E.onBlur,onInput:m,onPaste:g,onKeyDown:y,slots:{root:D,section:FI,sectionContent:OI,sectionSeparator:PI},slotProps:{root:{ownerState:A},sectionContent:{className:pI.sectionContent},sectionSeparator:e=>{let{position:t}=e;return{className:"before"===t?pI.sectionBefore:pI.sectionAfter}}}}),l,c?c((0,Po.A)({},E)):null,(0,hr.jsx)(LI,(0,Po.A)({name:b,className:_.input,value:s,onChange:i,id:o,"aria-hidden":"true",tabIndex:-1,readOnly:v,required:E.required,disabled:E.disabled},x,{ref:C}))]}))})),BI=["label","autoFocus","ownerState","notched"],WI=(0,Gn.Ay)(DI,{name:"MuiPickersOutlinedInput",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{padding:"0 14px",borderRadius:(t.vars||t).shape.borderRadius,[`&:hover .${mI.notchedOutline}`]:{borderColor:(t.vars||t).palette.text.primary},"@media (hover: none)":{[`&:hover .${mI.notchedOutline}`]:{borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}},[`&.${mI.focused} .${mI.notchedOutline}`]:{borderStyle:"solid",borderWidth:2},[`&.${mI.disabled}`]:{[`& .${mI.notchedOutline}`]:{borderColor:(t.vars||t).palette.action.disabled},"*":{color:(t.vars||t).palette.action.disabled}},[`&.${mI.error} .${mI.notchedOutline}`]:{borderColor:(t.vars||t).palette.error.main},variants:Object.keys((t.vars??t).palette).filter((e=>(t.vars??t).palette[e]?.main??!1)).map((e=>({props:{color:e},style:{[`&.${mI.focused}:not(.${mI.error}) .${mI.notchedOutline}`]:{borderColor:(t.vars||t).palette[e].main}}})))}})),VI=(0,Gn.Ay)(MI,{name:"MuiPickersOutlinedInput",slot:"SectionsContainer",overridesResolver:(e,t)=>t.sectionsContainer})({padding:"16.5px 0",variants:[{props:{size:"small"},style:{padding:"8.5px 0"}}]}),UI=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiPickersOutlinedInput"}),{label:r,ownerState:a,notched:s}=n,i=zs(n,BI),o=sa(),l=(0,Po.A)({},n,a,o,{color:o?.color||"primary"}),u=(e=>{const{classes:t}=e,n=Tx({root:["root"],notchedOutline:["notchedOutline"],input:["input"]},fI,t);return(0,Po.A)({},t,n)})(l);return(0,hr.jsx)(zI,(0,Po.A)({slots:{root:WI,input:VI},renderSuffix:e=>(0,hr.jsx)(xI,{shrink:Boolean(s||e.adornedStart||e.focused||e.filled),notched:Boolean(s||e.adornedStart||e.focused||e.filled),className:u.notchedOutline,label:null!=r&&""!==r&&o?.required?(0,hr.jsxs)(T.Fragment,{children:[r,"\u2009","*"]}):r,ownerState:l})},i,{label:r,classes:u,ref:t}))}));function jI(e){return Rx("MuiPickersFilledInput",e)}UI.muiName="Input";const GI=(0,Po.A)({},pI,Dx("MuiPickersFilledInput",["root","underline","input"])),HI=["label","autoFocus","disableUnderline","ownerState"],qI=(0,Gn.Ay)(DI,{name:"MuiPickersFilledInput",slot:"Root",overridesResolver:(e,t)=>t.root,shouldForwardProp:e=>(0,Ml.MC)(e)&&"disableUnderline"!==e})((e=>{let{theme:t}=e;const n="light"===t.palette.mode,r=n?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)",a=n?"rgba(0, 0, 0, 0.06)":"rgba(255, 255, 255, 0.09)",s=n?"rgba(0, 0, 0, 0.09)":"rgba(255, 255, 255, 0.13)",i=n?"rgba(0, 0, 0, 0.12)":"rgba(255, 255, 255, 0.12)";return{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a,borderTopLeftRadius:(t.vars||t).shape.borderRadius,borderTopRightRadius:(t.vars||t).shape.borderRadius,transition:t.transitions.create("background-color",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),"&:hover":{backgroundColor:t.vars?t.vars.palette.FilledInput.hoverBg:s,"@media (hover: none)":{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a}},[`&.${GI.focused}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a},[`&.${GI.disabled}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.disabledBg:i},variants:[...Object.keys((t.vars??t).palette).filter((e=>(t.vars??t).palette[e].main)).map((e=>({props:{color:e,disableUnderline:!1},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[e]?.main}`}}}))),{props:{disableUnderline:!1},style:{"&::after":{left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${GI.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${GI.error}`]:{"&:before, &:after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`:r}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${GI.disabled}, .${GI.error}):before`]:{borderBottom:`1px solid ${(t.vars||t).palette.text.primary}`},[`&.${GI.disabled}:before`]:{borderBottomStyle:"dotted"}}},{props:e=>{let{startAdornment:t}=e;return!!t},style:{paddingLeft:12}},{props:e=>{let{endAdornment:t}=e;return!!t},style:{paddingRight:12}}]}})),KI=(0,Gn.Ay)(MI,{name:"MuiPickersFilledInput",slot:"sectionsContainer",overridesResolver:(e,t)=>t.sectionsContainer})({paddingTop:25,paddingRight:12,paddingBottom:8,paddingLeft:12,variants:[{props:{size:"small"},style:{paddingTop:21,paddingBottom:4}},{props:e=>{let{startAdornment:t}=e;return!!t},style:{paddingLeft:0}},{props:e=>{let{endAdornment:t}=e;return!!t},style:{paddingRight:0}},{props:{hiddenLabel:!0},style:{paddingTop:16,paddingBottom:17}},{props:{hiddenLabel:!0,size:"small"},style:{paddingTop:8,paddingBottom:9}}]}),XI=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiPickersFilledInput"}),{label:r,disableUnderline:a=!1,ownerState:s}=n,i=zs(n,HI),o=sa(),l=(e=>{const{classes:t,disableUnderline:n}=e,r=Tx({root:["root",!n&&"underline"],input:["input"]},jI,t);return(0,Po.A)({},t,r)})((0,Po.A)({},n,s,o,{color:o?.color||"primary"}));return(0,hr.jsx)(zI,(0,Po.A)({slots:{root:qI,input:KI},slotProps:{root:{disableUnderline:a}}},i,{label:r,classes:l,ref:t}))}));function YI(e){return Rx("MuiPickersFilledInput",e)}XI.muiName="Input";const QI=(0,Po.A)({},pI,Dx("MuiPickersInput",["root","input"])),JI=["label","autoFocus","disableUnderline","ownerState"],ZI=(0,Gn.Ay)(DI,{name:"MuiPickersInput",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;let n="light"===t.palette.mode?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)";return t.vars&&(n=`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`),{"label + &":{marginTop:16},variants:[...Object.keys((t.vars??t).palette).filter((e=>(t.vars??t).palette[e].main)).map((e=>({props:{color:e},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[e].main}`}}}))),{props:{disableUnderline:!1},style:{"&::after":{background:"red",left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${QI.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${QI.error}`]:{"&:before, &:after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${n}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${QI.disabled}, .${QI.error}):before`]:{borderBottom:`2px solid ${(t.vars||t).palette.text.primary}`,"@media (hover: none)":{borderBottom:`1px solid ${n}`}},[`&.${QI.disabled}:before`]:{borderBottomStyle:"dotted"}}}]}})),eC=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiPickersInput"}),{label:r,disableUnderline:a=!1,ownerState:s}=n,i=zs(n,JI),o=sa(),l=(e=>{const{classes:t,disableUnderline:n}=e,r=Tx({root:["root",!n&&"underline"],input:["input"]},YI,t);return(0,Po.A)({},t,r)})((0,Po.A)({},n,s,o,{disableUnderline:a,color:o?.color||"primary"}));return(0,hr.jsx)(zI,(0,Po.A)({slots:{root:ZI}},i,{label:r,classes:l,ref:t}))}));eC.muiName="Input";const tC=["onFocus","onBlur","className","color","disabled","error","variant","required","InputProps","inputProps","inputRef","sectionListRef","elements","areAllSectionsEmpty","onClick","onKeyDown","onKeyUp","onPaste","onInput","endAdornment","startAdornment","tabIndex","contentEditable","focused","value","onChange","fullWidth","id","name","helperText","FormHelperTextProps","label","InputLabelProps"],nC={standard:eC,filled:XI,outlined:UI},rC=(0,Gn.Ay)(ns,{name:"MuiPickersTextField",slot:"Root",overridesResolver:(e,t)=>t.root})({}),aC=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiPickersTextField"}),{onFocus:r,onBlur:a,className:s,color:i="primary",disabled:o=!1,error:l=!1,variant:u="outlined",required:c=!1,InputProps:d,inputProps:h,inputRef:p,sectionListRef:f,elements:m,areAllSectionsEmpty:g,onClick:y,onKeyDown:b,onKeyUp:v,onPaste:x,onInput:w,endAdornment:k,startAdornment:S,tabIndex:I,contentEditable:C,focused:N,value:E,onChange:A,fullWidth:_,id:$,name:R,helperText:D,FormHelperTextProps:M,label:F,InputLabelProps:O}=n,P=zs(n,tC),L=qx(t,T.useRef(null)),z=uw($),B=D&&z?`${z}-helper-text`:void 0,W=F&&z?`${z}-label`:void 0,V=(0,Po.A)({},n,{color:i,disabled:o,error:l,focused:N,required:c,variant:u}),U=(e=>{const{focused:t,disabled:n,classes:r,required:a}=e;return Tx({root:["root",t&&!n&&"focused",n&&"disabled",a&&"required"]},dI,r)})(V),j=nC[u];return(0,hr.jsxs)(rC,(0,Po.A)({className:(0,Bn.A)(U.root,s),ref:L,focused:N,onFocus:r,onBlur:a,disabled:o,variant:u,error:l,color:i,fullWidth:_,required:c,ownerState:V},P,{children:[(0,hr.jsx)(Qa,(0,Po.A)({htmlFor:z,id:W},O,{children:F})),(0,hr.jsx)(j,(0,Po.A)({elements:m,areAllSectionsEmpty:g,onClick:y,onKeyDown:b,onKeyUp:v,onInput:w,onPaste:x,endAdornment:k,startAdornment:S,tabIndex:I,contentEditable:C,value:E,onChange:A,id:z,fullWidth:_,inputProps:h,inputRef:p,sectionListRef:f,label:F,name:R,role:"group","aria-labelledby":W},d)),D&&(0,hr.jsx)(os,(0,Po.A)({id:B},M,{children:D}))]}))})),sC=["enableAccessibleFieldDOMStructure"],iC=["InputProps","readOnly"],oC=["onPaste","onKeyDown","inputMode","readOnly","InputProps","inputProps","inputRef"],lC=["slots","slotProps","InputProps","inputProps"],uC=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiDateField"}),{slots:r,slotProps:a,InputProps:s,inputProps:i}=n,o=zs(n,lC),l=n,u=r?.textField??(e.enableAccessibleFieldDOMStructure?aC:Mo),c=ew({elementType:u,externalSlotProps:a?.textField,externalForwardedProps:o,additionalProps:{ref:t},ownerState:l});c.inputProps=(0,Po.A)({},i,c.inputProps),c.InputProps=(0,Po.A)({},s,c.InputProps);const d=(e=>{let{enableAccessibleFieldDOMStructure:t}=e,n=zs(e,sC);if(t){const{InputProps:e,readOnly:t}=n,r=zs(n,iC);return(0,Po.A)({},r,{InputProps:(0,Po.A)({},e??{},{readOnly:t})})}const{onPaste:r,onKeyDown:a,inputMode:s,readOnly:i,InputProps:o,inputProps:l,inputRef:u}=n,c=zs(n,oC);return(0,Po.A)({},c,{InputProps:(0,Po.A)({},o??{},{readOnly:i}),inputProps:(0,Po.A)({},l??{},{inputMode:s,onPaste:r,onKeyDown:a,ref:u})})})(lI(c)),h=(e=>{const t=zx(),{clearable:n,onClear:r,InputProps:a,sx:s,slots:i,slotProps:o}=e,l=zs(e,uI),u=i?.clearButton??bl,c=zs(ew({elementType:u,externalSlotProps:o?.clearButton,ownerState:{},className:"clearButton",additionalProps:{title:t.fieldClearLabel}}),cI),d=i?.clearIcon??HS,h=ew({elementType:d,externalSlotProps:o?.clearIcon,ownerState:{}});return(0,Po.A)({},l,{InputProps:(0,Po.A)({},a,{endAdornment:(0,hr.jsxs)(T.Fragment,{children:[n&&(0,hr.jsx)(iw,{position:"end",sx:{marginRight:a?.endAdornment?-1:-1.5},children:(0,hr.jsx)(u,(0,Po.A)({},c,{onClick:r,children:(0,hr.jsx)(d,(0,Po.A)({fontSize:"small"},h))}))}),a?.endAdornment]})}),sx:[{"& .clearButton":{opacity:1},"@media (pointer: fine)":{"& .clearButton":{opacity:0},"&:hover, &:focus-within":{".clearButton":{opacity:1}}}},...Array.isArray(s)?s:[s]]})})((0,Po.A)({},d,{slots:r,slotProps:a}));return(0,hr.jsx)(u,(0,Po.A)({},h))})),cC=e=>{let{shouldDisableDate:t,shouldDisableMonth:n,shouldDisableYear:r,minDate:a,maxDate:s,disableFuture:i,disablePast:o,timezone:l}=e;const u=Sx();return T.useCallback((e=>null!==Hx({adapter:u,value:e,props:{shouldDisableDate:t,shouldDisableMonth:n,shouldDisableYear:r,minDate:a,maxDate:s,disableFuture:i,disablePast:o,timezone:l}})),[u,t,n,r,a,s,i,o,l])},dC=e=>{const{value:t,referenceDate:n,disableFuture:r,disablePast:a,disableSwitchToMonthOnDayFocus:s=!1,maxDate:i,minDate:o,onMonthChange:l,reduceAnimations:u,shouldDisableDate:c,timezone:d}=e,h=Ix(),p=T.useRef(((e,t,n)=>(r,a)=>{switch(a.type){case"changeMonth":return(0,Po.A)({},r,{slideDirection:a.direction,currentMonth:a.newMonth,isMonthSwitchingAnimating:!e});case"finishMonthSwitchingAnimation":return(0,Po.A)({},r,{isMonthSwitchingAnimating:!1});case"changeFocusedDay":{if(null!=r.focusedDay&&null!=a.focusedDay&&n.isSameDay(a.focusedDay,r.focusedDay))return r;const s=null!=a.focusedDay&&!t&&!n.isSameMonth(r.currentMonth,a.focusedDay);return(0,Po.A)({},r,{focusedDay:a.focusedDay,isMonthSwitchingAnimating:s&&!e&&!a.withoutMonthSwitchingAnimation,currentMonth:s?n.startOfMonth(a.focusedDay):r.currentMonth,slideDirection:null!=a.focusedDay&&n.isAfterDay(a.focusedDay,r.currentMonth)?"left":"right"})}default:throw new Error("missing support")}})(Boolean(u),s,h)).current,f=T.useMemo((()=>bx.getInitialReferenceValue({value:t,utils:h,timezone:d,props:e,referenceDate:n,granularity:Kv.day})),[]),[m,g]=T.useReducer(p,{isMonthSwitchingAnimating:!1,focusedDay:f,currentMonth:h.startOfMonth(f),slideDirection:"left"}),y=T.useCallback((e=>{g((0,Po.A)({type:"changeMonth"},e)),l&&l(e.newMonth)}),[l]),b=T.useCallback((e=>{const t=e;h.isSameMonth(t,m.currentMonth)||y({newMonth:h.startOfMonth(t),direction:h.isAfterDay(t,m.currentMonth)?"left":"right"})}),[m.currentMonth,y,h]),v=cC({shouldDisableDate:c,minDate:o,maxDate:i,disableFuture:r,disablePast:a,timezone:d}),x=T.useCallback((()=>{g({type:"finishMonthSwitchingAnimation"})}),[]),w=Pk(((e,t)=>{v(e)||g({type:"changeFocusedDay",focusedDay:e,withoutMonthSwitchingAnimation:t})}));return{referenceDate:f,calendarState:m,changeMonth:b,changeFocusedDay:w,isDateDisabled:v,onMonthSwitchingAnimationEnd:x,handleChangeMonth:y}},hC=e=>Rx("MuiPickersFadeTransitionGroup",e),pC=(Dx("MuiPickersFadeTransitionGroup",["root"]),(0,Gn.Ay)(Uo,{name:"MuiPickersFadeTransitionGroup",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"block",position:"relative"}));function fC(e){const t=So({props:e,name:"MuiPickersFadeTransitionGroup"}),{children:n,className:r,reduceAnimations:a,transKey:s}=t,i=(e=>{const{classes:t}=e;return Tx({root:["root"]},hC,t)})(t),o=Zn();return a?n:(0,hr.jsx)(pC,{className:(0,Bn.A)(i.root,r),children:(0,hr.jsx)(gi,{appear:!1,mountOnEnter:!0,unmountOnExit:!0,timeout:{appear:o.transitions.duration.enteringScreen,enter:o.transitions.duration.enteringScreen,exit:0},children:n},s)})}function mC(e){return Rx("MuiPickersDay",e)}const gC=Dx("MuiPickersDay",["root","dayWithMargin","dayOutsideMonth","hiddenDaySpacingFiller","today","selected","disabled"]),yC=["autoFocus","className","day","disabled","disableHighlightToday","disableMargin","hidden","isAnimating","onClick","onDaySelect","onFocus","onBlur","onKeyDown","onMouseDown","onMouseEnter","outsideCurrentMonth","selected","showDaysOutsideCurrentMonth","children","today","isFirstVisibleCell","isLastVisibleCell"],bC=e=>{let{theme:t}=e;return(0,Po.A)({},t.typography.caption,{width:36,height:36,borderRadius:"50%",padding:0,backgroundColor:"transparent",transition:t.transitions.create("background-color",{duration:t.transitions.duration.short}),color:(t.vars||t).palette.text.primary,"@media (pointer: fine)":{"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Wn.X4)(t.palette.primary.main,t.palette.action.hoverOpacity)}},"&:focus":{backgroundColor:t.vars?`rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.focusOpacity})`:(0,Wn.X4)(t.palette.primary.main,t.palette.action.focusOpacity),[`&.${gC.selected}`]:{willChange:"background-color",backgroundColor:(t.vars||t).palette.primary.dark}},[`&.${gC.selected}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.main,fontWeight:t.typography.fontWeightMedium,"&:hover":{willChange:"background-color",backgroundColor:(t.vars||t).palette.primary.dark}},[`&.${gC.disabled}:not(.${gC.selected})`]:{color:(t.vars||t).palette.text.disabled},[`&.${gC.disabled}&.${gC.selected}`]:{opacity:.6},variants:[{props:{disableMargin:!1},style:{margin:"0 2px"}},{props:{outsideCurrentMonth:!0,showDaysOutsideCurrentMonth:!0},style:{color:(t.vars||t).palette.text.secondary}},{props:{disableHighlightToday:!1,today:!0},style:{[`&:not(.${gC.selected})`]:{border:`1px solid ${(t.vars||t).palette.text.secondary}`}}}]})},vC=(e,t)=>{const{ownerState:n}=e;return[t.root,!n.disableMargin&&t.dayWithMargin,!n.disableHighlightToday&&n.today&&t.today,!n.outsideCurrentMonth&&n.showDaysOutsideCurrentMonth&&t.dayOutsideMonth,n.outsideCurrentMonth&&!n.showDaysOutsideCurrentMonth&&t.hiddenDaySpacingFiller]},xC=(0,Gn.Ay)(nl,{name:"MuiPickersDay",slot:"Root",overridesResolver:vC})(bC),wC=(0,Gn.Ay)("div",{name:"MuiPickersDay",slot:"Root",overridesResolver:vC})((e=>{let{theme:t}=e;return(0,Po.A)({},bC({theme:t}),{opacity:0,pointerEvents:"none"})})),kC=()=>{},SC=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiPickersDay"}),{autoFocus:r=!1,className:a,day:s,disabled:i=!1,disableHighlightToday:o=!1,disableMargin:l=!1,isAnimating:u,onClick:c,onDaySelect:d,onFocus:h=kC,onBlur:p=kC,onKeyDown:f=kC,onMouseDown:m=kC,onMouseEnter:g=kC,outsideCurrentMonth:y,selected:b=!1,showDaysOutsideCurrentMonth:v=!1,children:x,today:w=!1}=n,k=zs(n,yC),S=(0,Po.A)({},n,{autoFocus:r,disabled:i,disableHighlightToday:o,disableMargin:l,selected:b,showDaysOutsideCurrentMonth:v,today:w}),I=(e=>{const{selected:t,disableMargin:n,disableHighlightToday:r,today:a,disabled:s,outsideCurrentMonth:i,showDaysOutsideCurrentMonth:o,classes:l}=e,u=i&&!o;return Tx({root:["root",t&&!u&&"selected",s&&"disabled",!n&&"dayWithMargin",!r&&a&&"today",i&&o&&"dayOutsideMonth",u&&"hiddenDaySpacingFiller"],hiddenDaySpacingFiller:["hiddenDaySpacingFiller"]},mC,l)})(S),C=Ix(),N=T.useRef(null),E=qx(N,t);Ok((()=>{!r||i||u||y||N.current.focus()}),[r,i,u,y]);return y&&!v?(0,hr.jsx)(wC,{className:(0,Bn.A)(I.root,I.hiddenDaySpacingFiller,a),ownerState:S,role:k.role}):(0,hr.jsx)(xC,(0,Po.A)({className:(0,Bn.A)(I.root,a),ref:E,centerRipple:!0,disabled:i,tabIndex:b?0:-1,onKeyDown:e=>f(e,s),onFocus:e=>h(e,s),onBlur:e=>p(e,s),onMouseEnter:e=>g(e,s),onClick:e=>{i||d(s),y&&e.currentTarget.focus(),c&&c(e)},onMouseDown:e=>{m(e),y&&e.preventDefault()}},k,{ownerState:S,children:x||C.format(s,"dayOfMonth")}))})),IC=T.memo(SC);function CC(e,t){return e.replace(new RegExp("(^|\\s)"+t+"(?:\\s|$)","g"),"$1").replace(/\s+/g," ").replace(/^\s*|\s*$/g,"")}var NC=function(e,t){return e&&t&&t.split(" ").forEach((function(t){return r=t,void((n=e).classList?n.classList.remove(r):"string"===typeof n.className?n.className=CC(n.className,r):n.setAttribute("class",CC(n.className&&n.className.baseVal||"",r)));var n,r}))},TC=function(e){function t(){for(var t,n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];return(t=e.call.apply(e,[this].concat(r))||this).appliedClasses={appear:{},enter:{},exit:{}},t.onEnter=function(e,n){var r=t.resolveArguments(e,n),a=r[0],s=r[1];t.removeClasses(a,"exit"),t.addClass(a,s?"appear":"enter","base"),t.props.onEnter&&t.props.onEnter(e,n)},t.onEntering=function(e,n){var r=t.resolveArguments(e,n),a=r[0],s=r[1]?"appear":"enter";t.addClass(a,s,"active"),t.props.onEntering&&t.props.onEntering(e,n)},t.onEntered=function(e,n){var r=t.resolveArguments(e,n),a=r[0],s=r[1]?"appear":"enter";t.removeClasses(a,s),t.addClass(a,s,"done"),t.props.onEntered&&t.props.onEntered(e,n)},t.onExit=function(e){var n=t.resolveArguments(e)[0];t.removeClasses(n,"appear"),t.removeClasses(n,"enter"),t.addClass(n,"exit","base"),t.props.onExit&&t.props.onExit(e)},t.onExiting=function(e){var n=t.resolveArguments(e)[0];t.addClass(n,"exit","active"),t.props.onExiting&&t.props.onExiting(e)},t.onExited=function(e){var n=t.resolveArguments(e)[0];t.removeClasses(n,"exit"),t.addClass(n,"exit","done"),t.props.onExited&&t.props.onExited(e)},t.resolveArguments=function(e,n){return t.props.nodeRef?[t.props.nodeRef.current,e]:[e,n]},t.getClassNames=function(e){var n=t.props.classNames,r="string"===typeof n,a=r?""+(r&&n?n+"-":"")+e:n[e];return{baseClassName:a,activeClassName:r?a+"-active":n[e+"Active"],doneClassName:r?a+"-done":n[e+"Done"]}},t}Ws(t,e);var n=t.prototype;return n.addClass=function(e,t,n){var r=this.getClassNames(t)[n+"ClassName"],a=this.getClassNames("enter").doneClassName;"appear"===t&&"done"===n&&a&&(r+=" "+a),"active"===n&&e&&js(e),r&&(this.appliedClasses[t][n]=r,function(e,t){e&&t&&t.split(" ").forEach((function(t){return r=t,void((n=e).classList?n.classList.add(r):function(e,t){return e.classList?!!t&&e.classList.contains(t):-1!==(" "+(e.className.baseVal||e.className)+" ").indexOf(" "+t+" ")}(n,r)||("string"===typeof n.className?n.className=n.className+" "+r:n.setAttribute("class",(n.className&&n.className.baseVal||"")+" "+r)));var n,r}))}(e,r))},n.removeClasses=function(e,t){var n=this.appliedClasses[t],r=n.base,a=n.active,s=n.done;this.appliedClasses[t]={},r&&NC(e,r),a&&NC(e,a),s&&NC(e,s)},n.render=function(){var e=this.props,t=(e.classNames,zs(e,["classNames"]));return T.createElement(Js,(0,Po.A)({},t,{onEnter:this.onEnter,onEntered:this.onEntered,onEntering:this.onEntering,onExit:this.onExit,onExiting:this.onExiting,onExited:this.onExited}))},t}(T.Component);TC.defaultProps={classNames:""},TC.propTypes={};const EC=TC,AC=e=>Rx("MuiPickersSlideTransition",e),_C=Dx("MuiPickersSlideTransition",["root","slideEnter-left","slideEnter-right","slideEnterActive","slideExit","slideExitActiveLeft-left","slideExitActiveLeft-right"]),$C=["children","className","reduceAnimations","slideDirection","transKey","classes"],RC=(0,Gn.Ay)(Uo,{name:"MuiPickersSlideTransition",slot:"Root",overridesResolver:(e,t)=>[t.root,{[`.${_C["slideEnter-left"]}`]:t["slideEnter-left"]},{[`.${_C["slideEnter-right"]}`]:t["slideEnter-right"]},{[`.${_C.slideEnterActive}`]:t.slideEnterActive},{[`.${_C.slideExit}`]:t.slideExit},{[`.${_C["slideExitActiveLeft-left"]}`]:t["slideExitActiveLeft-left"]},{[`.${_C["slideExitActiveLeft-right"]}`]:t["slideExitActiveLeft-right"]}]})((e=>{let{theme:t}=e;const n=t.transitions.create("transform",{duration:t.transitions.duration.complex,easing:"cubic-bezier(0.35, 0.8, 0.4, 1)"});return{display:"block",position:"relative",overflowX:"hidden","& > *":{position:"absolute",top:0,right:0,left:0},[`& .${_C["slideEnter-left"]}`]:{willChange:"transform",transform:"translate(100%)",zIndex:1},[`& .${_C["slideEnter-right"]}`]:{willChange:"transform",transform:"translate(-100%)",zIndex:1},[`& .${_C.slideEnterActive}`]:{transform:"translate(0%)",transition:n},[`& .${_C.slideExit}`]:{transform:"translate(0%)"},[`& .${_C["slideExitActiveLeft-left"]}`]:{willChange:"transform",transform:"translate(-100%)",transition:n,zIndex:0},[`& .${_C["slideExitActiveLeft-right"]}`]:{willChange:"transform",transform:"translate(100%)",transition:n,zIndex:0}}}));const DC=e=>Rx("MuiDayCalendar",e),MC=(Dx("MuiDayCalendar",["root","header","weekDayLabel","loadingContainer","slideTransition","monthContainer","weekContainer","weekNumberLabel","weekNumber"]),["parentProps","day","focusableDay","selectedDays","isDateDisabled","currentMonthNumber","isViewFocused"]),FC=["ownerState"],OC=(0,Gn.Ay)("div",{name:"MuiDayCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({}),PC=(0,Gn.Ay)("div",{name:"MuiDayCalendar",slot:"Header",overridesResolver:(e,t)=>t.header})({display:"flex",justifyContent:"center",alignItems:"center"}),LC=(0,Gn.Ay)(Ir,{name:"MuiDayCalendar",slot:"WeekDayLabel",overridesResolver:(e,t)=>t.weekDayLabel})((e=>{let{theme:t}=e;return{width:36,height:40,margin:"0 2px",textAlign:"center",display:"flex",justifyContent:"center",alignItems:"center",color:(t.vars||t).palette.text.secondary}})),zC=(0,Gn.Ay)(Ir,{name:"MuiDayCalendar",slot:"WeekNumberLabel",overridesResolver:(e,t)=>t.weekNumberLabel})((e=>{let{theme:t}=e;return{width:36,height:40,margin:"0 2px",textAlign:"center",display:"flex",justifyContent:"center",alignItems:"center",color:t.palette.text.disabled}})),BC=(0,Gn.Ay)(Ir,{name:"MuiDayCalendar",slot:"WeekNumber",overridesResolver:(e,t)=>t.weekNumber})((e=>{let{theme:t}=e;return(0,Po.A)({},t.typography.caption,{width:36,height:36,padding:0,margin:"0 2px",color:t.palette.text.disabled,fontSize:"0.75rem",alignItems:"center",justifyContent:"center",display:"inline-flex"})})),WC=(0,Gn.Ay)("div",{name:"MuiDayCalendar",slot:"LoadingContainer",overridesResolver:(e,t)=>t.loadingContainer})({display:"flex",justifyContent:"center",alignItems:"center",minHeight:240}),VC=(0,Gn.Ay)((function(e){const t=So({props:e,name:"MuiPickersSlideTransition"}),{children:n,className:r,reduceAnimations:a,transKey:s}=t,i=zs(t,$C),o=(e=>{const{classes:t,slideDirection:n}=e;return Tx({root:["root"],exit:["slideExit"],enterActive:["slideEnterActive"],enter:[`slideEnter-${n}`],exitActive:[`slideExitActiveLeft-${n}`]},AC,t)})(t),l=Zn();if(a)return(0,hr.jsx)("div",{className:(0,Bn.A)(o.root,r),children:n});const u={exit:o.exit,enterActive:o.enterActive,enter:o.enter,exitActive:o.exitActive};return(0,hr.jsx)(RC,{className:(0,Bn.A)(o.root,r),childFactory:e=>T.cloneElement(e,{classNames:u}),role:"presentation",children:(0,hr.jsx)(EC,(0,Po.A)({mountOnEnter:!0,unmountOnExit:!0,timeout:l.transitions.duration.complex,classNames:u},i,{children:n}),s)})}),{name:"MuiDayCalendar",slot:"SlideTransition",overridesResolver:(e,t)=>t.slideTransition})({minHeight:240}),UC=(0,Gn.Ay)("div",{name:"MuiDayCalendar",slot:"MonthContainer",overridesResolver:(e,t)=>t.monthContainer})({overflow:"hidden"}),jC=(0,Gn.Ay)("div",{name:"MuiDayCalendar",slot:"WeekContainer",overridesResolver:(e,t)=>t.weekContainer})({margin:"2px 0",display:"flex",justifyContent:"center"});function GC(e){let{parentProps:t,day:n,focusableDay:r,selectedDays:a,isDateDisabled:s,currentMonthNumber:i,isViewFocused:o}=e,l=zs(e,MC);const{disabled:u,disableHighlightToday:c,isMonthSwitchingAnimating:d,showDaysOutsideCurrentMonth:h,slots:p,slotProps:f,timezone:m}=t,g=Ix(),y=Nx(m),b=null!==r&&g.isSameDay(n,r),v=a.some((e=>g.isSameDay(e,n))),x=g.isSameDay(n,y),w=p?.day??IC,k=zs(ew({elementType:w,externalSlotProps:f?.day,additionalProps:(0,Po.A)({disableHighlightToday:c,showDaysOutsideCurrentMonth:h,role:"gridcell",isAnimating:d,"data-timestamp":g.toJsDate(n).valueOf()},l),ownerState:(0,Po.A)({},t,{day:n,selected:v})}),FC),S=T.useMemo((()=>u||s(n)),[u,s,n]),I=T.useMemo((()=>g.getMonth(n)!==i),[g,n,i]),C=T.useMemo((()=>{const e=g.startOfMonth(g.setMonth(n,i));return h?g.isSameDay(n,g.startOfWeek(e)):g.isSameDay(n,e)}),[i,n,h,g]),N=T.useMemo((()=>{const e=g.endOfMonth(g.setMonth(n,i));return h?g.isSameDay(n,g.endOfWeek(e)):g.isSameDay(n,e)}),[i,n,h,g]);return(0,hr.jsx)(w,(0,Po.A)({},k,{day:n,disabled:S,autoFocus:o&&b,today:x,outsideCurrentMonth:I,isFirstVisibleCell:C,isLastVisibleCell:N,selected:v,tabIndex:b?0:-1,"aria-selected":v,"aria-current":x?"date":void 0}))}function HC(e){const t=So({props:e,name:"MuiDayCalendar"}),n=Ix(),{onFocusedDayChange:r,className:a,currentMonth:s,selectedDays:i,focusedDay:o,loading:l,onSelectedDaysChange:u,onMonthSwitchingAnimationEnd:c,readOnly:d,reduceAnimations:h,renderLoading:p=()=>(0,hr.jsx)("span",{children:"..."}),slideDirection:f,TransitionProps:m,disablePast:g,disableFuture:y,minDate:b,maxDate:v,shouldDisableDate:x,shouldDisableMonth:w,shouldDisableYear:k,dayOfWeekFormatter:S=e=>n.format(e,"weekdayShort").charAt(0).toUpperCase(),hasFocus:I,onFocusedViewChange:C,gridLabelId:N,displayWeekNumber:E,fixedWeekNumber:A,autoFocus:_,timezone:$}=t,R=Nx($),D=(e=>{const{classes:t}=e;return Tx({root:["root"],header:["header"],weekDayLabel:["weekDayLabel"],loadingContainer:["loadingContainer"],slideTransition:["slideTransition"],monthContainer:["monthContainer"],weekContainer:["weekContainer"],weekNumberLabel:["weekNumberLabel"],weekNumber:["weekNumber"]},DC,t)})(t),M=ds(),F=cC({shouldDisableDate:x,shouldDisableMonth:w,shouldDisableYear:k,minDate:b,maxDate:v,disablePast:g,disableFuture:y,timezone:$}),O=zx(),[P,L]=Zk({name:"DayCalendar",state:"hasFocus",controlled:I,default:_??!1}),[z,B]=T.useState((()=>o||R)),W=Pk((e=>{d||u(e)})),V=e=>{F(e)||(r(e),B(e),C?.(!0),L(!0))},U=Pk(((e,t)=>{switch(e.key){case"ArrowUp":V(n.addDays(t,-7)),e.preventDefault();break;case"ArrowDown":V(n.addDays(t,7)),e.preventDefault();break;case"ArrowLeft":{const r=n.addDays(t,M?1:-1),a=n.addMonths(t,M?1:-1),s=Lv({utils:n,date:r,minDate:M?r:n.startOfMonth(a),maxDate:M?n.endOfMonth(a):r,isDateDisabled:F,timezone:$});V(s||r),e.preventDefault();break}case"ArrowRight":{const r=n.addDays(t,M?-1:1),a=n.addMonths(t,M?-1:1),s=Lv({utils:n,date:r,minDate:M?n.startOfMonth(a):r,maxDate:M?r:n.endOfMonth(a),isDateDisabled:F,timezone:$});V(s||r),e.preventDefault();break}case"Home":V(n.startOfWeek(t)),e.preventDefault();break;case"End":V(n.endOfWeek(t)),e.preventDefault();break;case"PageUp":V(n.addMonths(t,1)),e.preventDefault();break;case"PageDown":V(n.addMonths(t,-1)),e.preventDefault()}})),j=Pk(((e,t)=>V(t))),G=Pk(((e,t)=>{P&&n.isSameDay(z,t)&&C?.(!1)})),H=n.getMonth(s),q=n.getYear(s),K=T.useMemo((()=>i.filter((e=>!!e)).map((e=>n.startOfDay(e)))),[n,i]),X=`${q}-${H}`,Y=T.useMemo((()=>T.createRef()),[X]),Q=T.useMemo((()=>{const e=n.startOfMonth(s),t=n.endOfMonth(s);return F(z)||n.isAfterDay(z,t)||n.isBeforeDay(z,e)?Lv({utils:n,date:z,minDate:e,maxDate:t,disablePast:g,disableFuture:y,isDateDisabled:F,timezone:$}):z}),[s,y,g,z,F,n,$]),J=T.useMemo((()=>{const e=n.setTimezone(s,$),t=n.getWeekArray(e);let r=n.addMonths(e,1);for(;A&&t.length<A;){const e=n.getWeekArray(r),a=n.isSameDay(t[t.length-1][0],e[0][0]);e.slice(a?1:0).forEach((e=>{t.length<A&&t.push(e)})),r=n.addMonths(r,1)}return t}),[s,A,n,$]);return(0,hr.jsxs)(OC,{role:"grid","aria-labelledby":N,className:D.root,children:[(0,hr.jsxs)(PC,{role:"row",className:D.header,children:[E&&(0,hr.jsx)(zC,{variant:"caption",role:"columnheader","aria-label":O.calendarWeekNumberHeaderLabel,className:D.weekNumberLabel,children:O.calendarWeekNumberHeaderText}),Gv(n,R).map(((e,t)=>(0,hr.jsx)(LC,{variant:"caption",role:"columnheader","aria-label":n.format(e,"weekday"),className:D.weekDayLabel,children:S(e)},t.toString())))]}),l?(0,hr.jsx)(WC,{className:D.loadingContainer,children:p()}):(0,hr.jsx)(VC,(0,Po.A)({transKey:X,onExited:c,reduceAnimations:h,slideDirection:f,className:(0,Bn.A)(a,D.slideTransition)},m,{nodeRef:Y,children:(0,hr.jsx)(UC,{ref:Y,role:"rowgroup",className:D.monthContainer,children:J.map(((e,r)=>(0,hr.jsxs)(jC,{role:"row",className:D.weekContainer,"aria-rowindex":r+1,children:[E&&(0,hr.jsx)(BC,{className:D.weekNumber,role:"rowheader","aria-label":O.calendarWeekNumberAriaLabelText(n.getWeekNumber(e[0])),children:O.calendarWeekNumberText(n.getWeekNumber(e[0]))}),e.map(((e,n)=>(0,hr.jsx)(GC,{parentProps:t,day:e,selectedDays:K,focusableDay:Q,onKeyDown:U,onFocus:j,onBlur:G,onDaySelect:W,isDateDisabled:F,currentMonthNumber:H,isViewFocused:P,"aria-colindex":n+1},e.toString())))]},`week-${e[0]}`)))})}))]})}function qC(e){return Rx("MuiPickersMonth",e)}const KC=Dx("MuiPickersMonth",["root","monthButton","disabled","selected"]),XC=["autoFocus","className","children","disabled","selected","value","tabIndex","onClick","onKeyDown","onFocus","onBlur","aria-current","aria-label","monthsPerRow","slots","slotProps"],YC=(0,Gn.Ay)("div",{name:"MuiPickersMonth",slot:"Root",overridesResolver:(e,t)=>[t.root]})({display:"flex",alignItems:"center",justifyContent:"center",flexBasis:"33.3%",variants:[{props:{monthsPerRow:4},style:{flexBasis:"25%"}}]}),QC=(0,Gn.Ay)("button",{name:"MuiPickersMonth",slot:"MonthButton",overridesResolver:(e,t)=>[t.monthButton,{[`&.${KC.disabled}`]:t.disabled},{[`&.${KC.selected}`]:t.selected}]})((e=>{let{theme:t}=e;return(0,Po.A)({color:"unset",backgroundColor:"transparent",border:0,outline:0},t.typography.subtitle1,{margin:"8px 0",height:36,width:72,borderRadius:18,cursor:"pointer","&:focus":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Wn.X4)(t.palette.action.active,t.palette.action.hoverOpacity)},"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Wn.X4)(t.palette.action.active,t.palette.action.hoverOpacity)},"&:disabled":{cursor:"auto",pointerEvents:"none"},[`&.${KC.disabled}`]:{color:(t.vars||t).palette.text.secondary},[`&.${KC.selected}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.main,"&:focus, &:hover":{backgroundColor:(t.vars||t).palette.primary.dark}}})})),JC=T.memo((function(e){const t=So({props:e,name:"MuiPickersMonth"}),{autoFocus:n,className:r,children:a,disabled:s,selected:i,value:o,tabIndex:l,onClick:u,onKeyDown:c,onFocus:d,onBlur:h,"aria-current":p,"aria-label":f,slots:m,slotProps:g}=t,y=zs(t,XC),b=T.useRef(null),v=(e=>{const{disabled:t,selected:n,classes:r}=e;return Tx({root:["root"],monthButton:["monthButton",t&&"disabled",n&&"selected"]},qC,r)})(t);Ok((()=>{n&&b.current?.focus()}),[n]);const x=m?.monthButton??QC,w=ew({elementType:x,externalSlotProps:g?.monthButton,additionalProps:{children:a,disabled:s,tabIndex:l,ref:b,type:"button",role:"radio","aria-current":p,"aria-checked":i,"aria-label":f,onClick:e=>u(e,o),onKeyDown:e=>c(e,o),onFocus:e=>d(e,o),onBlur:e=>h(e,o)},ownerState:t,className:v.monthButton});return(0,hr.jsx)(YC,(0,Po.A)({className:(0,Bn.A)(v.root,r),ownerState:t},y,{children:(0,hr.jsx)(x,(0,Po.A)({},w))}))}));function ZC(e){return Rx("MuiMonthCalendar",e)}Dx("MuiMonthCalendar",["root"]);const eN=["className","value","defaultValue","referenceDate","disabled","disableFuture","disablePast","maxDate","minDate","onChange","shouldDisableMonth","readOnly","disableHighlightToday","autoFocus","onMonthFocus","hasFocus","onFocusedViewChange","monthsPerRow","timezone","gridLabelId","slots","slotProps"];const tN=(0,Gn.Ay)("div",{name:"MuiMonthCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",flexWrap:"wrap",alignContent:"stretch",padding:"0 4px",width:$S,boxSizing:"border-box"}),nN=T.forwardRef((function(e,t){const n=function(e,t){const n=Ix(),r=Cx(),a=So({props:e,name:t});return(0,Po.A)({disableFuture:!1,disablePast:!1},a,{minDate:zv(n,a.minDate,r.minDate),maxDate:zv(n,a.maxDate,r.maxDate)})}(e,"MuiMonthCalendar"),{className:r,value:a,defaultValue:s,referenceDate:i,disabled:o,disableFuture:l,disablePast:u,maxDate:c,minDate:d,onChange:h,shouldDisableMonth:p,readOnly:f,autoFocus:m=!1,onMonthFocus:g,hasFocus:y,onFocusedViewChange:b,monthsPerRow:v=3,timezone:x,gridLabelId:w,slots:k,slotProps:S}=n,I=zs(n,eN),{value:C,handleValueChange:N,timezone:E}=tS({name:"MonthCalendar",timezone:x,value:a,defaultValue:s,onChange:h,valueManager:bx}),A=Nx(E),_=ds(),$=Ix(),R=T.useMemo((()=>bx.getInitialReferenceValue({value:C,utils:$,props:n,timezone:E,referenceDate:i,granularity:Kv.month})),[]),D=n,M=(e=>{const{classes:t}=e;return Tx({root:["root"]},ZC,t)})(D),F=T.useMemo((()=>$.getMonth(A)),[$,A]),O=T.useMemo((()=>null!=C?$.getMonth(C):null),[C,$]),[P,L]=T.useState((()=>O||$.getMonth(R))),[z,B]=Zk({name:"MonthCalendar",state:"hasFocus",controlled:y,default:m??!1}),W=Pk((e=>{B(e),b&&b(e)})),V=T.useCallback((e=>{const t=$.startOfMonth(u&&$.isAfter(A,d)?A:d),n=$.startOfMonth(l&&$.isBefore(A,c)?A:c),r=$.startOfMonth(e);return!!$.isBefore(r,t)||(!!$.isAfter(r,n)||!!p&&p(r))}),[l,u,c,d,A,p,$]),U=Pk(((e,t)=>{if(f)return;const n=$.setMonth(C??R,t);N(n)})),j=Pk((e=>{V($.setMonth(C??R,e))||(L(e),W(!0),g&&g(e))}));T.useEffect((()=>{L((e=>null!==O&&e!==O?O:e))}),[O]);const G=Pk(((e,t)=>{const n=12;switch(e.key){case"ArrowUp":j((n+t-3)%n),e.preventDefault();break;case"ArrowDown":j((n+t+3)%n),e.preventDefault();break;case"ArrowLeft":j((n+t+(_?1:-1))%n),e.preventDefault();break;case"ArrowRight":j((n+t+(_?-1:1))%n),e.preventDefault()}})),H=Pk(((e,t)=>{j(t)})),q=Pk(((e,t)=>{P===t&&W(!1)}));return(0,hr.jsx)(tN,(0,Po.A)({ref:t,className:(0,Bn.A)(M.root,r),ownerState:D,role:"radiogroup","aria-labelledby":w},I,{children:Bv($,C??R).map((e=>{const t=$.getMonth(e),n=$.format(e,"monthShort"),r=$.format(e,"month"),a=t===O,s=o||V(e);return(0,hr.jsx)(JC,{selected:a,value:t,onClick:U,onKeyDown:G,autoFocus:z&&t===P,disabled:s,tabIndex:t!==P||s?-1:0,onFocus:H,onBlur:q,"aria-current":F===t?"date":void 0,"aria-label":r,monthsPerRow:v,slots:k,slotProps:S,children:n},n)}))}))}));function rN(e){return Rx("MuiPickersYear",e)}const aN=Dx("MuiPickersYear",["root","yearButton","selected","disabled"]),sN=["autoFocus","className","children","disabled","selected","value","tabIndex","onClick","onKeyDown","onFocus","onBlur","aria-current","yearsPerRow","slots","slotProps"],iN=(0,Gn.Ay)("div",{name:"MuiPickersYear",slot:"Root",overridesResolver:(e,t)=>[t.root]})({display:"flex",alignItems:"center",justifyContent:"center",flexBasis:"33.3%",variants:[{props:{yearsPerRow:4},style:{flexBasis:"25%"}}]}),oN=(0,Gn.Ay)("button",{name:"MuiPickersYear",slot:"YearButton",overridesResolver:(e,t)=>[t.yearButton,{[`&.${aN.disabled}`]:t.disabled},{[`&.${aN.selected}`]:t.selected}]})((e=>{let{theme:t}=e;return(0,Po.A)({color:"unset",backgroundColor:"transparent",border:0,outline:0},t.typography.subtitle1,{margin:"6px 0",height:36,width:72,borderRadius:18,cursor:"pointer","&:focus":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.focusOpacity})`:(0,Wn.X4)(t.palette.action.active,t.palette.action.focusOpacity)},"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Wn.X4)(t.palette.action.active,t.palette.action.hoverOpacity)},"&:disabled":{cursor:"auto",pointerEvents:"none"},[`&.${aN.disabled}`]:{color:(t.vars||t).palette.text.secondary},[`&.${aN.selected}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.main,"&:focus, &:hover":{backgroundColor:(t.vars||t).palette.primary.dark}}})})),lN=T.memo((function(e){const t=So({props:e,name:"MuiPickersYear"}),{autoFocus:n,className:r,children:a,disabled:s,selected:i,value:o,tabIndex:l,onClick:u,onKeyDown:c,onFocus:d,onBlur:h,"aria-current":p,slots:f,slotProps:m}=t,g=zs(t,sN),y=T.useRef(null),b=(e=>{const{disabled:t,selected:n,classes:r}=e;return Tx({root:["root"],yearButton:["yearButton",t&&"disabled",n&&"selected"]},rN,r)})(t);Ok((()=>{n&&y.current?.focus()}),[n]);const v=f?.yearButton??oN,x=ew({elementType:v,externalSlotProps:m?.yearButton,additionalProps:{children:a,disabled:s,tabIndex:l,ref:y,type:"button",role:"radio","aria-current":p,"aria-checked":i,onClick:e=>u(e,o),onKeyDown:e=>c(e,o),onFocus:e=>d(e,o),onBlur:e=>h(e,o)},ownerState:t,className:b.yearButton});return(0,hr.jsx)(iN,(0,Po.A)({className:(0,Bn.A)(b.root,r),ownerState:t},g,{children:(0,hr.jsx)(v,(0,Po.A)({},x))}))}));function uN(e){return Rx("MuiYearCalendar",e)}Dx("MuiYearCalendar",["root"]);const cN=["autoFocus","className","value","defaultValue","referenceDate","disabled","disableFuture","disablePast","maxDate","minDate","onChange","readOnly","shouldDisableYear","disableHighlightToday","onYearFocus","hasFocus","onFocusedViewChange","yearsPerRow","timezone","gridLabelId","slots","slotProps"];const dN=(0,Gn.Ay)("div",{name:"MuiYearCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",flexDirection:"row",flexWrap:"wrap",overflowY:"auto",height:"100%",padding:"0 4px",width:$S,maxHeight:280,boxSizing:"border-box",position:"relative"}),hN=T.forwardRef((function(e,t){const n=function(e,t){const n=Ix(),r=Cx(),a=So({props:e,name:t});return(0,Po.A)({disablePast:!1,disableFuture:!1},a,{yearsPerRow:a.yearsPerRow??3,minDate:zv(n,a.minDate,r.minDate),maxDate:zv(n,a.maxDate,r.maxDate)})}(e,"MuiYearCalendar"),{autoFocus:r,className:a,value:s,defaultValue:i,referenceDate:o,disabled:l,disableFuture:u,disablePast:c,maxDate:d,minDate:h,onChange:p,readOnly:f,shouldDisableYear:m,onYearFocus:g,hasFocus:y,onFocusedViewChange:b,yearsPerRow:v,timezone:x,gridLabelId:w,slots:k,slotProps:S}=n,I=zs(n,cN),{value:C,handleValueChange:N,timezone:E}=tS({name:"YearCalendar",timezone:x,value:s,defaultValue:i,onChange:p,valueManager:bx}),A=Nx(E),_=ds(),$=Ix(),R=T.useMemo((()=>bx.getInitialReferenceValue({value:C,utils:$,props:n,timezone:E,referenceDate:o,granularity:Kv.year})),[]),D=n,M=(e=>{const{classes:t}=e;return Tx({root:["root"]},uN,t)})(D),F=T.useMemo((()=>$.getYear(A)),[$,A]),O=T.useMemo((()=>null!=C?$.getYear(C):null),[C,$]),[P,L]=T.useState((()=>O||$.getYear(R))),[z,B]=Zk({name:"YearCalendar",state:"hasFocus",controlled:y,default:r??!1}),W=Pk((e=>{B(e),b&&b(e)})),V=T.useCallback((e=>{if(c&&$.isBeforeYear(e,A))return!0;if(u&&$.isAfterYear(e,A))return!0;if(h&&$.isBeforeYear(e,h))return!0;if(d&&$.isAfterYear(e,d))return!0;if(!m)return!1;const t=$.startOfYear(e);return m(t)}),[u,c,d,h,A,m,$]),U=Pk(((e,t)=>{if(f)return;const n=$.setYear(C??R,t);N(n)})),j=Pk((e=>{V($.setYear(C??R,e))||(L(e),W(!0),g?.(e))}));T.useEffect((()=>{L((e=>null!==O&&e!==O?O:e))}),[O]);const G=Pk(((e,t)=>{switch(e.key){case"ArrowUp":j(t-v),e.preventDefault();break;case"ArrowDown":j(t+v),e.preventDefault();break;case"ArrowLeft":j(t+(_?1:-1)),e.preventDefault();break;case"ArrowRight":j(t+(_?-1:1)),e.preventDefault()}})),H=Pk(((e,t)=>{j(t)})),q=Pk(((e,t)=>{P===t&&W(!1)})),K=T.useRef(null),X=qx(t,K);return T.useEffect((()=>{if(r||null===K.current)return;const e=K.current.querySelector('[tabindex="0"]');if(!e)return;const t=e.offsetHeight,n=e.offsetTop,a=K.current.clientHeight,s=K.current.scrollTop,i=n+t;t>a||n<s||(K.current.scrollTop=i-a/2-t/2)}),[r]),(0,hr.jsx)(dN,(0,Po.A)({ref:X,className:(0,Bn.A)(M.root,a),ownerState:D,role:"radiogroup","aria-labelledby":w},I,{children:$.getYearRange([h,d]).map((e=>{const t=$.getYear(e),n=t===O,r=l||V(e);return(0,hr.jsx)(lN,{selected:n,value:t,onClick:U,onKeyDown:G,autoFocus:z&&t===P,disabled:r,tabIndex:t!==P||r?-1:0,onFocus:H,onBlur:q,"aria-current":F===t?"date":void 0,yearsPerRow:v,slots:k,slotProps:S,children:$.format(e,"year")},$.format(e,"year"))}))}))}));function pN(e){return Rx("MuiPickersArrowSwitcher",e)}Dx("MuiPickersArrowSwitcher",["root","spacer","button","previousIconButton","nextIconButton","leftArrowIcon","rightArrowIcon"]);const fN=["children","className","slots","slotProps","isNextDisabled","isNextHidden","onGoToNext","nextLabel","isPreviousDisabled","isPreviousHidden","onGoToPrevious","previousLabel","labelId"],mN=["ownerState"],gN=["ownerState"],yN=(0,Gn.Ay)("div",{name:"MuiPickersArrowSwitcher",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex"}),bN=(0,Gn.Ay)("div",{name:"MuiPickersArrowSwitcher",slot:"Spacer",overridesResolver:(e,t)=>t.spacer})((e=>{let{theme:t}=e;return{width:t.spacing(3)}})),vN=(0,Gn.Ay)(bl,{name:"MuiPickersArrowSwitcher",slot:"Button",overridesResolver:(e,t)=>t.button})({variants:[{props:{hidden:!0},style:{visibility:"hidden"}}]}),xN=T.forwardRef((function(e,t){const n=ds(),r=So({props:e,name:"MuiPickersArrowSwitcher"}),{children:a,className:s,slots:i,slotProps:o,isNextDisabled:l,isNextHidden:u,onGoToNext:c,nextLabel:d,isPreviousDisabled:h,isPreviousHidden:p,onGoToPrevious:f,previousLabel:m,labelId:g}=r,y=zs(r,fN),b=r,v=(e=>{const{classes:t}=e;return Tx({root:["root"],spacer:["spacer"],button:["button"],previousIconButton:["previousIconButton"],nextIconButton:["nextIconButton"],leftArrowIcon:["leftArrowIcon"],rightArrowIcon:["rightArrowIcon"]},pN,t)})(b),x={isDisabled:l,isHidden:u,goTo:c,label:d},w={isDisabled:h,isHidden:p,goTo:f,label:m},k=i?.previousIconButton??vN,S=ew({elementType:k,externalSlotProps:o?.previousIconButton,additionalProps:{size:"medium",title:w.label,"aria-label":w.label,disabled:w.isDisabled,edge:"end",onClick:w.goTo},ownerState:(0,Po.A)({},b,{hidden:w.isHidden}),className:(0,Bn.A)(v.button,v.previousIconButton)}),I=i?.nextIconButton??vN,C=ew({elementType:I,externalSlotProps:o?.nextIconButton,additionalProps:{size:"medium",title:x.label,"aria-label":x.label,disabled:x.isDisabled,edge:"start",onClick:x.goTo},ownerState:(0,Po.A)({},b,{hidden:x.isHidden}),className:(0,Bn.A)(v.button,v.nextIconButton)}),N=i?.leftArrowIcon??US,T=zs(ew({elementType:N,externalSlotProps:o?.leftArrowIcon,additionalProps:{fontSize:"inherit"},ownerState:b,className:v.leftArrowIcon}),mN),E=i?.rightArrowIcon??jS,A=zs(ew({elementType:E,externalSlotProps:o?.rightArrowIcon,additionalProps:{fontSize:"inherit"},ownerState:b,className:v.rightArrowIcon}),gN);return(0,hr.jsxs)(yN,(0,Po.A)({ref:t,className:(0,Bn.A)(v.root,s),ownerState:b},y,{children:[(0,hr.jsx)(k,(0,Po.A)({},S,{children:n?(0,hr.jsx)(E,(0,Po.A)({},A)):(0,hr.jsx)(N,(0,Po.A)({},T))})),a?(0,hr.jsx)(Ir,{variant:"subtitle1",component:"span",id:g,children:a}):(0,hr.jsx)(bN,{className:v.spacer,ownerState:b}),(0,hr.jsx)(I,(0,Po.A)({},C,{children:n?(0,hr.jsx)(N,(0,Po.A)({},T)):(0,hr.jsx)(E,(0,Po.A)({},A))}))]}))}));const wN=e=>Rx("MuiPickersCalendarHeader",e),kN=Dx("MuiPickersCalendarHeader",["root","labelContainer","label","switchViewButton","switchViewIcon"]),SN=["slots","slotProps","currentMonth","disabled","disableFuture","disablePast","maxDate","minDate","onMonthChange","onViewChange","view","reduceAnimations","views","labelId","className","timezone","format"],IN=["ownerState"],CN=(0,Gn.Ay)("div",{name:"MuiPickersCalendarHeader",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",alignItems:"center",marginTop:12,marginBottom:4,paddingLeft:24,paddingRight:12,maxHeight:40,minHeight:40}),NN=(0,Gn.Ay)("div",{name:"MuiPickersCalendarHeader",slot:"LabelContainer",overridesResolver:(e,t)=>t.labelContainer})((e=>{let{theme:t}=e;return(0,Po.A)({display:"flex",overflow:"hidden",alignItems:"center",cursor:"pointer",marginRight:"auto"},t.typography.body1,{fontWeight:t.typography.fontWeightMedium})})),TN=(0,Gn.Ay)("div",{name:"MuiPickersCalendarHeader",slot:"Label",overridesResolver:(e,t)=>t.label})({marginRight:6}),EN=(0,Gn.Ay)(bl,{name:"MuiPickersCalendarHeader",slot:"SwitchViewButton",overridesResolver:(e,t)=>t.switchViewButton})({marginRight:"auto",variants:[{props:{view:"year"},style:{[`.${kN.switchViewIcon}`]:{transform:"rotate(180deg)"}}}]}),AN=(0,Gn.Ay)(VS,{name:"MuiPickersCalendarHeader",slot:"SwitchViewIcon",overridesResolver:(e,t)=>t.switchViewIcon})((e=>{let{theme:t}=e;return{willChange:"transform",transition:t.transitions.create("transform"),transform:"rotate(0deg)"}})),_N=T.forwardRef((function(e,t){const n=zx(),r=Ix(),a=So({props:e,name:"MuiPickersCalendarHeader"}),{slots:s,slotProps:i,currentMonth:o,disabled:l,disableFuture:u,disablePast:c,maxDate:d,minDate:h,onMonthChange:p,onViewChange:f,view:m,reduceAnimations:g,views:y,labelId:b,className:v,timezone:x,format:w=`${r.formats.month} ${r.formats.year}`}=a,k=zs(a,SN),S=a,I=(e=>{const{classes:t}=e;return Tx({root:["root"],labelContainer:["labelContainer"],label:["label"],switchViewButton:["switchViewButton"],switchViewIcon:["switchViewIcon"]},wN,t)})(a),C=s?.switchViewButton??EN,N=ew({elementType:C,externalSlotProps:i?.switchViewButton,additionalProps:{size:"small","aria-label":n.calendarViewSwitchingButtonAriaLabel(m)},ownerState:S,className:I.switchViewButton}),E=s?.switchViewIcon??AN,A=zs(ew({elementType:E,externalSlotProps:i?.switchViewIcon,ownerState:S,className:I.switchViewIcon}),IN),_=function(e,t){let{disableFuture:n,maxDate:r,timezone:a}=t;const s=Ix();return T.useMemo((()=>{const t=s.date(void 0,a),i=s.startOfMonth(n&&s.isBefore(t,r)?t:r);return!s.isAfter(i,e)}),[n,r,e,s,a])}(o,{disableFuture:u,maxDate:d,timezone:x}),$=function(e,t){let{disablePast:n,minDate:r,timezone:a}=t;const s=Ix();return T.useMemo((()=>{const t=s.date(void 0,a),i=s.startOfMonth(n&&s.isAfter(t,r)?t:r);return!s.isBefore(i,e)}),[n,r,e,s,a])}(o,{disablePast:c,minDate:h,timezone:x});if(1===y.length&&"year"===y[0])return null;const R=r.formatByString(o,w);return(0,hr.jsxs)(CN,(0,Po.A)({},k,{ownerState:S,className:(0,Bn.A)(v,I.root),ref:t,children:[(0,hr.jsxs)(NN,{role:"presentation",onClick:()=>{if(1!==y.length&&f&&!l)if(2===y.length)f(y.find((e=>e!==m))||y[0]);else{const e=0!==y.indexOf(m)?0:1;f(y[e])}},ownerState:S,"aria-live":"polite",className:I.labelContainer,children:[(0,hr.jsx)(fC,{reduceAnimations:g,transKey:R,children:(0,hr.jsx)(TN,{id:b,ownerState:S,className:I.label,children:R})}),y.length>1&&!l&&(0,hr.jsx)(C,(0,Po.A)({},N,{children:(0,hr.jsx)(E,(0,Po.A)({},A))}))]}),(0,hr.jsx)(gi,{in:"day"===m,children:(0,hr.jsx)(xN,{slots:s,slotProps:i,onGoToPrevious:()=>p(r.addMonths(o,-1),"right"),isPreviousDisabled:$,previousLabel:n.previousMonth,onGoToNext:()=>p(r.addMonths(o,1),"left"),isNextDisabled:_,nextLabel:n.nextMonth})})]}))})),$N=(0,Gn.Ay)("div")({overflow:"hidden",width:$S,maxHeight:336,display:"flex",flexDirection:"column",margin:"0 auto"}),RN=e=>Rx("MuiDateCalendar",e),DN=(Dx("MuiDateCalendar",["root","viewTransitionContainer"]),["autoFocus","onViewChange","value","defaultValue","referenceDate","disableFuture","disablePast","onChange","onYearChange","onMonthChange","reduceAnimations","shouldDisableDate","shouldDisableMonth","shouldDisableYear","view","views","openTo","className","disabled","readOnly","minDate","maxDate","disableHighlightToday","focusedView","onFocusedViewChange","showDaysOutsideCurrentMonth","fixedWeekNumber","dayOfWeekFormatter","slots","slotProps","loading","renderLoading","displayWeekNumber","yearsPerRow","monthsPerRow","timezone"]);const MN=(0,Gn.Ay)($N,{name:"MuiDateCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",flexDirection:"column",height:336}),FN=(0,Gn.Ay)(fC,{name:"MuiDateCalendar",slot:"ViewTransitionContainer",overridesResolver:(e,t)=>t.viewTransitionContainer})({}),ON=T.forwardRef((function(e,t){const n=Ix(),r=uw(),a=function(e,t){const n=Ix(),r=Cx(),a=Hk(),s=So({props:e,name:t});return(0,Po.A)({},s,{loading:s.loading??!1,disablePast:s.disablePast??!1,disableFuture:s.disableFuture??!1,openTo:s.openTo??"day",views:s.views??["year","day"],reduceAnimations:s.reduceAnimations??a,renderLoading:s.renderLoading??(()=>(0,hr.jsx)("span",{children:"..."})),minDate:zv(n,s.minDate,r.minDate),maxDate:zv(n,s.maxDate,r.maxDate)})}(e,"MuiDateCalendar"),{autoFocus:s,onViewChange:i,value:o,defaultValue:l,referenceDate:u,disableFuture:c,disablePast:d,onChange:h,onYearChange:p,onMonthChange:f,reduceAnimations:m,shouldDisableDate:g,shouldDisableMonth:y,shouldDisableYear:b,view:v,views:x,openTo:w,className:k,disabled:S,readOnly:I,minDate:C,maxDate:N,disableHighlightToday:E,focusedView:A,onFocusedViewChange:_,showDaysOutsideCurrentMonth:$,fixedWeekNumber:R,dayOfWeekFormatter:D,slots:M,slotProps:F,loading:O,renderLoading:P,displayWeekNumber:L,yearsPerRow:z,monthsPerRow:B,timezone:W}=a,V=zs(a,DN),{value:U,handleValueChange:j,timezone:G}=tS({name:"DateCalendar",timezone:W,value:o,defaultValue:l,onChange:h,valueManager:bx}),{view:H,setView:q,focusedView:K,setFocusedView:X,goToNextView:Y,setValueAndGoToNextView:Q}=rS({view:v,views:x,openTo:w,onChange:j,onViewChange:i,autoFocus:s,focusedView:A,onFocusedViewChange:_}),{referenceDate:J,calendarState:Z,changeFocusedDay:ee,changeMonth:te,handleChangeMonth:ne,isDateDisabled:re,onMonthSwitchingAnimationEnd:ae}=dC({value:U,referenceDate:u,reduceAnimations:m,onMonthChange:f,minDate:C,maxDate:N,shouldDisableDate:g,disablePast:d,disableFuture:c,timezone:G}),se=S&&U||C,ie=S&&U||N,oe=`${r}-grid-label`,le=null!==K,ue=M?.calendarHeader??_N,ce=ew({elementType:ue,externalSlotProps:F?.calendarHeader,additionalProps:{views:x,view:H,currentMonth:Z.currentMonth,onViewChange:q,onMonthChange:(e,t)=>ne({newMonth:e,direction:t}),minDate:se,maxDate:ie,disabled:S,disablePast:d,disableFuture:c,reduceAnimations:m,timezone:G,labelId:oe},ownerState:a}),de=Pk((e=>{const t=n.startOfMonth(e),r=n.endOfMonth(e),a=re(e)?Lv({utils:n,date:e,minDate:n.isBefore(C,t)?t:C,maxDate:n.isAfter(N,r)?r:N,disablePast:d,disableFuture:c,isDateDisabled:re,timezone:G}):e;a?(Q(a,"finish"),f?.(t)):(Y(),te(t)),ee(a,!0)})),he=Pk((e=>{const t=n.startOfYear(e),r=n.endOfYear(e),a=re(e)?Lv({utils:n,date:e,minDate:n.isBefore(C,t)?t:C,maxDate:n.isAfter(N,r)?r:N,disablePast:d,disableFuture:c,isDateDisabled:re,timezone:G}):e;a?(Q(a,"finish"),p?.(a)):(Y(),te(t)),ee(a,!0)})),pe=Pk((e=>j(e?Pv(n,e,U??J):e,"finish",H)));T.useEffect((()=>{null!=U&&n.isValid(U)&&te(U)}),[U]);const fe=a,me=(e=>{const{classes:t}=e;return Tx({root:["root"],viewTransitionContainer:["viewTransitionContainer"]},RN,t)})(fe),ge={disablePast:d,disableFuture:c,maxDate:N,minDate:C},ye={disableHighlightToday:E,readOnly:I,disabled:S,timezone:G,gridLabelId:oe,slots:M,slotProps:F},be=T.useRef(H);T.useEffect((()=>{be.current!==H&&(K===be.current&&X(H,!0),be.current=H)}),[K,X,H]);const ve=T.useMemo((()=>[U]),[U]);return(0,hr.jsxs)(MN,(0,Po.A)({ref:t,className:(0,Bn.A)(me.root,k),ownerState:fe},V,{children:[(0,hr.jsx)(ue,(0,Po.A)({},ce,{slots:M,slotProps:F})),(0,hr.jsx)(FN,{reduceAnimations:m,className:me.viewTransitionContainer,transKey:H,ownerState:fe,children:(0,hr.jsxs)("div",{children:["year"===H&&(0,hr.jsx)(hN,(0,Po.A)({},ge,ye,{value:U,onChange:he,shouldDisableYear:b,hasFocus:le,onFocusedViewChange:e=>X("year",e),yearsPerRow:z,referenceDate:J})),"month"===H&&(0,hr.jsx)(nN,(0,Po.A)({},ge,ye,{hasFocus:le,className:k,value:U,onChange:de,shouldDisableMonth:y,onFocusedViewChange:e=>X("month",e),monthsPerRow:B,referenceDate:J})),"day"===H&&(0,hr.jsx)(HC,(0,Po.A)({},Z,ge,ye,{onMonthSwitchingAnimationEnd:ae,onFocusedDayChange:ee,reduceAnimations:m,selectedDays:ve,onSelectedDaysChange:pe,shouldDisableDate:g,shouldDisableMonth:y,shouldDisableYear:b,hasFocus:le,onFocusedViewChange:e=>X("day",e),showDaysOutsideCurrentMonth:$,fixedWeekNumber:R,dayOfWeekFormatter:D,displayWeekNumber:L,loading:O,renderLoading:P}))]})})]}))})),PN=e=>{let{view:t,onViewChange:n,views:r,focusedView:a,onFocusedViewChange:s,value:i,defaultValue:o,referenceDate:l,onChange:u,className:c,classes:d,disableFuture:h,disablePast:p,minDate:f,maxDate:m,shouldDisableDate:g,shouldDisableMonth:y,shouldDisableYear:b,reduceAnimations:v,onMonthChange:x,monthsPerRow:w,onYearChange:k,yearsPerRow:S,slots:I,slotProps:C,loading:N,renderLoading:T,disableHighlightToday:E,readOnly:A,disabled:_,showDaysOutsideCurrentMonth:$,dayOfWeekFormatter:R,sx:D,autoFocus:M,fixedWeekNumber:F,displayWeekNumber:O,timezone:P}=e;return(0,hr.jsx)(ON,{view:t,onViewChange:n,views:r.filter(Uv),focusedView:a&&Uv(a)?a:null,onFocusedViewChange:s,value:i,defaultValue:o,referenceDate:l,onChange:u,className:c,classes:d,disableFuture:h,disablePast:p,minDate:f,maxDate:m,shouldDisableDate:g,shouldDisableMonth:y,shouldDisableYear:b,reduceAnimations:v,onMonthChange:x,monthsPerRow:w,onYearChange:k,yearsPerRow:S,slots:I,slotProps:C,loading:N,renderLoading:T,disableHighlightToday:E,readOnly:A,disabled:_,showDaysOutsideCurrentMonth:$,dayOfWeekFormatter:R,sx:D,autoFocus:M,fixedWeekNumber:F,displayWeekNumber:O,timezone:P})},LN=T.forwardRef((function(e,t){const n=zx(),r=Ix(),a=Gx(e,"MuiDesktopDatePicker"),s=(0,Po.A)({day:PN,month:PN,year:PN},a.viewRenderers),i=(0,Po.A)({},a,{viewRenderers:s,format:jv(r,a,!1),yearsPerRow:a.yearsPerRow??4,slots:(0,Po.A)({openPickerIcon:GS,field:uC},a.slots),slotProps:(0,Po.A)({},a.slotProps,{field:e=>(0,Po.A)({},Mv(a.slotProps?.field,e),iI(a),{ref:t}),toolbar:(0,Po.A)({hidden:!0},a.slotProps?.toolbar)})}),{renderPicker:o}=(e=>{let{props:t,getOpenDialogAriaText:n}=e,r=zs(e,zS);const{slots:a,slotProps:s,className:i,sx:o,format:l,formatDensity:u,enableAccessibleFieldDOMStructure:c,selectedSections:d,onSelectedSectionsChange:h,timezone:p,name:f,label:m,inputRef:g,readOnly:y,disabled:b,autoFocus:v,localeText:x,reduceAnimations:w}=t,k=Ix(),S=T.useRef(null),I=T.useRef(null),C=uw(),N=s?.toolbar?.hidden??!1,{open:E,actions:A,hasUIView:_,layoutProps:$,renderCurrentView:R,shouldRestoreFocus:D,fieldProps:M}=lS((0,Po.A)({},r,{props:t,fieldRef:I,autoFocusView:!0,additionalViewProps:{},wrapperVariant:"desktop"})),F={open:E},O=a.inputAdornment??iw,P=zs(ew({elementType:O,externalSlotProps:s?.inputAdornment,additionalProps:{position:"end"},ownerState:t}),BS),L=a.openPickerButton??bl,z=zs(ew({elementType:L,externalSlotProps:s?.openPickerButton,additionalProps:{disabled:b||y,onClick:E?A.onClose:A.onOpen,"aria-label":n(M.value,k),edge:P.position},ownerState:t}),WS),B=a.openPickerIcon,W=ew({elementType:B,externalSlotProps:s?.openPickerIcon,ownerState:F}),V=a.field,U=ew({elementType:V,externalSlotProps:s?.field,additionalProps:(0,Po.A)({},M,N&&{id:C},{readOnly:y,disabled:b,className:i,sx:o,format:l,formatDensity:u,enableAccessibleFieldDOMStructure:c,selectedSections:d,onSelectedSectionsChange:h,timezone:p,label:m,name:f,autoFocus:v&&!t.open,focused:!!E||void 0},g?{inputRef:g}:{}),ownerState:t});_&&(U.InputProps=(0,Po.A)({},U.InputProps,{ref:S},!t.disableOpenPicker&&{[`${P.position}Adornment`]:(0,hr.jsx)(O,(0,Po.A)({},P,{children:(0,hr.jsx)(L,(0,Po.A)({},z,{children:(0,hr.jsx)(B,(0,Po.A)({},W))}))}))}));const j=(0,Po.A)({textField:a.textField,clearIcon:a.clearIcon,clearButton:a.clearButton},U.slots),G=a.layout??LS;let H=C;N&&(H=m?`${C}-label`:void 0);const q=(0,Po.A)({},s,{toolbar:(0,Po.A)({},s?.toolbar,{titleId:C}),popper:(0,Po.A)({"aria-labelledby":H},s?.popper)}),K=qx(I,U.unstableFieldRef);return{renderPicker:()=>(0,hr.jsxs)(Tv,{localeText:x,children:[(0,hr.jsx)(V,(0,Po.A)({},U,{slots:j,slotProps:q,unstableFieldRef:K})),(0,hr.jsx)(Qk,(0,Po.A)({role:"dialog",placement:"bottom-start",anchorEl:S.current},A,{open:E,slots:a,slotProps:q,shouldRestoreFocus:D,reduceAnimations:w,children:(0,hr.jsx)(G,(0,Po.A)({},$,q?.layout,{slots:a,slotProps:q,children:R()}))}))]})}})({props:i,valueManager:bx,valueType:"date",getOpenDialogAriaText:i.localeText?.openDatePickerDialogue??n.openDatePickerDialogue,validator:Hx});return o()}));LN.propTypes={autoFocus:Dv().bool,className:Dv().string,closeOnSelect:Dv().bool,dayOfWeekFormatter:Dv().func,defaultValue:Dv().object,disabled:Dv().bool,disableFuture:Dv().bool,disableHighlightToday:Dv().bool,disableOpenPicker:Dv().bool,disablePast:Dv().bool,displayWeekNumber:Dv().bool,enableAccessibleFieldDOMStructure:Dv().any,fixedWeekNumber:Dv().number,format:Dv().string,formatDensity:Dv().oneOf(["dense","spacious"]),inputRef:Fv,label:Dv().node,loading:Dv().bool,localeText:Dv().object,maxDate:Dv().object,minDate:Dv().object,monthsPerRow:Dv().oneOf([3,4]),name:Dv().string,onAccept:Dv().func,onChange:Dv().func,onClose:Dv().func,onError:Dv().func,onMonthChange:Dv().func,onOpen:Dv().func,onSelectedSectionsChange:Dv().func,onViewChange:Dv().func,onYearChange:Dv().func,open:Dv().bool,openTo:Dv().oneOf(["day","month","year"]),orientation:Dv().oneOf(["landscape","portrait"]),readOnly:Dv().bool,reduceAnimations:Dv().bool,referenceDate:Dv().object,renderLoading:Dv().func,selectedSections:Dv().oneOfType([Dv().oneOf(["all","day","empty","hours","meridiem","minutes","month","seconds","weekDay","year"]),Dv().number]),shouldDisableDate:Dv().func,shouldDisableMonth:Dv().func,shouldDisableYear:Dv().func,showDaysOutsideCurrentMonth:Dv().bool,slotProps:Dv().object,slots:Dv().object,sx:Dv().oneOfType([Dv().arrayOf(Dv().oneOfType([Dv().func,Dv().object,Dv().bool])),Dv().func,Dv().object]),timezone:Dv().string,value:Dv().object,view:Dv().oneOf(["day","month","year"]),viewRenderers:Dv().shape({day:Dv().func,month:Dv().func,year:Dv().func}),views:Dv().arrayOf(Dv().oneOf(["day","month","year"]).isRequired),yearsPerRow:Dv().oneOf([3,4])};const zN=(0,Gn.Ay)(Kl)({[`& .${Vl.container}`]:{outline:0},[`& .${Vl.paper}`]:{outline:0,minWidth:$S}}),BN=(0,Gn.Ay)(tu)({"&:first-of-type":{padding:0}});function WN(e){const{children:t,onDismiss:n,open:r,slots:a,slotProps:s}=e,i=a?.dialog??zN,o=a?.mobileTransition??gi;return(0,hr.jsx)(i,(0,Po.A)({open:r,onClose:n},s?.dialog,{TransitionComponent:o,TransitionProps:s?.mobileTransition,PaperComponent:a?.mobilePaper,PaperProps:s?.mobilePaper,children:(0,hr.jsx)(BN,{children:t})}))}const VN=["props","getOpenDialogAriaText"],UN=T.forwardRef((function(e,t){const n=zx(),r=Ix(),a=Gx(e,"MuiMobileDatePicker"),s=(0,Po.A)({day:PN,month:PN,year:PN},a.viewRenderers),i=(0,Po.A)({},a,{viewRenderers:s,format:jv(r,a,!1),slots:(0,Po.A)({field:uC},a.slots),slotProps:(0,Po.A)({},a.slotProps,{field:e=>(0,Po.A)({},Mv(a.slotProps?.field,e),iI(a),{ref:t}),toolbar:(0,Po.A)({hidden:!1},a.slotProps?.toolbar)})}),{renderPicker:o}=(e=>{let{props:t,getOpenDialogAriaText:n}=e,r=zs(e,VN);const{slots:a,slotProps:s,className:i,sx:o,format:l,formatDensity:u,enableAccessibleFieldDOMStructure:c,selectedSections:d,onSelectedSectionsChange:h,timezone:p,name:f,label:m,inputRef:g,readOnly:y,disabled:b,localeText:v}=t,x=Ix(),w=T.useRef(null),k=uw(),S=s?.toolbar?.hidden??!1,{open:I,actions:C,layoutProps:N,renderCurrentView:E,fieldProps:A}=lS((0,Po.A)({},r,{props:t,fieldRef:w,autoFocusView:!0,additionalViewProps:{},wrapperVariant:"mobile"})),_=a.field,$=ew({elementType:_,externalSlotProps:s?.field,additionalProps:(0,Po.A)({},A,S&&{id:k},!(b||y)&&{onClick:C.onOpen,onKeyDown:(R=C.onOpen,e=>{"Enter"!==e.key&&" "!==e.key||(R(e),e.preventDefault(),e.stopPropagation()),D&&D(e)})},{readOnly:y??!0,disabled:b,className:i,sx:o,format:l,formatDensity:u,enableAccessibleFieldDOMStructure:c,selectedSections:d,onSelectedSectionsChange:h,timezone:p,label:m,name:f},g?{inputRef:g}:{}),ownerState:t});var R,D;$.inputProps=(0,Po.A)({},$.inputProps,{"aria-label":n(A.value,x)});const M=(0,Po.A)({textField:a.textField},$.slots),F=a.layout??LS;let O=k;S&&(O=m?`${k}-label`:void 0);const P=(0,Po.A)({},s,{toolbar:(0,Po.A)({},s?.toolbar,{titleId:k}),mobilePaper:(0,Po.A)({"aria-labelledby":O},s?.mobilePaper)}),L=qx(w,$.unstableFieldRef);return{renderPicker:()=>(0,hr.jsxs)(Tv,{localeText:v,children:[(0,hr.jsx)(_,(0,Po.A)({},$,{slots:M,slotProps:P,unstableFieldRef:L})),(0,hr.jsx)(WN,(0,Po.A)({},C,{open:I,slots:a,slotProps:P,children:(0,hr.jsx)(F,(0,Po.A)({},N,P?.layout,{slots:a,slotProps:P,children:E()}))}))]})}})({props:i,valueManager:bx,valueType:"date",getOpenDialogAriaText:i.localeText?.openDatePickerDialogue??n.openDatePickerDialogue,validator:Hx});return o()}));UN.propTypes={autoFocus:Dv().bool,className:Dv().string,closeOnSelect:Dv().bool,dayOfWeekFormatter:Dv().func,defaultValue:Dv().object,disabled:Dv().bool,disableFuture:Dv().bool,disableHighlightToday:Dv().bool,disableOpenPicker:Dv().bool,disablePast:Dv().bool,displayWeekNumber:Dv().bool,enableAccessibleFieldDOMStructure:Dv().any,fixedWeekNumber:Dv().number,format:Dv().string,formatDensity:Dv().oneOf(["dense","spacious"]),inputRef:Fv,label:Dv().node,loading:Dv().bool,localeText:Dv().object,maxDate:Dv().object,minDate:Dv().object,monthsPerRow:Dv().oneOf([3,4]),name:Dv().string,onAccept:Dv().func,onChange:Dv().func,onClose:Dv().func,onError:Dv().func,onMonthChange:Dv().func,onOpen:Dv().func,onSelectedSectionsChange:Dv().func,onViewChange:Dv().func,onYearChange:Dv().func,open:Dv().bool,openTo:Dv().oneOf(["day","month","year"]),orientation:Dv().oneOf(["landscape","portrait"]),readOnly:Dv().bool,reduceAnimations:Dv().bool,referenceDate:Dv().object,renderLoading:Dv().func,selectedSections:Dv().oneOfType([Dv().oneOf(["all","day","empty","hours","meridiem","minutes","month","seconds","weekDay","year"]),Dv().number]),shouldDisableDate:Dv().func,shouldDisableMonth:Dv().func,shouldDisableYear:Dv().func,showDaysOutsideCurrentMonth:Dv().bool,slotProps:Dv().object,slots:Dv().object,sx:Dv().oneOfType([Dv().arrayOf(Dv().oneOfType([Dv().func,Dv().object,Dv().bool])),Dv().func,Dv().object]),timezone:Dv().string,value:Dv().object,view:Dv().oneOf(["day","month","year"]),viewRenderers:Dv().shape({day:Dv().func,month:Dv().func,year:Dv().func}),views:Dv().arrayOf(Dv().oneOf(["day","month","year"]).isRequired),yearsPerRow:Dv().oneOf([3,4])};const jN=["desktopModeMediaQuery"],GN=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiDatePicker"}),{desktopModeMediaQuery:r=Wk}=n,a=zs(n,jN);return $v(r,{defaultMatches:!0})?(0,hr.jsx)(LN,(0,Po.A)({ref:t},a)):(0,hr.jsx)(UN,(0,Po.A)({ref:t},a))}));var HN=n(446),qN=n.n(HN),KN=n(6865),XN=n.n(KN),YN=n(8988),QN=n.n(YN),JN=n(4443),ZN=n.n(JN),eT=n(1525),tT=n.n(eT),nT=n(7076),rT=n.n(nT);qN().extend(ZN()),qN().extend(XN()),qN().extend(tT()),qN().extend(rT());const aT={YY:"year",YYYY:{sectionType:"year",contentType:"digit",maxLength:4},M:{sectionType:"month",contentType:"digit",maxLength:2},MM:"month",MMM:{sectionType:"month",contentType:"letter"},MMMM:{sectionType:"month",contentType:"letter"},D:{sectionType:"day",contentType:"digit",maxLength:2},DD:"day",Do:{sectionType:"day",contentType:"digit-with-letter"},d:{sectionType:"weekDay",contentType:"digit",maxLength:2},dd:{sectionType:"weekDay",contentType:"letter"},ddd:{sectionType:"weekDay",contentType:"letter"},dddd:{sectionType:"weekDay",contentType:"letter"},A:"meridiem",a:"meridiem",H:{sectionType:"hours",contentType:"digit",maxLength:2},HH:"hours",h:{sectionType:"hours",contentType:"digit",maxLength:2},hh:"hours",m:{sectionType:"minutes",contentType:"digit",maxLength:2},mm:"minutes",s:{sectionType:"seconds",contentType:"digit",maxLength:2},ss:"seconds"},sT={year:"YYYY",month:"MMMM",monthShort:"MMM",dayOfMonth:"D",dayOfMonthFull:"Do",weekday:"dddd",weekdayShort:"dd",hours24h:"HH",hours12h:"hh",meridiem:"A",minutes:"mm",seconds:"ss",fullDate:"ll",keyboardDate:"L",shortDate:"MMM D",normalDate:"D MMMM",normalDateWithWeekday:"ddd, MMM D",fullTime:"LT",fullTime12h:"hh:mm A",fullTime24h:"HH:mm",keyboardDateTime:"L LT",keyboardDateTime12h:"L hh:mm A",keyboardDateTime24h:"L HH:mm"},iT=["Missing UTC plugin","To be able to use UTC or timezones, you have to enable the `utc` plugin","Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-utc"].join("\n"),oT=["Missing timezone plugin","To be able to use timezones, you have to enable both the `utc` and the `timezone` plugin","Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-timezone"].join("\n");class lT{constructor(){var e=this;let{locale:t,formats:n}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};var r,a;this.isMUIAdapter=!0,this.isTimezoneCompatible=!0,this.lib="dayjs",this.dayjs=void 0,this.locale=void 0,this.formats=void 0,this.escapedCharacters={start:"[",end:"]"},this.formatTokenMap=aT,this.setLocaleToValue=e=>{const t=this.getCurrentLocaleCode();return t===e.locale()?e:e.locale(t)},this.hasUTCPlugin=()=>"undefined"!==typeof qN().utc,this.hasTimezonePlugin=()=>"undefined"!==typeof qN().tz,this.isSame=(e,t,n)=>{const r=this.setTimezone(t,this.getTimezone(e));return e.format(n)===r.format(n)},this.cleanTimezone=e=>{switch(e){case"default":return;case"system":return qN().tz.guess();default:return e}},this.createSystemDate=e=>{if(this.hasUTCPlugin()&&this.hasTimezonePlugin()){const t=qN().tz.guess();return"UTC"!==t?qN().tz(e,t):qN()(e)}return qN()(e)},this.createUTCDate=e=>{if(!this.hasUTCPlugin())throw new Error(iT);return qN().utc(e)},this.createTZDate=(e,t)=>{if(!this.hasUTCPlugin())throw new Error(iT);if(!this.hasTimezonePlugin())throw new Error(oT);const n=void 0!==e&&!e.endsWith("Z");return qN()(e).tz(this.cleanTimezone(t),n)},this.getLocaleFormats=()=>{const e=qN().Ls;let t=e[this.locale||"en"];return void 0===t&&(t=e.en),t.formats},this.adjustOffset=e=>{if(!this.hasTimezonePlugin())return e;const t=this.getTimezone(e);if("UTC"!==t){const n=e.tz(this.cleanTimezone(t),!0);if(n.$offset===(e.$offset??0))return e;e.$offset=n.$offset}return e},this.date=function(t){let n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default";return null===t?null:(n="UTC"===r?e.createUTCDate(t):"system"===r||"default"===r&&!e.hasTimezonePlugin()?e.createSystemDate(t):e.createTZDate(t,r),void 0===e.locale?n:n.locale(e.locale))},this.getInvalidDate=()=>qN()(new Date("Invalid date")),this.getTimezone=e=>{if(this.hasTimezonePlugin()){const t=e.$x?.$timezone;if(t)return t}return this.hasUTCPlugin()&&e.isUTC()?"UTC":"system"},this.setTimezone=(e,t)=>{if(this.getTimezone(e)===t)return e;if("UTC"===t){if(!this.hasUTCPlugin())throw new Error(iT);return e.utc()}if("system"===t)return e.local();if(!this.hasTimezonePlugin()){if("default"===t)return e;throw new Error(oT)}return qN().tz(e,this.cleanTimezone(t))},this.toJsDate=e=>e.toDate(),this.parse=(e,t)=>""===e?null:this.dayjs(e,t,this.locale,!0),this.getCurrentLocaleCode=()=>this.locale||"en",this.is12HourCycleInCurrentLocale=()=>/A|a/.test(this.getLocaleFormats().LT||""),this.expandFormat=e=>{const t=this.getLocaleFormats();return e.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,((e,n,r)=>{const a=r&&r.toUpperCase();return n||t[r]||t[a].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,((e,t,n)=>t||n.slice(1)))}))},this.isValid=e=>null!=e&&e.isValid(),this.format=(e,t)=>this.formatByString(e,this.formats[t]),this.formatByString=(e,t)=>this.dayjs(e).format(t),this.formatNumber=e=>e,this.isEqual=(e,t)=>null===e&&null===t||null!==e&&null!==t&&e.toDate().getTime()===t.toDate().getTime(),this.isSameYear=(e,t)=>this.isSame(e,t,"YYYY"),this.isSameMonth=(e,t)=>this.isSame(e,t,"YYYY-MM"),this.isSameDay=(e,t)=>this.isSame(e,t,"YYYY-MM-DD"),this.isSameHour=(e,t)=>e.isSame(t,"hour"),this.isAfter=(e,t)=>e>t,this.isAfterYear=(e,t)=>this.hasUTCPlugin()?!this.isSameYear(e,t)&&e.utc()>t.utc():e.isAfter(t,"year"),this.isAfterDay=(e,t)=>this.hasUTCPlugin()?!this.isSameDay(e,t)&&e.utc()>t.utc():e.isAfter(t,"day"),this.isBefore=(e,t)=>e<t,this.isBeforeYear=(e,t)=>this.hasUTCPlugin()?!this.isSameYear(e,t)&&e.utc()<t.utc():e.isBefore(t,"year"),this.isBeforeDay=(e,t)=>this.hasUTCPlugin()?!this.isSameDay(e,t)&&e.utc()<t.utc():e.isBefore(t,"day"),this.isWithinRange=(e,t)=>{let[n,r]=t;return e>=n&&e<=r},this.startOfYear=e=>this.adjustOffset(e.startOf("year")),this.startOfMonth=e=>this.adjustOffset(e.startOf("month")),this.startOfWeek=e=>this.adjustOffset(this.setLocaleToValue(e).startOf("week")),this.startOfDay=e=>this.adjustOffset(e.startOf("day")),this.endOfYear=e=>this.adjustOffset(e.endOf("year")),this.endOfMonth=e=>this.adjustOffset(e.endOf("month")),this.endOfWeek=e=>this.adjustOffset(this.setLocaleToValue(e).endOf("week")),this.endOfDay=e=>this.adjustOffset(e.endOf("day")),this.addYears=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"year"):e.add(t,"year")),this.addMonths=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"month"):e.add(t,"month")),this.addWeeks=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"week"):e.add(t,"week")),this.addDays=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"day"):e.add(t,"day")),this.addHours=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"hour"):e.add(t,"hour")),this.addMinutes=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"minute"):e.add(t,"minute")),this.addSeconds=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"second"):e.add(t,"second")),this.getYear=e=>e.year(),this.getMonth=e=>e.month(),this.getDate=e=>e.date(),this.getHours=e=>e.hour(),this.getMinutes=e=>e.minute(),this.getSeconds=e=>e.second(),this.getMilliseconds=e=>e.millisecond(),this.setYear=(e,t)=>this.adjustOffset(e.set("year",t)),this.setMonth=(e,t)=>this.adjustOffset(e.set("month",t)),this.setDate=(e,t)=>this.adjustOffset(e.set("date",t)),this.setHours=(e,t)=>this.adjustOffset(e.set("hour",t)),this.setMinutes=(e,t)=>this.adjustOffset(e.set("minute",t)),this.setSeconds=(e,t)=>this.adjustOffset(e.set("second",t)),this.setMilliseconds=(e,t)=>this.adjustOffset(e.set("millisecond",t)),this.getDaysInMonth=e=>e.daysInMonth(),this.getWeekArray=e=>{const t=this.startOfWeek(this.startOfMonth(e)),n=this.endOfWeek(this.endOfMonth(e));let r=0,a=t;const s=[];for(;a<n;){const e=Math.floor(r/7);s[e]=s[e]||[],s[e].push(a),a=this.addDays(a,1),r+=1}return s},this.getWeekNumber=e=>e.week(),this.getYearRange=e=>{let[t,n]=e;const r=this.startOfYear(t),a=this.endOfYear(n),s=[];let i=r;for(;this.isBefore(i,a);)s.push(i),i=this.addYears(i,1);return s},this.dayjs=(r=qN(),(a=t)?function(){return r(...arguments).locale(a)}:r),this.locale=t,this.formats=(0,Po.A)({},sT,n),qN().extend(QN())}getDayOfWeek(e){return e.day()+1}}var uT=n(7029),cT=n.n(uT),dT="/index.js",hT=Object.defineProperty,pT=n(7291),fT=(e,t)=>{for(var n in t)hT(e,n,{get:t[n],enumerable:!0})};fT({},{Abs:()=>YE,Acos:()=>QE,Acosh:()=>JE,AdadeltaOptimizer:()=>WW,AdagradOptimizer:()=>VW,AdamOptimizer:()=>UW,AdamaxOptimizer:()=>jW,Add:()=>ZE,AddN:()=>eA,All:()=>tA,Any:()=>nA,ArgMax:()=>rA,ArgMin:()=>aA,Asin:()=>sA,Asinh:()=>iA,Atan:()=>oA,Atan2:()=>uA,Atanh:()=>lA,AvgPool:()=>cA,AvgPool3D:()=>hA,AvgPool3DGrad:()=>pA,AvgPoolGrad:()=>dA,BackendWasm:()=>$me,BatchMatMul:()=>fA,BatchToSpaceND:()=>mA,Bincount:()=>gA,BitwiseAnd:()=>yA,BroadcastArgs:()=>vA,BroadcastTo:()=>bA,Callback:()=>b0,CallbackList:()=>nX,Cast:()=>xA,Ceil:()=>wA,ClipByValue:()=>kA,Complex:()=>SA,ComplexAbs:()=>IA,Concat:()=>CA,Conv2D:()=>NA,Conv2DBackpropFilter:()=>TA,Conv2DBackpropInput:()=>EA,Conv3D:()=>AA,Conv3DBackpropFilterV2:()=>_A,Conv3DBackpropInputV2:()=>$A,Cos:()=>RA,Cosh:()=>DA,CropAndResize:()=>OA,Cumprod:()=>MA,Cumsum:()=>FA,CustomCallback:()=>sX,DataStorage:()=>GT,DenseBincount:()=>PA,DepthToSpace:()=>LA,DepthwiseConv2dNative:()=>zA,DepthwiseConv2dNativeBackpropFilter:()=>BA,DepthwiseConv2dNativeBackpropInput:()=>WA,Diag:()=>VA,Dilation2D:()=>UA,Dilation2DBackpropFilter:()=>GA,Dilation2DBackpropInput:()=>jA,Draw:()=>HA,ENV:()=>qE,EarlyStopping:()=>w0,Einsum:()=>KA,Elu:()=>XA,EluGrad:()=>YA,Environment:()=>UE,Equal:()=>JA,Erf:()=>QA,Exp:()=>ZA,ExpandDims:()=>e_,Expm1:()=>t_,FFT:()=>n_,Fill:()=>r_,FlipLeftRight:()=>a_,Floor:()=>s_,FloorDiv:()=>i_,FromPixels:()=>uR,FusedBatchNorm:()=>o_,FusedConv2D:()=>hR,FusedDepthwiseConv2D:()=>pR,GPGPUContext:()=>xne,GatherNd:()=>u_,GatherV2:()=>l_,GraphModel:()=>u2,Greater:()=>c_,GreaterEqual:()=>d_,History:()=>aX,IFFT:()=>p_,Identity:()=>h_,Imag:()=>f_,InputSpec:()=>aK,IsFinite:()=>m_,IsInf:()=>g_,IsNan:()=>y_,KernelBackend:()=>HT,LRN:()=>__,LRNGrad:()=>$_,LayerVariable:()=>tK,LayersModel:()=>iY,LeakyRelu:()=>b_,Less:()=>v_,LessEqual:()=>x_,LinSpace:()=>w_,Log:()=>k_,Log1p:()=>S_,LogSoftmax:()=>E_,LogicalAnd:()=>I_,LogicalNot:()=>C_,LogicalOr:()=>N_,LogicalXor:()=>T_,LowerBound:()=>A_,MathBackendCPU:()=>E3,MathBackendWebGL:()=>Ure,MatrixBandPart:()=>R_,Max:()=>D_,MaxPool:()=>F_,MaxPool3D:()=>P_,MaxPool3DGrad:()=>L_,MaxPoolGrad:()=>O_,MaxPoolWithArgmax:()=>z_,Maximum:()=>M_,Mean:()=>B_,Min:()=>W_,Minimum:()=>V_,MirrorPad:()=>U_,Mod:()=>j_,MomentumOptimizer:()=>HW,Multinomial:()=>G_,Multiply:()=>H_,Neg:()=>q_,NonMaxSuppressionV3:()=>X_,NonMaxSuppressionV4:()=>Y_,NonMaxSuppressionV5:()=>Q_,NotEqual:()=>K_,OP_SCOPE_SUFFIX:()=>KD,OneHot:()=>Z_,OnesLike:()=>J_,Optimizer:()=>BW,OptimizerConstructors:()=>QV,Pack:()=>e$,PadV2:()=>t$,Pool:()=>n$,Pow:()=>r$,Prelu:()=>a$,Prod:()=>s$,RMSPropOptimizer:()=>qW,RNN:()=>hQ,RaggedGather:()=>i$,RaggedRange:()=>o$,RaggedTensorToTensor:()=>l$,Range:()=>u$,Rank:()=>fD,Real:()=>c$,RealDiv:()=>qA,Reciprocal:()=>d$,Reduction:()=>oW,Relu:()=>h$,Relu6:()=>b$,Reshape:()=>p$,ResizeBilinear:()=>g$,ResizeBilinearGrad:()=>y$,ResizeNearestNeighbor:()=>f$,ResizeNearestNeighborGrad:()=>m$,Reverse:()=>v$,RotateWithOffset:()=>cR,Round:()=>x$,Rsqrt:()=>w$,SGDOptimizer:()=>GW,ScatterNd:()=>k$,SearchSorted:()=>I$,Select:()=>C$,Selu:()=>N$,Sequential:()=>cY,Sigmoid:()=>$$,Sign:()=>_$,Sin:()=>E$,Sinh:()=>A$,Slice:()=>T$,Softmax:()=>P$,Softplus:()=>R$,SpaceToBatchND:()=>F$,SparseFillEmptyRows:()=>L$,SparseReshape:()=>z$,SparseSegmentMean:()=>B$,SparseSegmentSum:()=>W$,SparseToDense:()=>V$,SplitV:()=>O$,Sqrt:()=>D$,Square:()=>j$,SquaredDifference:()=>U$,StaticRegexReplace:()=>G$,Step:()=>lR,StridedSlice:()=>H$,StringNGrams:()=>q$,StringSplit:()=>K$,StringToHashBucketFast:()=>X$,Sub:()=>Y$,Sum:()=>M$,SymbolicTensor:()=>sK,Tan:()=>Q$,Tanh:()=>J$,Tensor:()=>dD,TensorBuffer:()=>lD,TensorScatterUpdate:()=>S$,Tile:()=>Z$,TopK:()=>eR,Transform:()=>tR,Transpose:()=>nR,Unique:()=>rR,Unpack:()=>aR,UnsortedSegmentSum:()=>sR,UpperBound:()=>iR,Variable:()=>pD,ZerosLike:()=>oR,_FusedMatMul:()=>dR,abs:()=>EF,acos:()=>AF,acosh:()=>_F,add:()=>IF,addN:()=>$F,all:()=>RF,any:()=>DF,argMax:()=>MF,argMin:()=>FF,asin:()=>OF,asinh:()=>PF,atan:()=>LF,atan2:()=>zF,atanh:()=>BF,avgPool:()=>rO,avgPool3d:()=>aO,backend:()=>xM,backend_util:()=>nU,basicLSTMCell:()=>cO,batchNorm:()=>pO,batchNorm2d:()=>fO,batchNorm3d:()=>mO,batchNorm4d:()=>gO,batchToSpaceND:()=>dO,bincount:()=>yO,bitwiseAnd:()=>bO,booleanMaskAsync:()=>lB,broadcastArgs:()=>vO,broadcastTo:()=>xO,broadcast_util:()=>jO,browser:()=>bV,buffer:()=>xF,callbacks:()=>I0,cast:()=>wF,ceil:()=>wO,clipByValue:()=>SO,clone:()=>kF,complex:()=>YD,concat:()=>sO,concat1d:()=>IO,concat2d:()=>CO,concat3d:()=>NO,concat4d:()=>TO,constraints:()=>xK,conv1d:()=>AO,conv2d:()=>EO,conv2dTranspose:()=>$O,conv3d:()=>RO,conv3dTranspose:()=>MO,copyRegisteredKernels:()=>CR,cos:()=>FO,cosh:()=>OO,cosineWindow:()=>gB,cumprod:()=>PO,cumsum:()=>LO,customGrad:()=>HP,data:()=>p2,denseBincount:()=>zO,deprecationWarn:()=>aM,depthToSpace:()=>BO,depthwiseConv2d:()=>WO,deregisterOp:()=>E0,device_util:()=>LD,diag:()=>VO,dilation2d:()=>UO,disableDeprecationWarnings:()=>rM,dispose:()=>cM,disposeVariables:()=>sM,div:()=>NF,divNoNan:()=>QO,dot:()=>JO,dropout:()=>fB,einsum:()=>ZO,elu:()=>eP,enableDebugMode:()=>nM,enableProdMode:()=>tM,enclosingPowerOfTwo:()=>mB,engine:()=>iM,ensureShape:()=>tP,env:()=>GE,equal:()=>KO,erf:()=>nP,euclideanNorm:()=>xP,exp:()=>wP,expandDims:()=>kP,expm1:()=>SP,eye:()=>CP,fft:()=>$z,fill:()=>kO,findBackend:()=>yM,findBackendFactory:()=>bM,floor:()=>NP,floorDiv:()=>CF,forceHalfFloat:()=>Gre,fused:()=>bB,gather:()=>TP,gatherND:()=>pB,gather_util:()=>EV,getBackend:()=>mM,getGradient:()=>vR,getKernel:()=>bR,getKernelsForBackend:()=>xR,getThreadsCount:()=>Gme,gpgpu_util:()=>Qte,grad:()=>WP,grads:()=>VP,greater:()=>EP,greaterEqual:()=>AP,ifft:()=>Rz,imag:()=>_P,image:()=>EW,inTopKAsync:()=>yB,initializers:()=>FK,input:()=>pY,io:()=>XW,irfft:()=>Dz,isFinite:()=>$P,isInf:()=>RP,isNaN:()=>DP,keep:()=>dM,kernel_impls:()=>lj,layers:()=>JK,leakyRelu:()=>MP,less:()=>FP,lessEqual:()=>OP,linalg:()=>AW,linspace:()=>PP,loadGraphModel:()=>c2,loadGraphModelSync:()=>d2,loadLayersModel:()=>uY,localResponseNormalization:()=>LP,log:()=>zP,log1p:()=>BP,logSigmoid:()=>YP,logSoftmax:()=>JP,logSumExp:()=>ZP,logicalAnd:()=>eL,logicalNot:()=>tL,logicalOr:()=>nL,logicalXor:()=>rL,losses:()=>_W,lowerBound:()=>iL,matMul:()=>iO,math:()=>gV,max:()=>dP,maxPool:()=>oL,maxPool3d:()=>lL,maxPoolWithArgmax:()=>uL,maximum:()=>cL,mean:()=>dL,memory:()=>oM,meshgrid:()=>fL,metrics:()=>QZ,min:()=>hP,minimum:()=>mL,mirrorPad:()=>gL,mod:()=>yL,model:()=>dY,models:()=>p0,moments:()=>bL,movingAverage:()=>cB,mul:()=>TF,multiRNNCell:()=>vL,multinomial:()=>xL,neg:()=>KP,nextFrame:()=>eU,norm:()=>vP,notEqual:()=>wL,oneHot:()=>kL,ones:()=>pL,onesLike:()=>SL,op:()=>XD,outerProduct:()=>IL,pad:()=>CL,pad1d:()=>NL,pad2d:()=>TL,pad3d:()=>EL,pad4d:()=>AL,pool:()=>$L,pow:()=>pP,prelu:()=>RL,print:()=>SF,prod:()=>DL,profile:()=>lM,raggedGather:()=>ML,raggedRange:()=>FL,raggedTensorToTensor:()=>OL,rand:()=>PL,randomGamma:()=>rz,randomNormal:()=>az,randomStandardNormal:()=>sz,randomUniform:()=>iz,randomUniformInt:()=>oz,range:()=>lz,ready:()=>fM,real:()=>uz,reciprocal:()=>cz,registerBackend:()=>vM,registerCallbackConstructor:()=>fY,registerGradient:()=>kR,registerKernel:()=>wR,registerOp:()=>N0,regularizers:()=>f0,relu:()=>dz,relu6:()=>hz,removeBackend:()=>gM,reshape:()=>nO,reverse:()=>pz,reverse1d:()=>fz,reverse2d:()=>mz,reverse3d:()=>gz,reverse4d:()=>yz,rfft:()=>Fz,round:()=>bz,rsqrt:()=>vz,scalar:()=>fP,scatterND:()=>dB,scatter_util:()=>Kz,searchSorted:()=>sL,selu:()=>xz,separableConv2d:()=>wz,sequential:()=>hY,serialization:()=>DW,setBackend:()=>pM,setPlatform:()=>wM,setThreadsCount:()=>jme,setWasmPath:()=>Bme,setWasmPaths:()=>Wme,setWebGLContext:()=>mee,setdiff1dAsync:()=>kz,shared:()=>A3,sigmoid:()=>oO,sign:()=>Sz,signal:()=>TW,sin:()=>Iz,sinh:()=>Cz,slice:()=>lO,slice1d:()=>Nz,slice2d:()=>Tz,slice3d:()=>Ez,slice4d:()=>Az,slice_util:()=>_V,softmax:()=>_z,softplus:()=>XP,spaceToBatchND:()=>_L,sparse:()=>$W,sparseToDense:()=>hB,spectral:()=>NW,split:()=>Mz,sqrt:()=>mP,square:()=>gP,squaredDifference:()=>Oz,squeeze:()=>Pz,stack:()=>Lz,step:()=>zz,stridedSlice:()=>Bz,string:()=>RW,sub:()=>QP,sum:()=>yP,sumOutType:()=>SD,tan:()=>Wz,tanh:()=>uO,tensor:()=>JD,tensor1d:()=>Vz,tensor2d:()=>Uz,tensor3d:()=>jz,tensor4d:()=>Gz,tensor5d:()=>Hz,tensor6d:()=>qz,tensorScatterUpdate:()=>Jz,tensor_util:()=>xD,test_util:()=>zL,tidy:()=>uM,tile:()=>IP,time:()=>hM,topk:()=>Zz,train:()=>JV,transpose:()=>uB,truncatedNormal:()=>eB,unique:()=>tB,unregisterGradient:()=>IR,unregisterKernel:()=>SR,unsortedSegmentSum:()=>nB,unstack:()=>rB,upcastType:()=>kD,upperBound:()=>aB,util:()=>TR,valueAndGrad:()=>UP,valueAndGrads:()=>jP,variable:()=>sB,variableGrads:()=>GP,version:()=>Kme,version_converter:()=>h2,version_core:()=>YV,version_cpu:()=>n6,version_layers:()=>WX,version_wasm:()=>Hme,version_webgl:()=>jre,webgl:()=>Hre,webgl_util:()=>uee,where:()=>XO,whereAsync:()=>oB,zeros:()=>hL,zerosLike:()=>YO});var mT=Object.create,gT=Object.defineProperty,yT=Object.getOwnPropertyDescriptor,bT=Object.getOwnPropertyNames,vT=Object.getPrototypeOf,xT=Object.prototype.hasOwnProperty,wT=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),kT=(e,t)=>{for(var n in t)gT(e,n,{get:t[n],enumerable:!0})},ST=(e,t,n)=>(n=null!=e?mT(vT(e)):{},((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of bT(t))!xT.call(e,a)&&a!==n&&gT(e,a,{get:()=>t[a],enumerable:!(r=yT(t,a))||r.enumerable});return e})(!t&&e&&e.__esModule?n:gT(n,"default",{value:e,enumerable:!0}),e)),IT=wT(((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(md){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var s={},i={};function o(e,t){var n,r,a;return t?(a=0<=(e>>>=0)&&e<256)&&(r=i[e])?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(i[e]=n),n):(a=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=u(e,e<0?-1:0,!1),a&&(s[e]=n),n)}function l(e,t){if(isNaN(e))return t?b:y;if(t){if(e<0)return b;if(e>=f)return S}else{if(e<=-m)return I;if(e+1>=m)return k}return e<0?l(-e,t).neg():u(e%p|0,e/p|0,t)}function u(e,t,n){return new r(e,t,n)}r.fromInt=o,r.fromNumber=l,r.fromBits=u;var c=Math.pow;function d(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return y;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return d(e.substring(1),t,n).neg();for(var a=l(c(n,8)),s=y,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),u=parseInt(e.substring(i,i+o),n);if(o<8){var h=l(c(n,o));s=s.mul(h).add(l(u))}else s=(s=s.mul(a)).add(l(u))}return s.unsigned=t,s}function h(e,t){return"number"==typeof e?l(e,t):"string"==typeof e?d(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=d,r.fromValue=h;var p=4294967296,f=p*p,m=f/2,g=o(1<<24),y=o(0);r.ZERO=y;var b=o(0,!0);r.UZERO=b;var v=o(1);r.ONE=v;var x=o(1,!0);r.UONE=x;var w=o(-1);r.NEG_ONE=w;var k=u(-1,2147483647,!1);r.MAX_VALUE=k;var S=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=S;var I=u(0,-2147483648,!1);r.MIN_VALUE=I;var C=r.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},C.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(I)){var t=l(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=l(c(e,6),this.unsigned),s=this,i="";;){var o=s.div(a),u=(s.sub(o.mul(a)).toInt()>>>0).toString(e);if((s=o).isZero())return u+i;for(;u.length<6;)u="0"+u;i=""+u+i}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1===(1&this.low)},C.isEven=function(){return 0===(1&this.low)},C.equals=function(e){return a(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return this.comp(e)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return this.comp(e)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(a(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(v)},C.neg=C.negate,C.add=function(e){a(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,d+=(p+=r+l)>>>16,c+=(d+=n+o)>>>16,c+=t+i,u((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},C.subtract=function(e){return a(e)||(e=h(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return y;if(a(e)||(e=h(e)),n)return u(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return y;if(this.eq(I))return e.isOdd()?I:y;if(e.eq(I))return this.isOdd()?I:y;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return l(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,r=65535&this.high,s=this.low>>>16,i=65535&this.low,o=e.high>>>16,c=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,m=0,b=0,v=0;return b+=(v+=i*p)>>>16,m+=(b+=s*p)>>>16,b&=65535,m+=(b+=i*d)>>>16,f+=(m+=r*p)>>>16,m&=65535,f+=(m+=s*d)>>>16,m&=65535,f+=(m+=i*c)>>>16,f+=t*p+r*d+s*c+i*o,u((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(m&=65535),this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(a(e)||(e=h(e)),e.isZero())throw Error("division by zero");var t,r,s;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:y;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return x;s=b}else{if(this.eq(I))return e.eq(v)||e.eq(w)?I:e.eq(I)?v:(t=this.shr(1).div(e).shl(1)).eq(y)?e.isNegative()?v:w:(r=this.sub(e.mul(t)),s=t.add(r.div(e)));if(e.eq(I))return this.unsigned?b:y;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=y}for(r=this;r.gte(e);){t=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(t)/Math.LN2),o=i<=48?1:c(2,i-48),d=l(t),p=d.mul(e);p.isNegative()||p.gt(r);)p=(d=l(t-=o,this.unsigned)).mul(e);d.isZero()&&(d=v),s=s.add(d),r=r.sub(p)}return s},C.div=C.divide,C.modulo=function(e){return a(e)||(e=h(e)),n?u((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return u(~this.low,~this.high,this.unsigned)},C.and=function(e){return a(e)||(e=h(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return a(e)||(e=h(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return a(e)||(e=h(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}})),CT=wT((()=>{})),NT=wT((()=>{})),TT=wT(((e,t)=>{!function(e,t,n){function r(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new r(e),s=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),ET=wT(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),AT=wT(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),_T=wT(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&(s.x&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),$T=wT(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,a=0==(n=o[127&s]^=r+i)?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&(s.X&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),RT=wT(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),DT=wT((()=>{})),MT=wT(((e,t)=>{!function(e,r,a){var s,i=256,o="random",l=a.pow(i,6),u=a.pow(2,52),c=2*u,d=i-1;function h(t,n,d){var h=[],b=g(m((n=1==n?{entropy:!0}:n||{}).entropy?[t,y(r)]:null==t?function(){try{var t;return s&&(t=s.randomBytes)?t=t(i):(t=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(t)),y(t)}catch(h){var n=e.navigator,a=n&&n.plugins;return[+new Date,e,a,e.screen,y(r)]}}():t,3),h),v=new p(h),x=function(){for(var e=v.g(6),t=l,n=0;e<u;)e=(e+n)*i,t*=i,n=v.g(1);for(;e>=c;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|v.g(4)},x.quick=function(){return v.g(4)/4294967296},x.double=x,g(y(v.S),r),(n.pass||d||function(e,t,n,r){return r&&(r.S&&f(r,v),e.state=function(){return f(v,{})}),n?(a[o]=e,t):e})(x,b,"global"in n?n.global:this==a,n.state)}function p(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);a<i;)o[a]=a++;for(a=0;a<i;a++)o[a]=o[s=d&s+e[a%n]+(t=o[a])],o[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,o=r.S;e--;)t=o[a=d&a+1],n=n*i+o[d&(o[a]=o[s=d&s+t])+(o[s]=t)];return r.i=a,r.j=s,n})(i)}function f(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function m(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(m(e[n],t-1))}catch(bd){}return r.length?r:"string"==a?e:e+"\0"}function g(e,t){for(var n,r=e+"",a=0;a<r.length;)t[d&a]=d&(n^=19*t[d&a])+r.charCodeAt(a++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(g(a.random(),r),"object"==typeof t&&t.exports){t.exports=h;try{s=DT()}catch(T6e){}}else"function"==typeof define&&n.amdO?define((function(){return h})):a["seed"+o]=h}("undefined"!=typeof self?self:e,[],Math)})),FT=wT(((e,t)=>{var n=TT(),r=ET(),a=AT(),s=_T(),i=$T(),o=RT(),l=MT();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l})),OT=wT((()=>{})),PT=wT((()=>{})),LT=wT((()=>{})),zT=wT((()=>{})),BT=wT((()=>{})),WT=wT((()=>{})),VT=wT(((e,t)=>{var r=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||dT,function(t){function r(){return $.buffer!=F&&j($.buffer),P}function a(){return $.buffer!=F&&j($.buffer),L}function s(){return $.buffer!=F&&j($.buffer),z}function i(){return $.buffer!=F&&j($.buffer),B}var o,l,u,c="undefined"!=typeof(t=t||{})?t:{};c.ready=new Promise((function(e,t){o=e,l=t})),"undefined"!=typeof process&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d,h,p,f=Object.assign({},c),m=[],g=(e,t)=>{throw t},y="object"==typeof window,b="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=c.ENVIRONMENT_IS_PTHREAD||!1,w="";function k(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var S=PT(),I=LT();let e;w=b?I.dirname(w)+"/":"//",d=(e,t)=>(e=oe(e)?new URL(e):I.normalize(e),S.readFileSync(e,t?void 0:"utf8")),p=e=>{var t=d(e,!0);return t.buffer||(t=new Uint8Array(t)),t},h=(e,t,n)=>{e=oe(e)?new URL(e):I.normalize(e),S.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),m=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ce))throw e})),process.on("unhandledRejection",(function(e){throw e})),g=(e,t)=>{if(Y())throw process.exitCode=e,t;(function(e){e instanceof ce||E("exiting due to exception: "+e)})(t),process.exit(e)},c.inspect=function(){return"[Emscripten Module object]"};try{e=zT()}catch(Je){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Je}n.g.Worker=e.Worker}else(y||b)&&(b?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),"undefined"!=typeof e&&e&&(w=e),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},b&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),h=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}),e=>document.title=e);v&&"undefined"==typeof performance&&(n.g.performance=BT().performance);var C=console.log.bind(console),N=console.warn.bind(console);v&&(C=e=>S.writeSync(1,e+"\n"),N=e=>S.writeSync(2,e+"\n"));var T=c.print||C,E=c.printErr||N;Object.assign(c,f),f=null,c.arguments&&(m=c.arguments),c.thisProgram&&c.thisProgram,c.quit&&(g=c.quit);var A;Atomics.load,Atomics.store,Atomics.compareExchange;c.wasmBinary&&(A=c.wasmBinary);var _=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&re("no native wasm support detected");var $,R,D,M=!1;var F,O,P,L,z,B,W="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function V(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&W)return W.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,a):e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if((i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function U(e,t){return(e>>>=0)?V(r(),e,t):""}function j(e){F=e,c.HEAP8=O=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=L=new Int32Array(e),c.HEAPU8=P=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=z=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=B=new Float64Array(e)}x&&(F=c.buffer);var G=c.INITIAL_MEMORY||16777216;if(x)$=c.wasmMemory,F=c.buffer;else if(c.wasmMemory)$=c.wasmMemory;else if(!(($=new WebAssembly.Memory({initial:G/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw E("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&E("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");$&&(F=$.buffer),G=F.byteLength,j(F);var H,q=[],K=[],X=[];function Y(){return _}function Q(){!x&&ge(K)}function J(e){q.unshift(e)}function Z(e){X.unshift(e)}var ee=0,te=null,ne=null;function re(e){c.onAbort&&c.onAbort(e),E(e="Aborted("+e+")"),M=!0,D=1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw l(t),t}var ae,se="data:application/octet-stream;base64,";function ie(e){return e.startsWith(se)}function oe(e){return e.startsWith("file://")}function le(e){try{if(e==ae&&A)return new Uint8Array(A);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(Je){re(Je)}}ie(ae="tfjs-backend-wasm-threaded-simd.wasm")||(ae=k(ae));var ue={};function ce(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function de(e){var t=me.pthreads[e];(function(e,t){e||re(t)})(t),me.returnWorkerToPool(t)}function he(e){var t=me.getNewWorker();if(!t)return 6;me.runningWorkers.push(t),me.pthreads[e.pthread_ptr]=t,t.pthread_ptr=e.pthread_ptr;var n={cmd:"run",start_routine:e.startRoutine,arg:e.arg,pthread_ptr:e.pthread_ptr};return t.runPthread=()=>{v&&t.ref(),t.postMessage(n,e.transferList),delete t.runPthread},t.loaded&&t.runPthread(),0}function pe(e){if(x)return Ie(1,1,e);D=e,Y()||(me.terminateAllThreads(),c.onExit&&c.onExit(e),M=!0),g(e,new ce(e))}var fe=function(e,t){if(D=e,!t&&x)throw ye(e),"unwind";pe(e)};var me={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?me.initWorker():me.initMainThread()},initMainThread:function(){for(var e=8;e--;)me.allocateUnusedWorker()},initWorker:function(){_=!1},setExitStatus:function(e){D=e},terminateAllThreads:function(){for(var e of Object.values(me.pthreads))me.returnWorkerToPool(e);for(var e of me.unusedWorkers)e.terminate();me.unusedWorkers=[]},returnWorkerToPool:function(e){var t=e.pthread_ptr;delete me.pthreads[t],me.unusedWorkers.push(e),me.runningWorkers.splice(me.runningWorkers.indexOf(e),1),e.pthread_ptr=0,v&&e.unref(),je(t)},receiveObjectTransfer:function(e){},threadInitTLS:function(){me.tlsInitFunctions.forEach((e=>e()))},loadWasmModuleToWorker:function(t,n){t.onmessage=e=>{var r=e.data,a=r.cmd;if(t.pthread_ptr&&(me.currentProxiedOperationCallerThread=t.pthread_ptr),r.targetThread&&r.targetThread!=Be()){var s=me.pthreads[r.targetThread];return s?s.postMessage(r,r.transferList):E('Internal error! Worker sent a message "'+a+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(me.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===a?ke(r.queue):"spawnThread"===a?he(r):"cleanupThread"===a?de(r.thread):"killThread"===a?function(e){var t=me.pthreads[e];delete me.pthreads[e],t.terminate(),je(e),me.runningWorkers.splice(me.runningWorkers.indexOf(t),1),t.pthread_ptr=0}(r.thread):"cancelThread"===a?function(e){me.pthreads[e].postMessage({cmd:"cancel"})}(r.thread):"loaded"===a?(t.loaded=!0,v&&t.unref(),n&&n(t),t.runPthread&&t.runPthread()):"print"===a?T("Thread "+r.threadId+": "+r.text):"printErr"===a?E("Thread "+r.threadId+": "+r.text):"alert"===a?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?t.postMessage(r):"callHandler"===a?c[r.handler](...r.args):a&&E("worker sent an unknown command "+a),me.currentProxiedOperationCallerThread=void 0},t.onerror=e=>{throw E("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){})));var r=[];for(var a of["onExit","onAbort","print","printErr"])c.hasOwnProperty(a)&&r.push(a);t.postMessage({cmd:"load",handlers:r,urlOrBlob:c.mainScriptUrlOrBlob||e,wasmMemory:$,wasmModule:R})},allocateUnusedWorker:function(){var e,t=k("tfjs-backend-wasm-threaded-simd.worker.js");e=new Worker(t),me.unusedWorkers.push(e)},getNewWorker:function(){return 0==me.unusedWorkers.length&&(me.allocateUnusedWorker(),me.loadWasmModuleToWorker(me.unusedWorkers[0])),me.unusedWorkers.pop()}};function ge(e){for(;e.length>0;)e.shift()(c)}function ye(e){if(x)return Ie(2,0,e);try{fe(e)}catch(Je){!function(e){if(e instanceof ce||"unwind"==e)return D;g(1,e)}(Je)}}c.PThread=me,c.establishStackSpace=function(){var e=Be(),t=a()[e+52>>>2],n=a()[e+56>>>2];He(t,t-n),Ke(t)};var be=[];function ve(e,t,n,r){return x?Ie(3,1,e,t,n,r):xe(e,t,n,r)}function xe(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return E("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];if(x&&0===a.length)return ve(e,t,n,r);var s={startRoutine:n,pthread_ptr:e,arg:r,transferList:a};return x?(s.cmd="spawnThread",postMessage(s,a),0):he(s)}c.invokeEntryPoint=function(e,t){var n=function(e){var t=be[e];return t||(e>=be.length&&(be.length=e+1),be[e]=t=H.get(e)),t}(e)(t);Y()?me.setExitStatus(n):Ge(n)};var we;function ke(e){Atomics.store(a(),e>>2,1),Be()&&Ue(e),Atomics.compareExchange(a(),e>>2,1,0)}function Se(e){Se.shown||(Se.shown={}),Se.shown[e]||(Se.shown[e]=1,v&&(e="warning: "+e),E(e))}function Ie(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=qe(),n=e();return Ke(t),n}((()=>{for(var a=n,s=Xe(8*a),o=s>>3,l=0;l<n;l++){var u=r[2+l];i()[o+l>>>0]=u}return Ve(e,a,s,t)}))}c.executeNotifiedProxyingQueue=ke,we=v?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.timeOrigin+performance.now();var Ce=[];function Ne(e){try{return $.grow(e-F.byteLength+65535>>>16),j($.buffer),1}catch(Je){}}function Te(e){return x?Ie(4,1,e):52}function Ee(e,t,n,r,a){return x?Ie(5,1,e,t,n,r,a):70}var Ae=[null,[],[]];function _e(e,t){var n=Ae[e];0===t||10===t?((1===e?T:E)(V(n,0)),n.length=0):n.push(t)}function $e(e,t,n,a){if(x)return Ie(6,1,e,t,n,a);for(var i=0,o=0;o<n;o++){var l=s()[t>>>2],u=s()[t+4>>>2];t+=8;for(var c=0;c<u;c++)_e(e,r()[l+c>>>0]);i+=u}return s()[a>>>2]=i,0}function Re(e){return c["_"+e]}function De(e,t){($.buffer!=F&&j($.buffer),O).set(e,t>>>0)}function Me(e,t,n,a,s){var i={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);(function(e,t,n){(function(e,t,n,r){if(!(r>0))return 0;for(var a=n>>>=0,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),o<=127){if(n>=s)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=s)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=s)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0})(e,r(),t,n)})(e,t=Xe(n),n)}return t},array:e=>{var t=Xe(e.length);return De(e,t),t}};var o=Re(e),l=[],u=0;if(a)for(var c=0;c<a.length;c++){var d=i[n[c]];d?(0===u&&(u=qe()),l[c]=d(a[c])):l[c]=a[c]}var h,p=o.apply(null,l);return h=p,0!==u&&Ke(u),p=function(e){return"string"===t?U(e):"boolean"===t?!!e:e}(h),p}me.init();var Fe,Oe,Pe,Le=[null,pe,ye,ve,Te,Ee,$e],ze={__emscripten_init_main_thread_js:function(e){We(e,!b,1,!y),me.threadInitTLS()},__emscripten_thread_cleanup:function(e){x?postMessage({cmd:"cleanupThread",thread:e}):de(e)},__pthread_create_js:xe,_emscripten_default_pthread_stack_size:function(){return 65536},_emscripten_get_now_is_monotonic:function(){return true},_emscripten_notify_task_queue:function(e,t,n,r){if(e==t)setTimeout((()=>ke(r)));else if(x)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{var a=me.pthreads[e];if(!a)return;a.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},_emscripten_set_offscreencanvas_size:function(e,t,n){return-1},abort:function(){re("")},emscripten_check_blocking_allowed:function(){v||b||Se("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function(){return Date.now()},emscripten_get_heap_max:function(){return 4294901760},emscripten_get_now:we,emscripten_memcpy_big:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_num_logical_cores:function(){return v?WT().cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(e,t,n){Ce.length=t;for(var r=n>>3,a=0;a<t;a++)Ce[a]=i()[r+a>>>0];return(e<0?ue[-e-1]:Le[e]).apply(null,Ce)},emscripten_resize_heap:function(e){var t=r().length;if((e>>>=0)<=t)return!1;var n,a,s=4294901760;if(e>s)return!1;for(var i=1;i<=4;i*=2){var o=t*(1+.2/i);if(o=Math.min(o,e+100663296),Ne(Math.min(s,(n=Math.max(e,o))+((a=65536)-n%a)%a)))return!0}return!1},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},exit:fe,fd_close:Te,fd_seek:Ee,fd_write:$e,memory:$||c.wasmMemory},Be=(function(){var e={env:ze,wasi_snapshot_preview1:ze};function t(e,t){var n=e.exports;if(c.asm=n,function(e){me.tlsInitFunctions.push(e)}(c.asm._emscripten_tls_init),H=c.asm.__indirect_function_table,function(e){K.unshift(e)}(c.asm.__wasm_call_ctors),R=t,!x){var r=me.unusedWorkers.length;me.unusedWorkers.forEach((function(e){me.loadWasmModuleToWorker(e,(function(){--r||function(){if(ee--,c.monitorRunDependencies&&c.monitorRunDependencies(ee),0==ee&&(null!==te&&(clearInterval(te),te=null),ne)){var e=ne;ne=null,e()}}()}))}))}}function n(e){t(e.instance,e.module)}function r(t){return function(){if(!A&&(y||b)){if("function"==typeof fetch&&!oe(ae))return fetch(ae,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+ae+"'";return e.arrayBuffer()})).catch((function(){return le(ae)}));if(h)return new Promise((function(e,t){h(ae,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return le(ae)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){E("failed to asynchronously prepare wasm: "+e),re(e)}))}if(x||(ee++,c.monitorRunDependencies&&c.monitorRunDependencies(ee)),c.instantiateWasm)try{return c.instantiateWasm(e,t)}catch(a){E("Module.instantiateWasm callback failed with error: "+a),l(a)}(A||"function"!=typeof WebAssembly.instantiateStreaming||ie(ae)||oe(ae)||v||"function"!=typeof fetch?r(n):fetch(ae,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return E("wasm streaming compile failed: "+e),E("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(l)}(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Acos=function(){return(c._Acos=c.asm.Acos).apply(null,arguments)},c._Acosh=function(){return(c._Acosh=c.asm.Acosh).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._ArgMin=function(){return(c._ArgMin=c.asm.ArgMin).apply(null,arguments)},c._Asin=function(){return(c._Asin=c.asm.Asin).apply(null,arguments)},c._Asinh=function(){return(c._Asinh=c.asm.Asinh).apply(null,arguments)},c._Atan=function(){return(c._Atan=c.asm.Atan).apply(null,arguments)},c._Atan2=function(){return(c._Atan2=c.asm.Atan2).apply(null,arguments)},c._Atanh=function(){return(c._Atanh=c.asm.Atanh).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._AvgPool3D=function(){return(c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},c._AvgPool3DGrad=function(){return(c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},c._AvgPoolGrad=function(){return(c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Bincount=function(){return(c._Bincount=c.asm.Bincount).apply(null,arguments)},c._BitwiseAnd=function(){return(c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Conv3D=function(){return(c._Conv3D=c.asm.Conv3D).apply(null,arguments)},c._Conv3DBackpropFilterV2=function(){return(c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},c._Conv3DBackpropInputV2=function(){return(c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DenseBincount=function(){return(c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Diag=function(){return(c._Diag=c.asm.Diag).apply(null,arguments)},c._Dilation2D=function(){return(c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},c._Dilation2DBackpropFilter=function(){return(c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},c._Dilation2DBackpropInput=function(){return(c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._EluGrad=function(){return(c._EluGrad=c.asm.EluGrad).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Erf=function(){return(c._Erf=c.asm.Erf).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._Expm1=function(){return(c._Expm1=c.asm.Expm1).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._IsFinite=function(){return(c._IsFinite=c.asm.IsFinite).apply(null,arguments)},c._IsInf=function(){return(c._IsInf=c.asm.IsInf).apply(null,arguments)},c._IsNan=function(){return(c._IsNan=c.asm.IsNan).apply(null,arguments)},c._LRN=function(){return(c._LRN=c.asm.LRN).apply(null,arguments)},c._LRNGrad=function(){return(c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._LinSpace=function(){return(c._LinSpace=c.asm.LinSpace).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._Log1p=function(){return(c._Log1p=c.asm.Log1p).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._MaxPool3D=function(){return(c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},c._MaxPool3DGrad=function(){return(c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},c._MaxPoolGrad=function(){return(c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},c._MaxPoolWithArgmax=function(){return(c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Mod=function(){return(c._Mod=c.asm.Mod).apply(null,arguments)},c._Multinomial=function(){return(c._Multinomial=c.asm.Multinomial).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Reciprocal=function(){return(c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeBilinearGrad=function(){return(c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._ResizeNearestNeighborGrad=function(){return(c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SearchSorted=function(){return(c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Selu=function(){return(c._Selu=c.asm.Selu).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sign=function(){return(c._Sign=c.asm.Sign).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Sinh=function(){return(c._Sinh=c.asm.Sinh).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._Softplus=function(){return(c._Softplus=c.asm.Softplus).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._SparseToDense=function(){return(c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._TensorScatterUpdate=function(){return(c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)},c._pthread_self=function(){return(Be=c._pthread_self=c.asm.pthread_self).apply(null,arguments)}),We=(c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)},c.__emscripten_thread_init=function(){return(We=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)}),Ve=(c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)},c._emscripten_run_in_main_runtime_thread_js=function(){return(Ve=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),Ue=(c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},c.__emscripten_proxy_execute_task_queue=function(){return(Ue=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),je=c.__emscripten_thread_free_data=function(){return(je=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},Ge=c.__emscripten_thread_exit=function(){return(Ge=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},He=c._emscripten_stack_set_limits=function(){return(He=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},qe=c.stackSave=function(){return(qe=c.stackSave=c.asm.stackSave).apply(null,arguments)},Ke=c.stackRestore=function(){return(Ke=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},Xe=c.stackAlloc=function(){return(Xe=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)};function Ye(e){if(e=e||m,!(ee>0)){if(x)return o(c),Q(),void startWorker(c);(function(){if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)J(c.preRun.shift());ge(q)})(),ee>0||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),t()}),1)):t())}function t(){Fe||(Fe=!0,c.calledRun=!0,!M&&(Q(),o(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),function(){if(!x){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;)Z(c.postRun.shift());ge(X)}}()))}}if(c.keepRuntimeAlive=Y,c.wasmMemory=$,c.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?Re(e):function(){return Me(e,t,n,arguments)}},c.ExitStatus=ce,c.PThread=me,ne=function e(){Fe||Ye(),Fe||(ne=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();if(Ye(),u&&(Oe={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!u.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!u.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)Pe=WasmBackendModule;else{if("undefined"==typeof t)throw new Error("Could not find wasm module in post.js");Pe=t}if(Oe){var Qe=Pe._dispose;Pe._dispose=function(){Qe(),Oe.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Oe.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&n.amdO?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=r)})),UT=wT(((e,t)=>{t.exports.wasmWorkerContents='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'})),jT=wT(((e,t)=>{var r=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||dT,function(t){var n,r,a,s="undefined"!=typeof(t=t||{})?t:{};s.ready=new Promise((function(e,t){n=e,r=t})),"undefined"!=typeof process&&process.listeners&&(a={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i,o,l,u=Object.assign({},s),c=[],d="object"==typeof window,h="function"==typeof importScripts,p="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,f="";if(p){var m=PT(),g=LT();f=h?g.dirname(f)+"/":"//",i=(e,t)=>(e=U(e)?new URL(e):g.normalize(e),m.readFileSync(e,t?void 0:"utf8")),l=e=>{var t=i(e,!0);return t.buffer||(t=new Uint8Array(t)),t},o=(e,t,n)=>{e=U(e)?new URL(e):g.normalize(e),m.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),c=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof G))throw e})),process.on("unhandledRejection",(function(e){throw e})),s.inspect=function(){return"[Emscripten Module object]"}}else(d||h)&&(h?f=self.location.href:"undefined"!=typeof document&&document.currentScript&&(f=document.currentScript.src),e&&(f=e),f=0!==f.indexOf("blob:")?f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},h&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)},e=>document.title=e);var y=s.print||console.log.bind(console),b=s.printErr||console.warn.bind(console);Object.assign(s,u),u=null,s.arguments&&(c=s.arguments),s.thisProgram&&s.thisProgram,s.quit&&s.quit;var v;s.wasmBinary&&(v=s.wasmBinary);var x=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&z("no native wasm support detected");var w,k=!1;var S,I,C,N,T="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function E(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&T)return T.decode(e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if((i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function A(e,t){return(e>>>=0)?E(C,e,t):""}function _(e){S=e,s.HEAP8=I=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=new Int32Array(e),s.HEAPU8=C=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=N=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=new Float64Array(e)}s.INITIAL_MEMORY;var $=[],R=[],D=[];function M(e){$.unshift(e)}function F(e){D.unshift(e)}var O=0,P=null,L=null;function z(e){s.onAbort&&s.onAbort(e),b(e="Aborted("+e+")"),k=!0,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw r(t),t}var B,W="data:application/octet-stream;base64,";function V(e){return e.startsWith(W)}function U(e){return e.startsWith("file://")}function j(e){try{if(e==B&&v)return new Uint8Array(v);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(t){z(t)}}function G(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function H(e){for(;e.length>0;)e.shift()(s)}function q(e){try{return w.grow(e-S.byteLength+65535>>>16),_(w.buffer),1}catch(t){}}V(B="tfjs-backend-wasm.wasm")||(B=function(e){return s.locateFile?s.locateFile(e,f):f+e}(B));var K=[null,[],[]];function X(e,t){var n=K[e];0===t||10===t?((1===e?y:b)(E(n,0)),n.length=0):n.push(t)}function Y(e){return s["_"+e]}function Q(e,t,n,r,a){var s={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);(function(e,t,n){(function(e,t,n,r){if(!(r>0))return 0;for(var a=n>>>=0,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),o<=127){if(n>=s)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=s)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=s)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0})(e,C,t,n)})(e,t=ae(n),n)}return t},array:e=>{var t=ae(e.length);return function(e,t){I.set(e,t>>>0)}(e,t),t}};var i=Y(e),o=[],l=0;if(r)for(var u=0;u<r.length;u++){var c=s[n[u]];c?(0===l&&(l=ne()),o[u]=c(r[u])):o[u]=r[u]}var d,h=i.apply(null,o);return d=h,0!==l&&re(l),h=function(e){return"string"===t?A(e):"boolean"===t?!!e:e}(d),h}var J,Z,ee,te={abort:function(){z("")},emscripten_get_heap_max:function(){return 4294901760},emscripten_memcpy_big:function(e,t,n){C.copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_resize_heap:function(e){var t,n,r=C.length,a=4294901760;if((e>>>=0)>a)return!1;for(var s=1;s<=4;s*=2){var i=r*(1+.2/s);if(i=Math.min(i,e+100663296),q(Math.min(a,(t=Math.max(e,i))+((n=65536)-t%n)%n)))return!0}return!1},fd_close:function(e){return 52},fd_seek:function(e,t,n,r,a){return 70},fd_write:function(e,t,n,r){for(var a=0,s=0;s<n;s++){var i=N[t>>>2],o=N[t+4>>>2];t+=8;for(var l=0;l<o;l++)X(e,C[i+l>>>0]);a+=o}return N[r>>>2]=a,0}},ne=(function(){var e={env:te,wasi_snapshot_preview1:te};function t(e,t){var n=e.exports;s.asm=n,_((w=s.asm.memory).buffer),s.asm.__indirect_function_table,function(e){R.unshift(e)}(s.asm.__wasm_call_ctors),function(){if(O--,s.monitorRunDependencies&&s.monitorRunDependencies(O),0==O&&(null!==P&&(clearInterval(P),P=null),L)){var e=L;L=null,e()}}()}function n(e){t(e.instance)}function a(t){return function(){if(!v&&(d||h)){if("function"==typeof fetch&&!U(B))return fetch(B,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+B+"'";return e.arrayBuffer()})).catch((function(){return j(B)}));if(o)return new Promise((function(e,t){o(B,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return j(B)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){b("failed to asynchronously prepare wasm: "+e),z(e)}))}if(O++,s.monitorRunDependencies&&s.monitorRunDependencies(O),s.instantiateWasm)try{return s.instantiateWasm(e,t)}catch(i){b("Module.instantiateWasm callback failed with error: "+i),r(i)}(v||"function"!=typeof WebAssembly.instantiateStreaming||V(B)||U(B)||p||"function"!=typeof fetch?a(n):fetch(B,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return b("wasm streaming compile failed: "+e),b("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(r)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)},s.stackSave=function(){return(ne=s.stackSave=s.asm.stackSave).apply(null,arguments)}),re=s.stackRestore=function(){return(re=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},ae=s.stackAlloc=function(){return(ae=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)};function se(e){function t(){J||(J=!0,s.calledRun=!0,!k&&(H(R),n(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),function(){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;)F(s.postRun.shift());H(D)}()))}e=e||c,O>0||(function(){if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)M(s.preRun.shift());H($)}(),O>0)||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),t()}),1)):t())}if(s.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?Y(e):function(){return Q(e,t,n,arguments)}},L=function e(){J||se(),J||(L=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();if(se(),a&&(Z={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!a.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!a.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof t)ee=t;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");ee=WasmBackendModuleThreadedSimd}if(Z){var ie=ee._dispose;ee._dispose=function(){ie(),Z.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Z.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&n.amdO?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModule=r)})),GT=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},HT=class{refCount(e){return qT("refCount")}incRef(e){return qT("incRef")}timerAvailable(){return!0}time(e){return qT("time")}read(e){return qT("read")}readSync(e){return qT("readSync")}readToGPU(e,t){return qT("readToGPU")}numDataIds(){return qT("numDataIds")}disposeData(e,t){return qT("disposeData")}write(e,t,n){return qT("write")}move(e,t,n,r,a){return qT("move")}createTensorFromGPUData(e,t,n){return qT("createTensorFromGPUData")}memory(){return qT("memory")}floatPrecision(){return qT("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return qT("dispose")}};function qT(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function KT(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,JT(e,t,n)}function XT(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,JT(e,n,r),JT(t,n,r)}function YT(e,t,n){return Math.max(e,Math.min(t,n))}function QT(e){return e%2===0?e:e+1}function JT(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function ZT(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function eE(e,t){let n=Math.random();return t*n+(1-n)*e}function tE(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function nE(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function rE(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";nE(lE(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function aE(e){nE(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function sE(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function iE(e){return 0===e.length}function oE(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function lE(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function uE(e){return e%1===0}function cE(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function dE(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function hE(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return KT(t),t}function pE(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function fE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,s)=>{let i=0,o=()=>{if(e())return void a();i++;let l=t(i);null!=n&&i>=n?s():null!=r?r(o,l):setTimeout(o,l)};o()}))}function mE(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function gE(e,t){let n=t.length;return nE((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),nE(e.every((e=>uE(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function yE(e,t){let n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:gE(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function bE(e,t){return vE(e,t)}function vE(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function xE(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function wE(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function kE(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function SE(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function IE(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function CE(e){return"string"==typeof e||e instanceof String}function NE(e){return"boolean"==typeof e}function TE(e){return"number"==typeof e}function EE(e){return Array.isArray(e)?EE(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":TE(e)?"float32":CE(e)?"string":NE(e)?"bool":"float32"}function AE(e){return!!(e&&e.constructor&&e.call&&e.apply)}function _E(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function $E(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function RE(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=new Array;if(1===t.length){let s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{let s=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=RE(e+t*o,i,n,r)}return a}function DE(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];let r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return RE(0,e,t,n)}function ME(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function FE(e,t){let n=OE(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function OE(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function PE(e,t){let n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return DE(e,new Float32Array(n));if("int32"===t)return DE(e,new Int32Array(n));if("bool"===t)return DE(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function LE(e){e.forEach((t=>{nE(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function zE(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function BE(e,t,n){if(0===t)return[];if(1===t)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function WE(e){return e&&e.then&&"function"==typeof e.then}var VE="tfjsflags",UE=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=jE,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(GE().getBool("IS_TEST")||GE().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];GE().getBool("IS_TEST")||GE().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(WE(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"==typeof this.global||"undefined"==typeof this.global.location||"undefined"==typeof this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);VE in e&&e[VE].split(",").forEach((e=>{let[t,n]=e.split(":");this.urlFlags[t]=function(e,t){let n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}};function jE(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function GE(){return qE}var HE,qE=null;function KE(){if(null==HE){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}HE=e}return HE}function XE(e,t){let n=function(){let e=KE();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var YE="Abs",QE="Acos",JE="Acosh",ZE="Add",eA="AddN",tA="All",nA="Any",rA="ArgMax",aA="ArgMin",sA="Asin",iA="Asinh",oA="Atan",lA="Atanh",uA="Atan2",cA="AvgPool",dA="AvgPoolGrad",hA="AvgPool3D",pA="AvgPool3DGrad",fA="BatchMatMul",mA="BatchToSpaceND",gA="Bincount",yA="BitwiseAnd",bA="BroadcastTo",vA="BroadcastArgs",xA="Cast",wA="Ceil",kA="ClipByValue",SA="Complex",IA="ComplexAbs",CA="Concat",NA="Conv2D",TA="Conv2DBackpropFilter",EA="Conv2DBackpropInput",AA="Conv3D",_A="Conv3DBackpropFilterV2",$A="Conv3DBackpropInputV2",RA="Cos",DA="Cosh",MA="Cumprod",FA="Cumsum",OA="CropAndResize",PA="DenseBincount",LA="DepthToSpace",zA="DepthwiseConv2dNative",BA="DepthwiseConv2dNativeBackpropFilter",WA="DepthwiseConv2dNativeBackpropInput",VA="Diag",UA="Dilation2D",jA="Dilation2DBackpropInput",GA="Dilation2DBackpropFilter",HA="Draw",qA="RealDiv",KA="Einsum",XA="Elu",YA="EluGrad",QA="Erf",JA="Equal",ZA="Exp",e_="ExpandDims",t_="Expm1",n_="FFT",r_="Fill",a_="FlipLeftRight",s_="Floor",i_="FloorDiv",o_="FusedBatchNorm",l_="GatherV2",u_="GatherNd",c_="Greater",d_="GreaterEqual",h_="Identity",p_="IFFT",f_="Imag",m_="IsFinite",g_="IsInf",y_="IsNan",b_="LeakyRelu",v_="Less",x_="LessEqual",w_="LinSpace",k_="Log",S_="Log1p",I_="LogicalAnd",C_="LogicalNot",N_="LogicalOr",T_="LogicalXor",E_="LogSoftmax",A_="LowerBound",__="LRN",$_="LRNGrad",R_="MatrixBandPart",D_="Max",M_="Maximum",F_="MaxPool",O_="MaxPoolGrad",P_="MaxPool3D",L_="MaxPool3DGrad",z_="MaxPoolWithArgmax",B_="Mean",W_="Min",V_="Minimum",U_="MirrorPad",j_="Mod",G_="Multinomial",H_="Multiply",q_="Neg",K_="NotEqual",X_="NonMaxSuppressionV3",Y_="NonMaxSuppressionV4",Q_="NonMaxSuppressionV5",J_="OnesLike",Z_="OneHot",e$="Pack",t$="PadV2",n$="Pool",r$="Pow",a$="Prelu",s$="Prod",i$="RaggedGather",o$="RaggedRange",l$="RaggedTensorToTensor",u$="Range",c$="Real",d$="Reciprocal",h$="Relu",p$="Reshape",f$="ResizeNearestNeighbor",m$="ResizeNearestNeighborGrad",g$="ResizeBilinear",y$="ResizeBilinearGrad",b$="Relu6",v$="Reverse",x$="Round",w$="Rsqrt",k$="ScatterNd",S$="TensorScatterUpdate",I$="SearchSorted",C$="Select",N$="Selu",T$="Slice",E$="Sin",A$="Sinh",_$="Sign",$$="Sigmoid",R$="Softplus",D$="Sqrt",M$="Sum",F$="SpaceToBatchND",O$="SplitV",P$="Softmax",L$="SparseFillEmptyRows",z$="SparseReshape",B$="SparseSegmentMean",W$="SparseSegmentSum",V$="SparseToDense",U$="SquaredDifference",j$="Square",G$="StaticRegexReplace",H$="StridedSlice",q$="StringNGrams",K$="StringSplit",X$="StringToHashBucketFast",Y$="Sub",Q$="Tan",J$="Tanh",Z$="Tile",eR="TopK",tR="Transform",nR="Transpose",rR="Unique",aR="Unpack",sR="UnsortedSegmentSum",iR="UpperBound",oR="ZerosLike",lR="Step",uR="FromPixels",cR="RotateWithOffset",dR="_FusedMatMul",hR="FusedConv2D",pR="FusedDepthwiseConv2D";function fR(){GE().getBool("IS_TEST")||GE().getBool("PROD")||console.warn(...arguments)}function mR(){GE().getBool("IS_TEST")||GE().getBool("PROD")||console.log(...arguments)}var gR=XE("kernelRegistry",(()=>new Map)),yR=XE("gradRegistry",(()=>new Map));function bR(e,t){let n=NR(e,t);return gR.get(n)}function vR(e){return yR.get(e)}function xR(e){let t=gR.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function wR(e){let{kernelName:t,backendName:n}=e,r=NR(t,n);gR.has(r)&&fR(`The kernel '${t}' for backend '${n}' is already registered`),gR.set(r,e)}function kR(e){let{kernelName:t}=e;yR.has(t)&&GE().getBool("DEBUG")&&fR(`Overriding the gradient for '${t}'`),yR.set(t,e)}function SR(e,t){let n=NR(e,t);if(!gR.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);gR.delete(n)}function IR(e){if(!yR.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);yR.delete(e)}function CR(e,t){xR(e).forEach((e=>{wR(Object.assign({},e,{backendName:t}))}))}function NR(e,t){return`${t}_${e}`}var TR={};function ER(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}kT(TR,{arraysEqual:()=>lE,arraysEqualWithNull:()=>oE,assert:()=>nE,assertNonNegativeIntegerDimensions:()=>LE,assertNonNull:()=>aE,assertShapesMatch:()=>rE,bytesFromStringArray:()=>IE,bytesPerElement:()=>SE,checkConversionForErrors:()=>xE,clamp:()=>YT,computeStrides:()=>$E,convertBackendValuesAndArrayBuffer:()=>ME,createScalarValue:()=>UR,createShuffledIndices:()=>hE,decodeString:()=>KR,distSquared:()=>tE,encodeString:()=>qR,fetch:()=>HR,fingerPrint64:()=>VR,flatten:()=>YR,getArrayFromDType:()=>vE,getTypedArrayFromDType:()=>bE,hasEncodingLoss:()=>kE,hexToLong:()=>$R,indexToLoc:()=>BE,inferDtype:()=>EE,inferFromImplicitShape:()=>mE,isBoolean:()=>NE,isFunction:()=>AE,isInt:()=>uE,isNumber:()=>TE,isPromise:()=>WE,isScalarShape:()=>iE,isString:()=>CE,isTypedArray:()=>XR,isValidDtype:()=>wE,locToIndex:()=>zE,makeOnesTypedArray:()=>FE,makeZerosNestedTypedArray:()=>PE,makeZerosTypedArray:()=>OE,nearestDivisor:()=>_E,nearestLargerEven:()=>QT,now:()=>GR,parseAxisParam:()=>gE,randUniform:()=>eE,repeatedTry:()=>fE,rightPad:()=>pE,shuffle:()=>KT,shuffleCombo:()=>XT,sizeFromShape:()=>sE,sizeToSquarishShape:()=>dE,squeezeShape:()=>yE,sum:()=>ZT,swap:()=>JT,tanh:()=>cE,toNestedArray:()=>DE,toTypedArray:()=>jR});var AR=ST(IT()),_R=AR.default||AR;function $R(e){return _R.fromString(e,!0,16)}var RR=$R("c3a5c85c97cb3127"),DR=$R("b492b66fbe98f273"),MR=$R("9ae16a3b2f90404f");function FR(e){return e.xor(e.shru(47))}function OR(e,t,n){let r=e.slice(t,t+n);return _R.fromBytes(Array.from(r),!0,!0)}function PR(e,t){return OR(e,t,8)}function LR(e,t){return OR(e,t,4)}function zR(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function BR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:$R("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function WR(e,t,n,r){return function(e,t,n,r,a,s){a=a.add(e),s=zR(s.add(a).add(r),21);let i=a;return a=(a=a.add(t)).add(n),s=s.add(zR(a,44)),[a.add(r),s.add(i)]}(PR(e,t),PR(e,t+8),PR(e,t+16),PR(e,t+24),n,r)}function VR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=_R.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){let n=MR.add(2*t),r=PR(e,0).add(MR),a=PR(e,t-8);return BR(zR(a,37).mul(n).add(r),zR(r,25).add(a).mul(n),n)}if(t>=4){let n=MR.add(2*t);return BR(LR(e,0).shl(3).add(t),LR(e,t-4),n)}if(t>0){let n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return FR(MR.mul(n).xor(RR.mul(r))).mul(MR)}return MR}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=MR.add(2*t),r=PR(e,0).mul(DR),a=PR(e,8),s=PR(e,t-8).mul(n),i=PR(e,t-16).mul(MR);return BR(zR(r.add(a),43).add(zR(s,30)).add(i),r.add(zR(a.add(MR),18)).add(s),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=MR.add(2*t),r=PR(e,0).mul(MR),a=PR(e,8),s=PR(e,t-8).mul(n),i=PR(e,t-16).mul(MR),o=zR(r.add(a),43).add(zR(s,30)).add(i),l=BR(o,r.add(zR(a.add(MR),18)).add(s),n),u=PR(e,16).mul(n),c=PR(e,24),d=o.add(PR(e,t-32)).mul(n),h=l.add(PR(e,t-24)).mul(n);return BR(zR(u.add(c),43).add(zR(d,30)).add(h),u.add(zR(c.add(r),18)).add(d),n)}(e,t);let r=n,a=n.mul(DR).add(113),s=FR(a.mul(MR).add(113)).mul(MR),i=[_R.UZERO,_R.UZERO],o=[_R.UZERO,_R.UZERO];r=r.mul(MR).add(PR(e,0));let l=0,u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=zR(r.add(a).add(i[0]).add(PR(e,l+8)),37).mul(DR),a=zR(a.add(i[1]).add(PR(e,l+48)),42).mul(DR),r=r.xor(o[1]),a=a.add(i[0]).add(PR(e,l+40)),s=zR(s.add(o[0]),33).mul(DR),i=WR(e,l,i[1].mul(DR),r.add(o[0])),o=WR(e,l+32,s.add(o[1]),a.add(PR(e,l+16))),[s,r]=[r,s],l+=64}while(l!==u);let d=DR.add(s.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=zR(r.add(a).add(i[0]).add(PR(e,l+8)),37).mul(d),a=zR(a.add(i[1]).add(PR(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(PR(e,l+40))),s=zR(s.add(o[0]),33).mul(d),i=WR(e,l,i[1].mul(d),r.add(o[0])),o=WR(e,l+32,s.add(o[1]),a.add(PR(e,l+16))),[s,r]=[r,s],BR(BR(i[0],o[0],d).add(FR(a).mul(RR)).add(s),BR(i[1],o[1],d).add(r),d)}function UR(e,t){return"string"===t?qR(e):jR([e],t)}function jR(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=YR(e)),GE().getBool("DEBUG")&&xE(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function GR(){return GE().platform.now()}function HR(e,t){return GE().platform.fetch(e,t)}function qR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",GE().platform.encode(e,t)}function KR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",GE().platform.decode(e,t)}function XR(e){return null!=GE().platform.isTypedArray?GE().platform.isTypedArray(e):ER(e)}function YR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||WE(e)||null==e||XR(e)&&n)t.push(e);else if(Array.isArray(e)||XR(e))for(let r=0;r<e.length;++r)YR(e[r],t,n);else{let r=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)YR(e[a],t,n)}return t}var QR=class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new ZR)}profileKernel(e,t,n){let r,a,s=()=>{r=n()},i=GR();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let e of r)e.dataSync();a=Promise.resolve({kernelMs:GR()-i})}if(GE().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let t=r[o];t.data().then((n=>{JR(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}};function JR(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){let t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}var ZR=class{logKernelProfile(e,t,n,r,a,s){let i="number"==typeof r?pE(`${r}ms`,9):r.error,o=pE(e,25),l=t.rank,u=t.size,c=pE(t.shape.toString(),14),d="";for(let h in a){let e=a[h];if(null!=e){let n=e.shape||t.shape,r=n.length;d+=`${h}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};var eD=20,tD=3,nD=7;function rD(e,t,n,r){let a=$E(t),s=function(e,t,n,r){let a=sE(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l="complex64"===n?oD(e):e;if(o>1)for(let u=0;u<a/s;u++){let e=u*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],aD(l[e+t],0,n).length)}return i}(e,t,n,a),i=t.length,o=iD(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function aD(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(nD))} + ${parseFloat(e[1].toFixed(nD))}j`:CE(e)?`'${e}'`:"bool"===n?sD(e):parseFloat(e.toFixed(nD)).toString(),pE(r,t)}function sD(e){return 0===e?"false":"true"}function iD(e,t,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[aD(oD(e)[0],0,n)]}return"bool"===n?[sD(e[0])]:[e[0].toString()]}if(1===l){if(o>eD){let t=tD*i,r=Array.from(e.slice(0,t)),s=Array.from(e.slice((o-tD)*i,o*i));return"complex64"===n&&(r=oD(r),s=oD(s)),["["+r.map(((e,t)=>aD(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>aD(e,a[o-tD+t],n))).join(", ")+"]"]}return["["+("complex64"===n?oD(e):Array.from(e)).map(((e,t)=>aD(e,a[t],n))).join(", ")+"]"]}let u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>eD){for(let t=0;t<tD;t++){let r=t*d,s=r+d;h.push(...iD(e.slice(r,s),u,n,c,a,!1))}h.push("...");for(let t=o-tD;t<o;t++){let r=t*d,s=r+d;h.push(...iD(e.slice(r,s),u,n,c,a,t===o-1))}}else for(let m=0;m<o;m++){let t=m*d,r=t+d;h.push(...iD(e.slice(t,r),u,n,c,a,m===o-1))}let p=2===l?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(s?"":f),h}function oD(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var lD=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=sE(e),null!=n){let e=n.length;nE(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||vE(t,this.size),this.strides=$E(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),nE(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));let a=this.locToIndex(n);this.values[a]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(let s of t){if(s<0||s>=this.shape[r]){let e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let a=t[t.length-1];for(let s=0;s<t.length-1;++s)a+=this.strides[s]*t[s];return this.values[a]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return uD().makeTensor(this.values,this.shape,this.dtype)}},uD=null,cD=null;var dD=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=sE(e),this.strides=$E(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return cD.buffer(this.shape,this.dtype,e)}bufferSync(){return cD.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return DE(this.shape,e,"complex64"===this.dtype)}arraySync(){return DE(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=uD().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map((e=>KR(e)))}catch(Pye){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),uD().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=uD().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>KR(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await uD().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),uD().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return cD.print(this,e)}clone(){return this.throwIfDisposed(),cD.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return rD(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),cD.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),uD().makeVariable(this,e,t,n)}};function hD(){return XE("Tensor",(()=>dD))}Object.defineProperty(dD,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),hD();var pD=class extends dD{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!lE(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);uD().disposeTensor(this),this.dataId=e.dataId,uD().incRef(this,null)}dispose(){uD().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(pD,Symbol.hasInstance,{value:e=>e instanceof dD&&null!=e.assign&&e.assign instanceof Function});var fD,mD,gD,yD,bD,vD,xD={};kT(xD,{assertTypesMatch:()=>TD,getTensorsInContainer:()=>AD,isTensorInList:()=>ED,makeTypesMatch:()=>ND}),(mD=fD||(fD={})).R0="R0",mD.R1="R1",mD.R2="R2",mD.R3="R3",mD.R4="R4",mD.R5="R5",mD.R6="R6",function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(gD||(gD={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(yD||(yD={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(bD||(bD={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(vD||(vD={}));var wD={float32:bD,int32:gD,bool:yD,complex64:vD};function kD(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return wD[e][t]}function SD(e){return kD(e,"int32")}function ID(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function CD(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function ND(e,t){if(e.dtype===t.dtype)return[e,t];let n=kD(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function TD(e,t){nE(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function ED(e,t){return t.some((t=>t.id===e.id))}function AD(e){let t=[];return _D(e,t,new Set),t}function _D(e,t,n){if(null==e)return;if(e instanceof dD)return void t.push(e);if(!function(e){return Array.isArray(e)||"object"==typeof e}(e))return;let r=e;for(let a in r){let e=r[a];n.has(e)||(n.add(e),_D(e,t,n))}}function $D(e){return null!=e.kernelName}var RD=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},DD=class e{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new RD}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(fR(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new QR(this.backendInstance),!0}setupRegisteredKernels(){xR(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){xR(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(!n||n instanceof HT||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,fR(`Initialization of backend ${e} failed`),fR(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return fR(`Initialization of backend ${e} failed`),fR(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(Lge){throw t(),Lge}}nextTensorId(){return e.nextTensorId++}nextVariableId(){return e.nextVariableId++}clone(e){let t=FD.runKernel(h_,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{let t={x:e},n={dtype:"float32"};return FD.runKernel(xA,t,n)}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==bR(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n,r=[],a=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let o,l=$D(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if($D(e)){let{kernelName:t,inputs:s,attrs:i}=e;null==this.backendName&&this.backend;let l=bR(t,this.backendName);nE(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),n=()=>{let e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:i,backend:this.backend});let n=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let u=n.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){let e=this.getTensorsForGradient(t,s,u);r=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,s=e=>{a&&(r=e.map((e=>this.keep(this.clone(e)))))};n=()=>{let e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));let n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}let u,{inputs:c,attrs:d}=e,h=$D(e)?null:e.backwardsFunc;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(u=this.profiler.profileKernel(l,c,(()=>n())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(u),t=u.outputs):t=n()})),a&&this.addTapeNode(l,c,t,h,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((e=>null!=c[e]?c[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:u.timeMs,extraInfo:u.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){let r=vR(e);if(null!=r){let e,a=r.inputsToSave||[],s=r.outputsToSave||[];r.saveAllInputs?(nE(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),e=Object.keys(t).map((e=>t[e]))):e=a.map((e=>t[e]));let i=n.filter(((e,t)=>s[t]));return e.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&CE(e[0])&&(a=e.map((e=>qR(e))));let s=r.write(a,t,n),i=new dD(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){let e=this.state.tensorInfo.get(s),t=IE(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){let a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:a}=e,s=new dD(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));let a=new pD(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*SE(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof pD||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*SE(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=vR(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){let e=n[t],r=OE(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=AD(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){let e=this.state.activeScope.track[a];!e.kept&&!n.has(e.id)&&e.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{!e.kept&&e.scopeId===r.id&&this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(nE(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));nE(a instanceof dD,(()=>"The result y returned by f() must be a tensor."));let s=function(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let n=e[l],s=n.inputs;for(let e in s){let i=s[e],o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[n.id]=!0;break}if(o)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(let e in n)s[n[e].id]=!0,i[t.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let t=e[l];if(a[t.id]&&i[t.id]){let e={};for(let a in t.inputs){let n=t.inputs[a];r[n.id]&&(e[a]=n)}let n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{let e={};e[a.id]=null==n?function(e){let t=FE(sE(e),"float32");return FD.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach((t=>{let n=e[t.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);let a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let i=s.inputs[t];if(!lE(a.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{let t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}(e,s,(e=>this.tidy(e)),OD);let r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(let t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){var t=this;return nE(AE(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];nE(r.every((e=>e instanceof dD)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));let s,i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(s=e(...r,n),nE(s.value instanceof dD,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),nE(AE(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(e,t)=>{let n=s.gradFunc(e,t),a=Array.isArray(n)?n:[n];nE(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),nE(a.every((e=>e instanceof dD)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));let i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=GR(),n=await this.backend.time(e);return n.wallMs=GR()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new RD;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function MD(){let e=KE();if(null==e._tfengine){let t=new UE(e);e._tfengine=new DD(t)}return function(e){qE=e}(e._tfengine.ENV),function(e){uD=e}((()=>e._tfengine)),e._tfengine}DD.nextTensorId=0,DD.nextVariableId=0;var FD=MD();function OD(e,t){let n={a:e,b:t};return FD.runKernel(ZE,n)}var PD,LD={};function zD(e){PD=e}function BD(e){if(void 0!==PD)return PD;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function WD(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}kT(LD,{isBrowser:()=>WD,isMobile:()=>BD,mockIsMobile:()=>zD});var VD=GE();function UD(e,t){let n=e;if(XR(e))return"string"===t?[]:[e.length];if(ID(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(CD(e))return[e.buffer.size/(null==t?4:SE(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||XR(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&GE().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&jD(e,r,[]),r}function jD(e,t,n){if(n=n||[],!Array.isArray(e)&&!XR(e))return void nE(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));nE(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),nE(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));let r=t.slice(1);for(let a=0;a<e.length;++a)jD(e[a],r,n.concat(a))}function GD(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function HD(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof hD())return GD(r,e.dtype,t,n),e;let a=EE(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),GD(r,a,t,n),null==e||!XR(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let s=UD(e,a);!XR(e)&&!Array.isArray(e)&&(e=[e]);let i="string"!==a?jR(e,a):YR(e,[],!0);return FD.makeTensor(i,s,a)}function qD(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>HD(e,`${t}[${a}]`,n,r)))}VD.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),VD.registerFlag("IS_BROWSER",(()=>WD())),VD.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&"undefined"!=typeof process.versions&&"undefined"!=typeof process.versions.node)),VD.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),VD.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),VD.registerFlag("PROD",(()=>!1)),VD.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>VD.getBool("DEBUG"))),VD.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),VD.registerFlag("IS_TEST",(()=>!1)),VD.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>VD.getBool("DEBUG"))),VD.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),VD.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),VD.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));var KD="__op";function XD(e){let t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=KD;let a=function(){FD.startScope(n);try{let e=r(...arguments);return WE(e)&&console.error("Cannot return a Promise inside of tidy."),FD.endScope(e),e}catch(e){throw FD.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}var YD=XD({complex_:function(e,t){let n=HD(e,"real","complex"),r=HD(t,"imag","complex");rE(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return FD.runKernel(SA,a)}});function QD(e,t,n,r){if(null==r)r=EE(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(CD(e)||ID(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return FD.backend.createTensorFromGPUData(e,t||n,r)}if(!XR(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){LE(t);let e=sE(t),r=sE(n);nE(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){let e=n[a],r=a!==n.length-1||e!==sE(t.slice(a));nE(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return!XR(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e="string"!==r?jR(e,r):YR(e,[],!0),FD.makeTensor(e,t,r)}function JD(e,t,n){return QD(e,t,UD(e,n),n)}var ZD={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},eM=class e{static join(t){return new e(t).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),0===(e=e.map((e=>XR(e)?e.buffer:e))).length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){let r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);let n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);let r=new ArrayBuffer(t-e),a=new Uint8Array(r),s=0;for(let i=n;i<this.shards.length;i++){let n=this.shards[i],r=e+s-n.start,o=s,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(a.set(u,o),s+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;let n=function(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,s=t(e[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}};function tM(){GE().set("PROD",!0)}function nM(){GE().set("DEBUG",!0)}function rM(){GE().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function aM(e){GE().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function sM(){FD.disposeVariables()}function iM(){return FD}function oM(){return FD.memory()}function lM(e){return FD.profile(e)}function uM(e,t){return FD.tidy(e,t)}function cM(e){AD(e).forEach((e=>e.dispose()))}function dM(e){return FD.keep(e)}function hM(e){return FD.time(e)}function pM(e){return FD.setBackend(e)}function fM(){return FD.ready()}function mM(){return FD.backendName}function gM(e){FD.removeBackend(e)}function yM(e){return FD.findBackend(e)}function bM(e){return FD.findBackendFactory(e)}function vM(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return FD.registerBackend(e,t,n)}function xM(){return FD.backend}function wM(e,t){GE().setPlatform(e,t)}!function(e){e}(aM);var kM=4;async function SM(e,t){let n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<a.length;++s){let i=a[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);let l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise((async e=>{let t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+kM*t.length,r=new Uint8Array(n),a=0;for(let s=0;s<t.length;s++){let e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=kM,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:_M(await Promise.all(r)),specs:n}}function IM(e,t){let n=new eM(e),r={},a=0;for(let s of t){let e=CM(s,((e,t)=>n.slice(a+e,a+t)));r[s.name]=TM(s,n.slice(a,a+e)),a+=e}return r}function CM(e,t){let n,r=sE(e.shape);if("quantization"in e){let t=e.quantization;n=ZD[t.dtype]}else{if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=kM+new Uint32Array(t(e,e+kM))[0];return e}n=ZD[e.dtype]}return r*n}async function NM(e,t){let n,r=sE(e.shape);if("quantization"in e){let t=e.quantization;n=ZD[t.dtype]}else{if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=kM+new Uint32Array(await t(e,e+kM))[0];return e}n=ZD[e.dtype]}return r*n}function TM(e,t){let n,r=e.name,a=e.dtype,s=e.shape,i=sE(s),o=0;if("quantization"in e){let s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${a}.`)}let l=ZD[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===s.dtype||"uint16"===s.dtype){n=new Float32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);n=function(){let e=function(){let e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){let a=r[i],o=e[n[a>>10]+(1023&a)]+t[a>>10];s[i]=o}return new Float32Array(a)}}()(u)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${r}': ${a}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);n=new Int32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=Math.round(t*s.scale+s.min)}}o+=i*l}else if("string"===a){let r=sE(e.shape);n=[];for(let e=0;e<r;e++){let e=new Uint32Array(t.slice(o,o+kM))[0];o+=kM;let r=new Uint8Array(t.slice(o,o+e));n.push(r),o+=e}}else{let e=ZD[a];if("float32"===a)n=new Float32Array(t);else if("int32"===a)n=new Int32Array(t);else{if("bool"!==a){if("complex64"===a){n=new Float32Array(t);let e=new Float32Array(n.length/2),r=new Float32Array(n.length/2);for(let t=0;t<e.length;t++)e[t]=n[2*t],r[t]=n[2*t+1];let a=JD(e,s,"float32"),i=JD(r,s,"float32"),o=YD(a,i);return a.dispose(),i.dispose(),o}throw new Error(`Unsupported dtype in weight '${r}': ${a}`)}n=new Uint8Array(t)}o+=i*e}return JD(n,s,a)}async function EM(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:t,value:a}=await e.read();if(t&&null==a){let e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}let s=new Uint8Array(r.length+a.byteLength);s.set(r,0),s.set(new Uint8Array(a),r.length),r=s}return r.buffer}async function AM(e,t){let n={},r=e.getReader(),a=new ArrayBuffer(0);for(let s of t){let e=await NM(s,(async(e,t)=>(a=await EM(r,a,t),a.slice(e,t))));a=await EM(r,a,e);let t=a.slice(0,e);a=a.slice(e);let i=TM(s,t);if(n[s.name]=i,"webgpu"===mM()){let e=xM();"uploadToGPU"in e&&sE(i.shape)>=GE().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function _M(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));let r=new Uint8Array(t),a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}var $M="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function RM(e){return $M?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function DM(e){return eM.join(e)}function MM(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function FM(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function OM(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function PM(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),OM(e,n,r)}function LM(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:RM(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:RM(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new eM(e.weightData).byteLength}}function zM(e){let t=[];for(let n of e)t.push(...n.weights);return t}var BM=class e{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==e.instance&&(e.instance=new e),e.instance}static registerSaveRouter(t){e.getInstance().saveRouters.push(t)}static registerLoadRouter(t){e.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return e.getHandlers(t,"save")}static getLoadHandlers(t,n){return e.getHandlers(t,"load",n)}static getHandlers(t,n,r){let a=[];return("load"===n?e.getInstance().loadRouters:e.getInstance().saveRouters).forEach((e=>{let n=e(t,r);null!==n&&a.push(n)})),a}},WM=e=>BM.registerSaveRouter(e),VM=e=>BM.registerLoadRouter(e),UM=e=>BM.getSaveHandlers(e),jM=(e,t)=>BM.getLoadHandlers(e,t),GM="tensorflowjs",HM="models_store",qM="model_info_store";function KM(){if(!GE().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function XM(e){let t=e.result;t.createObjectStore(HM,{keyPath:"modelPath"}),t.createObjectStore(qM,{keyPath:"modelPath"})}var YM=class{constructor(e){if(this.indexedDB=KM(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{let r=this.indexedDB.open(GM,1);r.onupgradeneeded=()=>XM(r),r.onsuccess=()=>{let a=r.result;if(null==t){let t=a.transaction(HM,"readonly"),r=t.objectStore(HM).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=eM.join(t.weightData);let r,i,o=LM(t),l=a.transaction(qM,"readwrite"),u=l.objectStore(qM);try{r=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(s){return n(s)}r.onsuccess=()=>{i=a.transaction(HM,"readwrite");let r,s=i.objectStore(HM);try{r=s.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(c){return n(c)}r.onsuccess=()=>e({modelArtifactsInfo:o}),r.onerror=e=>{u=l.objectStore(qM);let t=u.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(r.error)),t.onerror=e=>(a.close(),n(r.error))}},r.onerror=e=>(a.close(),n(r.error)),l.oncomplete=()=>{null==i?a.close():i.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}};YM.URL_SCHEME="indexeddb://";var QM=e=>GE().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(YM.URL_SCHEME)?function(e){return new YM(e)}(e.slice(YM.URL_SCHEME.length)):null;BM.registerSaveRouter(QM),BM.registerLoadRouter(QM);var JM="/",ZM="tensorflowjs_models",eF="info",tF="model_topology",nF="weight_specs",rF="weight_data",aF="model_metadata";function sF(e){return{info:[ZM,e,eF].join(JM),topology:[ZM,e,tF].join(JM),weightSpecs:[ZM,e,nF].join(JM),weightData:[ZM,e,rF].join(JM),modelMetadata:[ZM,e,aF].join(JM)}}function iF(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function oF(e){let t=e.split(JM);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(JM)}var lF=class{constructor(e){if(!GE().getBool("IS_BROWSER")||"undefined"==typeof window||"undefined"==typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=sF(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=LM(e),s=eM.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if($M)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(s));let t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw iF(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if($M){let t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(s),t}};lF.URL_SCHEME="localstorage://";var uF=e=>GE().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(lF.URL_SCHEME)?function(e){return new lF(e)}(e.slice(lF.URL_SCHEME.length)):null;BM.registerSaveRouter(uF),BM.registerLoadRouter(uF);var cF="://",dF=class e{constructor(){this.managers={}}static getInstance(){return null==e.instance&&(e.instance=new e),e.instance}static registerManager(t,n){nE(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(cF)&&(t=t.slice(0,t.indexOf(cF))),nE(t.length>0,(()=>"scheme must not be an empty string."));let r=e.getInstance();nE(null==r.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),r.managers[t]=n}static getManager(t){let n=e.getInstance().managers[t];if(null==n)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(e.getInstance().managers)}};function hF(e){if(-1===e.indexOf(cF))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${dF.getSchemes().join(",")}`);return{scheme:e.split(cF)[0],path:e.split(cF)[1]}}async function pF(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];nE(e!==t,(()=>`Old path and new path are the same: '${e}'`));let r=BM.getLoadHandlers(e);nE(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),nE(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));let a=r[0],s=BM.getSaveHandlers(t);nE(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),nE(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));let i=s[0],o=hF(e).scheme,l=hF(e).path,u=o===hF(e).scheme,c=await a.load();n&&u&&await dF.getManager(o).removeModel(l);let d=await i.save(c);return n&&!u&&await dF.getManager(o).removeModel(l),d.modelArtifactsInfo}async function fF(){let e=dF.getSchemes(),t={};for(let n of e){let e=await dF.getManager(n).listModels();for(let r in e){t[n+cF+r]=e[r]}}return t}async function mF(e){let t=hF(e);return dF.getManager(t.scheme).removeModel(t.path)}async function gF(e,t){return pF(e,t,!1)}async function yF(e,t){return pF(e,t,!0)}if(GE().get("IS_BROWSER")){GE().setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&GE().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return ER(e)}});try{dF.registerManager(lF.URL_SCHEME,new class{constructor(){nE(GE().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),nE("undefined"==typeof window||"undefined"!=typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){let e={},t=ZM+JM,n=JM+eF;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);a.startsWith(t)&&a.endsWith(n)&&(e[oF(a)]=JSON.parse(this.LS.getItem(a)))}return e}async removeModel(e){let t=sF(e=function(e){return e.startsWith(lF.URL_SCHEME)?e.slice(lF.URL_SCHEME.length):e}(e));if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return iF(t),n}})}catch(mD){}try{dF.registerManager(YM.URL_SCHEME,new class{constructor(){this.indexedDB=KM()}async listModels(){return new Promise(((e,t)=>{let n=this.indexedDB.open(GM,1);n.onupgradeneeded=()=>XM(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(qM,"readonly"),s=a.objectStore(qM).getAll();s.onsuccess=()=>{let t={};for(let e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){return e=function(e){return e.startsWith(YM.URL_SCHEME)?e.slice(YM.URL_SCHEME.length):e}(e),new Promise(((t,n)=>{let r=this.indexedDB.open(GM,1);r.onupgradeneeded=()=>XM(r),r.onsuccess=()=>{let a,s=r.result,i=s.transaction(qM,"readwrite"),o=i.objectStore(qM),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=o.delete(e),i=()=>{a=s.transaction(HM,"readwrite");let r=a.objectStore(HM).delete(e);r.onsuccess=()=>t(l.result.modelArtifactsInfo),r.onerror=e=>n(l.error)};r.onsuccess=i,r.onerror=e=>(i(),s.close(),n(l.error))}},l.onerror=e=>(s.close(),n(l.error)),i.oncomplete=()=>{null==a?s.close():a.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}})}catch(mD){}}var bF,vF=()=>CT();function xF(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",LE(e),new lD(e,t,n)}GE().get("IS_NODE")&&!GE().get("IS_BROWSER")&&GE().setPlatform("node",new class{constructor(){this.util=NT(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=GE().global.fetch?GE().global.fetch(e,t):(null==bF&&(bF=vF()),bF(e,t))}now(){let e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});var wF=XD({cast_:function(e,t){let n=HD(e,"x","cast");if(!wE(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return FD.runKernel(xA,r,a)}});var kF=XD({clone_:function(e){let t={x:HD(e,"x","clone","string_or_numeric")};return FD.runKernel(h_,t)}});function SF(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}MD(),function(e){cD=e}({buffer:xF,cast:wF,clone:kF,print:SF});var IF=XD({add_:function(e,t){let n=HD(e,"a","add"),r=HD(t,"b","add");[n,r]=ND(n,r);let a={a:n,b:r};return FD.runKernel(ZE,a)}});var CF=XD({floorDiv_:function(e,t){let n=HD(e,"a","floorDiv"),r=HD(t,"b","floorDiv");[n,r]=ND(n,r);let a={a:n,b:r};return FD.runKernel(i_,a)}});var NF=XD({div_:function(e,t){let n=HD(e,"a","div"),r=HD(t,"b","div");if([n,r]=ND(n,r),"int32"===n.dtype&&"int32"===r.dtype)return CF(n,r);let a={a:n,b:r};return FD.runKernel(qA,a,{})}});var TF=XD({mul_:function(e,t){let n=HD(e,"a","mul"),r=HD(t,"b","mul");[n,r]=ND(n,r);let a={a:n,b:r};return FD.runKernel(H_,a)}});var EF=XD({abs_:function(e){let t=HD(e,"x","abs");if("complex64"===t.dtype){let e={x:t};return FD.runKernel(IA,e)}{let e={x:t};return FD.runKernel(YE,e)}}});var AF=XD({acos_:function(e){let t={x:HD(e,"x","acos")};return FD.runKernel(QE,t)}});var _F=XD({acosh_:function(e){let t={x:HD(e,"x","acosh")};return FD.runKernel(JE,t)}});var $F=XD({addN_:function(e){nE(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),nE(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));let t=e.map(((e,t)=>HD(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!lE(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));let r=t;return FD.runKernel(eA,r)}});var RF=XD({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:HD(e,"x","all","bool")},a={axis:t,keepDims:n};return FD.runKernel(tA,r,a)}});var DF=XD({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:HD(e,"x","any","bool")},a={axis:t,keepDims:n};return FD.runKernel(nA,r,a)}});var MF=XD({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:HD(e,"x","argMax")},r={axis:t};return FD.runKernel(rA,n,r)}});var FF=XD({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:HD(e,"x","argMin")},r={axis:t};return FD.runKernel(aA,n,r)}});var OF=XD({asin_:function(e){let t={x:HD(e,"x","asin")};return FD.runKernel(sA,t)}});var PF=XD({asinh_:function(e){let t={x:HD(e,"x","asinh")};return FD.runKernel(iA,t)}});var LF=XD({atan_:function(e){let t={x:HD(e,"x","atan")};return FD.runKernel(oA,t)}});var zF=XD({atan2_:function(e,t){let n=HD(e,"a","atan2"),r=HD(t,"b","atan2");[n,r]=ND(n,r);let a={a:n,b:r};return FD.runKernel(uA,a)}});var BF=XD({atanh_:function(e){let t={x:HD(e,"x","atanh")};return FD.runKernel(lA,t)}});function WF(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return jF(e,[...t,e[3]],n,s,r,null,null,eO(a))}function VF(e,t,n,r,a,s){let i,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",[l,u]=qF(t);if("channelsLast"===o)i=[l,u,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);i=[l,u,e[1],e[1]]}return jF(e,i,n,r,a,s,!1,o)}function UF(e,t,n,r,a,s){let i,o,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC",[u,c,d]=KF(t);if("NDHWC"===l)o="channelsLast",i=[u,c,d,e[4],e[4]];else{if("NCDHW"!==l)throw new Error(`Unknown dataFormat ${l}`);o="channelsFirst",i=[u,c,d,e[1],e[1]]}return GF(e,i,n,r,a,!1,o,s)}function jF(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,c]=e}let h,[p,f,,m]=t,[g,y]=qF(n),[b,v]=qF(r),x=XF(p,b),w=XF(f,v),{padInfo:k,outHeight:S,outWidth:I}=function(e,t,n,r,a,s,i,o,l){let u,c,d;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};let a=function(e,t,n,r,a){null==r&&(r=HF(e,t,n));let s=e[0],i=e[1],o=YF((s-t+2*r)/n+1,a),l=YF((i-t+2*r)/n+1,a);return[o,l]}([t,n],s,r,e,o);c=a[0],d=a[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/a);let e=Math.max(0,(c-1)*r+s-t),o=Math.max(0,(d-1)*a+i-n),l=Math.floor(e/2),h=e-l,p=Math.floor(o/2);u={top:l,bottom:h,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/r),d=Math.ceil((n-i+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{let h="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=YF((t-s+h+p)/r+1,o),d=YF((n-i+f+m)/a+1,o)}}return{padInfo:u,outHeight:c,outWidth:d}}(a,u,c,g,y,x,w,s,o),C=i?m*d:m;return"channelsFirst"===o?h=[l,C,S,I]:"channelsLast"===o&&(h=[l,S,I,C]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:S,outWidth:I,outChannels:C,padInfo:k,strideHeight:g,strideWidth:y,filterHeight:p,filterWidth:f,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:v,inShape:e,outShape:h,filterShape:t}}function GF(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=e}let p,[f,m,g,,y]=t,[b,v,x]=KF(n),[w,k,S]=KF(r),I=XF(f,w),C=XF(m,k),N=XF(g,S),{padInfo:T,outDepth:E,outHeight:A,outWidth:_}=function(e,t,n,r,a,s,i,o,l,u,c){let d,h,p,f;if("valid"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};let m=function(e,t,n,r,a,s){null==a&&(a=HF(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=YF((e[o]-t[o]+2*a)/r[o]+1,s));return i}([t,n,r,1],[o,l,u],1,[a,s,i],e,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(t/a),p=Math.ceil(n/s),f=Math.ceil(r/i);let e=(h-1)*a+o-t,c=(p-1)*s+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),v=c-b,x=Math.floor(m/2);d={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(a,u,c,d,b,v,x,I,C,N,o),$=s?y*h:y;return"channelsFirst"===i?p=[l,$,E,A,_]:"channelsLast"===i&&(p=[l,E,A,_,$]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:E,outHeight:A,outWidth:_,outChannels:$,padInfo:T,strideDepth:b,strideHeight:v,strideWidth:x,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:I,effectiveFilterHeight:C,effectiveFilterWidth:N,dilationDepth:w,dilationHeight:k,dilationWidth:S,inShape:e,outShape:p,filterShape:t}}function HF(e,t,n){let r=XF(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function qF(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function KF(e){return"number"==typeof e?[e,e,e]:e}function XF(e,t){return t<=1?e:e+(e-1)*(t-1)}function YF(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function QF(e){let[t,n,r]=qF(e);return 1===t&&1===n&&1===r}function JF(e,t){return QF(e)||QF(t)}function ZF(e){return qF(e).every((e=>e>0))}function eO(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function tO(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)nE(uE(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{nE(uE(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}var nO=XD({reshape_:function(e,t){let n={x:HD(e,"x","reshape","string_or_numeric")},r={shape:t};return FD.runKernel(p$,n,r)}});var rO=XD({avgPool_:function(e,t,n,r,a){let s=HD(e,"x","avgPool","float32");nE(JF(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=s,o=!1;3===s.rank&&(o=!0,i=nO(s,[1,s.shape[0],s.shape[1],s.shape[2]])),nE(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),tO("avgPool",r,a);let l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=FD.runKernel(cA,l,u);return c=wF(c,s.dtype),o?nO(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var aO=XD({avgPool3d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC",i=HD(e,"x","avgPool3d","float32"),o=i,l=!1;4===i.rank&&(l=!0,o=nO(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),nE(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),nE("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),nE("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),tO("avgPool3d",r,a);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=FD.runKernel(hA,u,c);return d=wF(d,o.dtype),l?nO(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var sO=XD({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;nE(e.length>=1,(()=>"Pass at least one tensor to concat"));let n=qD(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return kF(n[0]);let r=n,a={axis:t};return FD.runKernel(CA,r,a)}});var iO=XD({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=HD(e,"a","matMul"),s=HD(t,"b","matMul");[a,s]=ND(a,s);let i={a:a,b:s},o={transposeA:n,transposeB:r};return FD.runKernel(fA,i,o)}});var oO=XD({sigmoid_:function(e){let t={x:HD(e,"x","sigmoid","float32")};return FD.runKernel($$,t)}});var lO=XD({slice_:function(e,t,n){let r=HD(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return FD.runKernel(T$,a,s)}});var uO=XD({tanh_:function(e){let t={x:HD(e,"x","tanh","float32")};return FD.runKernel(J$,t)}});var cO=XD({basicLSTMCell_:function(e,t,n,r,a,s){let i=HD(e,"forgetBias","basicLSTMCell"),o=HD(t,"lstmKernel","basicLSTMCell"),l=HD(n,"lstmBias","basicLSTMCell"),u=HD(r,"data","basicLSTMCell"),c=HD(a,"c","basicLSTMCell"),d=HD(s,"h","basicLSTMCell"),h=sO([u,d],1),p=iO(h,o),f=IF(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=lO(f,[0,0],y),v=lO(f,[0,g],y),x=lO(f,[0,2*g],y),w=lO(f,[0,3*g],y),k=IF(TF(oO(b),uO(v)),TF(c,oO(IF(i,x))));return[k,TF(uO(k),oO(w))]}});var dO=XD({batchToSpaceND_:function(e,t,n){let r=HD(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));nE(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),nE(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),nE(r.shape[0]%a===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));let s={x:r},i={blockShape:t,crops:n};return FD.runKernel(mA,s,i)}});function hO(e){let t;return t=0===e.rank||1===e.rank?nO(e,[1,1,1,e.size]):2===e.rank?nO(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?nO(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}var pO=XD({batchNorm_:function(e,t,n,r,a,s){null==s&&(s=.001);let i,o,l=HD(e,"x","batchNorm"),u=HD(t,"mean","batchNorm"),c=HD(n,"variance","batchNorm");null!=a&&(i=HD(a,"scale","batchNorm")),null!=r&&(o=HD(r,"offset","batchNorm")),nE(u.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),nE(null==o||u.rank===o.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),nE(null==i||u.rank===i.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let d={x:hO(l),scale:i,offset:o,mean:u,variance:c},h={varianceEpsilon:s},p=FD.runKernel(o_,d,h);return nO(p,l.shape)}});var fO=XD({batchNorm2d_:function(e,t,n,r,a,s){let i,o,l=HD(e,"x","batchNorm"),u=HD(t,"mean","batchNorm"),c=HD(n,"variance","batchNorm");return null!=a&&(i=HD(a,"scale","batchNorm")),null!=r&&(o=HD(r,"offset","batchNorm")),nE(2===l.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`)),nE(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`)),nE(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`)),null!=i&&nE(2===i.rank||1===i.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${i.rank}.`)),null!=o&&nE(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${o.rank}.`)),pO(l,u,c,o,i,s)}});var mO=XD({batchNorm3d_:function(e,t,n,r,a,s){let i,o,l=HD(e,"x","batchNorm"),u=HD(t,"mean","batchNorm"),c=HD(n,"variance","batchNorm");return null!=a&&(i=HD(a,"scale","batchNorm")),null!=r&&(o=HD(r,"offset","batchNorm")),nE(3===l.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`)),nE(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`)),nE(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`)),null!=i&&nE(3===i.rank||1===i.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${i.rank}.`)),null!=o&&nE(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${o.rank}.`)),pO(l,u,c,o,i,s)}});var gO=XD({batchNorm4d_:function(e,t,n,r,a,s){let i,o,l=HD(e,"x","batchNorm"),u=HD(t,"mean","batchNorm"),c=HD(n,"variance","batchNorm");return null!=a&&(i=HD(a,"scale","batchNorm")),null!=r&&(o=HD(r,"offset","batchNorm")),nE(4===l.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`)),nE(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`)),nE(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`)),null!=i&&nE(4===i.rank||1===i.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${i.rank}.`)),null!=o&&nE(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${o.rank}.`)),pO(l,u,c,o,i,s)}});var yO=XD({bincount_:function(e,t,n){let r=HD(e,"x","bincount"),a=HD(t,"weights","bincount");nE("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),nE(n>=0,(()=>`size must be non-negative, but got ${n}.`)),nE(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));let s={x:r,weights:a},i={size:n};return FD.runKernel(gA,s,i)}});var bO=XD({bitwiseAnd_:function(e,t){let n=HD(e,"x","bitwiseAnd"),r=HD(t,"y","bitwiseAnd");if(!lE(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let a={a:n,b:r};return FD.runKernel(yA,a)}});var vO=XD({broadcastArgs_:function(e,t){let n=HD(e,"s0","broadcastArgs","int32"),r=HD(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return FD.runKernel(vA,a)}});var xO=XD({broadcastTo_:function(e,t){let n=HD(e,"broadcastTo","x"),r=n.shape;if(LE(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=nO(n,e)}let a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return kF(n);let i={x:n},o={reps:s};return FD.runKernel(Z$,i,o)}});var wO=XD({ceil_:function(e){let t={x:HD(e,"x","ceil","float32")};return FD.runKernel(wA,t)}});function kO(e,t,n){LE(e);let r={shape:e,value:t,dtype:n=n||EE(t)};return FD.runKernel(r_,{},r)}var SO=XD({clipByValue_:function(e,t,n){let r=HD(e,"x","clipByValue");if(nE(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return kO(r.shape,t,r.dtype);let a={x:r},s={clipValueMin:t,clipValueMax:n};return FD.runKernel(kA,a,s)}});var IO=XD({concat1d_:function(e){return sO(e,0)}});var CO=XD({concat2d_:function(e,t){return sO(e,t)}});var NO=XD({concat3d_:function(e,t){return sO(e,t)}});var TO=XD({concat4d_:function(e,t){return sO(e,t)}});var EO=XD({conv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=HD(e,"x","conv2d","float32"),l=HD(t,"filter","conv2d","float32"),u=o,c=!1;3===o.rank&&(c=!0,u=nO(o,[1,o.shape[0],o.shape[1],o.shape[2]])),nE(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),nE(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),tO("conv2d",r,i);let d="NHWC"===a?u.shape[3]:u.shape[1];nE(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),nE(JF(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),nE(ZF(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),nE(ZF(n),(()=>"Error in conv2D: Strides should be larger than 0."));let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=FD.runKernel(NA,h,p);return c?nO(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var AO=XD({conv1d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0,o=HD(e,"x","conv1d"),l=HD(t,"filter","conv1d"),u=o,c=!1;2===o.rank&&(c=!0,u=nO(o,[1,o.shape[0],o.shape[1]])),nE(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),nE(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),tO("conv1d",r,i),nE(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),nE(JF(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),nE(ZF(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),nE(ZF(n),(()=>"Error in conv1D: Stride should be larger than 0.")),nE("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));let d=nO(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=nO(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=EO(h,d,[1,n],r,"NHWC",[1,s],i);return nO(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});var _O=XD({conv2DBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;nE(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=nO(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),nE(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),nE(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),nE(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));let c="NHWC"===s?o[3]:o[1],d="NHWC"===s?l.shape[3]:l.shape[1];nE(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),nE(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),tO("conv2dDerInput",a,i);let h={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=FD.runKernel(EA,h,p);return u?nO(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var $O=XD({conv2dTranspose_:function(e,t,n,r,a,s){let i=HD(e,"x","conv2dTranspose"),o=HD(t,"filter","conv2dTranspose");return _O(n,i,o,r,a,"NHWC",s)}});var RO=XD({conv3d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1],i=HD(e,"x","conv3d"),o=HD(t,"filter","conv3d"),l=i,u=!1;4===i.rank&&(u=!0,l=nO(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),nE(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),nE(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),nE(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),nE(JF(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),nE("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),nE(ZF(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),nE(ZF(n),(()=>"Error in conv3D: Strides should be larger than 0."));let c={x:l,filter:o},d={strides:n,pad:r,dataFormat:a,dilations:s},h=FD.runKernel(AA,c,d);return u?nO(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var DO=XD({conv3DBackpropInput_:function(e,t,n,r,a){nE(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=nO(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];nE(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),nE(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),nE(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),nE(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),nE(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));let c={dy:i,filter:n},d={pad:a,strides:r,inputShape:s},h=FD.runKernel($A,c,d);return o?nO(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var MO=XD({conv3dTranspose_:function(e,t,n,r,a){let s=HD(e,"x","conv3dTranspose"),i=HD(t,"filter","conv3dTranspose");return DO(n,s,i,r,a)}});var FO=XD({cos_:function(e){let t={x:HD(e,"x","cos","float32")};return FD.runKernel(RA,t)}});var OO=XD({cosh_:function(e){let t={x:HD(e,"x","cosh","float32")};return FD.runKernel(DA,t)}});var PO=XD({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={x:HD(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return FD.runKernel(MA,a,s)}});var LO=XD({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={x:HD(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return FD.runKernel(FA,a,s)}});var zO=XD({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=HD(e,"x","denseBincount"),s=HD(t,"weights","denseBincount");nE("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),nE(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),nE(n>=0,(()=>`size must be non-negative, but got ${n}.`)),nE(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));let i={x:a,weights:s},o={size:n,binaryOutput:r};return FD.runKernel(PA,i,o)}});var BO=XD({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC",r=HD(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];nE(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),nE(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),nE(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),nE(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));let o={x:r},l={blockSize:t,dataFormat:n};return FD.runKernel(LA,o,l)}});var WO=XD({depthwiseConv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=HD(e,"x","depthwiseConv2d","float32"),l=HD(t,"filter","depthwiseConv2d","float32"),u=o,c=!1;3===o.rank&&(c=!0,u=nO(o,[1,o.shape[0],o.shape[1],o.shape[2]])),nE(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),nE(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));let d="NHWC"===a?u.shape[3]:u.shape[1];nE(d===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`)),tO("depthwiseConv2d",r,i);let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=FD.runKernel(zA,h,p);return c?nO(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var VO=XD({diag_:function(e){let t={x:HD(e,"x","diag")};return FD.runKernel(VA,t)}});var UO=XD({dilation2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=HD(e,"x","dilation2d"),o=HD(t,"filter","dilation2d");nE(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),nE(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),nE("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=i,u=!1;3===i.rank&&(l=nO(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),nE(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));let c={x:l,filter:o},d={strides:n,pad:r,dilations:a},h=FD.runKernel(UA,c,d);return u?nO(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),jO={};function GO(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function HO(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function qO(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];null==s&&(s=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===s)r[n-a-1]=i;else if(1===i)r[n-a-1]=s;else{if(s!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-a-1]=s}}return r}kT(jO,{assertAndGetBroadcastShape:()=>qO,getBroadcastDims:()=>GO,getReductionAxes:()=>HO});var KO=XD({equal_:function(e,t){let n=HD(e,"a","equal","string_or_numeric"),r=HD(t,"b","equal","string_or_numeric");[n,r]=ND(n,r),qO(n.shape,r.shape);let a={a:n,b:r};return FD.runKernel(JA,a)}});var XO=XD({where_:function(e,t,n){let r=HD(t,"a","where"),a=HD(n,"b","where"),s=HD(e,"condition","where","bool"),i=qO(qO(s.shape,r.shape),a.shape),o={condition:xO(s,i),t:xO(r,i),e:xO(a,i)};return FD.runKernel(C$,o)}});var YO=XD({zerosLike_:function(e){let t={x:HD(e,"x","zerosLike")};return FD.runKernel(oR,t)}});var QO=XD({divNoNan_:function(e,t){let n=HD(e,"a","div"),r=HD(t,"b","div");[n,r]=ND(n,r);let a=NF(n,r),s=YO(a),i=KO(r,s);return XO(i,s,a)}});var JO=XD({dot_:function(e,t){let n=HD(e,"t1","dot"),r=HD(t,"t2","dot");nE((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));let a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(nE(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){let e=nO(n,[1,-1]),t=nO(r,[-1,1]),a=iO(e,t);return nO(a,[])}if(1===n.rank&&2===r.rank){let e=nO(n,[1,-1]),t=nO(r,[r.shape[0],r.shape[1]]),a=iO(e,t);return nO(a,[a.size])}if(2===n.rank&&1===r.rank){let e=nO(r,[-1,1]),t=iO(n,e);return nO(t,[t.size])}{let e=nO(r,[r.shape[0],r.shape[1]]);return iO(n,e)}}});var ZO=XD({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];let a=n.map(((e,t)=>HD(e,`tensors${t}`,"einsum"))),s={equation:e};return FD.runKernel(KA,a,s)}});var eP=XD({elu_:function(e){let t={x:HD(e,"x","elu","float32")};return FD.runKernel(XA,t)}});var tP=XD({ensureShape_:function(e,t){let n=HD(e,"x","ensureShape","string_or_numeric");if(!oE(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});var nP=XD({erf_:function(e){let t=HD(e,"x","erf");nE("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=wF(t,"float32"));let n={x:t};return FD.runKernel(QA,n)}});function rP(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function aP(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function sP(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function iP(e,t){return aP(e,t.map((e=>1)),t)}function oP(e,t,n){nE(rP(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function lP(e,t){if(rP(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function uP(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function cP(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}var dP=XD({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:HD(e,"x","max")},a={reductionIndices:t,keepDims:n};return FD.runKernel(D_,r,a)}});var hP=XD({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:HD(e,"x","min")},a={axis:t,keepDims:n};return FD.runKernel(W_,r,a)}});var pP=XD({pow_:function(e,t){let n=HD(e,"base","pow"),r=HD(t,"exp","pow");[n,r]=ND(n,r);let a={a:n,b:r};return FD.runKernel(r$,a)}});function fP(e,t){if((XR(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&XR(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return QD(e,[],[],t)}var mP=XD({sqrt_:function(e){let t={x:HD(e,"x","sqrt","float32")};return FD.runKernel(D$,t)}});var gP=XD({square_:function(e){let t=HD(e,"x","square");return FD.runKernel("Square",{x:t},{})}});var yP=XD({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=HD(e,"x","sum");"bool"===r.dtype&&(r=wF(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return FD.runKernel(M$,a,s)}});function bP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return EF(e);if(1!==e.rank&&null===n)return bP(nO(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return yP(EF(e),n);if(t===1/0)return dP(EF(e),n);if(t===-1/0)return hP(EF(e),n);if("euclidean"===t||2===t)return mP(yP(pP(EF(e),fP(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return dP(yP(EF(e),n[0]),n[1]-1);if(t===1/0)return dP(yP(EF(e),n[1]),n[0]);if(t===-1/0)return hP(yP(EF(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return mP(yP(gP(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var vP=XD({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=bP(e=HD(e,"x","norm"),t,n),s=a.shape;if(r){let t=gE(n,e.shape);s=iP(a.shape,t)}return nO(a,s)}});var xP=XD({euclideanNorm_:function(e){return vP(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});var wP=XD({exp_:function(e){let t={x:HD(e,"x","exp")};return FD.runKernel(ZA,t)}});var kP=XD({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=HD(e,"x","expandDims","string_or_numeric");nE(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));let r={input:n},a={dim:t};return FD.runKernel(e_,r,a)}});var SP=XD({expm1_:function(e){let t={x:HD(e,"x","expm1")};return FD.runKernel(t_,t)}});var IP=XD({tile_:function(e,t){let n=HD(e,"x","tile","string_or_numeric");nE(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));let r={x:n},a={reps:t};return FD.runKernel(Z$,r,a)}});var CP=XD({eye_:function(e,t,n){null==t&&(t=e);let r=xF([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=e<=t?e:t;for(let i=0;i<a;++i)r.set(1,i,i);let s=nO(r.toTensor(),[e,t]);if(null==n)return s;if(1===n.length)return IP(kP(s,0),[n[0],1,1]);if(2===n.length)return IP(kP(kP(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return IP(kP(kP(kP(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var NP=XD({floor_:function(e){let t={x:HD(e,"x","floor","float32")};return FD.runKernel(s_,t)}});var TP=XD({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a={x:HD(e,"x","gather"),indices:HD(t,"indices","gather","int32")},s={axis:n,batchDims:r};return FD.runKernel(l_,a,s)}});var EP=XD({greater_:function(e,t){let n=HD(e,"a","greater","string_or_numeric"),r=HD(t,"b","greater","string_or_numeric");[n,r]=ND(n,r),qO(n.shape,r.shape);let a={a:n,b:r};return FD.runKernel(c_,a)}});var AP=XD({greaterEqual_:function(e,t){let n=HD(e,"a","greaterEqual","string_or_numeric"),r=HD(t,"b","greaterEqual","string_or_numeric");[n,r]=ND(n,r),qO(n.shape,r.shape);let a={a:n,b:r};return FD.runKernel(d_,a)}});var _P=XD({imag_:function(e){let t={input:HD(e,"input","imag")};return FD.runKernel(f_,t)}});var $P=XD({isFinite_:function(e){let t={x:HD(e,"x","isFinite")};return FD.runKernel(m_,t)}});var RP=XD({isInf_:function(e){let t={x:HD(e,"x","isInf")};return FD.runKernel(g_,t)}});var DP=XD({isNaN_:function(e){let t={x:HD(e,"x","isNaN")};return FD.runKernel(y_,t)}});var MP=XD({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2,n={x:HD(e,"x","leakyRelu")},r={alpha:t};return FD.runKernel(b_,n,r)}});var FP=XD({less_:function(e,t){let n=HD(e,"a","less","string_or_numeric"),r=HD(t,"b","less","string_or_numeric");[n,r]=ND(n,r),qO(n.shape,r.shape);let a={a:n,b:r};return FD.runKernel(v_,a)}});var OP=XD({lessEqual_:function(e,t){let n=HD(e,"a","lessEqual","string_or_numeric"),r=HD(t,"b","lessEqual","string_or_numeric");[n,r]=ND(n,r),qO(n.shape,r.shape);let a={a:n,b:r};return FD.runKernel(x_,a)}});function PP(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return FD.runKernel(w_,{},r)}var LP=XD({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=HD(e,"x","localResponseNormalization");nE(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),nE(uE(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=s,o=!1;3===s.rank&&(o=!0,i=nO(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:a},c=FD.runKernel(__,l,u);return o?nO(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var zP=XD({log_:function(e){let t={x:HD(e,"x","log","float32")};return FD.runKernel(k_,t)}});var BP=XD({log1p_:function(e){let t={x:HD(e,"x","log1p")};return FD.runKernel(S_,t)}});function WP(e){return nE(AE(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{let r=HD(t,"x","tf.grad","string_or_numeric"),a=null!=n?HD(n,"dy","tf.grad"):null;return FD.tidy((()=>{let{value:t,grads:n}=FD.gradients((()=>e(r)),[r],a);return null!=a&&rE(t.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),qP(n),n[0]}))}}function VP(e){return nE(AE(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{nE(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));let r=qD(t,"args","tf.grads","string_or_numeric"),a=null!=n?HD(n,"dy","tf.grads"):null;return FD.tidy((()=>{let{value:t,grads:n}=FD.gradients((()=>e(...r)),r,a);return null!=a&&rE(t.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),qP(n),n}))}}function UP(e){return nE(AE(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{nE(t instanceof dD,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),nE(null==n||n instanceof dD,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));let{grads:r,value:a}=FD.gradients((()=>e(t)),[t],n);return qP(r),{grad:r[0],value:a}}}function jP(e){return nE(AE(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{nE(Array.isArray(t)&&t.every((e=>e instanceof dD)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),nE(null==n||n instanceof dD,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));let r=FD.gradients((()=>e(...t)),t,n);return null!=n&&rE(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),qP(r.grads),r}}function GP(e,t){nE(AE(e),(()=>"The f passed in variableGrads(f) must be a function")),nE(null==t||Array.isArray(t)&&t.every((e=>e instanceof pD)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));let n=null!=t;if(!n){t=[];for(let e in FD.registeredVariables)t.push(FD.registeredVariables[e])}let r=n?t.filter((e=>!e.trainable)):null,a=t.length;nE((t=t.filter((e=>e.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));let{value:s,grads:i}=FD.gradients(e,t,null,!0);nE(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),nE(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));let o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:s,grads:o}}function HP(e){return FD.customGrad(e)}function qP(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var KP=XD({neg_:function(e){let t={x:HD(e,"x","neg")};return FD.runKernel(q_,t)}});var XP=XD({softplus_:function(e){let t={x:HD(e,"x","softplus")};return FD.runKernel(R$,t)}});var YP=XD({logSigmoid_:function(e){let t=HD(e,"x","logSigmoid");return HP((e=>({value:KP(XP(KP(e))),gradFunc:t=>TF(t,oO(KP(e)))})))(t)}});var QP=XD({sub_:function(e,t){let n=HD(e,"a","sub"),r=HD(t,"b","sub");[n,r]=ND(n,r);let a={a:n,b:r};return FD.runKernel(Y$,a)}});var JP=XD({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=HD(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return HP(((e,n)=>{let r=dP(e,t,!0),a=QP(e,r),s=QP(wF(a,"float32"),zP(yP(wP(a),t,!0)));return n([s]),{value:s,gradFunc:(e,n)=>{let[r]=n,a=wP(r);return QP(e,TF(yP(e,t,!0),a))}}}))(n)}});var ZP=XD({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=HD(e,"x","logSumExp"),a=gE(t,r.shape),s=dP(r,a,!0),i=QP(r,s),o=wP(i),l=yP(o,a),u=zP(l),c=IF(nO(s,u.shape),u);if(n){let e=iP(c.shape,a);return nO(c,e)}return c}});var eL=XD({logicalAnd_:function(e,t){let n=HD(e,"a","logicalAnd","bool"),r=HD(t,"b","logicalAnd","bool");qO(n.shape,r.shape);let a={a:n,b:r};return FD.runKernel(I_,a)}});var tL=XD({logicalNot_:function(e){let t={x:HD(e,"x","logicalNot","bool")};return FD.runKernel(C_,t)}});var nL=XD({logicalOr_:function(e,t){let n=HD(e,"a","logicalOr","bool"),r=HD(t,"b","logicalOr","bool");qO(n.shape,r.shape);let a={a:n,b:r};return FD.runKernel(N_,a)}});var rL=XD({logicalXor_:function(e,t){let n=HD(e,"a","logicalXor","bool"),r=HD(t,"b","logicalXor","bool");return qO(n.shape,r.shape),eL(nL(e,t),tL(eL(e,t)))}}),aL=2147483648;var sL=XD({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left",r=HD(e,"sortedSequence","searchSorted"),a=HD(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=nO(r,[-1,s]),l=nO(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(sE(l.shape)>=aL)throw new Error(`values tensor size must less than ${aL}`);if(o.shape[1]>=aL)throw new Error(`trailing dim_size must less than ${aL} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},c={side:n};return FD.runKernel(I$,u,c)}});function iL(e,t){return sL(e,t,"left")}var oL=XD({maxPool_:function(e,t,n,r,a){let s=HD(e,"x","maxPool"),i=s,o=!1;3===s.rank&&(o=!0,i=nO(s,[1,s.shape[0],s.shape[1],s.shape[2]])),nE(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),nE(JF(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),tO("maxPool",r,a);let l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=FD.runKernel(F_,l,u);return o?nO(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var lL=XD({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC",i=HD(e,"x","maxPool3d"),o=i,l=!1;4===i.rank&&(l=!0,o=nO(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),nE(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),nE("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),tO("maxPool3d",r,a);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=FD.runKernel(P_,u,c);return l?nO(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var uL=XD({maxPoolWithArgmax_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s={x:HD(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=FD.runKernel(z_,s,i);return{result:o[0],indexes:o[1]}}});var cL=XD({maximum_:function(e,t){let n=HD(e,"a","maximum"),r=HD(t,"b","maximum");[n,r]=ND(n,r),"bool"===n.dtype&&(n=wF(n,"int32"),r=wF(r,"int32")),qO(n.shape,r.shape);let a={a:n,b:r};return FD.runKernel(M_,a)}});var dL=XD({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:HD(e,"x","mean")},a={axis:t,keepDims:n};return FD.runKernel(B_,r,a)}});function hL(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(LE(e),"complex64"===t){let t=hL(e,"float32"),n=hL(e,"float32");return YD(t,n)}let n=OE(sE(e),t);return FD.makeTensor(n,e,t)}function pL(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(LE(e),"complex64"===t){let t=pL(e,"float32"),n=hL(e,"float32");return YD(t,n)}let n=FE(sE(e),t);return FD.makeTensor(n,e,t)}function fL(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=HD(e,"x","meshgrid",e instanceof dD?e.dtype:"float32");if(void 0===t)return[r];let a=HD(t,"y","meshgrid",t instanceof dD?t.dtype:"float32"),s=sE(r.shape),i=sE(a.shape);return"xy"===n?(r=nO(r,[1,-1]),a=nO(a,[-1,1]),[iO(pL([i,1],r.dtype),r),iO(a,pL([1,s],a.dtype))]):(r=nO(r,[-1,1]),a=nO(a,[1,-1]),[iO(r,pL([1,i],r.dtype)),iO(pL([s,1],a.dtype),a)])}var mL=XD({minimum_:function(e,t){let n=HD(e,"a","minimum"),r=HD(t,"b","minimum");[n,r]=ND(n,r),"bool"===n.dtype&&(n=wF(n,"int32"),r=wF(r,"int32")),qO(n.shape,r.shape);let a={a:n,b:r};return FD.runKernel(V_,a)}});var gL=XD({mirrorPad_:function(e,t,n){nE("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));let r=HD(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");nE(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));let a="reflect"===n?1:0;for(let o=0;o<r.rank;o++)nE(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),nE(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`));let s={paddings:t,mode:n},i={x:r};return FD.runKernel(U_,i,s)}});var yL=XD({mod_:function(e,t){let n=HD(e,"a","mod"),r=HD(t,"b","mod");[n,r]=ND(n,r);let a={a:n,b:r};return FD.runKernel(j_,a)}});var bL=XD({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=gE(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=HD(e,"x","moments")).shape),r=dL(e,n,t),a=r.shape;t||(a=iP(r.shape,n));let s=gP(QP(wF(e,"float32"),nO(r,a)));return{mean:r,variance:dL(s,n,t)}}});var vL=XD({multiRNNCell_:function(e,t,n,r){let a=HD(t,"data","multiRNNCell"),s=qD(n,"c","multiRNNCell"),i=qD(r,"h","multiRNNCell"),o=a,l=[];for(let d=0;d<e.length;d++){let t=e[d](o,s[d],i[d]);l.push(t[0]),l.push(t[1]),o=t[1]}let u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}});var xL=XD({multinomial_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=HD(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:1===i?nO(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=FD.runKernel(G_,o,l);return 1===i?nO(u,[u.size]):u}});var wL=XD({notEqual_:function(e,t){let n=HD(e,"a","notEqual","string_or_numeric"),r=HD(t,"b","notEqual","string_or_numeric");[n,r]=ND(n,r),qO(n.shape,r.shape);let a={a:n,b:r};return FD.runKernel(K_,a)}});var kL=XD({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:HD(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return FD.runKernel(Z_,s,i)}});var SL=XD({onesLike_:function(e){let t={x:HD(e,"x","onesLike")};return FD.runKernel(J_,t)}});var IL=XD({outerProduct_:function(e,t){let n=HD(e,"v1","outerProduct"),r=HD(t,"v2","outerProduct");nE(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));let a=nO(n,[-1,1]),s=nO(r,[1,-1]);return iO(a,s)}});var CL=XD({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=HD(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return FD.runKernel(t$,s,a)}});var NL=XD({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return nE(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),CL(e,[t],n)}});var TL=XD({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return nE(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),CL(e,t,n)}});var EL=XD({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return nE(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),CL(e,t,n)}});var AL=XD({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return nE(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),CL(e,t,n)}});var _L=XD({spaceToBatchND_:function(e,t,n){let r=HD(e,"x","spaceToBatchND");nE(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),nE(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),nE(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));let a={x:r},s={blockShape:t,paddings:n};return FD.runKernel(F$,a,s)}});var $L=XD({pool_:function(e,t,n,r,a,s,i){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");let o=HD(e,"x","maxPool"),l=o,u=!1;3===o.rank&&(u=!0,l=nO(o,[1,o.shape[0],o.shape[1],o.shape[2]])),nE(JF(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));let c,d=VF(l.shape,t,s,a,r),h=[d.dilationHeight,d.dilationWidth];c="same"===r?function(e,t){let n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),a=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],a[t]]))}([d.filterHeight,d.filterWidth],h):[[0,0],[0,0]];let p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){let r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),i=t.map(((e,t)=>(e-s[t]%e)%e)),o=a.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([d.inHeight,d.inWidth],h,c),g=p?r:"valid",y=p?l:_L(l,h,f),b=("avg"===n?()=>rO(y,t,s,g,i):()=>oL(y,t,s,g,i))(),v=p?b:dO(b,h,m);return u?nO(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});var RL=XD({prelu_:function(e,t){let n={x:HD(e,"x","prelu"),alpha:HD(t,"alpha","prelu")};return FD.runKernel(a$,n)}});var DL=XD({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=HD(e,"x","prod");"bool"===r.dtype&&(r=wF(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return FD.runKernel(s$,a,s)}});var ML=XD({raggedGather_:function(e,t,n,r){let a=e.map(((e,t)=>HD(e,`tensors${t}`,"raggedGather","int32"))),s={paramsNestedSplits:a,paramsDenseValues:HD(t,"paramsDenseValues","raggedGather"),indices:HD(n,"indices","raggedGather","int32")},i={outputRaggedRank:r},o=FD.runKernel(i$,s,i);return{outputNestedSplits:o.slice(0,o.length-1),outputDenseValues:o[o.length-1]}}});var FL=XD({raggedRange_:function(e,t,n){let r=HD(e,"starts","raggedRange"),a={starts:r,limits:HD(t,"limits","raggedRange",r.dtype),deltas:HD(n,"deltas","raggedRange",r.dtype)},s=FD.runKernel(o$,a);return{rtNestedSplits:s[0],rtDenseValues:s[1]}}});var OL=XD({raggedTensorToTensor_:function(e,t,n,r,a){let s=HD(e,"shape","raggedTensorToTensor","int32"),i=HD(t,"values","raggedTensorToTensor"),o={shape:s,values:i,defaultValue:HD(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>HD(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:a};return FD.runKernel(l$,o,l)}});var PL=XD({rand_:function(e,t,n){LE(e);let r=sE(e),a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let s=0;s<r;s++)a[s]=t();return FD.makeTensor(a,e,n)}}),LL=ST(FT()),zL={};kT(zL,{TEST_EPSILON_FLOAT16:()=>WL,createVideoElement:()=>JL,encodeStrings:()=>QL,expectArrayBuffersEqual:()=>YL,expectArraysClose:()=>VL,expectArraysEqual:()=>HL,expectNumbersClose:()=>qL,expectPromiseToFail:()=>GL,expectValuesInRange:()=>XL,play:()=>ZL,testEpsilon:()=>UL});var BL=.001,WL=.1;function VL(e,t,n){return null==n&&(n=UL()),jL(e,t,((e,t)=>KL(e,t,n)))}function UL(){return 32===FD.backend.floatPrecision()?BL:WL}function jL(e,t,n){let r=!0;if((XR(e)||XR(t))&&(r=!1),XR(e)&&XR(t)&&(r=!0),r){let n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){let n=UD(e),r=UD(t);if(!lE(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}let a=XR(e)?e:YR(e),s=XR(t)?t:YR(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.\nActual:   ${a}.\nExpected: ${s}.`);for(let i=0;i<s.length;++i){let e=a[i],t=s[i];if(!n(e,t))throw new Error(`Arrays differ: actual[${i}] = ${e}, expected[${i}] = ${t}.\nActual:   ${a}.\nExpected: ${s}.`)}"undefined"!=typeof expect&&expect().nothing()}function GL(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!=typeof expect&&expect().nothing()}function HL(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return CE(e)||CE(e[0])||CE(t)||CE(t[0])?jL(e,n,((e,t)=>e==t)):jL(e,t,((e,t)=>KL(e,t,0)))}function qL(e,t,n){if(null==n&&(n=UL()),!KL(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function KL(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function XL(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function YL(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function QL(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?QL(n):e[t]=qR(n)}return e}function JL(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function ZL(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}var ez=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let s=a||Math.random();this.random=LL.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},tz=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=LL.alea(a.toString()),this.randn=new ez(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}},nz=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=LL.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};var rz=XD({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;if(LE(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);let s=new tz(t,n,r,a),i=xF(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var az=XD({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(LE(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);let s=new ez(t,n,r,!1,a),i=xF(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var sz=XD({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return az(e,0,1,t,n)}});var iz=XD({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;LE(e);let s=xF(e,r),i=new nz(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});var oz=XD({randomUniformInt_:function(e,t,n,r){return iz(e,t,n,"int32",r)}});function lz(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return FD.runKernel(u$,{},a)}var uz=XD({real_:function(e){let t={input:HD(e,"input","real")};return FD.runKernel(c$,t)}});var cz=XD({reciprocal_:function(e){let t={x:HD(e,"x","reciprocal")};return FD.runKernel(d$,t)}});var dz=XD({relu_:function(e){let t={x:HD(e,"x","relu")};return FD.runKernel(h$,t)}});var hz=XD({relu6_:function(e){let t={x:HD(e,"x","relu6")};return FD.runKernel(b$,t)}});var pz=XD({reverse_:function(e,t){let n={x:HD(e,"x","reverse")},r={dims:t};return FD.runKernel(v$,n,r)}});var fz=XD({reverse1d_:function(e){let t=HD(e,"x","reverse");return nE(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),pz(t,0)}});var mz=XD({reverse2d_:function(e,t){let n=HD(e,"x","reverse");return nE(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),pz(n,t)}});var gz=XD({reverse3d_:function(e,t){let n=HD(e,"x","reverse");return nE(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),pz(n,t)}});var yz=XD({reverse4d_:function(e,t){let n=HD(e,"x","reverse");return nE(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),pz(n,t)}});var bz=XD({round_:function(e){let t={x:HD(e,"x","round")};return FD.runKernel(x$,t)}});var vz=XD({rsqrt_:function(e){let t={x:HD(e,"x","rsqrt","float32")};return FD.runKernel(w$,t)}});var xz=XD({selu_:function(e){let t={x:HD(e,"x","selu")};return FD.runKernel(N$,t)}});var wz=XD({separableConv2d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC",o=HD(e,"x","separableConv2d"),l=HD(t,"depthwiseFilter","separableConv2d"),u=HD(n,"pointwiseFilter","separableConv2d"),c=o,d=!1;if(3===o.rank&&(d=!0,c=nO(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");nE(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),nE(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),nE(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),nE(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),nE(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));let h=l.shape[2],p=l.shape[3];nE(u.shape[2]===h*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`));let f=WO(c,l,r,a,i,s),m=EO(f,u,1,"valid",i);return d?nO(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});var kz=async function(e,t){let n=HD(e,"x","setdiff1d"),r=HD(t,"y","setdiff1d");nE(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),nE(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),nE(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let c=0;c<a.length;c++)i.has(a[c])||o++;let l=new lD([o],n.dtype),u=new lD([o],"int32");for(let c=0,d=0;c<a.length;c++)i.has(a[c])||(l.values[d]=a[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]};var Sz=XD({sign_:function(e){let t={x:HD(e,"x","sign")};return FD.runKernel(_$,t)}});var Iz=XD({sin_:function(e){let t={x:HD(e,"x","sin","float32")};return FD.runKernel(E$,t)}});var Cz=XD({sinh_:function(e){let t={x:HD(e,"x","sinh")};return FD.runKernel(A$,t)}});var Nz=XD({slice1d_:function(e,t,n){let r=HD(e,"x","slice1d");return nE(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),lO(r,[t],[n])}});var Tz=XD({slice2d_:function(e,t,n){let r=HD(e,"x","slice2d");return nE(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),lO(r,t,n)}});var Ez=XD({slice3d_:function(e,t,n){let r=HD(e,"x","slice3d");return nE(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),lO(r,t,n)}});var Az=XD({slice4d_:function(e,t,n){let r=HD(e,"x","slice4d");return nE(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),lO(r,t,n)}});var _z=XD({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=HD(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return FD.runKernel(P$,r,a)}});var $z=XD({fft_:function(e){nE("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));let t={input:e};return FD.runKernel(n_,t)}});var Rz=XD({ifft_:function(e){nE("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));let t={input:e};return FD.runKernel(p_,t)}});var Dz=XD({irfft_:function(e){let t,n=e.shape[e.shape.length-1],r=e.size/n;if(n<=2){let a=nO(e,[r,n]);t=Rz(a)}else{let a=[r,2*(n-1)],s=nO(uz(e),[r,n]),i=nO(_P(e),[r,n]),o=pz(lO(s,[0,1],[r,n-2]),1),l=TF(pz(lO(i,[0,1],[r,n-2]),1),fP(-1)),u=sO([s,o],1),c=sO([i,l],1),d=nO(YD(u,c),[a[0],a[1]]);t=Rz(d)}if(t=uz(t),3===e.rank&&0!==e.shape[0]){let n=t,r=e.shape[0];t=nO(t,[r,t.shape[0]/r,t.shape[1]]),n.dispose()}return t}});var Mz=XD({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r={x:HD(e,"x","split")},a={numOrSizeSplits:t,axis:n};return FD.runKernel(O$,r,a)}});var Fz=XD({rfft_:function(e,t){nE("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n,r=e.shape[e.shape.length-1],a=e.size/r;if(null!=t&&t<r){let a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,n=lO(e,a,s),r=t}else if(null!=t&&t>r){let a=e.shape.map((e=>e));a[e.shape.length-1]=t-r,n=sO([e,hL(a)],e.shape.length-1),r=t}else n=e;let s=YO(n),i=nO(YD(n,s),[a,r]),o=$z(i),l=Math.floor(r/2)+1,u=uz(o),c=_P(o),d=Mz(u,[l,r-l],u.shape.length-1),h=Mz(c,[l,r-l],c.shape.length-1),p=n.shape.slice();return p[n.shape.length-1]=l,nO(YD(d[0],h[0]),p)}});var Oz=XD({squaredDifference_:function(e,t){let n=HD(e,"a","squaredDifference"),r=HD(t,"b","squaredDifference");[n,r]=ND(n,r),qO(n.shape,r.shape);let a={a:n,b:r};return FD.runKernel(U$,a,{})}});var Pz=XD({squeeze_:function(e,t){let n=HD(e,"x","squeeze","string_or_numeric");return nO(n,yE(n.shape,t).newShape)}});var Lz=XD({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=qD(e,"tensors","stack","string_or_numeric");nE(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&nE(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));let r=n,a={axis:t};return FD.runKernel(e$,r,a)}});var zz=XD({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:HD(e,"x","step")},r={alpha:t};return FD.runKernel(lR,n,r)}});var Bz=XD({stridedSlice_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,u={x:HD(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return FD.runKernel(H$,u,c)}});var Wz=XD({tan_:function(e){let t={x:HD(e,"x","tan","float32")};return FD.runKernel(Q$,t)}});function Vz(e,t){aE(e);let n=UD(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return QD(e,null,n,t)}function Uz(e,t,n){if(aE(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");let r=UD(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return QD(e,t,r,n)}function jz(e,t,n){if(aE(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");let r=UD(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return QD(e,t,r,n)}function Gz(e,t,n){if(aE(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");let r=UD(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return QD(e,t,r,n)}function Hz(e,t,n){if(aE(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");let r=UD(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return QD(e,t,r,n)}function qz(e,t,n){if(aE(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");let r=UD(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return QD(e,t=t||r,r,n)}var Kz={};function Xz(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function Yz(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Xz(n,t,e)}function Qz(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let l=a;l<s;++l)i*=n[l];let o=a<1?1:a;return{sliceRank:a,numUpdates:sE(t.shape)/o,sliceSize:i,strides:[...$E(n.slice(0,a)),1],outputSize:sE(n)}}kT(Kz,{calculateShapes:()=>Qz,validateInput:()=>Yz,validateUpdateShape:()=>Xz});var Jz=XD({tensorScatterUpdate_:function(e,t,n){let r=HD(e,"tensor","tensorScatterupdate"),a=HD(t,"indices","tensorScatterupdate","int32"),s=HD(n,"updates","tensorScatterupdate");if(Yz(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:a,updates:s};return FD.runKernel(S$,i,{})}});var Zz=XD({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=HD(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=FD.runKernel(eR,s,i);return{values:o,indices:l}}});var eB=XD({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(LE(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");let s=new ez(t,n,r,!0,a),i=xF(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var tB=XD({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=HD(e,"x","unique","string_or_numeric");nE(n.rank>0,(()=>"The input tensor must be at least 1D"));let r={x:n},a={axis:t},[s,i]=FD.runKernel(rR,r,a);return{values:s,indices:i}}});var nB=XD({unsortedSegmentSum_:function(e,t,n){let r=HD(e,"x","unsortedSegmentSum"),a=HD(t,"segmentIds","unsortedSegmentSum","int32");nE(uE(n),(()=>"numSegments must be of dtype int"));let s={x:r,segmentIds:a},i={numSegments:n};return FD.runKernel(sR,s,i)}});var rB=XD({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=HD(e,"x","unstack","string_or_numeric");nE(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));let r={value:n},a={axis:t};return FD.runKernel(aR,r,a)}});function aB(e,t){return sL(e,t,"right")}function sB(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return FD.makeVariable(e,t,n,r)}function iB(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let r=xF(e,"int32"),a=xF([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let t=r.indexToLoc(n[s]),i=s*e.length;a.values.set(t,i)}return a.toTensor()}var oB=async function(e){let t=HD(e,"condition","whereAsync","bool"),n=await t.data(),r=iB(t.shape,n);return e!==t&&t.dispose(),r};var lB=async function(e,t,n){let r=HD(e,"tensor","boolMask"),a=HD(t,"mask","boolMask","bool"),s=null==n?0:n,i=a.rank,o=r.shape;nE(i>0,(()=>"mask cannot be scalar")),rE(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];let u=o.slice(0,s).concat([l],o.slice(s+i)),c=nO(r,u),d=nO(a,[-1]),h=await oB(d),p=Pz(h,[1]),f=TP(c,p,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f};var uB=XD({transpose_:function(e,t,n){let r=HD(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),nE(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{nE(e>=0&&e<r.rank,(()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`))})),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return"complex64"===r.dtype?uM((()=>{let e=uz(r),t=_P(r);return e=FD.runKernel(nR,{x:e},s),t=FD.runKernel(nR,{x:t},s),n&&(t=KP(t)),YD(e,t)})):FD.runKernel(nR,a,s)}});var cB=XD({movingAverage_:function(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=HD(e,"v","movingAverage"),i=HD(t,"x","movingAverage"),o=HD(n,"decay","movingAverage");TD(s,i),nE(lE(s.shape,i.shape),(()=>"Shape mismatch in v and x"));let l=fP(1),u=QP(l,o),c=TF(QP(i,s),u);if(a){nE(null!=r,(()=>"When using zeroDebias: true, step is required."));let e=HD(r,"step","movingAverage");c=NF(c,QP(l,pP(o,e)))}return IF(s,c)}});var dB=XD({scatterND_:function(e,t,n){LE(n);let r=HD(e,"indices","scatterND","int32"),a=HD(t,"updates","scatterND");Yz(a,r,n);let s={indices:r,updates:a},i={shape:n};return FD.runKernel(k$,s,i)}});var hB=XD({sparseToDense_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;LE(n);let a=HD(e,"sparseIndices","sparseToDense","int32"),s=HD(t,"sparseValues","sparseToDense","string_or_numeric"),i=HD(r,"defaultValue","sparseToDense",s.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(0!==t.rank&&(1!==t.rank||i!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return FD.runKernel(V$,o,l)}});var pB=XD({gatherND_:function(e,t){let n=HD(t,"indices","gatherND","int32"),r={params:HD(e,"x","gatherND","string_or_numeric"),indices:n};return FD.runKernel(u_,r)}});var fB=XD({dropout_:function(e,t,n,r){let a=HD(e,"x","dropout");if(nE("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),nE(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof dD?a.clone():a;let s=function(e,t){if(null==t)return e.shape.slice();if(lE(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),i=1-t,o=NF(NP(IF(iz(s,0,1,"float32",r),i)),i);return TF(a,o)}});function mB(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function gB(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return Vz(a,"float32")}var yB=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=HD(e,"predictions","inTopK"),a=HD(t,"targets","inTopK");nE(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),nE(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),rE(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];nE(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));let i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],c=bE("bool",l);for(let d=0;d<l;d++){let e=d*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),c[d]=0;for(let a=0;a<n;a++)if(r[a].index===o[d]){c[d]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),JD(c,a.shape,"bool")},bB={};kT(bB,{conv2d:()=>IB,depthwiseConv2d:()=>TB,matMul:()=>EB});var vB=XD({conv2DBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=nO(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=nO(t,[1,t.shape[0],t.shape[1],t.shape[2]])),nE(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),nE(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),nE(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));let u="NHWC"===s?o.shape[3]:o.shape[1],c="NHWC"===s?l.shape[3]:l.shape[1];nE(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),nE(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),tO("conv2dDerFilter",a,i);let d={x:o,dy:l},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return FD.runKernel(TA,d,h)}});function xB(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return TF(e,zz(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function wB(e,t){let n=t,r=HO(e.shape,t.shape);return r.length>0&&(n=yP(n,r)),nO(n,e.shape)}function kB(e,t,n,r){if("linear"===t)return e;if("relu"===t)return dz(e);if("elu"===t)return eP(e);if("relu6"===t)return hz(e);if("prelu"===t)return RL(e,n);if("leakyrelu"===t)return MP(e,r);if("sigmoid"===t)return oO(e);throw new Error(`Unknown fused activation ${t}.`)}var SB=(e,t)=>!(e>0)||"linear"===t;var IB=XD({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(u=u||"linear",!1===SB(FD.state.gradientDepth,u)){nE("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=EO(t,n,r,a,s,i,o);return null!=l&&(e=IF(e,l)),kB(e,u,c,d)}let h=HD(t,"x","conv2d","float32"),p=HD(n,"filter","conv2d","float32"),f=h,m=!1;3===h.rank&&(m=!0,f=nO(h,[1,h.shape[0],h.shape[1],h.shape[2]])),nE(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),nE(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),tO("fused conv2d",a,o);let g="NHWC"===s?f.shape[3]:f.shape[1];nE(p.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`)),nE(JF(r,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`));let y,b,v=jF(f.shape,p.shape,r,i,a,o);if(null!=l&&(y=HD(l,"bias","fused conv2d"),[y]=ND(y,h),"NHWC"===s?qO(v.outShape,y.shape):(nE(y.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`)),nE(0===y.shape.length||y.shape[0]===v.outChannels||1===y.shape[0],(()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${v.outChannels})`)))),null!=c){let e=c.shape;if(nE(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)nE(1===e[0]||e[0]===v.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${v.outChannels}).`));else if(3===e.length)try{qO(e,v.outShape)}catch(Hd){let n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${v.outShape}).`;throw Error(n)}b=HD(c,"prelu weights","fused conv2d")}let x=(e,t)=>{nE("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));let[n,o,l,c]=t,d=xB(e,l,u);nE(QF(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));let h=[_O(o.shape,d,n,r,a),vB(o,d,n.shape,r,a)];if(null!=c){let e=wB(c,d);h.push(e)}return h},w={x:f,filter:p,bias:y,preluActivationWeights:b},k={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};return null==l?HP(((e,t,n)=>{let r=FD.runKernel(hR,w,k);return n([t,e,r]),m&&(r=nO(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}))(f,p):HP(((e,t,n,r)=>{let a=FD.runKernel(hR,w,k);return r([t,e,a,n]),m&&(a=nO(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}))(f,p,y)}});var CB=XD({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=nO(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=nO(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return FD.runKernel(BA,u,c)}});var NB=XD({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,l=!1;3===t.rank&&(l=!0,o=nO(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},d=FD.runKernel(WA,u,c);return l?nO(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});var TB=XD({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(!1===SB(FD.state.gradientDepth,u)){let e=WO(t,n,r,a,s,i,o);return null!=l&&(e=IF(e,l)),kB(e,u,c,d)}let h=HD(t,"x","depthwiseConv2d","float32"),p=HD(n,"filter","depthwiseConv2d","float32"),f=h,m=!1;3===h.rank&&(m=!0,f=nO(h,[1,h.shape[0],h.shape[1],h.shape[2]])),nE(4===f.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`)),nE(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),nE(f.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==i&&(i=[1,1]),nE(JF(r,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`)),tO("fused depthwiseConv2d",a,o);let g,y,b=jF(f.shape,p.shape,r,i,a,o,!0);null!=l&&(g=HD(l,"bias","fused conv2d"),[g]=ND(g,h),qO(b.outShape,g.shape)),null!=c&&(y=HD(c,"prelu weights","fused depthwiseConv2d"));let v=(e,t)=>{nE(QF(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));let[n,s,l,c]=t,d=xB(e,l,u),h=NB(s.shape,d,n,r,a,i,o),p=CB(s,d,n.shape,r,a,i,o);if(null!=c){return[h,p,wB(g,d)]}return[h,p]},x={x:f,filter:p,bias:g,preluActivationWeights:y},w={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};return null==l?HP(((e,t,n)=>{let r=FD.runKernel(pR,x,w);return n([t,e,r]),m&&(r=nO(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}))(f,p):HP(((e,t,n,r)=>{let a=FD.runKernel(pR,x,w);return r([t,e,a,n]),m&&(a=nO(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}))(f,p,g)}});var EB=XD({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}=e;if(!1===SB(FD.state.gradientDepth,i)){let e=iO(t,n,r,a);return null!=s&&(e=IF(e,s)),kB(e,i,o,l)}let u=HD(t,"a","fused matMul"),c=HD(n,"b","fused matMul");[u,c]=ND(u,c);let d=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=a?c.shape[c.rank-1]:c.shape[c.rank-2],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=a?c.shape[c.rank-2]:c.shape[c.rank-1],m=u.shape.slice(0,-2),g=c.shape.slice(0,-2),y=sE(m),b=sE(g);nE(d===h,(()=>`Error in fused matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${r} and transposeB=${a} must match.`));let v,x,w=qO(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),k=nO(u,r?[y,d,p]:[y,p,d]),S=nO(c,a?[b,f,h]:[b,h,f]);null!=s&&(v=HD(s,"bias","fused matMul"),[v]=ND(v,u),qO(w,v.shape)),null!=o&&(x=HD(o,"prelu weights","fused matMul"));let I=(e,t)=>{let n,o,[l,u,c,d]=t,h=xB(nO(e,c.shape),c,i);if(r||a?!r&&a?(n=iO(h,u,!1,!1),o=iO(h,l,!0,!1)):r&&!a?(n=iO(u,h,!1,!0),o=iO(l,h,!1,!1)):(n=iO(u,h,!0,!0),o=iO(h,l,!0,!0)):(n=iO(h,u,!1,!0),o=iO(l,h,!0,!1)),null!=s){return[n,o,wB(d,h)]}return[n,o]},C={a:k,b:S,bias:v,preluActivationWeights:x},N={transposeA:r,transposeB:a,activation:i,leakyreluAlpha:l};return null==s?HP(((e,t,n)=>{let r=FD.runKernel(dR,C,N);return n([e,t,r]),{value:nO(r,w),gradFunc:I}}))(k,S):HP(((e,t,n,r)=>{let a=FD.runKernel(dR,C,N);return r([e,t,a,n]),{value:nO(a,w),gradFunc:I}}))(k,S,v)}});var AB=XD({hammingWindow_:function(e){return gB(e,.54,.46)}});var _B=XD({hannWindow_:function(e){return gB(e,.5,.5)}});var $B=XD({frame_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0,i=[];for(;s+t<=e.size;)i.push(lO(e,s,t)),s+=n;if(r)for(;s<e.size;){let r=s+t-e.size,o=sO([lO(e,s,t-r),kO([r],a)]);i.push(o),s+=n}return 0===i.length?Uz([],[0,t]):nO(sO(i),[i.length,t])}});var RB=XD({stft_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:_B;null==r&&(r=mB(t));let s=$B(e,t,n),i=TF(s,a(t));return Fz(i,r)}});var DB=XD({cropAndResize_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=HD(e,"image","cropAndResize"),o=HD(t,"boxes","cropAndResize","float32"),l=HD(n,"boxInd","cropAndResize","int32"),u=o.shape[0];nE(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),nE(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),nE(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),nE(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),nE(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),nE("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));let c={image:i,boxes:o,boxInd:l},d={method:a,extrapolationValue:s,cropSize:r};return FD.runKernel(OA,c,d)}});var MB=XD({flipLeftRight_:function(e){let t=HD(e,"image","flipLeftRight","float32");nE(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));let n={image:t};return FD.runKernel(a_,n,{})}});var FB=XD({grayscaleToRGB_:function(e){let t=HD(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];nE(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),nE(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,IP(t,a)}});var OB=XD({rgbToGrayscale_:function(e){let t=HD(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];nE(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),nE(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));let a,s=t.dtype,i=wF(t,"float32"),o=Vz([.2989,.587,.114]);switch(t.rank){case 2:a=ZO("ij,j->i",i,o);break;case 3:a=ZO("ijk,k->ij",i,o);break;case 4:a=ZO("ijkl,l->ijk",i,o);break;case 5:a=ZO("ijklm,m->ijkl",i,o);break;case 6:a=ZO("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=kP(a,-1),wF(a,s)}});var PB=XD({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=HD(e,"image","rotateWithOffset","float32");nE(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));let s={image:a},i={radians:t,fillValue:n,center:r};return FD.runKernel(cR,s,i)}});function LB(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);let i=e.shape[0];return n=Math.min(n,i),nE(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),nE(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),nE(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),nE(1===t.rank,(()=>"scores must be a 1D tensor")),nE(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),nE(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}var zB=XD({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=HD(e,"boxes","nonMaxSuppression","float32"),i=HD(t,"scores","nonMaxSuppression","float32"),o=LB(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return FD.runKernel(X_,{boxes:s,scores:i},l)}});function BB(e,t,n){let r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}(e,t,n||WB)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function WB(e,t){return e>t?1:e<t?-1:0}function VB(e,t,n,r,a){return GB(e,t,n,r,a,0)}function UB(e,t,n,r,a,s){return GB(e,t,n,r,a,0,!1,s,!0)}function jB(e,t,n,r,a,s){return GB(e,t,n,r,a,s,!0)}function GB(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8],u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(KB);let c=s>0?-.5/s:0,d=[],h=[];for(;d.length<n&&u.length>0;){let t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<a)break;let o=!1;for(let l=d.length-1;l>=i;--l){let n=HB(e,s,d[l]);if(n>=r){o=!0;break}if(t.score=t.score*qB(r,c,n),t.score<=a)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(s),h.push(t.score)):t.score>a&&BB(u,t,KB))}let p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));let m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function HB(e,t,n){let r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),h=Math.max(a[1],a[3]),p=(o-s)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;let m=Math.max(s,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function qB(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function KB(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}var XB=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=HD(e,"boxes","nonMaxSuppressionAsync"),i=HD(t,"scores","nonMaxSuppressionAsync"),o=LB(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=VB(u,c,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),Vz(d,"int32")};var YB=XD({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=HD(e,"boxes","nonMaxSuppression"),o=HD(t,"scores","nonMaxSuppression"),l=LB(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},d=FD.runKernel(Q_,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}});var QB=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=HD(e,"boxes","nonMaxSuppressionAsync"),o=HD(t,"scores","nonMaxSuppressionAsync"),l=LB(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=jB(c,d,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Vz(h,"int32"),selectedScores:Vz(p)}};var JB=XD({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=HD(e,"boxes","nonMaxSuppression"),o=HD(t,"scores","nonMaxSuppression"),l=LB(i,o,n,r,a,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},d=FD.runKernel(Y_,u,c);return{selectedIndices:d[0],validOutputs:d[1]}}});var ZB=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=HD(e,"boxes","nonMaxSuppressionAsync"),o=HD(t,"scores","nonMaxSuppressionAsync"),l=LB(i,o,n,r,a,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=UB(h,p,u,c,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Vz(f,"int32"),validOutputs:fP(m,"int32")}};var eW=XD({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=HD(e,"images","resizeBilinear");nE(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),nE(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),nE(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=nO(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=FD.runKernel(g$,o,l);return i?nO(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var tW=XD({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=HD(e,"images","resizeNearestNeighbor");nE(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),nE(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),nE("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),nE(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=nO(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=FD.runKernel(f$,o,l);return i?nO(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var nW=XD({threshold_:function(e){let t,n,r,a,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,l=HD(e,"image","threshold"),u=l.shape[0]*l.shape[1],c=TF(Vz([o]),255);if(nE(3===l.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`)),nE(3===l.shape[2]||1===l.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`)),nE("int32"===l.dtype||"float32"===l.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`)),nE("otsu"===s||"binary"===s,(()=>`Method must be binary or otsu, but was ${s}`)),3===l.shape[2]){[t,n,r]=Mz(l,[1,1,1],-1);let e=TF(t,.2989),s=TF(n,.587),i=TF(r,.114);a=IF(IF(e,s),i)}else a=e;if("otsu"===s){c=function(e,t){let n,r,a,s,i,o,l=Vz([-1]),u=Vz([0]),c=Vz([0]);for(let d=0;d<e.size-1;d++){n=lO(e,0,d+1),r=lO(e,d+1),i=NF(yP(n),t),o=NF(yP(r),t);let h=yP(TF(n,lz(0,n.size)));a=NF(h,yP(n));let p=kO(r.shape,n.size),f=IF(lz(0,r.size),p),m=TF(r,f);s=NF(yP(m),yP(r));let g=QP(a,s),y=QP(a,s),b=TF(i,o);c=TF(TF(b,g),y);let v=EP(c,u);u=XO(v,c,u),l=XO(v,Vz([d]),l)}return l}(yO(wF(bz(a),"int32"),JD([]),256),u)}let d=i?OP(a,c):EP(a,c);return wF(TF(d,255),"int32")}});var rW=XD({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0,i=HD(e,"image","transform","float32"),o=HD(t,"transforms","transform","float32");nE(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),nE(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),nE(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));let l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return FD.runKernel(tR,l,u)}});var aW=XD({bandPart_:function(e,t,n){let r=HD(e,"a","bandPart");nE(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));let a,s,i=r.shape,[o,l]=r.shape.slice(-2);"number"==typeof t?(nE(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),nE(t<=o,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`)),a=HD(t<0?o:t,"numLower","bandPart")):(nE("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),a=XO(FP(t,0),o,mL(t,o))),"number"==typeof n?(nE(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),nE(n<=l,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${l}).`)),s=HD(n<0?l:n,"numUpper","bandPart")):(nE("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),s=XO(FP(n,0),l,mL(n,l)));let u=nO(lz(0,o,1,"int32"),[-1,1]),c=lz(0,l,1,"int32"),d=QP(u,c),h=eL(OP(d,a),AP(d,KP(s))),p=hL([o,l],r.dtype);return nO(Lz(rB(nO(r,[-1,o,l])).map((e=>XO(h,e,p)))),i)}});var sW=XD({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,nE(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));let n=e[0].shape[0];for(let t=1;t<e.length;++t)nE(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=Mz(e,e.shape[0],0).map((e=>Pz(e,[0])));nE(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));let n=[],r=e;for(let a=0;a<e.length;++a)n.push(FD.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){let r=TF(yP(TF(n[t],e)),n[t]);e=QP(e,r)}return NF(e,vP(e,"euclidean"))})));return t?Lz(n,0):n}});function iW(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return FD.tidy((()=>{nE(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));let n=e.shape[0],r=e.shape[1],a=CP(n),s=kF(e),i=Uz([[1]],[1,1]),o=kF(i),l=n>=r?r:n;for(let e=0;e<l;++e){let t=s,l=o,u=a;[o,s,a]=FD.tidy((()=>{let t=lO(s,[e,e],[n-e,1]),l=vP(t),u=lO(s,[e,e],[1,1]),c=XO(EP(u,0),Uz([[-1]]),Uz([[1]])),d=QP(u,TF(c,l)),h=NF(t,d);o=1===h.shape[0]?kF(i):sO([i,lO(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);let p=KP(NF(iO(c,d),l)),f=lO(s,[e,0],[n-e,r]),m=TF(p,o),g=uB(o);if(0===e)s=QP(f,iO(m,iO(g,f)));else{let t=QP(f,iO(m,iO(g,f)));s=sO([lO(s,[0,0],[e,r]),t],0)}let y=uB(m),b=lO(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=QP(b,iO(iO(b,o),y));else{let t=QP(b,iO(iO(b,o),y));a=sO([lO(a,[0,0],[n,e]),t],1)}return[o,s,a]})),cM([t,l,u])}return!t&&n>r&&(a=lO(a,[0,0],[n,r]),s=lO(s,[0,0],[r,r])),[a,s]}))}var oW,lW=XD({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(nE(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return iW(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=rB(nO(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];return r.forEach((e=>{let[n,r]=iW(e,t);a.push(n),s.push(r)})),[nO(Lz(a,0),e.shape),nO(Lz(s,0),e.shape)]}}});!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(oW||(oW={}));var uW=XD({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:oW.SUM_BY_NONZERO_WEIGHTS,r=HD(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=HD(t,"weights","computeWeightedLoss"));let s=null==a?r:TF(r,a);if(n===oW.NONE)return s;if(n===oW.SUM)return yP(s);if(n===oW.MEAN){if(null==a)return dL(s);{let e=r.size/a.size,t=NF(yP(s),yP(a));return e>1?NF(t,fP(e)):t}}if(n===oW.SUM_BY_NONZERO_WEIGHTS){if(null==a)return NF(yP(s),fP(r.size));{let e=TF(a,pL(r.shape)),t=wF(yP(wL(e,fP(0))),"float32");return NF(yP(s),t)}}throw Error(`Unknown reduction: ${n}`)}});var cW=XD({absoluteDifference_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:oW.SUM_BY_NONZERO_WEIGHTS,a=HD(e,"labels","absoluteDifference"),s=HD(t,"predictions","absoluteDifference"),i=null;null!=n&&(i=HD(n,"weights","absoluteDifference")),rE(a.shape,s.shape,"Error in absoluteDifference: ");let o=EF(QP(a,s));return uW(o,i,r)}});var dW=XD({cosineDistance_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:oW.SUM_BY_NONZERO_WEIGHTS,s=HD(e,"labels","cosineDistance"),i=HD(t,"predictions","cosineDistance"),o=null;null!=r&&(o=HD(r,"weights","cosineDistance")),rE(s.shape,i.shape,"Error in cosineDistance: ");let l=fP(1),u=QP(l,yP(TF(s,i),n,!0));return uW(u,o,a)}});var hW=XD({hingeLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:oW.SUM_BY_NONZERO_WEIGHTS,a=HD(e,"labels","hingeLoss"),s=HD(t,"predictions","hingeLoss"),i=null;null!=n&&(i=HD(n,"weights","hingeLoss")),rE(a.shape,s.shape,"Error in hingeLoss: ");let o=fP(1);a=QP(TF(fP(2),a),o);let l=dz(QP(o,TF(a,s)));return uW(l,i,r)}});var pW=XD({huberLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:oW.SUM_BY_NONZERO_WEIGHTS,s=HD(e,"labels","huberLoss"),i=HD(t,"predictions","huberLoss"),o=null;null!=n&&(o=HD(n,"weights","huberLoss")),rE(s.shape,i.shape,"Error in huberLoss: ");let l=fP(r),u=EF(QP(i,s)),c=mL(u,l),d=QP(u,c),h=IF(TF(fP(.5),gP(c)),TF(l,d));return uW(h,o,a)}});var fW=XD({logLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:oW.SUM_BY_NONZERO_WEIGHTS,s=HD(e,"labels","logLoss"),i=HD(t,"predictions","logLoss"),o=null;null!=n&&(o=HD(n,"weights","logLoss")),rE(s.shape,i.shape,"Error in logLoss: ");let l=fP(1),u=fP(r),c=KP(TF(s,zP(IF(i,u)))),d=TF(QP(l,s),zP(IF(QP(l,i),u))),h=QP(c,d);return uW(h,o,a)}});var mW=XD({meanSquaredError_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:oW.SUM_BY_NONZERO_WEIGHTS,a=HD(e,"labels","meanSquaredError"),s=HD(t,"predictions","meanSquaredError"),i=null;null!=n&&(i=HD(n,"weights","meanSquaredError")),rE(a.shape,s.shape,"Error in meanSquaredError: ");let o=Oz(a,s);return uW(o,i,r)}});var gW=XD({sigmoidCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:oW.SUM_BY_NONZERO_WEIGHTS,s=HD(e,"multiClassLabels","sigmoidCrossEntropy"),i=HD(t,"logits","sigmoidCrossEntropy"),o=null;if(null!=n&&(o=HD(n,"weights","sigmoidCrossEntropy")),rE(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let e=fP(r),t=fP(1),n=fP(.5);s=IF(TF(s,QP(t,e)),TF(n,e))}let l=function(e,t){let n=HD(e,"labels","sigmoidCrossEntropyWithLogits"),r=HD(t,"logits","sigmoidCrossEntropyWithLogits");rE(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=dz(r),s=TF(r,n),i=BP(wP(KP(EF(r))));return IF(QP(a,s),i)}(s,i);return uW(l,o,a)}});var yW=XD({softmaxCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:oW.SUM_BY_NONZERO_WEIGHTS,s=HD(e,"onehotLabels","softmaxCrossEntropy"),i=HD(t,"logits","softmaxCrossEntropy"),o=null;if(null!=n&&(o=HD(n,"weights","softmaxCrossEntropy")),rE(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let e=fP(r),t=fP(1),n=fP(s.shape[1]);s=IF(TF(s,QP(t,e)),NF(e,n))}let l=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return HP(((e,t,r)=>{let a=ZP(t,[n],!0),s=QP(wF(t,"float32"),a);r([e,s]);let i=KP(TF(s,e));return{value:yP(i,[n]),gradFunc:(e,t)=>{let[r,a]=t,s=iP(e.shape,[n]);return[TF(nO(e,s),QP(wF(r,"float32"),wP(a))),TF(nO(e,s),QP(wP(a),wF(r,"float32")))]}}}))(e,t)}(s,i);return uW(l,o,a)}});var bW=XD({sparseFillEmptyRows_:function(e,t,n,r){let a=HD(e,"indices","sparseFillEmptyRows","int32"),s=HD(t,"values","sparseFillEmptyRows"),i=HD(n,"denseShape","sparseFillEmptyRows","int32"),o=HD(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},u=FD.runKernel(L$,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});var vW=XD({sparseReshape_:function(e,t,n){let r=HD(e,"inputIndices","sparseReshape","int32"),a=HD(t,"inputShape","sparseReshape","int32"),s=HD(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=FD.runKernel(z$,i);return{outputIndices:o[0],outputShape:o[1]}}});var xW=XD({sparseSegmentMean_:function(e,t,n){let r=HD(e,"data","sparseSegmentMean"),a=HD(t,"indices","sparseSegmentMean","int32"),s=HD(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return FD.runKernel(B$,i)}});var wW=XD({sparseSegmentSum_:function(e,t,n){let r=HD(e,"data","sparseSegmentSum"),a=HD(t,"indices","sparseSegmentSum","int32"),s=HD(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return FD.runKernel(W$,i)}});var kW=XD({stringNGrams_:function(e,t,n,r,a,s,i,o){let l=HD(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=HD(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=FD.runKernel(q$,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}});var SW=XD({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=HD(e,"input","stringSplit","string"),a=HD(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=FD.runKernel(K$,i,s);return{indices:o[0],values:o[1],shape:o[2]}}});var IW=XD({stringToHashBucketFast_:function(e,t){let n=HD(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return FD.runKernel(X$,a,r)}});var CW=XD({staticRegexReplace_:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=HD(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return FD.runKernel(G$,{x:a},s)}}),NW={fft:$z,ifft:Rz,rfft:Fz,irfft:Dz},TW={hammingWindow:AB,hannWindow:_B,frame:$B,stft:RB},EW={flipLeftRight:MB,grayscaleToRGB:FB,resizeNearestNeighbor:tW,resizeBilinear:eW,rgbToGrayscale:OB,rotateWithOffset:PB,cropAndResize:DB,nonMaxSuppression:zB,nonMaxSuppressionAsync:XB,nonMaxSuppressionWithScore:YB,nonMaxSuppressionWithScoreAsync:QB,nonMaxSuppressionPadded:JB,nonMaxSuppressionPaddedAsync:ZB,threshold:nW,transform:rW},AW={bandPart:aW,gramSchmidt:sW,qr:lW},_W={absoluteDifference:cW,computeWeightedLoss:uW,cosineDistance:dW,hingeLoss:hW,huberLoss:pW,logLoss:fW,meanSquaredError:mW,sigmoidCrossEntropy:gW,softmaxCrossEntropy:yW},$W={sparseFillEmptyRows:bW,sparseReshape:vW,sparseSegmentMean:xW,sparseSegmentSum:wW},RW={stringNGrams:kW,stringSplit:SW,stringToHashBucketFast:IW,staticRegexReplace:CW},DW={};kT(DW,{Serializable:()=>OW,SerializationMap:()=>PW,getRegisteredName:()=>zW,registerClass:()=>LW});var MW=new Map,FW=new Map,OW=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},PW=class e{constructor(){this.classNameMap={}}static getMap(){return null==e.instance&&(e.instance=new e),e.instance}static register(t){e.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function LW(e,t,n){nE(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),nE("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),nE(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"==typeof t&&(t="Custom"),"undefined"==typeof n&&(n=e.className);let r=t+">"+n;return PW.register(e),MW.set(r,e),FW.set(e,r),e}function zW(e){return FW.has(e)?FW.get(e):e.className}var BW=class extends OW{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0,{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){let e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return cM(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return GP(e,t)}dispose(){null!=this.iterations_&&cM(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:fP(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(BW,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var WW=class extends BW{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=FD.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=FD.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:uM((()=>YO(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:uM((()=>YO(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;uM((()=>{let e=IF(TF(i,this.rho),TF(gP(s),1-this.rho)),t=TF(NF(mP(IF(o,this.epsilon)),mP(IF(i,this.epsilon))),s),n=IF(TF(o,this.rho),TF(gP(t),1-this.rho));i.assign(e),o.assign(n);let a=IF(TF(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(cM(this.accumulatedGrads.map((e=>e.variable))),cM(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){let t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},VW=class extends BW{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=FD.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:uM((()=>kO(r.shape,this.initialAccumulatorValue).variable(!1)))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[n].variable;uM((()=>{let e=IF(s,gP(a));s.assign(e);let t=IF(TF(NF(a,mP(IF(e,FD.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&cM(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},UW=class extends BW{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],uM((()=>{this.accBeta1=fP(t).variable(),this.accBeta2=fP(n).variable()})),null==r&&(this.epsilon=FD.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);uM((()=>{let n=QP(1,this.accBeta1),r=QP(1,this.accBeta2);t.forEach(((t,a)=>{let s=FD.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:uM((()=>YO(s).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:uM((()=>YO(s).variable(i)))});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,c=IF(TF(l,this.beta1),TF(o,1-this.beta1)),d=IF(TF(u,this.beta2),TF(gP(o),1-this.beta2)),h=NF(c,n),p=NF(d,r);l.assign(c),u.assign(d);let f=IF(TF(NF(h,IF(mP(p),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(TF(this.accBeta1,this.beta1)),this.accBeta2.assign(TF(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&cM(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&cM(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),uM((()=>{this.accBeta1.assign(pP(this.beta1,this.iterations_+1)),this.accBeta2.assign(pP(this.beta2,this.iterations_+1))}));let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},jW=class extends BW{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],uM((()=>{this.iteration=fP(0).variable(),this.accBeta1=fP(t).variable()})),null==r&&(this.epsilon=FD.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);uM((()=>{let n=QP(1,this.accBeta1),r=NF(-this.learningRate,IF(TF(this.iteration,this.decay),1));t.forEach(((t,a)=>{let s=FD.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:YO(s).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:YO(s).variable(i)});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,c=IF(TF(l,this.beta1),TF(o,1-this.beta1)),d=TF(u,this.beta2),h=EF(o),p=cL(d,h);l.assign(c),u.assign(p);let f=IF(TF(NF(r,n),NF(c,IF(p,this.epsilon))),s);s.assign(f)})),this.iteration.assign(IF(this.iteration,1)),this.accBeta1.assign(TF(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&cM(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&cM(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},GW=class extends BW{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let a=FD.registeredVariables[t];uM((()=>{let e=IF(TF(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=dM(fP(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},HW=class extends GW{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=fP(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=FD.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:uM((()=>YO(r).variable(!1)))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&uM((()=>{let e,t=IF(TF(this.m,a),s);e=this.useNesterov?IF(TF(this.c,IF(s,TF(t,this.m))),r):IF(TF(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&cM(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},qW=class extends BW{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=FD.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=FD.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:uM((()=>YO(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:uM((()=>YO(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:uM((()=>YO(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;uM((()=>{let e=IF(TF(i,this.decay),TF(gP(s),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,a=IF(TF(t,this.decay),TF(s,1-this.decay)),l=NF(TF(s,this.learningRate),mP(QP(e,IF(gP(a),this.epsilon)))),u=IF(TF(o,this.momentum),l);i.assign(e),t.assign(a),o.assign(u);let c=QP(r,u);r.assign(c)}else{let e=IF(TF(i,this.decay),TF(gP(s),1-this.decay)),t=IF(TF(o,this.momentum),NF(TF(s,this.learningRate),mP(IF(e,this.epsilon))));i.assign(e),o.assign(t);let n=QP(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&cM(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&cM(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&cM(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},KW=[WW,VW,UW,jW,HW,qW,GW];var XW={};kT(XW,{CompositeArrayBuffer:()=>eM,browserFiles:()=>ZW,browserHTTPRequest:()=>lV,concatenateArrayBuffers:()=>DM,copyModel:()=>gF,decodeWeights:()=>IM,decodeWeightsStream:()=>AM,encodeWeights:()=>SM,fromMemory:()=>hV,fromMemorySync:()=>pV,getLoadHandlers:()=>jM,getModelArtifactsForJSON:()=>PM,getModelArtifactsForJSONSync:()=>OM,getModelArtifactsInfoForJSON:()=>LM,getSaveHandlers:()=>UM,getWeightSpecs:()=>zM,http:()=>oV,isHTTPScheme:()=>sV,listModels:()=>fF,loadWeights:()=>nV,moveModel:()=>yF,registerLoadRouter:()=>VM,registerSaveRouter:()=>WM,removeModel:()=>mF,weightsLoaderFactory:()=>rV,withSaveHandler:()=>fV,withSaveHandlerSync:()=>mV});function YW(e){return new Promise((e=>setTimeout(e))).then(e)}var QW=class e{constructor(t){if(!GE().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),(null==t||0===t.length)&&(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=eM.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=FM(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await YW((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await YW((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:LM(e)}}}};QW.URL_SCHEME="downloads://";var JW=class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});let s=PM(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{let a=new FileReader;a.onload=e=>{let t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map((e=>MM(e.name))),r={};for(let a of e)a.paths.forEach((e=>{let a=MM(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}};function ZW(e){return new JW(e)}function eV(e,t,n,r){var a;nE(null!=(a=e)&&Array.isArray(a)&&a.length>0,(()=>"promises must be a none empty array")),function(e,t){nE(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),nE(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),nE(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((a=>(a.then((a=>{let i=n+ ++s/e.length*(r-n);return t(i),a})),a))))}async function tV(e,t){null==t&&(t={});let n=null==t.fetchFunc?GE().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await eV(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await eV(a,t.onProgress,.5,1)}async function nV(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return rV((e=>tV(e,{requestInit:r})))(e,t,n)}function rV(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0,a=t.map((()=>!1)),s={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{let l="quantization"in e?e.quantization.dtype:e.dtype,u=ZD[l]*sE(e.shape),c=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){let e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{let t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));let c=await e(u),d={},h=0;return l.forEach((e=>{let n=t[e].paths.length,r=new eM(c.slice(h,h+n));s[e].forEach((e=>{let t=IM(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(let n in t)d[n]=t[n]})),h+=n})),d}}BM.registerSaveRouter((e=>GE().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(QW.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new QW(e)}(e.slice(QW.URL_SCHEME.length)):null));var aV=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(nE("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=GE().platform.fetch,nE(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&nE(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=FM(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){let n=eM.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:LM(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(Lge){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}let n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return PM(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=zM(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;let r,a=null==t.fetchFunc?GE().platform.fetch:t.fetchFunc,s=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;s<e.length;){r||(r=(await a(e[s],t.requestInit,{isBinary:!0})).body.getReader());let{done:o,value:l}=await r.read();if(!o)return void n.enqueue(l);s++,r=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,s/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):s.push(a+e+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e);return[zM(e),await tV(t,this.loadOptions)]}};function sV(e){return null!=e.match(aV.URL_SCHEME_REGEX)}aV.URL_SCHEME_REGEX=/^https?:\/\//;var iV=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>sV(e))):sV(e),n)return oV(e,t)}return null};function oV(e,t){return new aV(e,t)}function lV(e,t){return oV(e,t)}BM.registerSaveRouter(iV),BM.registerLoadRouter(iV);var uV=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},cV=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},dV=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function hV(e,t,n,r){return new dV(pV(...arguments))}function pV(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new uV(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new uV({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new uV({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function fV(e){return new cV(e)}function mV(e){return new cV(e)}var gV={};kT(gV,{confusionMatrix:()=>yV});var yV=XD({confusionMatrix_:function(e,t,n){let r=HD(e,"labels","confusionMatrix"),a=HD(t,"predictions","confusionMatrix");nE(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),nE(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),nE(1===a.rank,(()=>`Expected the rank of predictions to be 1, but got ${a.rank}`)),nE(r.shape[0]===a.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`)),nE(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));let s=kL(wF(r,"int32"),n),i=kL(wF(a,"int32"),n),o=uB(s),l=iO(o,i);return wF(l,"int32")}}),bV={};kT(bV,{draw:()=>NV,fromPixels:()=>TV,fromPixelsAsync:()=>SV,toPixels:()=>CV});var vV,xV=!1;function wV(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=bR(uR,FD.backendName)){let n={pixels:e},r={numChannels:t};return FD.runKernel(uR,n,r)}let l,u,[c,d]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(i)l=e.getContext("2d").getImageData(0,0,c,d).data;else if(r||n)l=e.data;else if(s||a||o){if(null==vV)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");vV=new OffscreenCanvas(1,1).getContext("2d")}else vV=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});vV.canvas.width=c,vV.canvas.height=d,vV.drawImage(e,0,0,c,d),l=vV.getImageData(0,0,c,d).data}if(4===t)u=new Int32Array(l);else{let e=c*d;u=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)u[n*t+e]=l[4*n+e]}return jz(u,[d,c,t],"int32")}function kV(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function SV(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,n=null;if(GE().getBool("WRAP_TO_IMAGEBITMAP")&&kV(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(Lge){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return wV(n,t)}function IV(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function CV(e,t){let n=HD(e,"img","toPixels");if(!(e instanceof dD)){let e=n;n=wF(e,"int32"),e.dispose()}IV(n);let[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){let e=[0,0,0,255];for(let r=0;r<s;r++){let t=i[u*s+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===s?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[r]=t*o}let t=4*u;l[t+0]=Math.round(e[0]),l[t+1]=Math.round(e[1]),l[t+2]=Math.round(e[2]),l[t+3]=Math.round(e[3])}if(null!=t){xV||null!=bR(HA,FD.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),xV=!0),t.width=a,t.height=r;let e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function NV(e,t,n){let r=HD(e,"img","draw");if(!(e instanceof dD)){let e=r;r=wF(e,"int32"),e.dispose()}IV(r),function(e){let t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);let a={image:r},s={canvas:t,options:n};FD.runKernel(HA,a,s)}var TV=XD({fromPixels_:wV}),EV={};function AV(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===sE(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let d=0;d<a.length-1;++d)i*=a[d];let o=e.shape,l=a.slice();l.pop();let u=1;for(let d=s;d<n;++d)u*=o[d],l.push(o[d]);let c=[...$E(e.shape).map((e=>e/u)),1].slice(0,s);return[l,i,u,c]}kT(EV,{prepareAndValidate:()=>AV});var _V={};kT(_V,{assertParamsValid:()=>DV,computeFlatOffset:()=>HV,computeOutShape:()=>FV,getNormalizedAxes:()=>zV,isSliceContinous:()=>GV,maskToAxes:()=>MV,parseSliceParams:()=>qV,sliceInfo:()=>KV,startForAxis:()=>UV,startIndicesWithElidedDims:()=>BV,stopForAxis:()=>jV,stopIndicesWithElidedDims:()=>WV,stridesForAxis:()=>VV,stridesWithElidedDims:()=>OV});var $V=-2,RV=-1;function DV(e,t,n){let r=e.shape.length;nE(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),nE(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)nE(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function MV(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function FV(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function OV(e,t,n,r){let a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[t]=1:(a.splice(t,0,1),a.pop());return a}function PV(e,t,n){return n<=e?n:n-(t-1)}function LV(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function zV(e,t,n,r,a,s,i,o,l){let u=e.length,c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){let l=t[0],u=n+1;c=BV(i,l,u,r,e),d=WV(o,l,u,a,e),h=OV(s,l,u,e)}else for(let p=0;p<u;p++)c[p]=UV(i,r,s,e,p,l),d[p]=jV(o,a,s,e,p,l),h[p]=VV(s,p,l);return{begin:c,end:d,strides:h}}function BV(e,t,n,r,a){let s=[...a],i=LV(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let a=PV(t,n,o),i=r[a];e&1<<a&&(i=0),s[o]=i}return s}function WV(e,t,n,r,a){let s=[...a],i=LV(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let a=PV(t,n,o),i=r[a];e&1<<a&&(i=Number.MAX_SAFE_INTEGER),s[o]=i}for(let o=0;o<s.length;o++){let e=a[o];s[o]<0&&(s[o]+=e),s[o]=YT(0,s[o],a[o])}return s}function VV(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function UV(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=YT(0,i,l-1),i}function jV(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=o>0?YT(0,i,l):YT(-1,i,l-1),i}function GV(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function HV(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function qV(e,t,n){let r,a,s=e.shape.length;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{nE(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(nE(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function KV(e,t,n,r,a,s,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&1<<b&o&&d.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);let h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push($V),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(RV),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(0===h.strides[b])throw Error(`strides[${b}] must be non-zero`);let t=!!(h.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}let r=[h.beginMask&1<<b,h.endMask&1<<b],a=[h.strides[b]>0?0:-1,h.strides[b]>0?n:n-1];if(t&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[b];let s=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(t){let e=h.begin[b]<0?n+h.begin[b]:h.begin[b];if(h.begin[b]=e,h.end[b]=h.begin[b]+1,e<0||e>=n)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=XV(h.begin[b],0,h.strides[b],n,r,a),h.end[b]=XV(h.end[b],1,h.strides[b],n,r,a);let e=1===h.strides[b]&&0===h.begin[b]&&h.end[b]===n;p=p&&e,f=f&&(0===b&&1===h.strides[b]||e)}else p=p&&1===h.strides[b]&&s,f=f&&(0===b&&1===h.strides[b]||s);let i,o=!1;if(h.beginValid&&h.endValid?(i=h.end[b]-h.begin[b],o=!0):t?(i=1,o=!0):s&&n>=0&&(i=h.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!=h.strides[b]<0?0:Math.trunc(i/h.strides[b])+(i%h.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){let e=h.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===$V&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>h.finalShapeGatherIndices[t]!==$V)),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function XV(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}var YV="4.16.0",QV=class{static sgd(e){return new GW(e)}static momentum(e,t){return new HW(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new qW(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new UW(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new WW(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new jW(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new VW(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},JV=QV,ZV="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function eU(){return new Promise((e=>ZV((()=>e()))))}var tU,nU={};function rU(e,t){let n=e[0].length;e.forEach(((e,t)=>{nE(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),nE(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));let r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)nE(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function aU(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function sU(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function iU(e){let t={FIRST_DIM_SIZE:tU.FIRST_DIM_SIZE,VALUE_ROWIDS:tU.VALUE_ROWIDS,ROW_LENGTHS:tU.ROW_LENGTHS,ROW_SPLITS:tU.ROW_SPLITS,ROW_LIMITS:tU.ROW_LIMITS,ROW_STARTS:tU.ROW_STARTS},n=[];for(let r of e){if(!(r in t))break;n.push(t[r])}return n}function oU(e){return 0===e.length?0:e[0]===tU.FIRST_DIM_SIZE?e.length-1:e.length}function lU(e,t){if(null==e||null==t)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}kT(nU,{ERF_A1:()=>xU,ERF_A2:()=>wU,ERF_A3:()=>kU,ERF_A4:()=>SU,ERF_A5:()=>IU,ERF_P:()=>vU,PARALLELIZE_THRESHOLD:()=>uU,RowPartitionType:()=>tU,SELU_SCALE:()=>bU,SELU_SCALEALPHA:()=>yU,applyActivation:()=>kB,assertAndGetBroadcastShape:()=>qO,assertAxesAreInnerMostDims:()=>oP,assertParamsConsistent:()=>rU,assignToTypedArray:()=>_U,axesAreInnerMostDims:()=>rP,calculateShapes:()=>Qz,checkEinsumDimSizes:()=>zU,checkPadOnDimRoundingMode:()=>tO,combineLocations:()=>aP,combineRaggedTensorToTensorShapes:()=>sU,complexWithEvenIndex:()=>TU,complexWithOddIndex:()=>EU,computeConv2DInfo:()=>jF,computeConv3DInfo:()=>GF,computeDefaultPad:()=>HF,computeDilation2DInfo:()=>WF,computeOptimalWindowSize:()=>cU,computeOutAndReduceShapes:()=>sP,computeOutShape:()=>aU,computePool2DInfo:()=>VF,computePool3DInfo:()=>UF,convertConv2DDataFormat:()=>eO,decodeEinsumEquation:()=>PU,eitherStridesOrDilationsAreOne:()=>JF,expandShapeToKeepDim:()=>iP,exponent:()=>RU,exponents:()=>$U,fromStringArrayToUint8:()=>oj,fromUint8ToStringArray:()=>ij,getAxesPermutation:()=>lP,getBroadcastDims:()=>GO,getComplexWithIndex:()=>AU,getEinsumComputePath:()=>BU,getEinsumPermutation:()=>LU,getFusedBiasGradient:()=>wB,getFusedDyActivation:()=>xB,getImageCenter:()=>dU,getInnerMostAxes:()=>cP,getPermuted:()=>pU,getRaggedRank:()=>oU,getReductionAxes:()=>HO,getReshaped:()=>hU,getReshapedPermuted:()=>fU,getRowPartitionTypesHelper:()=>iU,getSliceBeginCoords:()=>mU,getSliceSize:()=>gU,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>jU,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>GU,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>HU,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>XU,getSparseReshapeInputOutputMismatchErrorMessage:()=>QU,getSparseReshapeInputOutputMultipleErrorMessage:()=>YU,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>qU,getSparseReshapeNegativeOutputDimErrorMessage:()=>KU,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>tj,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>JU,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>ZU,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>ej,getUndoAxesPermutation:()=>uP,isIdentityPermutation:()=>WU,log:()=>mR,mergeRealAndImagArrays:()=>CU,prepareAndValidate:()=>AV,prepareSplitSize:()=>UU,segment_util:()=>nj,shouldFuse:()=>SB,slice_util:()=>_V,splitRealAndImagArrays:()=>NU,stridesOrDilationsArePositive:()=>ZF,tupleValuesAreOne:()=>QF,upcastType:()=>kD,validateDefaultValueShape:()=>lU,validateInput:()=>Yz,validateUpdateShape:()=>Xz,warn:()=>fR}),function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(tU||(tU={}));var uU=30;function cU(e){return e<=uU?e:_E(e,Math.floor(Math.sqrt(e)))}function dU(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function hU(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function pU(e,t){let n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{let r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function fU(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function mU(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function gU(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var yU=1.7580993408473768,bU=1.0507009873554805,vU=.3275911,xU=.254829592,wU=-.284496736,kU=1.421413741,SU=-1.453152027,IU=1.061405429;function CU(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function NU(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function TU(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function EU(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function AU(e,t){return{real:e[2*t],imag:e[2*t+1]}}function _U(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function $U(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function RU(e,t,n){let r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}var DU="->",MU=/->/g,FU=",",OU="...";function PU(e,t){let n=((e=e.replace(/\s/g,"")).length-e.replace(MU,"").length)/DU.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${DU}").`);let[r,a]=e.split(DU);nE(-1===r.indexOf(OU),(()=>`The ellipsis notation ("${OU}") is not supported yet.`));let s=r.split(FU),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let d=0;d<a.length;++d){let e=a[d];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<r.length;++d){let e=r[d];-1===o.indexOf(e)&&e!==FU&&o.push(e)}let l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let e=0;e<s[d].length;++e)l[d].push(o.indexOf(s[d][e]))}let u=o.length,c=[];for(let d=a.length;d<u;++d)c.push(d);return{allDims:o,summedDims:c,idDims:l}}function LU(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function zU(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:nE(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function BU(e,t){let n=e,r=[],a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);let s=[];for(let i=0;i<n.length;++i){let e=VU(t,n[i]);for(let t of e)-1===s.indexOf(t)&&(r[i].push(t),s.push(t))}return{path:n,steps:r}}function WU(e){return e.every(((e,t)=>e===t))}function VU(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}function UU(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"==typeof t)nE(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{nE(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));let a=t.indexOf(-1);if(-1!==a){let r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}nE(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function jU(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function GU(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function HU(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function qU(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function KU(e,t){return`size ${e} must be non-negative, not ${t}`}function XU(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function YU(e,t){return`Input to reshape is a SparseTensor with ${sE(e)}\n  dense values, but the requested shape requires a multiple of ${sE(t)}. inputShape=${e} outputShape= ${t}`}function QU(e,t){return`Input to reshape is a tensor with ${sE(e)} dense values, but the requested shape has ${sE(t)}. inputShape=${e} outputShape=${t}`}function JU(){return"segment ids must be >= 0"}function ZU(){return"segment ids are not increasing"}function ej(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function tj(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var nj={};function rj(e,t){let n,r=!1;for(e<=uU?(n=e,r=!0):n=_E(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=_E(e,n+1);return n}function aj(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function sj(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let i=e.shape[n],o=[],l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<a;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function ij(e){try{return e.map((e=>KR(e)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function oj(e){return e.map((e=>qR(e)))}kT(nj,{collectGatherOpShapeInfo:()=>sj,computeOutShape:()=>aj,segOpComputeOptimalWindowSize:()=>rj});var lj={};kT(lj,{nonMaxSuppressionV3Impl:()=>VB,nonMaxSuppressionV4Impl:()=>UB,nonMaxSuppressionV5Impl:()=>jB,whereImpl:()=>iB}),function(){for(let e of KW)LW(e)}();var uj={kernelName:YE,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,zz(wF(n,"float32"),-1))}}},cj={kernelName:QE,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=gP(wF(n,"float32")),r=mP(QP(fP(1),t));return KP(NF(e,r))}}}},dj={kernelName:JE,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=mP(QP(gP(wF(n,"float32")),1));return NF(e,t)}}}},hj={kernelName:ZE,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=qO(n.shape,r.shape);return{a:()=>{let t=e,r=HO(n.shape,a);return r.length>0&&(t=yP(t,r)),nO(t,n.shape)},b:()=>{let t=e,n=HO(r.shape,a);return n.length>0&&(t=yP(t,n)),nO(t,r.shape)}}}},pj={kernelName:eA,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},fj={kernelName:rA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>YO(n)}}},mj={kernelName:aA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>YO(n)}}},gj={kernelName:sA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>NF(e,mP(QP(fP(1),gP(wF(n,"float32")))))}}},yj={kernelName:iA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=mP(IF(fP(1),gP(wF(n,"float32"))));return NF(e,t)}}}},bj={kernelName:uA,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=qO(n.shape,r.shape);return{a:()=>{let t=IF(gP(n),gP(r)),s=TF(e,NF(r,t)),i=HO(n.shape,a);return i.length>0&&(s=yP(s,i)),nO(s,n.shape)},b:()=>{let t=IF(gP(n),gP(r)),s=KP(TF(e,NF(n,t))),i=HO(r.shape,a);return i.length>0&&(s=yP(s,i)),nO(s,r.shape)}}}},vj={kernelName:oA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>NF(e,IF(gP(wF(n,"float32")),1))}}},xj={kernelName:lA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>NF(e,QP(fP(1),gP(wF(n,"float32"))))}}};var wj=XD({avgPool3dGrad_:function(e,t,n,r,a,s){let i=HD(e,"dy","avgPool3dGrad"),o=HD(t,"input","avgPool3dGrad"),l=i,u=o,c=!1;4===o.rank&&(c=!0,l=nO(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=nO(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),nE(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),nE(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),tO("avgPool3dGrad",a,s);let d={dy:l,input:u},h={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=FD.runKernel(pA,d,h);return c?nO(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),kj={kernelName:hA,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>wj(e,r,a,s,i,o)}}};var Sj=XD({avgPoolGrad_:function(e,t,n,r,a){let s=HD(e,"dy","avgPoolGrad"),i=HD(t,"input","avgPoolGrad");nE(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=nO(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=nO(s,[1,s.shape[0],s.shape[1],s.shape[2]])),nE(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),nE(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));let c={dy:l,input:o},d={filterSize:n,strides:r,pad:a},h=FD.runKernel(dA,c,d);return u?nO(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Ij={kernelName:cA,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>Sj(e,r,a,s,i)}}},Cj={kernelName:fA,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>iO(e,a,!1,!1),b:()=>iO(e,r,!0,!1)}:s&&!i?{a:()=>iO(a,e,!1,!0),b:()=>iO(r,e,!1,!1)}:{a:()=>iO(a,e,!0,!0),b:()=>iO(e,r,!0,!0)}:{a:()=>iO(e,a,!1,!0),b:()=>iO(r,e,!0,!1)}}},Nj={kernelName:mA,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>_L(e,r,a)}}},Tj={kernelName:bA,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>yP(e,o,!0)}}},Ej={kernelName:xA,gradFunc:e=>({x:()=>e.clone()})},Aj={kernelName:wA,gradFunc:e=>({x:()=>YO(e)})},_j={kernelName:kA,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>XO(eL(AP(r,a),OP(r,s)),e,YO(e))}}},$j={kernelName:IA,inputsToSave:["x"],gradFunc:uj.gradFunc},Rj={kernelName:CA,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map((e=>e.shape)),{axis:a}=n,s=gE(a,t[0].shape)[0],i=r.map((e=>e[s]));return Mz(e,i,s).map((e=>()=>e))}},Dj={kernelName:NA,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return nE(QF(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>_O(r.shape,e,a,i,o,l),filter:()=>vB(r,e,a.shape,i,o,l)}}},Mj={kernelName:EA,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>EO(e,a,s,i,o,1,l),filter:()=>vB(e,r,a.shape,s,i,o,l)}}};var Fj=XD({conv3DBackpropFilter_:function(e,t,n,r,a){let s=e;4===e.rank&&(s=nO(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=nO(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),nE(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),nE(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),nE(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),nE(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),nE(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return FD.runKernel(_A,o,l)}}),Oj={kernelName:AA,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;nE(QF(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));let[i,o]=t;return{x:()=>DO(i.shape,e,o,a,s),filter:()=>Fj(i,e,o.shape,a,s)}}},Pj={kernelName:RA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(KP(Iz(wF(n,"float32"))),e)}}},Lj={kernelName:DA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(Cz(wF(n,"float32")),e)}}},zj={kernelName:FA,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let t=lP([a],r.rank),n=LO(e,a,s,!i);return null!=t&&(n=uB(n,t)),n}}}},Bj={kernelName:zA,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;nE(QF(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));let[l,u]=t;return nE(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),nE(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),nE(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),nE(JF(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),tO("depthwiseConv2d",s,i),{x:()=>NB(l.shape,e,u,a,s,o,i),filter:()=>CB(l,e,u.shape,a,s,o,i)}}},Wj={kernelName:UA,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>FD.runKernel(jA,s,n),filter:()=>FD.runKernel(GA,i,n)}}},Vj={kernelName:XA,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>FD.runKernel(YA,r)}}},Uj={kernelName:QA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=TF(wP(KP(gP(n))),2/Math.sqrt(Math.PI));return{x:()=>TF(e,r)}}},jj={kernelName:ZA,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,n)}}},Gj={kernelName:e_,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>nO(e,n.shape)}}},Hj={kernelName:t_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,wP(n))}}},qj={kernelName:s_,gradFunc:e=>({x:()=>YO(e)})},Kj={kernelName:i_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=qO(n.shape,r.shape);return{a:()=>{let t=NF(e,wF(r,"float32")),s=HO(n.shape,a);return s.length>0?nO(yP(t,s),n.shape):t},b:()=>{let t=TF(e,wF(n,"float32")),s=HO(r.shape,a);s.length>0&&(t=nO(yP(t,s),r.shape));let i=gP(r);return KP(NF(t,wF(i,"float32")))}}}},Xj={kernelName:o_,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?fP(1):o,u=HO(s.shape,a.shape),c=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)c.push(a.shape[e]);c.push(1)}let d=QP(a,s),h=TF(e,l),p=vz(IF(i,fP(r))),f=TF(TF(TF(p,p),p),fP(-.5));return{x:()=>1===s.rank?nO(TF(TF(e,IP(nO(p,[1,1,1,s.shape[0]]),c)),l),a.shape):nO(TF(TF(e,p),l),a.shape),mean:()=>{let e=TF(TF(p,fP(-1)),h);return 1===s.rank&&(e=yP(e,u)),nO(e,s.shape)},variance:()=>{let e=TF(TF(f,d),h);return 1===s.rank&&(e=yP(e,u)),nO(e,s.shape)},scale:()=>{let t=TF(d,p),n=TF(e,t);return 1===s.rank&&(n=yP(n,u)),nO(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=yP(t,u)),nO(t,s.shape)}}}},Yj={kernelName:l_,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s,batchDims:i}=n,o=gE(s,r.shape)[0],l=(e,t,n)=>()=>{let r=e.shape,a=t.size,i=r.slice(0,o),l=i.length,u=r.slice(s,r.length).slice(1),c=u.length,d=Qj(0,l),h=Qj(l+1,l+1+c),p=Jj([i,[a],u]),f=nO(n,p),m=nO(t,[a]),g=Jj([[l],d,h]),y=uB(f,g),b=nB(y,m,e.shape[o]),v=uP(g);return b=uB(b,v),b};if(1===i){let t=r.shape[0],n=r.split(t,0);return{x:()=>Lz(n.map(((t,n)=>l(t,a.slice(n,1),e.slice(n,1))()))).reshape(r.shape),indices:()=>a}}return{x:l(r,a,e),indices:()=>a}}};function Qj(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Jj(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var Zj={kernelName:d_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>YO(n),b:()=>YO(r)}}},eG={kernelName:h_,gradFunc:e=>({x:()=>wF(e,"float32")})},tG={kernelName:m_,gradFunc:e=>({x:()=>YO(e)})},nG={kernelName:g_,gradFunc:e=>({x:()=>YO(e)})},rG={kernelName:y_,gradFunc:e=>({x:()=>YO(e)})},aG={kernelName:b_,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=EP(r,0);return{x:()=>XO(s,e,TF(e,a))}}},sG={kernelName:S_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>NF(e,IF(n,1))}}},iG={kernelName:k_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>NF(e,wF(n,"float32"))}}},oG={kernelName:E_,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let t=wP(r);return QP(e,TF(yP(e,a,!0),t))}}}};var lG=XD({localResponseNormalizationBackprop_:function(e,t,n){let r={x:e,y:t,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return FD.runKernel($_,r,a)}}),uG={kernelName:__,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>lG(r,a,e,s,i,o,l)}}};function cG(e,t,n,r){return t.rank<n.rank&&(t=nO(t,iP(t.shape,r))),e.rank<n.rank&&(e=nO(e,iP(e.shape,r))),{x:()=>TF(e,wF(KO(n,t),e.dtype))}}var dG={kernelName:D_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=cG(e,t[1],s,gE(a,s.shape));return{x:()=>i.x()}}},hG={kernelName:M_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>TF(e,wF(AP(n,r),"float32")),b:()=>TF(e,wF(FP(n,r),"float32"))}}};var pG=XD({maxPool3dGrad_:function(e,t,n,r,a,s,i){let o=HD(e,"dy","maxPool3dGrad"),l=HD(t,"input","maxPool3dGrad"),u=HD(n,"output","maxPool3dGrad"),c=o,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=nO(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=nO(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=nO(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),nE(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),nE(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),nE(5===h.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),tO("maxPool3dGrad",s,i);let f={dy:c,input:d,output:h},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=FD.runKernel(L_,f,m);return p?nO(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),fG={kernelName:P_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>pG(e,r,a,s,i,o,l)}}};var mG=XD({maxPoolGrad_:function(e,t,n,r,a,s,i){let o=HD(e,"dy","maxPoolGrad"),l=HD(t,"input","maxPoolGrad"),u=HD(n,"output","maxPoolGrad");nE(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),nE(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),nE(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),tO("maxPoolGrad",s,i);let c={dy:o,input:l,output:u},d={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return FD.runKernel(O_,c,d)}}),gG={kernelName:F_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>mG(e,r,a,s,i,o)}}},yG={kernelName:B_,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=gE(a,r.shape),i=sE(sP(r.shape,s)[1]);return{x:()=>{let t=r.shape.slice();s.forEach((e=>{t[e]=1}));let n=nO(e,t);return NF(TF(n,pL(r.shape,"float32")),i)}}}},bG={kernelName:W_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=cG(e,i,s,gE(a,s.shape));return{x:()=>o.x()}}},vG={kernelName:V_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>TF(e,wF(OP(n,r),"float32")),b:()=>TF(e,wF(EP(n,r),"float32"))}}},xG={kernelName:U_,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>lO(e,s,r.shape)}}},wG={kernelName:j_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=qO(n.shape,r.shape);return{a:()=>{let t=HO(n.shape,a);return t.length>0?nO(yP(e,t),n.shape):e},b:()=>{let t=TF(e,KP(NP(NF(n,r)))),s=HO(r.shape,a);return s.length>0?nO(yP(t,s),r.shape):t}}}},kG={kernelName:H_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=qO(n.shape,r.shape);return{a:()=>{let t=TF(e,wF(r,"float32")),s=HO(n.shape,a);return s.length>0?nO(yP(t,s),n.shape):t},b:()=>{let t=TF(e,wF(n,"float32")),s=HO(r.shape,a);return s.length>0?nO(yP(t,s),r.shape):t}}}},SG={kernelName:q_,gradFunc:e=>({x:()=>KP(e)})},IG={kernelName:Z_,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>hL(n.shape,"float32")}}},CG={kernelName:J_,gradFunc:e=>({x:()=>YO(e)})},NG={kernelName:e$,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return rB(e,r).map((e=>()=>e))}},TG={kernelName:t$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>lO(e,s,r.shape)}}},EG={kernelName:r$,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=qO(s.shape,i.shape);return{a:()=>{let t=wF(i,"float32"),n=TF(e,TF(t,pP(s,QP(t,fP(1))))),r=HO(s.shape,o);return r.length>0&&(n=yP(n,r)),nO(n,s.shape)},b:()=>{let t=EP(s,0),n=XO(t,zP(s),YO(s)),r=TF(e,TF(a,n)),l=HO(i.shape,o);return l.length>0&&(r=yP(r,l)),nO(r,i.shape)}}}},AG={kernelName:a$,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=EP(n,0);return{x:()=>XO(a,e,TF(e,r)),alpha:()=>{let t=XO(a,YO(e),TF(e,n)),s=HO(r.shape,e.shape);return s.length>0&&(t=yP(t,s)),nO(t,r.shape)}}}};function _G(e,t,n){let r=e.shape.length,a=r-n.length,s=nU.getAxesPermutation(n,r),i=e;null!=s&&(i=uB(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){let r=e.shape.slice();r[n]=1;let a=nO(t,r),s=PO(e,n,!0,!1),i=PO(e,n,!0,!0),o=TF(s,i);return TF(a,o)}(i.reshape(o),t,a);if(u=u.reshape(i.shape),null!=s){let e=nU.getUndoAxesPermutation(s);u=uB(u,e)}return u}var $G={kernelName:s$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return s=null==a?r.shape.map(((e,t)=>t)):"number"==typeof a?[a]:a,{x:()=>_G(r,e,s)}}},RG={kernelName:qA,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=qO(n.shape,r.shape);return{a:()=>{let t=NF(e,wF(r,"float32")),s=HO(n.shape,a);return s.length>0?nO(yP(t,s),n.shape):t},b:()=>{let t=TF(e,wF(n,"float32")),s=HO(r.shape,a);s.length>0&&(t=nO(yP(t,s),r.shape));let i=gP(r);return KP(NF(t,wF(i,"float32")))}}}},DG={kernelName:d$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>NF(e,KP(gP(n)))}}},MG={kernelName:b$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=TF(OP(n,6),zz(n));return{x:()=>TF(e,wF(r,"float32"))}}},FG={kernelName:h$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,wF(zz(n),"float32"))}}},OG={kernelName:p$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>nO(e,n.shape)}}},PG={kernelName:g$,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>FD.runKernel(y$,a,n)}}},LG={kernelName:f$,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>FD.runKernel(m$,a,n)}}},zG={kernelName:v$,gradFunc:(e,t,n)=>{let{dims:r}=n,a=gE(r,e.shape);return{x:()=>pz(e,a)}}},BG={kernelName:x$,gradFunc:e=>({x:()=>YO(e)})},WG={kernelName:w$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>KP(NF(e,TF(pP(n,1.5),2)))}}},VG={kernelName:C$,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>wF(YO(n),"float32"),t:()=>TF(e,wF(n,e.dtype)),e:()=>TF(e,wF(tL(n),e.dtype))}}},UG={kernelName:N$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=EP(n,fP(0)),r=fP(yU),a=fP(bU),s=TF(e,a),i=TF(TF(e,r),wP(wF(n,"float32")));return XO(t,s,i)}}}},jG={kernelName:$$,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,TF(n,QP(fP(1),n)))}}},GG={kernelName:_$,gradFunc:e=>({x:()=>YO(e)})},HG={kernelName:E$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(FO(wF(n,"float32")),e)}}},qG={kernelName:A$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(OO(wF(n,"float32")),e)}}},KG={kernelName:T$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=qV(r,a,s),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>CL(e,u)}}},XG={kernelName:P$,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=TF(e,r);return{logits:()=>QP(s,TF(yP(s,[a],true),r))}}},YG={kernelName:R$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,oO(n))}}},QG={kernelName:F$,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>dO(e,r,a)}}},JG={kernelName:O$,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>sO(e,r)}}},ZG={kernelName:D$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>NF(e,TF(mP(wF(n,"float32")),2))}}},eH={kernelName:j$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,TF(wF(n,"float32"),2))}}},tH={kernelName:U$,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=fP(2);return{a:()=>TF(e,TF(a,QP(n,r))),b:()=>TF(e,TF(a,QP(r,n)))}}},nH={kernelName:lR,gradFunc:e=>({x:()=>YO(e)})},rH={kernelName:Y$,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=qO(n.shape,r.shape);return{a:()=>{let t=e,r=HO(n.shape,a);return r.length>0&&(t=yP(t,r)),nO(t,n.shape)},b:()=>{let t=e,n=HO(r.shape,a);return n.length>0&&(t=yP(t,n)),nO(KP(t),r.shape)}}}},aH={kernelName:M$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;gE(s,r.shape).forEach((e=>{a[e]=1}));let i=nO(e,a),o=TF(i,pL(r.shape,"float32"));return{x:()=>o}}},sH={kernelName:Q$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>NF(e,gP(FO(n)))}}},iH={kernelName:J$,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(QP(fP(1),gP(n)),e)}}},oH={kernelName:Z$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let t=YO(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=IF(t,lO(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=IF(t,lO(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=IF(t,lO(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=IF(t,lO(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},lH={kernelName:nR,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=uP(a);return{x:()=>uB(e,s)}}},uH={kernelName:aR,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>Lz(e,a)}}},cH={kernelName:sR,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>function(e,t){let n=cL(t,YO(t)),r=TP(e,n),a=AP(t,fP(0,"int32")),s=r.rank-a.rank;for(let o=0;o<s;++o)a=kP(a,o+1);a=eL(a,pL(r.shape,"bool"));let i=YO(r);return XO(a,r,i)}(e,n)}}};var dH={kernelName:oR,gradFunc:e=>({x:()=>YO(e)})},hH=[uj,cj,dj,hj,pj,fj,mj,gj,yj,bj,vj,xj,kj,Ij,Cj,Nj,Tj,Ej,Aj,_j,$j,Rj,Mj,Dj,Oj,Pj,Lj,zj,Bj,Wj,RG,Vj,Uj,jj,Gj,Hj,Kj,qj,Xj,Yj,Zj,eG,tG,nG,rG,aG,sG,iG,oG,uG,dG,dG,hG,fG,gG,yG,bG,vG,xG,wG,kG,SG,IG,CG,NG,TG,TG,EG,AG,$G,DG,MG,FG,OG,PG,LG,zG,BG,WG,VG,UG,jG,GG,HG,qG,KG,XG,YG,QG,QG,JG,JG,ZG,tH,eH,nH,rH,aH,sH,iH,oH,lH,uH,cH,dH];for(let n of hH)kR(n);hD().prototype.abs=function(){return this.throwIfDisposed(),EF(this)},hD().prototype.acos=function(){return this.throwIfDisposed(),AF(this)},hD().prototype.acosh=function(){return this.throwIfDisposed(),_F(this)},hD().prototype.add=function(e){return this.throwIfDisposed(),IF(this,e)},hD().prototype.all=function(e,t){return this.throwIfDisposed(),RF(this,e,t)},hD().prototype.any=function(e,t){return this.throwIfDisposed(),DF(this,e,t)},hD().prototype.argMax=function(e){return this.throwIfDisposed(),MF(this,e)},hD().prototype.argMin=function(e){return this.throwIfDisposed(),FF(this,e)},hD().prototype.asScalar=function(){return this.throwIfDisposed(),nE(1===this.size,(()=>"The array must have only 1 element.")),nO(this,[])},hD().prototype.asType=function(e){return this.throwIfDisposed(),wF(this,e)},hD().prototype.as1D=function(){return this.throwIfDisposed(),nO(this,[this.size])},hD().prototype.as2D=function(e,t){return this.throwIfDisposed(),nO(this,[e,t])},hD().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),nO(this,[e,t,n])},hD().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),nO(this,[e,t,n,r])},hD().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),nO(this,[e,t,n,r,a])},hD().prototype.asin=function(){return this.throwIfDisposed(),OF(this)},hD().prototype.asinh=function(){return this.throwIfDisposed(),PF(this)},hD().prototype.atan=function(){return this.throwIfDisposed(),LF(this)},hD().prototype.atan2=function(e){return this.throwIfDisposed(),zF(this,e)},hD().prototype.atanh=function(){return this.throwIfDisposed(),BF(this)},hD().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),rO(this,e,t,n,r)},hD().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),dO(this,e,t)},hD().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),pO(this,e,t,n,r,a)},hD().prototype.broadcastTo=function(e){return this.throwIfDisposed(),xO(this,e)},hD().prototype.cast=function(e){return this.throwIfDisposed(),wF(this,e)},hD().prototype.ceil=function(){return this.throwIfDisposed(),wO(this)},hD().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),SO(this,e,t)},hD().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof dD&&(e=[e]),sO([this,...e],t)},hD().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),AO(this,e,t,n,r,a,s)},hD().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),$O(this,e,t,n,r,a)},hD().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),EO(this,e,t,n,r,a,s)},hD().prototype.cos=function(){return this.throwIfDisposed(),FO(this)},hD().prototype.cosh=function(){return this.throwIfDisposed(),OO(this)},hD().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),PO(this,e,t,n)},hD().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),LO(this,e,t,n)},hD().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),BO(this,e,t)},hD().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),WO(this,e,t,n,r,a,s)},hD().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),UO(this,e,t,n,r,a)},hD().prototype.divNoNan=function(e){return this.throwIfDisposed(),QO(this,e)},hD().prototype.div=function(e){return this.throwIfDisposed(),NF(this,e)},hD().prototype.dot=function(e){return this.throwIfDisposed(),JO(this,e)},hD().prototype.elu=function(){return this.throwIfDisposed(),eP(this)},hD().prototype.equal=function(e){return this.throwIfDisposed(),KO(this,e)},hD().prototype.erf=function(){return this.throwIfDisposed(),nP(this)},hD().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),xP(this,e,t)},hD().prototype.exp=function(){return this.throwIfDisposed(),wP(this)},hD().prototype.expandDims=function(e){return this.throwIfDisposed(),kP(this,e)},hD().prototype.expm1=function(){return this.throwIfDisposed(),SP(this)},hD().prototype.fft=function(){return this.throwIfDisposed(),$z(this)},hD().prototype.flatten=function(){return this.throwIfDisposed(),nO(this,[this.size])},hD().prototype.floor=function(){return this.throwIfDisposed(),NP(this)},hD().prototype.floorDiv=function(e){return this.throwIfDisposed(),CF(this,e)},hD().prototype.gather=function(e,t,n){return this.throwIfDisposed(),TP(this,e,t,n)},hD().prototype.greaterEqual=function(e){return this.throwIfDisposed(),AP(this,e)},hD().prototype.greater=function(e){return this.throwIfDisposed(),EP(this,e)},hD().prototype.ifft=function(){return this.throwIfDisposed(),Rz(this)},hD().prototype.irfft=function(){return this.throwIfDisposed(),Dz(this)},hD().prototype.isFinite=function(){return this.throwIfDisposed(),$P(this)},hD().prototype.isInf=function(){return this.throwIfDisposed(),RP(this)},hD().prototype.isNaN=function(){return this.throwIfDisposed(),DP(this)},hD().prototype.leakyRelu=function(e){return this.throwIfDisposed(),MP(this,e)},hD().prototype.lessEqual=function(e){return this.throwIfDisposed(),OP(this,e)},hD().prototype.less=function(e){return this.throwIfDisposed(),FP(this,e)},hD().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),LP(this,e,t,n,r)},hD().prototype.logSigmoid=function(){return this.throwIfDisposed(),YP(this)},hD().prototype.logSoftmax=function(e){return this.throwIfDisposed(),JP(this,e)},hD().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),ZP(this,e,t)},hD().prototype.log=function(){return this.throwIfDisposed(),zP(this)},hD().prototype.log1p=function(){return this.throwIfDisposed(),BP(this)},hD().prototype.logicalAnd=function(e){return this.throwIfDisposed(),eL(this,e)},hD().prototype.logicalNot=function(){return this.throwIfDisposed(),tL(this)},hD().prototype.logicalOr=function(e){return this.throwIfDisposed(),nL(this,e)},hD().prototype.logicalXor=function(e){return this.throwIfDisposed(),rL(this,e)},hD().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),iO(this,e,t,n)},hD().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),oL(this,e,t,n,r)},hD().prototype.max=function(e,t){return this.throwIfDisposed(),dP(this,e,t)},hD().prototype.maximum=function(e){return this.throwIfDisposed(),cL(this,e)},hD().prototype.mean=function(e,t){return this.throwIfDisposed(),dL(this,e,t)},hD().prototype.min=function(e,t){return this.throwIfDisposed(),hP(this,e,t)},hD().prototype.minimum=function(e){return this.throwIfDisposed(),mL(this,e)},hD().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),gL(this,e,t)},hD().prototype.mod=function(e){return this.throwIfDisposed(),yL(this,e)},hD().prototype.mul=function(e){return this.throwIfDisposed(),TF(this,e)},hD().prototype.neg=function(){return this.throwIfDisposed(),KP(this)},hD().prototype.norm=function(e,t,n){return this.throwIfDisposed(),vP(this,e,t,n)},hD().prototype.notEqual=function(e){return this.throwIfDisposed(),wL(this,e)},hD().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),kL(this,e,t,n)},hD().prototype.onesLike=function(){return this.throwIfDisposed(),SL(this)},hD().prototype.pad=function(e,t){return this.throwIfDisposed(),CL(this,e,t)},hD().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),$L(this,e,t,n,r,a,s)},hD().prototype.pow=function(e){return this.throwIfDisposed(),pP(this,e)},hD().prototype.prelu=function(e){return this.throwIfDisposed(),RL(this,e)},hD().prototype.prod=function(e,t){return this.throwIfDisposed(),DL(this,e,t)},hD().prototype.reciprocal=function(){return this.throwIfDisposed(),cz(this)},hD().prototype.relu=function(){return this.throwIfDisposed(),dz(this)},hD().prototype.relu6=function(){return this.throwIfDisposed(),hz(this)},hD().prototype.reshapeAs=function(e){return this.throwIfDisposed(),nO(this,e.shape)},hD().prototype.reshape=function(e){return this.throwIfDisposed(),nO(this,e)},hD().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),eW(this,e,t,n)},hD().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),tW(this,e,t,n)},hD().prototype.reverse=function(e){return this.throwIfDisposed(),pz(this,e)},hD().prototype.rfft=function(){return this.throwIfDisposed(),Fz(this)},hD().prototype.round=function(){return this.throwIfDisposed(),bz(this)},hD().prototype.rsqrt=function(){return this.throwIfDisposed(),vz(this)},hD().prototype.selu=function(){return this.throwIfDisposed(),xz(this)},hD().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),wz(this,e,t,n,r,a,s)},hD().prototype.sigmoid=function(){return this.throwIfDisposed(),oO(this)},hD().prototype.sign=function(){return this.throwIfDisposed(),Sz(this)},hD().prototype.sin=function(){return this.throwIfDisposed(),Iz(this)},hD().prototype.sinh=function(){return this.throwIfDisposed(),Cz(this)},hD().prototype.slice=function(e,t){return this.throwIfDisposed(),lO(this,e,t)},hD().prototype.softmax=function(e){return this.throwIfDisposed(),_z(this,e)},hD().prototype.softplus=function(){return this.throwIfDisposed(),XP(this)},hD().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),_L(this,e,t)},hD().prototype.split=function(e,t){return this.throwIfDisposed(),Mz(this,e,t)},hD().prototype.sqrt=function(){return this.throwIfDisposed(),mP(this)},hD().prototype.square=function(){return this.throwIfDisposed(),gP(this)},hD().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Oz(this,e)},hD().prototype.squeeze=function(e){return this.throwIfDisposed(),Pz(this,e)},hD().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof dD?[this,e]:[this,...e];return Lz(n,t)},hD().prototype.step=function(e){return this.throwIfDisposed(),zz(this,e)},hD().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),Bz(this,e,t,n,r,a,s,i,o)},hD().prototype.sub=function(e){return this.throwIfDisposed(),QP(this,e)},hD().prototype.sum=function(e,t){return this.throwIfDisposed(),yP(this,e,t)},hD().prototype.tan=function(){return this.throwIfDisposed(),Wz(this)},hD().prototype.tanh=function(){return this.throwIfDisposed(),uO(this)},hD().prototype.tile=function(e){return this.throwIfDisposed(),IP(this,e)},hD().prototype.toBool=function(){return this.throwIfDisposed(),wF(this,"bool")},hD().prototype.toFloat=function(){return this.throwIfDisposed(),wF(this,"float32")},hD().prototype.toInt=function(){return this.throwIfDisposed(),wF(this,"int32")},hD().prototype.topk=function(e,t){return this.throwIfDisposed(),Zz(this,e,t)},hD().prototype.transpose=function(e){return this.throwIfDisposed(),uB(this,e)},hD().prototype.unique=function(e){return this.throwIfDisposed(),tB(this,e)},hD().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),nB(this,e,t)},hD().prototype.unstack=function(e){return this.throwIfDisposed(),rB(this,e)},hD().prototype.where=function(e,t){return this.throwIfDisposed(),XO(e,this,t)},hD().prototype.zerosLike=function(){return this.throwIfDisposed(),YO(this)};var pH=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},fH=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},mH=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},gH=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},yH=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},bH=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}};function vH(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{let n=new Array(t);return n.fill(e),n}}function xH(e,t){if(!e)throw new yH(t)}function wH(e,t){let n=0;for(let r of e)r===t&&n++;return n}function kH(e){return 1===e.length?e[0]:e}function SH(e){return Array.isArray(e)?e:[e]}function IH(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function CH(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}var NH={};function TH(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function EH(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>EH(e)));else{let t=Object.keys(e);for(let n of t){let t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?EH(t):e[n]=t.value)}}}function AH(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"==typeof e){let a,s=e;if(s in n)a=n[s];else if(s in NH)a=NH[s];else if(a=t[s],null==a)throw new mH(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{let s=e;if(null==s.className||null==s.config)throw new mH(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);let i,o,l=s.className;if(l in n?[i,o]=n[l]:l in NH?[i,o]=NH.className:l in t&&([i,o]=t[l]),null==i)throw new mH(`Unknown ${r}: ${l}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=o){let e={};for(let n of Object.keys(NH))e[n]=NH[n];for(let a of Object.keys(n))e[a]=n[a];s.config.customObjects=e;let t=Object.assign({},NH);for(let a of Object.keys(n))NH[a]=n[a];EH(s.config);let r=o(i,s.config,n,a);return NH=Object.assign({},t),r}{let e=Object.assign({},NH);for(let r of Object.keys(n))NH[r]=n[r];let t=new i(s.config);return NH=Object.assign({},e),t}}}function _H(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function $H(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function RH(e){if(null==e)throw new mH(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function DH(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new mH(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function MH(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return xH(n>=0),xH(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function FH(e,t){Array.isArray(e)?(TR.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>FH(e,`element ${n+1} of ${t}`)))):TR.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${OH(e)}.`))}function OH(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>OH(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function PH(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var LH=0;function zH(){return LH++}var BH={};function WH(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in BH||(BH[e]=0),BH[e]+=1,e+BH[e].toString()}var VH=["channelsFirst","channelsLast"],UH=["nearest","bilinear"],jH=["valid","same","causal"],GH=["max","avg"],HH=["sum","mul","concat","ave"],qH=new Map;function KH(e){DH(VH,"DataFormat",e)}function XH(e){DH(jH,"PaddingMode",e)}function YH(e){DH(GH,"PoolMode",e)}var QH=[],JH="/";function ZH(e,t){QH.push(e);try{let e=t();return QH.pop(),e}catch(Pye){throw QH.pop(),Pye}}function eq(e){if(!aq(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===QH.length?"":QH.join(JH)+JH)+e}function tq(e){if(!aq(e))throw new Error("Not a valid tensor name: '"+e+"'");qH.has(e)||qH.set(e,0);let t=qH.get(e);if(qH.set(e,qH.get(e)+1),t>0){let n=`${e}_${t}`;return qH.set(n,1),n}return e}var nq,rq=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function aq(e){return!!e.match(rq)}function sq(e){return e===parseInt(e.toString(),10)}function iq(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function oq(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function lq(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function uq(e,t){if(t<e)throw new mH(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function cq(){return null==nq&&(nq=xM().epsilon()),nq}function dq(e,t){return wF(e,t)}function hq(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),nO(e,n)}function pq(e,t,n){return uM((()=>{switch(e.rank){case 1:return Nz(e,t,n);case 2:return Tz(e,[t,0],[n,e.shape[1]]);case 3:return Ez(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Az(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return lO(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return lO(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new mH(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function fq(e,t,n){return uM((()=>{switch(e.rank){case 1:return Nz(e,t,n);case 2:return Tz(e,[0,t],[e.shape[0],n]);case 3:return Ez(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Az(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new mH(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function mq(e,t,n,r){return uM((()=>{switch(e.rank){case 1:return Nz(e,t,n);case 2:switch(r){case 1:return pq(e,t,n);case 2:return fq(e,t,n);default:throw new mH(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return pq(e,t,n);case 2:return Ez(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return fq(e,t,n);default:throw new mH(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return pq(e,t,n);case 2:return Az(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Az(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return fq(e,t,n);default:throw new mH(`The axis is not within the rank of the tensor ${r}`)}default:throw new mH(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function gq(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),sO(e,n)}function yq(e,t){switch(e.rank){case 1:return IO([e,t]);case 2:return CO([e,t],0);case 3:return NO([e,t],0);case 4:return TO([e,t],0);default:throw new mH(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function bq(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new mH(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return IP(e,t)}function vq(e){return az(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function xq(e,t,n,r){if(e.rank<2||t.rank<2)throw new gH(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new gH(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank)return bB.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Sq(e.rank,r,"channelsLast"):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=nO(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=nO(uB(t,c),[l,-1]);let d=[...a,...u];return nO(bB.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Sq(e.rank,r,"channelsLast"):null,activation:n}),d)}}function wq(e,t,n){return uM((()=>(t=Array.isArray(t)?Vz(t,"int32"):wF(t,"int32"),TP(e,t,n))))}function kq(e){return TF(e,e)}function Sq(e,t,n){let r=t.shape;if(1!==t.rank&&t.rank!==e)throw new mH(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?nO(t,[1,r[0],1,1,1]):nO(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?nO(t,[1,1,1,1,r[0]]):nO(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?nO(t,[1,r[0],1,1]):nO(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?nO(t,[1,1,1,r[0]]):nO(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?nO(t,[1,r[0],1]):nO(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?nO(t,[1,1,r[0]]):nO(t,[1].concat(r))}else if(e<3)return t;throw new mH(`Unsupported input rank by biasAdd: ${t.rank}`)}function Iq(e,t,n){return uM((()=>(null==n&&(n="channelsLast"),KH(n),IF(e,Sq(e.rank,t,n)))))}function Cq(e,t,n,r){return uM((()=>fB(e,t,n,r)))}function Nq(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}var Tq=["fanIn","fanOut","fanAvg"],Eq=["normal","uniform","truncatedNormal"];var Aq=class extends DW.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},_q=class extends Aq{apply(e,t){return hL(e,t)}};_q.className="Zeros",DW.registerClass(_q);var $q=class extends Aq{apply(e,t){return pL(e,t)}};$q.className="Ones",DW.registerClass($q);var Rq=class extends Aq{constructor(e){if(super(),"object"!=typeof e)throw new mH(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new mH(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return uM((()=>TF(fP(this.value),pL(e,t))))}getConfig(){return{value:this.value}}};Rq.className="Constant",DW.registerClass(Rq);var Dq=class extends Aq{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return iz(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Dq.className="RandomUniform",DW.registerClass(Dq);var Mq=class extends Aq{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new gH(`randomNormal does not support dType ${t}.`);return vq(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Mq.className="RandomNormal",DW.registerClass(Mq);var Fq=class extends Aq{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new gH(`truncatedNormal does not support dType ${t}.`);return eB(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Fq.className="TruncatedNormal",DW.registerClass(Fq);var Oq=class extends Aq{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return uM((()=>{if(2!==e.length||e[0]!==e[1])throw new mH("Identity matrix initializer can only be used for 2D square matrices.");return TF(this.gain,CP(e[0]))}))}getConfig(){return{gain:this.gain}}};Oq.className="Identity",DW.registerClass(Oq);var Pq=class extends Aq{constructor(e){if(super(),e.scale<0)throw new mH(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function(e){DH(Tq,"FanMode",e)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function(e){DH(Eq,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){let n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(KH(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){let r=iq(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){let r=iq(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{let r=iq(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],a=n[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){let n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new gH(`${this.getClassName()} does not support dType ${t}.`);return eB(e,0,n,t,this.seed)}{let n=Math.sqrt(3*s);return iz(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Pq.className="VarianceScaling",DW.registerClass(Pq);var Lq=class extends Pq{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Pq.className}};Lq.className="GlorotUniform",DW.registerClass(Lq);var zq=class extends Pq{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Pq.className}};zq.className="GlorotNormal",DW.registerClass(zq);var Bq=class extends Pq{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Pq.className}};Bq.className="HeNormal",DW.registerClass(Bq);var Wq=class extends Pq{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Pq.className}};Wq.className="HeUniform",DW.registerClass(Wq);var Vq=class extends Pq{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Pq.className}};Vq.className="LeCunNormal",DW.registerClass(Vq);var Uq=class extends Pq{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Pq.className}};Uq.className="LeCunUniform",DW.registerClass(Uq);var jq=class extends Aq{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return uM((()=>{if(e.length<2)throw new gH("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);let n=TR.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let s=vq([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=AW.qr(s,!1),o=i[0],l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=TF(o,l.sign()),n<r&&(o=o.transpose()),TF(fP(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}};jq.className="Orthogonal",DW.registerClass(jq);var Gq={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Hq(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return AH(e,DW.SerializationMap.getMap().classNameMap,t,"initializer")}function qq(e){return TH(e)}function Kq(e){if("string"==typeof e){let t=e in Gq?Gq[e]:e;if("GlorotNormal"===t)return new zq;if("GlorotUniform"===t)return new Lq;if("HeNormal"===t)return new Bq;if("HeUniform"===t)return new Wq;if("LeCunNormal"===t)return new Vq;if("LeCunUniform"===t)return new Uq;{let e={};return e.className=t,e.config={},Hq(e)}}return e instanceof Aq?e:Hq(e)}function Xq(e){return Array.isArray(e)&&Array.isArray(e[0])}function Yq(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Qq(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new mH(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Jq(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new mH(`Expected exactly 1 Shape; got ${e.length}`)}return e}function Zq(e){let t=0;for(let n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}var eK="Variable",tK=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:eK,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=zH(),n=null==n?eK:n,this.originalName=eq(n),this.name=tq(this.originalName),this.trainable_=r,this.constraint=a,this.val=sB(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function nK(e){return e.map((e=>e.read()))}function rK(e){e.forEach((e=>{e[0].write(e[1])}))}var aK=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},sK=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=zH(),null!=s&&(this.originalName=eq(s),this.name=tq(this.originalName)),this.rank=t.length}},iK=0,oK=class{constructor(e,t){this.callArgs=t,this.id=iK++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},lK=0,uK=class extends DW.Serializable{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=lK++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let e=this.getClassName();t=IH(e)+"_"+WH(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new fH(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new mH(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return kH(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return kH(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new pH(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new pH(`Layer ${this.name} is not connected, no input to return.`);return kH(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new pH(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new pH(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return kH(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=SH(e);if(null==this.inputSpec||0===this.inputSpec.length)return;let n=SH(this.inputSpec);if(t.length!==n.length)throw new mH(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let e=t[r],a=n[r];if(null==a)continue;let s=e.rank;if(null!=a.ndim&&s!==a.ndim)throw new mH(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new mH(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new mH(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&e.dtype!==a.dtype)throw new mH(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${e.dtype}.`);if(a.axes){let t=e.shape;for(let e in a.axes){let n=Number(e),s=a.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=s&&-1===[s,null].indexOf(i))throw new mH(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){let n=a.shape[t],s=e.shape[t];if(null!=n&&null!=s&&n!==s)throw new mH(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=SH(e),r=function(e){let t=!0;for(let n of SH(e))if(!(n instanceof sK)){t=!1;break}return t}(e),a=function(e){let t=!0;for(let n of SH(e))if(n instanceof sK){t=!1;break}return t}(e);if(r===a)throw new mH("Arguments to apply() must be all SymbolicTensors or all Tensors");return ZH(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of SH(e))t.push(n.shape);this.build(kH(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);let a=SH(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=kH(s),null!=this.activityRegularizer)throw new gH("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{let n,r=function(e){e=SH(e);let t=[];for(let n of e)t.push(n.shape);return kH(t)}(e),a=this.computeOutputShape(r),s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?r[0]:r),n=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,r)=>new sK(s,n,this,SH(e),t,this.name,r))):new sK(s,a,this,SH(e),t,this.name),this.addInboundNode(e,n,null,null,r,a,t),this._refCount++,null!=this.activityRegularizer)throw new gH("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new pH(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new pH(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new fH(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Zq(this.weights)}build(e){this.built=!0}getWeights(){return nK(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){uM((()=>{let t=this.weights;if(t.length!==e.length)throw new mH(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let n=[],r=nK(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!TR.arraysEqual(s.shape,o.shape))throw new mH(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}rK(n)}))}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new mH(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():Kq("zeros"));let l=r.apply(t,n),u=new tK(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=SH(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),a=SH(t),s=SH(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=s[i]}addInboundNode(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=SH(e);t=SH(t),n=SH(n),r=SH(r),a=Yq(a),s=Yq(s);let l=[],u=[],c=[];for(let d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new oK({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function cK(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{let e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{let t=[];for(let n=0;n<e.inboundLayers.length;n++){let r=cK(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(let e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}var dK=class extends uK{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:WH("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new mH("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new mH("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new mH("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new sK(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new oK({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new mH(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function hK(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new mH("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new dK({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}dK.className="InputLayer",DW.registerClass(dK);var pK=class e{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof e)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(let e of t)this.add(e.key,e.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new mH(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,n){if(null==e.dtype||e.dtype===n.dtype)return n;try{return wF(n,e.dtype)}catch(t){throw new mH(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof sK){if(null==this.id2Value[e.id])throw new mH(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{let t=this.name2Id[e];if(null==t)throw new mH(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof sK){if(null==this.id2Value[e.id])throw new mH(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{let t=this.name2Id[e];if(null==t)throw new mH(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&cM(this.id2Mask)}},fK=new bH,mK=new bH;function gK(e,t,n,r){let a=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(let f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let c,d=o.join(",")+"|"+t.names().sort().join(","),h=fK.get(d);if(null==h){let e=function(e,t){TR.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){let a=bK(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:e,recipientMap:i}=bK(s,t);for(let t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(let t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:yK(r)}}(i,t);h=e.sorted,c=e.recipientCounts,fK.put(d,h),mK.put(d,c)}c={},a||Object.assign(c,mK.get(d));let p=new pK(t);for(let f=0;f<h.length;++f){if(null!=r){let e=oM().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}let e=h[f],s=e.sourceLayer;if(s instanceof dK)continue;let i=[],u=[],d=[],m=!1;for(let n of e.inputs){let e=p.getValue(n),r=p.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),a||(c[n.name]--,0===c[n.name]&&!t.hasKey(n)&&-1===o.indexOf(n.name)&&!e.isDisposed&&!0!==n.sourceLayer.stateful&&d.push(e))}m&&((n=n||{}).mask=u[0]);let g=SH(s.apply(i,n)),y=null;s.supportsMasking&&(y=s.computeMask(i,u));let b=vK(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);let e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}a||cM(d)}return p.disposeMasks(),s?l:l[0]}function yK(e){let t={};for(let n in e)t[n]=e[n].size;return t}function bK(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let e=s[s.length-1];if(n.has(e.name)){s.pop();continue}let t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(let t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),!n.has(t.name)&&s.push(t)}}return{sorted:r,recipientMap:a}}function vK(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}GE().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=fK&&fK.setMaxEntries(e),null!=mK&&mK.setMaxEntries(e)}));var xK={};function wK(e,t){return uM((()=>mP(yP(TF(e,e),t,!0))))}kT(xK,{maxNorm:()=>$K,minMaxNorm:()=>MK,nonNeg:()=>DK,unitNorm:()=>RK});var kK=class extends DW.Serializable{getConfig(){return{}}},SK=class extends kK{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return uM((()=>{let t=wK(e,this.axis),n=SO(t,0,this.maxValue);return TF(e,NF(n,IF(cq(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};SK.className="MaxNorm",DW.registerClass(SK);var IK=class extends kK{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return uM((()=>NF(e,IF(cq(),wK(e,this.axis)))))}getConfig(){return{axis:this.axis}}};IK.className="UnitNorm",DW.registerClass(IK);var CK=class extends kK{apply(e){return dz(e)}};CK.className="NonNeg",DW.registerClass(CK);var NK=class extends kK{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return uM((()=>{let t=wK(e,this.axis),n=IF(TF(this.rate,SO(t,this.minValue,this.maxValue)),TF(1-this.rate,t));return TF(e,NF(n,IF(cq(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};NK.className="MinMaxNorm",DW.registerClass(NK);var TK={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function EK(e){return TH(e)}function AK(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return AH(e,DW.SerializationMap.getMap().classNameMap,t,"constraint")}function _K(e){if(null==e)return null;if("string"==typeof e){return AK({className:e in TK?TK[e]:e,config:{}})}return e instanceof kK?e:AK(e)}function $K(e){return new SK(e)}function RK(e){return new IK(e)}function DK(){return new CK}function MK(e){return new NK(e)}var FK={};function OK(){return new _q}function PK(){return new $q}function LK(e){return new Rq(e)}function zK(e){return new Dq(e)}function BK(e){return new Mq(e)}function WK(e){return new Fq(e)}function VK(e){return new Oq(e)}function UK(e){return new Pq(e)}function jK(e){return new Lq(e)}function GK(e){return new zq(e)}function HK(e){return new Bq(e)}function qK(e){return new Wq(e)}function KK(e){return new Vq(e)}function XK(e){return new Uq(e)}function YK(e){return new jq(e)}kT(FK,{constant:()=>LK,glorotNormal:()=>GK,glorotUniform:()=>jK,heNormal:()=>HK,heUniform:()=>qK,identity:()=>VK,leCunNormal:()=>KK,leCunUniform:()=>XK,ones:()=>PK,orthogonal:()=>YK,randomNormal:()=>BK,randomUniform:()=>zK,truncatedNormal:()=>WK,varianceScaling:()=>UK,zeros:()=>OK});var QK,JK={};async function ZK(e){if(null==e)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if("number"!=typeof s){let e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){let a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];cM(r)}}function eX(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}kT(JK,{Layer:()=>uK,RNN:()=>hQ,RNNCell:()=>pQ,activation:()=>GJ,add:()=>eZ,alphaDropout:()=>jZ,average:()=>tZ,averagePooling1d:()=>cZ,averagePooling2d:()=>pZ,averagePooling3d:()=>gZ,avgPool1d:()=>dZ,avgPool2d:()=>fZ,avgPool3d:()=>yZ,avgPooling1d:()=>hZ,avgPooling2d:()=>mZ,avgPooling3d:()=>bZ,batchNormalization:()=>oZ,bidirectional:()=>OZ,categoryEncoding:()=>XZ,centerCrop:()=>qZ,concatenate:()=>nZ,conv1d:()=>OJ,conv2d:()=>PJ,conv2dTranspose:()=>LJ,conv3d:()=>zJ,conv3dTranspose:()=>BJ,convLstm2d:()=>RZ,convLstm2dCell:()=>DZ,cropping2D:()=>VJ,dense:()=>HJ,depthwiseConv2d:()=>jJ,dot:()=>iZ,dropout:()=>qJ,elu:()=>_J,embedding:()=>ZJ,flatten:()=>XJ,gaussianDropout:()=>UZ,gaussianNoise:()=>VZ,globalAveragePooling1d:()=>vZ,globalAveragePooling2d:()=>xZ,globalMaxPool1d:()=>LZ,globalMaxPool2d:()=>zZ,globalMaxPooling1d:()=>wZ,globalMaxPooling2d:()=>kZ,gru:()=>NZ,gruCell:()=>TZ,input:()=>pY,inputLayer:()=>AJ,layerNormalization:()=>lZ,leakyReLU:()=>RJ,lstm:()=>EZ,lstmCell:()=>AZ,masking:()=>GZ,maxPool1d:()=>BZ,maxPool2d:()=>WZ,maxPooling1d:()=>SZ,maxPooling2d:()=>IZ,maxPooling3d:()=>CZ,maximum:()=>rZ,minimum:()=>aZ,multiply:()=>sZ,permute:()=>JJ,prelu:()=>DJ,randomWidth:()=>YZ,reLU:()=>$J,repeatVector:()=>YJ,rescaling:()=>HZ,reshape:()=>QJ,resizing:()=>KZ,rnn:()=>MZ,separableConv2d:()=>WJ,simpleRNN:()=>_Z,simpleRNNCell:()=>$Z,softmax:()=>MJ,spatialDropout1d:()=>KJ,stackedRNNCells:()=>FZ,thresholdedReLU:()=>FJ,timeDistributed:()=>PZ,upSampling2d:()=>UJ,zeroPadding2d:()=>uZ}),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(QK||(QK={}));var tX=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},nX=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},rX=class extends tX{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let n=null==t.size?0:t.size;this.seen+=n;for(let r in t){let e=t[r];if("number"==typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;let a=uM((()=>IF(this.totals[r],TF(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?t[n]=this.totals[n]/this.seen:uM((()=>{let e=TF(NF(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),dM(t[n])})))}},aX=class extends tX{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(let n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let r=this.history[a];for(let s=0;s<r.length;++s)if("number"!=typeof r[s]){let i=r[s];e.push(i.data()),t.push(a),n.push(s)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},sX=class extends tX{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||eU,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");TR.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():TR.now();return function(){let s=null!=n?n():TR.now();return s-a<t||(a=s,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];null!=this.yield&&(await ZK(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await ZK(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];null!=this.epochEnd&&(await ZK(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await ZK(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];null!=this.batchEnd&&(await ZK(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):TR.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await ZK(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await ZK(e),await this.trainEnd(e))}};function iX(e,t){return null==e&&(e={}),e instanceof tX?[e]:Array.isArray(e)&&e[0]instanceof tX?e:SH(e).map((e=>new sX(e,t)))}var oX=class e{constructor(){}static registerCallbackConstructor(t,n){TR.assert(t>=0&&Number.isInteger(t),(()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`)),e.checkForDuplicate(n),null==e.constructors[t]&&(e.constructors[t]=[]),e.constructors[t].push(n)}static checkForDuplicate(t){for(let n in e.constructors)e.constructors[+n].forEach((e=>{if(e===t)throw new mH("Duplicate callback constructor.")}))}static clear(){e.constructors={}}static createCallbacks(t){let n=[];for(let r in e.constructors){let a=+r;t>=a&&n.push(...e.constructors[a])}return n.map((e=>new e))}};function lX(e,t,n,r,a,s,i,o,l){let u=new aX,c=[new rX,...oX.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);let d=new nX(c);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function uX(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return AH(e,DW.SerializationMap.getMap().classNameMap,t,"layer",n)}function cX(e,t){return uM((()=>{"float32"!==e.dtype&&(e=wF(e,"float32"));let n=yP(kq(e),t,!0),r=kO(n.shape,cq()),a=mP(cL(n,r));return NF(e,a)}))}function dX(e,t){return uM((()=>dL(kq(QP(t,e)),-1)))}function hX(e,t){return uM((()=>dL(EF(QP(t,e)),-1)))}function pX(e,t){return uM((()=>{let n=QP(e,t),r=SO(EF(e),cq(),Number.MAX_VALUE),a=EF(NF(n,r));return TF(100,dL(a,-1))}))}function fX(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return uM((()=>{if(n)t=_z(t);else{let e=yP(t,t.shape.length-1,!0);t=NF(t,e)}return t=SO(t,cq(),1-cq()),KP(yP(TF(wF(e,"float32"),zP(t)),t.shape.length-1))}))}function mX(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return uM((()=>{let r=wF(NP(function(e){let t=[iq(e.shape)];return nO(e,t)}(e)),"int32"),a=(t=SO(t,cq(),1-cq())).shape;return fX(nO(kL(r,a[a.length-1]),a),t,n)}))}function gX(e,t){return uM((()=>{let n;return n=SO(t,cq(),1-cq()),n=zP(NF(n,QP(1,n))),dL(function(e,t){if(!TR.arraysEqual(e.shape,t.shape))throw new mH(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return uM((()=>{let n=dz(t),r=KP(EF(t));return IF(QP(n,TF(t,e)),BP(wP(r)))}))}(e,n),-1)}))}function yX(e,t){return uM((()=>{let n=cX(e,-1),r=cX(t,-1),a=TF(n,r);return KP(yP(a,-1))}))}oX.constructors={};var bX={meanSquaredError:dX,meanAbsoluteError:hX,meanAbsolutePercentageError:pX,meanSquaredLogarithmicError:function(e,t){return uM((()=>{let n=SO(t,cq(),Number.MAX_VALUE),r=zP(IF(1,n)),a=SO(e,cq(),Number.MAX_VALUE),s=zP(IF(1,a));return dL(kq(QP(r,s)),-1)}))},squaredHinge:function(e,t){return uM((()=>{let n=cL(0,QP(1,TF(e,t)));return dL(kq(n),-1)}))},hinge:function(e,t){return uM((()=>{let n=cL(0,QP(1,TF(e,t)));return dL(n,-1)}))},categoricalHinge:function(e,t){return uM((()=>{let n=yP(TF(e,t),-1),r=dP(TF(QP(1,e),t),-1);return cL(0,IF(1,QP(r,n)))}))},logcosh:function(e,t){return uM((()=>{let n=Math.log(2),r=QP(t,e),a=QP(IF(r,XP(TF(-2,r))),n);return dL(a,-1)}))},categoricalCrossentropy:fX,sparseCategoricalCrossentropy:mX,binaryCrossentropy:gX,kullbackLeiblerDivergence:function(e,t){return uM((()=>{let n=SO(e,cq(),1),r=SO(t,cq(),1);return yP(TF(e,zP(NF(n,r))),-1)}))},poisson:function(e,t){return uM((()=>{let n=zP(IF(cq(),t));return dL(QP(t,TF(e,n)),-1)}))},cosineProximity:yX};function vX(e){if("string"==typeof e){if(e in bX)return bX[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new mH(t)}return e}function xX(e,t){return uM((()=>{let n=TF(.5,SL(t)),r=dq(EP(t,n),e.dtype);return dL(KO(e,r),-1)}))}function wX(e,t){return uM((()=>dq(KO(MF(e,-1),MF(t,-1)),"float32")))}function kX(e,t){return uM((()=>wF(yP(eL(KO(e,1),KO(t,1))),"float32")))}function SX(e,t){return uM((()=>{let n=kX(e,t),r=function(e,t){return uM((()=>wF(yP(eL(KO(e,0),KO(t,1))),"float32")))}(e,t),a=IF(n,r);return wF(XO(EP(a,0),NF(n,a),0),"float32")}))}function IX(e,t){return uM((()=>{let n=kX(e,t),r=function(e,t){return uM((()=>wF(yP(eL(KO(e,1),KO(t,0))),"float32")))}(e,t),a=IF(n,r);return wF(XO(EP(a,0),NF(n,a),0),"float32")}))}function CX(e,t){return gX(e,t)}function NX(e,t){return e.rank===t.rank&&(e=Pz(e,[e.rank-1])),(t=MF(t,-1)).dtype!==e.dtype&&(t=wF(t,e.dtype)),wF(KO(e,t),"float32")}var TX=fX,EX=mX,AX={binaryAccuracy:xX,categoricalAccuracy:wX,precision:SX,categoricalCrossentropy:TX,sparseCategoricalCrossentropy:EX,mse:dX,MSE:dX,mae:hX,MAE:hX,mape:pX,MAPE:pX,cosine:yX};function _X(e){if("string"==typeof e&&e in AX)return AX[e];if("string"!=typeof e&&null!=e)return e;throw new mH(`Unknown metric ${e}`)}function $X(e){if(xH(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let n of Object.keys(bX))if(bX[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(AX))if(AX[n]===e){t=n;break}return void 0!==t?t:e.name}}function RX(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!DX(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function DX(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if("string"!=typeof n||!DX(e[n]))return!1;return!0}if(Array.isArray(e)){for(let t of e)if(!DX(t))return!1;return!0}return!1}{let t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function MX(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log,s=function(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let e=!1;for(let n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),i=["Layer (type)","Input Shape","Output shape","Param #"];if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){i.push("Receives inputs"),r=[];for(let t in e.nodesByDepth)r.push(...e.nodesByDepth[t])}a("_".repeat(t)),FX(i,n,a),a("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)s?OX(o[c],n,a):PX(o[c],n,r,a),a((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=function(e){let t;return t=null!=e.collectedTrainableWeights?Zq(e.collectedTrainableWeights):Zq(e.trainableWeights),t}(e),u=Zq(e.nonTrainableWeights);a(`Total params: ${l+u}`),a(`Trainable params: ${l}`),a(`Non-trainable params: ${u}`),a("_".repeat(t))}function FX(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function OX(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(s){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(s){r="multiple"}FX([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function PX(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(c){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(c){a="multiple"}let i=[];for(let d of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(d)))for(let e=0;e<d.inboundLayers.length;++e){let t=d.inboundLayers[e].name,n=d.nodeIndices[e],r=d.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}let o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];FX([`${o} (${l})`,s,a,e.countParams().toString(),u],t,r);for(let d=1;d<i.length;++d)FX(["","","","",i[d]],t,r)}function LX(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function zX(e,t){if(null===e)return null;if("string"==typeof e)return CH(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];LX(t,a,r)?n.push(r):n.push(zX(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{let e=CH(n);t[e]=zX(r,e)}}return t}}function BX(e,t){if(null==e)return null;if("string"==typeof e)return IH(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];LX(t,a,r)?n.push(r):n.push(BX(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n],a=IH(n);t[a]="name"!==n&&"className"!==n||"string"!=typeof r?BX(r,n):r}return t}}var WX="4.16.0",VX=class e extends uK{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){let e=this.getClassName().toLowerCase();this.name=WH(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],$H(this.inputs).length!==this.inputs.length)throw new mH(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);$H(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let e of this.outputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(let e of this.inputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;xH(0===n,"input layer has >1 nodes"),xH(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let e=0;e<this.inputLayers.length;e++){let n=this.inputLayers[e];if(!(n instanceof dK))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${e} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(let e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));let n={},r={},a={},s={},i={},o=[],l=(t,n,r,a,s,u)=>{(null==a||null==s||null==u)&&(a=t.sourceLayer,s=t.nodeIndex,u=t.tensorIndex);let c=a.inboundNodes[s];if(-1!==r.indexOf(c))throw new fH(`The tensor ${t.name} at layer "${a.name}" is part of a cycle.`);if(-1!==n.indexOf(c))return;this.containerNodes.add(e.nodeKey(a,s)),a.id in i||(i[a.id]=Object.keys(i).length),-1===r.indexOf(c)&&r.push(c);let d=c.inboundLayers.length;for(let e=0;e<d;e++){let t=c.inputTensors[e],a=c.inboundLayers[e],s=c.nodeIndices[e],i=c.tensorIndices[e];l(t,n,r,a,s,i)}for(n.push(c);r.indexOf(c)>=0;)r.splice(r.indexOf(c),1);o.push(c)},u=[],c=[];for(let e of this.outputs)l(e,u,c);let d=o.slice().reverse();for(let e of d){r[e.id]=e,e.id in n||(n[e.id]=0);let t=n[e.id],i=null==a[e.outboundLayer.id]?0:a[e.outboundLayer.id];t=Math.max(t,i),a[e.outboundLayer.id]=t,s[e.outboundLayer.id]=e.outboundLayer,n[e.id]=t;for(let a=0;a<e.inboundLayers.length;a++){let s=e.inboundLayers[a],i=e.nodeIndices[a],o=s.inboundNodes[i],l=null==n[o.id]?0:n[o.id];n[o.id]=Math.max(t+1,l),r[o.id]=o}}let h={};for(let e in n){let t=n[e];t in h||(h[t]=[]),h[t].push(r[e])}let p={};for(let e in a){let t=a[e];t in p||(p[t]=[]),p[t].push(s[e])}let f=Object.keys(p).map((e=>parseInt(e,10))).sort(_H);this.layers=[];for(let b of f){let t=p[b];t.sort(((e,t)=>{let n=i[e.id],r=i[t.id];return n<r?-1:n>r?1:0}));for(let n of t)n instanceof e&&this.internalContainerRefs.push(n),this.layers.push(n)}this.layersByDepth=p,f=Object.keys(h).map((e=>parseInt(e,10))).sort(_H);let m=this.inputs.slice(),g=[];for(let e of f)for(let t of h[e]){let e=t.outboundLayer;if(null!=e){for(let n of t.inputTensors)if(-1===m.indexOf(n))throw new fH(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${g}`);for(let e of t.outputTensors)m.push(e);g.push(e.name)}}this.nodesByDepth=h;let y=this.layers.map((e=>e.name));for(let e of y){let t=y.filter((t=>t===e)).length;if(1!==t)throw new fH(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new oK({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new mH("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n={},r=0,a=(e=>{let t=Object.keys(e);if(0===t.length)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);a&&this.parseWeights(e);for(let i of this.layers)for(let[e,t]of i.weights.entries()){let s=a?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[s])throw new mH(`Duplicate weight name: ${s}`);n[s]=t,r++}let s=[];for(let i in e){let r=i;if(null==n[i]){let e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])s.push([n[r],e[i]]);else if(t)throw new mH(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new mH(`${e.length} of ${r} weights are not set: ${e}`)}rK(s)}parseWeights(e){for(let t in Object.keys(e)){let n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${WX}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=BX(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return uM((()=>{e=SH(e);let n=new pK;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return gK(this.outputs,n,t)}))}computeMask(e,t){return uM((()=>{let n;return e=SH(e),n=null==t?vH(null,e.length):SH(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){let t=Yq(e);if(t.length!==this.inputLayers.length)throw new mH(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(_H);if(r.length>1)for(let i of r){let e=this.nodesByDepth[i];for(let t of e){let e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;let r=[];for(let i=0;i<t.inboundLayers.length;i++){let e=t.inboundLayers[i],a=t.nodeIndices[i],s=t.tensorIndices[i],o=n[`${e.name}_${a}_${s}`];r.push(o)}let a=Yq(e.computeOutputShape(kH(r))),s=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++){n[`${e.name}_${s}_${t}`]=a[t]}}}let a=[],s=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;s.push(r)}for(let i=0;i<s.length;i++){let e=s[i];xH(e in n),a.push(n[e])}return kH(a)}runInternalGraph(e,t){null==t&&(t=vH(null,e.length));let n={};for(let o=0;o<this.inputs.length;++o){let r=this.inputs[o],a=e[o],s=t[o];n[r.id]=[a,s]}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(_H);for(let o of r){let e=this.nodesByDepth[o];for(let t of e){let e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,s=new Array;for(let t of r)t.id in n&&s.push(n[t.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){let[t,n]=s[0];null==u.mask&&(u.mask=n),o=SH(e.call(t,u)),l=SH(e.computeMask(t,n)),r=[t],i=[n]}else r=s.map((e=>e[0])),i=s.map((e=>e[1])),null==u.mask&&(u.mask=i),o=SH(e.call(r,u)),l=SH(e.computeMask(r,i));if(e.activityRegularizer)throw new gH("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){let t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}let a=[],s=[],i=[];for(let o of this.outputs){xH(o.id in n,`Could not compute output ${o.name} : ${o.id}`);let[e,t]=n[o.id];i.push(e.shape),a.push(e),s.push(t)}return[a,s,i]}buildNodeConversionMap(t){let n,r={};for(let a of this.layers){n=a instanceof e?1:0;for(let t=0;t<a.inboundNodes.length;t++){let s=e.nodeKey(a,t);this.containerNodes.has(s)&&(r[s]=n,n+=1)}}return r}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new mH("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(let n of this.layers)if(n.name===e)return n;throw new mH(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new mH(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return uM((()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let a=e.nodeKey(n,r);this.containerNodes.has(a)&&t.push(...n.calculateLosses())}return t}))}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let o of this.layers){let t=o.getClassName(),a=o.getConfig(),s=[];for(let r=0;r<o.inboundNodes.length;r++){let t=o.inboundNodes[r],a=e.nodeKey(o,r),l={};if(this.containerNodes.has(a)){if(t.callArgs)try{JSON.stringify(t.callArgs),l=t.callArgs}catch(i){console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${t.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),l={}}if(t.inboundLayers.length>0){let r=[];for(let a=0;a<t.inboundLayers.length;a++){let s=t.inboundLayers[a],i=t.nodeIndices[a],o=t.tensorIndices[a],u=n[e.nodeKey(s,i)];null==u&&(u=0),r.push([s.name,u,o,l])}s.push(r)}}}let l={};l.name=o.name,l.className=t,l.config=a,l.inboundNodes=s,r.push(l)}t.layers=r;let a=[];for(let o=0;o<this.inputLayers.length;o++){let t=this.inputLayers[o],r=this.inputLayersNodeIndices[o],s=e.nodeKey(t,r);if(!this.containerNodes.has(s))continue;let i=n[s];null==i&&(i=0);let l=this.inputLayersTensorIndices[o];a.push([t.name,i,l])}t.inputLayers=a;let s=[];for(let o=0;o<this.outputLayers.length;o++){let t=this.outputLayers[o],r=this.outputLayersNodeIndices[o],a=e.nodeKey(t,r);if(!this.containerNodes.has(a))continue;let i=n[a];null==i&&(i=0);let l=this.outputLayersTensorIndices[o];s.push([t.name,i,l])}return t.outputLayers=s,t}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={},a={};function s(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function i(e,t){let n,a=[];for(let i of t){let o=i[0],l=i[1],u=i[2];if(n=null==i[3]?{}:i[3],!(o in r))return void s(e,t);let c=r[o];if(c.inboundNodes.length<=l)return void s(e,t);let d=c.inboundNodes[l];a.push(d.outputTensors[u])}a.length>0&&e.apply(kH(a),n)}function o(e){let a=e.name,i=uX(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[a]=i,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new mH(`Corrupted configuration, expected array for nodeData: ${e}`);s(i,e)}))}let l=t.name,u=t.layers;for(let f of u)o(f);for(;!RH(a);)for(let e of u){let t=r[e.name];if(t.name in a){let e=a[t.name];delete a[t.name];for(let n of e)i(t,n)}}let c=[],d=[],h=t.inputLayers;for(let f of h){let e=f[0],t=f[1],n=f[2];xH(e in r);let a=r[e].inboundNodes[t].outputTensors;c.push(a[n])}let p=t.outputLayers;for(let f of p){let e=f[0],t=f[1],n=f[2];xH(e in r);let a=r[e].inboundNodes[t].outputTensors;d.push(a[n])}return new e({inputs:c,outputs:d,name:l})}get stateful(){if(this._stateful)throw new mH("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){uM((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}};function UX(e,t){return function(e,t,n){let r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function jX(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){let t=uM((()=>{if(1===e.shape.length)return kF(e);if(2===e.shape.length){if(e.shape[1]>1)return MF(e,1);if(1===e.shape[1])return nO(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());cM(t);let a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),Vz(a,"float32")}return null}function GX(e,t){return TF(e,t)}function HX(e,t){let n,r,a=t;n=a.xs,r=a.ys,TR.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));let s=qX("input",e.inputNames,n),i=qX("output",e.outputNames,r),o=s[0].shape[0];TR.assert(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),TR.assert(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<s.length;l++)TR.assert(s[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)TR.assert(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:i}}function qX(e,t,n){if(n instanceof dD)return[n];if(Array.isArray(n))return TR.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{let r=[];for(let a of t){if(null==n[a])throw new mH(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function KX(e,t,n){let r=null!=n.batchesPerEpoch;if(TR.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),TR.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),TR.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),TR.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),TR.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a,s,i=null!=n.validationData;if(i)if(XX(n.validationData))TR.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{let e=function(e){if(3===e.length)throw new gH("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,s=e.ys}let o,l=e.makeTrainFunction(),u=e.getDedupedMetricsNames();o=i?u.slice().concat(u.map((e=>"val_"+e))):u.slice();let c=iX(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=lX(c,d,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,i,o);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let o={};await h.onEpochBegin(f);let c=0,d=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){let t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){let{xs:r,ys:a}=HX(e,t.value),s={};s.batch=d,s.size=r[0].shape[0],await h.onBatchBegin(d,s);let i=[];if(null!=n.classWeight){let t=UX(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await jX(a[e],null,t[e]))}let o=r.concat(a).concat(i),p=l(o);cM(o);for(let e=0;e<u.length;++e){let t=u[e],n=p[e];s[t]=n,dM(n)}await h.onBatchEnd(d,s),eX(s),d++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(i){let t;t=XX(n.validationData)?SH(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):SH(e.evaluate(a,s,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)o[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,o),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function XX(e){return"function"==typeof e.iterator}function YX(e){TR.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function QX(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>pq(e,t,n-t))):pq(e,t,n-t)}function JX(e,t){return uM((()=>null==e?null:Array.isArray(e)?e.map((e=>JX(e,t))):wq(e,"int32"===t.dtype?t:wF(t,"int32"))))}function ZX(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function eY(e){let t=[];e instanceof dD&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(1===r.rank)t.push(hq(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function tY(e,t){if(null==e)return;let n=[];if(t instanceof dD)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(let a in t){let e=t[a];n.push(e.id)}let r=[];if(e instanceof dD)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(let a in e){let t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function nY(e){return Array.isArray(e)}function rY(e){return!function(e){return e instanceof dD}(e)&&!nY(e)}function aY(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(nY(e)&&e.length>0)t=!0;else if(rY(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new mH(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(rY(e)){r=[];for(let n of t){if(null==e[n])throw new mH(`No data provided for "${n}". Need data for each key in: ${t}`);r.push(e[n])}}else if(nY(e)){if(e.length!==t.length)throw new mH(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);r=e}else{if(t.length>1)throw new mH(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);r=[e]}if(r=eY(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=r[i];if(e.shape.length!==n[i].length)throw new mH(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!a)continue;let r=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&r!==o)throw new mH(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return r}function sY(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new mH(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);r=e}else{if(t.length>1)throw new mH(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=r[i];if(e.shape.length!==n[i].length)throw new mH(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let r=0;r<n[i].length;++r){if(0===r&&!a)continue;let o=e.shape[r],l=n[i][r];if(null!=l&&l!==o)throw new mH(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}var iY=class extends VX{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new mH("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");MX(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){let t={Adagrad:()=>JV.adagrad(.01),Adadelta:()=>JV.adadelta(1,.95,cq()),Adam:()=>JV.adam(.001,.9,.999,cq()),Adamax:()=>JV.adamax(.002,.9,.999,cq(),0),RMSProp:()=>JV.rmsprop(.001,.9,0,cq()),SGD:()=>JV.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new mH(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof BW))throw new mH("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new mH(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map((e=>vX(e)))}else{let n=vX(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(let t in e.loss)if(-1===this.outputNames.indexOf(t))throw new mH(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(vX(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ZH("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));let r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{let e=[];for(let r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};ZH("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,s;for(let i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){let t,a=this.internalOutputShapes[e];1===a[a.length-1]||this.lossFunctions[e]===gX?-1!==["accuracy","acc"].indexOf(i)?r=xX:-1!==["crossentropy","ce"].indexOf(i)&&(r=CX):this.lossFunctions[e]===mX?-1!==["accuracy","acc"].indexOf(i)?r=NX:-1!==["crossentropy","ce"].indexOf(i)&&(r=EX):-1!==["accuracy","acc"].indexOf(i)?r=wX:-1!==["crossentropy","ce"].indexOf(i)&&(r=TX),-1!==["accuracy","acc"].indexOf(i)?t="acc":-1!==["crossentropy","ce"].indexOf(i)&&(t="ce"),s=r,n=""+t}else s=_X(i),n=""+$X(i);let t;ZH(n,(()=>{t=s})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=null==n.batchSize?32:n.batchSize;YX(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let e=a[0].concat(a[1]);this.makeTestFunction();let t=this.testFunction;return kH(this.testLoop(t,e,r,n.verbose,n.steps))}finally{tY(a[0],e),tY(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){let r=null!=(n=n||{}).batches,a=e.testFunction,s=[];if(n.verbose>0)throw new gH("Verbose mode is not implemented yet.");TR.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));let i=function(e){return"function"==typeof e.next}(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let t=await i.next();if(s=uM((()=>{if(t.value){let{xs:n,ys:r}=HX(e,t.value),i=n.concat(r),u=uM((()=>a(i)));if(cM(i),0===l)for(let e=0;e<u.length;++e)s.push(fP(0));let c=i[0].shape[0];for(let e=0;e<u.length;++e){let t=u[e],n=s[e];s[e]=uM((()=>IF(s[e],TF(c,t)))),l>0&&cM(n)}cM(u),o+=c,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let e=s[u];s[u]=NF(s[u],o),cM(e)}return kH(s)}(this,e,t)}checkNumSamples(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new mH(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new mH(`Either the input data should have a defined shape, or ${a} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new mH("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new pK;if(e instanceof dD&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new mH(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(let o of this.inputs){let t=e[o.name];if(null==t)throw new mH(`No value is provided for the model's input ${o.name}`);s.add(o,t)}let i=gK(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=vH(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){let i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){let n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new mH(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return uM((()=>{let r=this.checkNumSamples(e);if(n)throw new gH("Verbose predictLoop() is not implemented yet.");let a=ZX(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t)uM((()=>{let n=a[t][0],r=a[t][1],s=QX(e,n,r),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});let o=new pK(i);return gK(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)));return kH(s.map((e=>sO(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=eY(e);sY(n,this.inputNames,this.feedInputShapes,!1);try{let e=null==t.batchSize?32:t.batchSize;return YX(e),this.predictLoop(n,e)}finally{tY(n,e)}}predictOnBatch(e){sY(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new fH("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let r=[];for(let a=0;a<this.feedOutputShapes.length;++a){let e=this.feedOutputShapes[a];this.feedLossFns[a]===mX?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){let n=$H(e.map((e=>e.shape[0])));n.sort();let r=$H(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new mH(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new mH(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!TR.arraysEqual(n,r))throw new mH(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=aY(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=aY(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){let r=[dX,gX,fX];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(null!=i){if(i===fX&&1===s.shape[s.shape.length-1])throw new mH(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){let e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){let r=e[n],a=t[n];if(null!=a&&r!==a)throw new mH(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new mH(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0,[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){let e=UX(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await jX(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return uM((()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new gH("Verbose mode is not implemented yet.");if(null!=a)throw new gH("steps mode in testLoop() is not implemented yet");{let r=ZX(s,n),a=Vz(uq(0,s));for(let n=0;n<r.length;++n){let s=r[n][0],o=r[n][1],l=pq(a,s,o-s),u=JX(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(fP(0));for(let e=0;e<c.length;++e){let t=c[e];i[e]=IF(i[e],TF(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=NF(i[e],s)}return i}))}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(wH(e,r)>1){a+=`_${wH(e.slice(0,n),r)}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{let e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});let i,o=new pK(e),l=gK(this.outputs,o,{training:!0});for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],l[n]);null!=a[n]&&(e=GX(e,a[n]));let s=dL(e);t.push(s),i=0===n?e:IF(i,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{let t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=dL(t(r[a],l[a]))}dM(e),s.push(e)}return i=dL(i),this.calculateLosses().forEach((e=>{i=IF(i,e)})),i}),!0,i)].concat(s)}}makeTestFunction(){this.testFunction=e=>uM((()=>{let t,n=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});let i=new pK(s),o=gK(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){let r=this.lossFunctions[e],s=dL(r(a[e],o[e]));t=0===e?s:IF(t,s),n.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=dL(t(a[r],o[r]));n.push(s)}return n}))}async fit(e,t){let n,r,a,s,i,o,l,u,c,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{let h=null==d.batchSize?32:d.batchSize;YX(h);let p=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,!1,h);n=p[0],r=p[1],c=p[2];let f,m=!1;if(null!=d.validationData&&d.validationData.length>0){if(m=!0,2!==d.validationData.length)throw 3===d.validationData.length?new gH("validationData including sample weights is not supported yet."):new mH(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${d.validationData} is invalid.`);i=d.validationData[0],o=d.validationData[1];let e=await this.standardizeUserData(i,o,null,null,!0,h);l=e[0],u=e[1],f=l.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){m=!0;let e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];l=QX(n,e,t),a=n,n=QX(n,0,e),u=QX(r,e,t),s=r,r=QX(r,0,e),f=l.concat(u)}else null!=d.validationSteps&&(m=!0);let g=n.concat(r).concat(c);this.checkTrainableWeightsConsistency();let y,b,v=this.makeTrainFunction(),x=this.getDedupedMetricsNames();m?(this.makeTestFunction(),y=this.testFunction,b=x.slice().concat(x.map((e=>"val_"+e)))):(y=null,f=[],b=x.slice());let w=iX(d.callbacks,d.yieldEvery);return await this.fitLoop(v,g,x,h,d.epochs,d.verbose,w,y,f,d.shuffle,b,d.initialEpoch,null,null)}finally{this.isTraining=!1,tY(n,e),tY(r,t),tY(a,e),tY(s,t),tY(l,i),tY(u,o),null!=c&&cM(c)}}async fitLoop(e,t,n,r,a,s,i,o,l,u,c,d,h,p){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==h))throw new mH("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m,g=this.checkNumSamples(t,r,h,"steps_per_epoch");null!=g&&(m=uq(0,g)),null==s&&(s=1);let{callbackList:y,history:b}=lX(i,s,a,d,g,h,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=d;v<a;++v){await y.onEpochBegin(v);let a={};if(null!=h)throw new gH("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new gH("batch shuffling is not implemneted yet");u&&TR.shuffle(m);let s=Vz(m),i=ZX(g,r);for(let u=0;u<i.length;++u){let c={};if(await y.onBatchBegin(u,c),uM((()=>{let d=i[u][0],h=i[u][1],p=pq(s,d,h-d);c.batch=u,c.size=h-d;let m=JX(t,p),g=e(m);for(let e=0;e<n.length;++e){let t=n[e],r=g[e];c[t]=r,dM(r)}if(u===i.length-1&&f){let e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){let r=n[t],s=e[t];dM(s),a["val_"+r]=s}}})),await y.onBatchEnd(u,c),eX(c),this.stopTraining_)break}s.dispose()}if(await y.onEpochEnd(v,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return KX(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let o of s){let e=await o.data();i.push(e[0])}return cM(s),tY(n[0],e),tY(n[1],t),kH(i)}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=oM().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-oM().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=IH(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>IH(e)))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=IH(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[IH($X(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>IH($X(e))));{let e={};for(let t in this.metrics)e[t]=IH($X(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");let t,n,r=uX(zX(e.optimizer_config));if("string"==typeof e.loss)t=CH(e.loss);else if(Array.isArray(e.loss))t=e.loss.map((e=>CH(e)));else if(null!=e.loss){t={};for(let n in e.loss)t[n]=CH(e.loss[n])}if(Array.isArray(e.metrics))n=e.metrics.map((e=>CH(e)));else if(null!=e.metrics){n={};for(let t in e.metrics)n[t]=CH(e.metrics[t])}this.compile({loss:t,metrics:n,optimizer:r})}async save(e,t){if("string"==typeof e){let t=XW.getSaveHandlers(e);if(0===t.length)throw new mH(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new mH(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new mH("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await XW.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${WX}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();let e="optimizer",{data:t,specs:a}=await XW.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...a),n.data=XW.concatenateArrayBuffers([n.data,t])}return null!=this.userDefinedMetadata&&(RX(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){RX(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};iY.className="Model",DW.registerClass(iY);var oY=class extends iY{};async function lY(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);let r=uX(zX(n),t);if(null!=e.weightsManifest){let t=await XW.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map((e=>e.originalName))),n={};for(let e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),cM(t)}return r}async function uY(e,t){if(null==t&&(t={}),"string"==typeof e){let n=XW.getLoadHandlers(e,t);if(0===n.length)n.push(XW.browserHTTPRequest(e,t));else if(n.length>1)throw new mH(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return async function(e,t,n){if(null==n&&(n={}),null==e.load)throw new mH("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;null!=a.model_config&&(a=a.model_config);let s=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&s,o=uX(zX(a),t,i),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new mH("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:e,optimizerWeights:t}=function(e,t){let n=XW.decodeWeights(e,t),r={},a=[];return t.forEach((e=>{"optimizer"===e.group?a.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);o.loadWeights(e,s),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),cM(e),cM(t.map((e=>e.tensor)))}return o}(e,void 0,t)}oY.className="Functional",DW.registerClass(oY);var cY=class e extends iY{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:WH("sequential_"),null!=e.layers)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new mH(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n,r=t instanceof e||t instanceof iY;if(r){if(n=t,1!==n.outputs.length)throw new mH("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new mH("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new mH("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let e=hK({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(r)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new mH(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new mH("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=cK(this.outputs[0])}this.inboundNodes=[],new oK({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:vH(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{let e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(Jq(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new iY({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new fH("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new fH("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new fH("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new fH("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(t,n){let r,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s={};if(n instanceof Array){if(null==n[0].className||"Merge"===n[0].className)throw new mH("Legacy serialization format not supported yet.");r=n}else TR.assert(null!=n.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),r=n.layers,delete n.layers,s=n;let i=new t(s);if(!(i instanceof e))throw new gH(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let e of r){let t=uX(e,void 0,a);a&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new mH("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new mH("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};function dY(e){return new iY(e)}function hY(e){return new cY(e)}function pY(e){return hK(e)}function fY(e,t){oX.registerCallbackConstructor(e,t)}cY.className="Sequential",DW.registerClass(cY);var mY=class extends DW.Serializable{getConfig(){return{}}},gY=class extends mY{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new gH(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return eP(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}};gY.className="elu",DW.registerClass(gY);var yY=class extends mY{apply(e){return xz(e)}};yY.className="selu",DW.registerClass(yY);var bY=class extends mY{apply(e){return dz(e)}};bY.className="relu",DW.registerClass(bY);var vY=class extends mY{apply(e){return uM((()=>mL(6,dz(e))))}};vY.className="relu6",DW.registerClass(vY);var xY=class extends mY{apply(e){return e}};xY.className="linear",DW.registerClass(xY);var wY=class extends mY{apply(e){return oO(e)}};wY.className="sigmoid",DW.registerClass(wY);var kY=class extends mY{apply(e){return function(e){return uM((()=>{let t=IF(.5,TF(.2,e));return SO(t,0,1)}))}(e)}};kY.className="hardSigmoid",DW.registerClass(kY);var SY=class extends mY{apply(e){return XP(e)}};SY.className="softplus",DW.registerClass(SY);var IY=class extends mY{apply(e){return function(e){return uM((()=>NF(e,IF(EF(e),1))))}(e)}};IY.className="softsign",DW.registerClass(IY);var CY=class extends mY{apply(e){return uO(e)}};CY.className="tanh",DW.registerClass(CY);var NY=class extends mY{apply(e){return _z(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}};NY.className="softmax",DW.registerClass(NY);var TY=class extends mY{apply(e){return JP(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}};TY.className="logSoftmax",DW.registerClass(TY);var EY=class extends mY{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return uM((()=>TF(oO(TF(e,t)),e)))}};EY.className="swish",DW.registerClass(EY);var AY=class extends mY{apply(e){return uM((()=>TF(e,uO(XP(e)))))}};function _Y(e){return e.getClassName()}function $Y(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return AH(e,DW.SerializationMap.getMap().classNameMap,t,"activation")}function RY(e){if(null==e){let e={className:"linear",config:{}};return $Y(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},$Y(t)}return e instanceof mY?e:$Y(e)}function DY(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}AY.className="mish",DW.registerClass(AY);var MY=class extends DW.Serializable{},FY=class extends MY{constructor(e){super(),DY(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return uM((()=>{let t=hL([1]);return this.hasL1&&(t=IF(t,yP(TF(this.l1,EF(e))))),this.hasL2&&(t=IF(t,yP(TF(this.l2,kq(e))))),nO(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};FY.className="L1L2",DW.registerClass(FY);var OY={l1l2:"L1L2"};function PY(e){return TH(e)}function LY(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return AH(e,DW.SerializationMap.getMap().classNameMap,t,"regularizer")}function zY(e){if(null==e)return null;if("string"==typeof e){return LY({className:e in OY?OY[e]:e,config:{}})}return e instanceof MY?e:LY(e)}var BY=class extends uK{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Qq(e);let n=dz(e);return null!=this.maxValue&&(n=SO(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};BY.className="ReLU",DW.registerClass(BY);var WY=class extends uK{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Qq(e);return MP(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};WY.className="LeakyReLU",DW.registerClass(WY);var VY=class extends uK{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Kq(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=zY(e.alphaRegularizer),this.alphaConstraint=_K(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new mH(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){let t=(e=Jq(e)).slice(1);if(null!=this.sharedAxes)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new aK({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Qq(e),RL(e,this.alpha.read())}getConfig(){let e={alphaInitializer:qq(this.alphaInitializer),alphaRegularizer:PY(this.alphaRegularizer),alphaConstraint:EK(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};VY.className="PReLU",DW.registerClass(VY);var UY=class extends uK{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new gH(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Qq(e);return eP(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};UY.className="ELU",DW.registerClass(UY);var jY=class extends uK{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let n=Qq(e);return TF(n,wF(EP(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};jY.className="ThresholdedReLU",DW.registerClass(jY);var GY=class extends uK{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new NY).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return uM((()=>{let n=Qq(e),r=t.mask;if(null!=r){let e=TF(QP(pL(n.shape),wF(r,n.dtype)),fP(-1e9));n=IF(n,e)}return this.axis instanceof Array?this.axis.length>1?wP(QP(n,ZP(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function HY(e,t,n){if("number"==typeof e)return vH(e,t);if(e.length!==t)throw new mH(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!sq(a))throw new mH(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function qY(e,t,n,r){let a;return null==e?e:(a="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r))}function KY(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+lq([n-t,0]);else{if("same"!==r)throw new mH(`Unsupport padding mode: ${r}.`);e*=t}return e}function XY(e,t){return uM((()=>(KH(t),"channelsFirst"===t?uB(e,[0,2,3,1]):e)))}function YY(e,t){return uM((()=>(KH(t),"channelsFirst"===t?uB(e,[0,2,3,4,1]):e)))}function QY(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return uM((()=>{if(null==s&&(s="channelsLast"),KH(s),3!==e.rank&&4!==e.rank)throw new mH(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new mH(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=XY(e,s);if("causal"===a)throw new gH("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=bB.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=uB(l,[0,3,1,2])),l}))}GY.className="Softmax",DW.registerClass(GY);var JY=class e extends uK{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.verifyArgs(n),this.rank=t,FH(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new gH(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=HY(n.kernelSize,t,"kernelSize"),this.strides=HY(null==n.strides?1:n.strides,t,"strides"),this.padding=null==n.padding?"valid":n.padding,XH(this.padding),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,KH(this.dataFormat),this.activation=RY(n.activation),this.useBias=null==n.useBias||n.useBias,this.biasInitializer=Kq(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=_K(n.biasConstraint),this.biasRegularizer=zY(n.biasRegularizer),this.activityRegularizer=zY(n.activityRegularizer),this.dilationRate=HY(null==n.dilationRate?1:n.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new mH(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new mH(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new mH(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(xH("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!MH(e.kernelSize,"number",1,3))throw new mH(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:_Y(this.activation),useBias:this.useBias,biasInitializer:qq(this.biasInitializer),biasRegularizer:PY(this.biasRegularizer),activityRegularizer:PY(this.activityRegularizer),biasConstraint:EK(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},ZY=class e extends JY{constructor(t,n){super(t,n),this.kernel=null,e.verifyArgs(n),this.filters=n.filters,FH(this.filters,"filters"),this.kernelInitializer=Kq(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=_K(n.kernelConstraint),this.kernelRegularizer=zY(n.kernelRegularizer)}build(e){e=Jq(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new mH(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return uM((()=>{e=Qq(e);let t,n=null==this.bias?null:this.bias.read(),r=PH(this.activation.getClassName());if(null!=r&&2===this.rank)t=QY(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return uM((()=>{if(null==s&&(s="channelsLast"),KH(s),3!==e.shape.length)throw new mH(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new mH(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new mH(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===s&&(e=uB(e,[0,2,1])),"causal"===a)throw new gH("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=AO(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=Iq(o,n)),o}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=QY(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new gH("convolutions greater than 3D are not implemented yet.");t=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return uM((()=>{if(null==s&&(s="channelsLast"),KH(s),4!==e.rank&&5!==e.rank)throw new mH(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new mH(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=YY(e,s);if("causal"===a)throw new gH("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=RO(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=Iq(o,n)),"channelsFirst"===s&&(o=uB(o,[0,4,1,2,3])),o}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=Jq(e);let t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){let e=qY(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:qq(this.kernelInitializer),kernelRegularizer:PY(this.kernelRegularizer),kernelConstraint:EK(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new mH(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},eQ=class e extends ZY{constructor(t){super(2,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!MH(e.kernelSize,"number",1,2))throw new mH(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};eQ.className="Conv2D",DW.registerClass(eQ);var tQ=class e extends ZY{constructor(t){super(3,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new mH(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};tQ.className="Conv3D",DW.registerClass(tQ);var nQ=class extends eQ{constructor(e){if(super(e),this.inputSpec=[new aK({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new mH(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Jq(e)).length)throw new mH("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new mH("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new aK({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return uM((()=>{let t=Qq(e);if(4!==t.shape.length)throw new mH(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a=t.shape,s=a[0];"channelsFirst"===this.dataFormat?(n=2,r=3):(n=1,r=2);let i=a[n],o=a[r],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],h=[s,KY(i,c,l,this.padding),KY(o,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=uB(t,[0,2,3,1]));let p=$O(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=uB(p,[0,3,1,2])),null!=this.bias&&(p=Iq(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){let t,n,r,a=(e=Jq(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return a[t]=this.filters,a[n]=KY(a[n],o,s,this.padding),a[r]=KY(a[r],l,i,this.padding),a}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};nQ.className="Conv2DTranspose",DW.registerClass(nQ);var rQ=class extends tQ{constructor(e){if(super(e),this.inputSpec=[new aK({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new mH(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Jq(e)).length)throw new mH("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new mH("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new aK({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return uM((()=>{let t=Qq(e);if(5!==t.shape.length)throw new mH(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a,s=t.shape,i=s[0];"channelsFirst"===this.dataFormat?(a=2,n=3,r=4):(a=1,n=2,r=3);let o=s[a],l=s[n],u=s[r],c=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[i,KY(o,p,c,this.padding),KY(l,f,d,this.padding),KY(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=uB(t,[0,2,3,4,1]));let y=MO(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=uB(y,[0,4,1,2,3])),null!==this.bias&&(y=Iq(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){let t,n,r,a,s=(e=Jq(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3,a=4):(t=4,n=1,r=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return s[t]=this.filters,s[n]=KY(s[n],u,i,this.padding),s[r]=KY(s[r],c,o,this.padding),s[a]=KY(s[a],d,l,this.padding),s}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};rQ.className="Conv3DTranspose",DW.registerClass(rQ);var aQ=class extends ZY{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new mH("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new mH("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new mH(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Kq(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=zY(t.depthwiseRegularizer),this.depthwiseConstraint=_K(t.depthwiseConstraint),this.pointwiseInitializer=Kq(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=zY(t.pointwiseRegularizer),this.pointwiseConstraint=_K(t.pointwiseConstraint)}build(e){if((e=Jq(e)).length<this.rank+2)throw new mH(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new mH(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new aK({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return uM((()=>{let t;if(e=Qq(e),1===this.rank)throw new gH("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=uB(e,[0,2,3,1])),t=wz(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=Iq(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=uB(t,[0,3,1,2])),t}))}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=qq(this.depthwiseInitializer),e.pointwiseInitializer=qq(this.pointwiseInitializer),e.depthwiseRegularizer=PY(this.depthwiseRegularizer),e.pointwiseRegularizer=PY(this.pointwiseRegularizer),e.depthwiseConstraint=EK(this.depthwiseConstraint),e.pointwiseConstraint=EK(this.pointwiseConstraint),e}};aQ.className="SeparableConv";var sQ=class extends aQ{constructor(e){super(2,e)}};sQ.className="SeparableConv2D",DW.registerClass(sQ);var iQ=class e extends ZY{constructor(t){super(1,t),e.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!MH(e.kernelSize,"number",1,1))throw new mH(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};iQ.className="Conv1D",DW.registerClass(iQ);var oQ=class extends uK{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return uM((()=>{if(e=Qq(e),"channelsLast"===this.dataFormat){let t=mq(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return mq(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=mq(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return mq(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};oQ.className="Cropping2D",DW.registerClass(oQ);var lQ=class extends uK{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,KH(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function(e){DH(UH,"InterpolationFormat",e)}(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{let t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return uM((()=>{let t=Qq(e),n=t.shape;if("channelsFirst"===this.dataFormat){t=uB(t,[0,2,3,1]);let e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?EW.resizeNearestNeighbor(t,[e,r]):EW.resizeBilinear(t,[e,r]);return uB(a,[0,3,1,2])}{let e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?EW.resizeNearestNeighbor(t,[e,r]):EW.resizeBilinear(t,[e,r])}}))}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};lQ.className="UpSampling2D",DW.registerClass(lQ);var uQ=class extends JY{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Kq(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=_K(e.depthwiseConstraint),this.depthwiseRegularizer=zY(e.depthwiseRegularizer)}build(e){if((e=Jq(e)).length<4)throw new mH(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new mH(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return uM((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return uM((()=>{null==a&&(a="channelsLast"),KH(a);let i=XY(e,a);if(4!==e.rank)throw new mH(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new mH(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=WO(i,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(i=uB(i,[0,3,1,2])),i}))}(e=Qq(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=Iq(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=Jq(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=qY(t,this.kernelSize[0],this.padding,this.strides[0]),s=qY(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=qq(this.depthwiseInitializer),e.depthwiseRegularizer=PY(this.depthwiseRegularizer),e.depthwiseConstraint=EK(this.depthwiseRegularizer),e}};function cQ(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new mH("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function dQ(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return uM((()=>{let l=t.shape.length;if(l<3)throw new mH(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(uq(2,l));if(t=uB(t,u),null!=s)throw new gH("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=wF(wF(a,"bool"),"float32"),a.rank===l-1&&(a=kP(a,-1)),a=uB(a,u)),r&&(t=pz(t,0),null!=a&&(a=pz(a,0)));let c,d,h,p=[],f=n,m=t.shape[0],g=rB(t);null!=a&&(d=rB(a));for(let t=0;t<m;++t){let n=g[t],r=uM((()=>e(n,f)));if(null==a)c=r[0],f=r[1];else{let e=uM((()=>{let e=d[t],n=QP(SL(e),e),a=IF(TF(r[0],e),TF(f[0],n)),s=f.map(((t,a)=>IF(TF(r[1][a],e),TF(t,n))));return{output:a,newStates:s}}));c=e.output,f=e.newStates}o&&p.push(c)}return o&&(h=Lz(p,1)),[c,h,f]}))}uQ.className="DepthwiseConv2D",DW.registerClass(uQ);var hQ=class e extends uK{constructor(e){let t;if(super(e),null==e.cell)throw new mH("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new xQ({cells:e.cell}):e.cell,null==t.stateSize)throw new mH("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new aK({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return uq(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Xq(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){let r=[];for(let n of t)r.push([e[0],n]);return[n].concat(r)}return n}computeMask(e,t){return uM((()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;if(this.returnState){let t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new gH("Constants support is not implemented in RNN yet.");Xq(e)&&(e=e[0]);let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new aK({shape:[t,null,...n]});let r,a=[e[0]].concat(e.slice(2));if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!TR.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new mH(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((e=>new aK({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];uM((()=>{if(!this.stateful)throw new pH("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(null==n)throw new mH("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>hL([n,e]))):this.states_=[hL([n,this.cell.stateSize])];else if(null==e)cM(this.states_),null!=this.keptStates&&(cM(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>hL([n,e]))):this.states_[0]=hL([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new mH(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):cM(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!TR.arraysEqual(r.shape,s))throw new mH(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>dM(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=cQ(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(let e of n)this.stateSpec.push(new aK({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof sK){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return uM((()=>{let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;e=Qq(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new mH(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:r},o=dQ(((e,t)=>{let n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);let d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return uM((()=>{let t=hL(e.shape);return t=yP(t,[1,2]),t=hq(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?bq(t,[1,e]):t)):this.cell.stateSize>1?[bq(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===e.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=uX(t.cell,n);return new e(Object.assign(t,{cell:r}))}};hQ.className="RNN",DW.registerClass(hQ);var pQ=class extends uK{},fQ=class extends pQ{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,FH(this.units,"units"),this.activation=RY(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Kq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Kq(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Kq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=zY(e.kernelRegularizer),this.recurrentRegularizer=zY(e.recurrentRegularizer),this.biasRegularizer=zY(e.biasRegularizer),this.kernelConstraint=_K(e.kernelConstraint),this.recurrentConstraint=_K(e.recurrentConstraint),this.biasConstraint=_K(e.biasConstraint),this.dropout=oq([1,lq([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=oq([1,lq([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Jq(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return uM((()=>{if(2!==e.length)throw new mH(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=wQ({ones:()=>SL(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=wQ({ones:()=>SL(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;a=xq(null!=s?TF(e,s):e,this.kernel.read()),null!=this.bias&&(a=Iq(a,this.bias.read())),null!=i&&(n=TF(n,i));let o=IF(a,xq(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:_Y(this.activation),useBias:this.useBias,kernelInitializer:qq(this.kernelInitializer),recurrentInitializer:qq(this.recurrentInitializer),biasInitializer:qq(this.biasInitializer),kernelRegularizer:PY(this.kernelRegularizer),recurrentRegularizer:PY(this.recurrentRegularizer),biasRegularizer:PY(this.biasRegularizer),activityRegularizer:PY(this.activityRegularizer),kernelConstraint:EK(this.kernelConstraint),recurrentConstraint:EK(this.recurrentConstraint),biasConstraint:EK(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};fQ.className="SimpleRNNCell",DW.registerClass(fQ);var mQ=class extends hQ{constructor(e){e.cell=new fQ(e),super(e)}call(e,t){return uM((()=>{null!=this.cell.dropoutMask&&(cM(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cM(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}};mQ.className="SimpleRNN",DW.registerClass(mQ);var gQ=class extends pQ{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new mH("GRUCell does not support reset_after parameter set to true.");this.units=e.units,FH(this.units,"units"),this.activation=RY(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=RY(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Kq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Kq(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Kq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=zY(e.kernelRegularizer),this.recurrentRegularizer=zY(e.recurrentRegularizer),this.biasRegularizer=zY(e.biasRegularizer),this.kernelConstraint=_K(e.kernelConstraint),this.recurrentConstraint=_K(e.recurrentConstraint),this.biasConstraint=_K(e.biasConstraint),this.dropout=oq([1,lq([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=oq([1,lq([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){let t=(e=Jq(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return uM((()=>{if(2!==e.length)throw new mH(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=null!=t.training&&t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=wQ({ones:()=>SL(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=wQ({ones:()=>SL(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a,s,i,o=this.dropoutMask,l=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=TF(e,o[0]));let u=xq(e,this.kernel.read());this.useBias&&(u=Iq(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=TF(r,l[0]));let c=this.recurrentKernel.read(),[d,h]=Mz(c,[2*this.units,this.units],c.rank-1),p=xq(r,d),[f,m,g]=Mz(u,3,u.rank-1),[y,b]=Mz(p,2,p.rank-1);a=this.recurrentActivation.apply(IF(f,y)),s=this.recurrentActivation.apply(IF(m,b));let v=xq(TF(s,r),h);i=this.activation.apply(IF(g,v));let x=IF(TF(a,r),TF(IF(1,KP(a)),i));return[x,x]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:_Y(this.activation),recurrentActivation:_Y(this.recurrentActivation),useBias:this.useBias,kernelInitializer:qq(this.kernelInitializer),recurrentInitializer:qq(this.recurrentInitializer),biasInitializer:qq(this.biasInitializer),kernelRegularizer:PY(this.kernelRegularizer),recurrentRegularizer:PY(this.recurrentRegularizer),biasRegularizer:PY(this.biasRegularizer),activityRegularizer:PY(this.activityRegularizer),kernelConstraint:EK(this.kernelConstraint),recurrentConstraint:EK(this.recurrentConstraint),biasConstraint:EK(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};gQ.className="GRUCell",DW.registerClass(gQ);var yQ=class extends hQ{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new gQ(e),super(e)}call(e,t){return uM((()=>{null!=this.cell.dropoutMask&&(cM(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cM(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};yQ.className="GRU",DW.registerClass(yQ);var bQ=class extends pQ{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,FH(this.units,"units"),this.activation=RY(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=RY(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Kq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Kq(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Kq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=zY(e.kernelRegularizer),this.recurrentRegularizer=zY(e.recurrentRegularizer),this.biasRegularizer=zY(e.biasRegularizer),this.kernelConstraint=_K(e.kernelConstraint),this.recurrentConstraint=_K(e.recurrentConstraint),this.biasConstraint=_K(e.biasConstraint),this.dropout=oq([1,lq([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=oq([1,lq([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n,r=(e=Jq(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,r=this.units;n=new(t=class extends Aq{apply(t,n){let a=e.apply([r]),s=(new $q).apply([r]),i=e.apply([2*r]);return yq(yq(a,s),i)}},t.className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return uM((()=>{let n=null!=t.training&&t.training;if(3!==e.length)throw new mH(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=wQ({ones:()=>SL(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=wQ({ones:()=>SL(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s,i,o,l,u=this.dropoutMask,c=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=TF(e,u[0]));let d=xq(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=TF(r,c[0])),d=IF(d,xq(r,this.recurrentKernel.read())),this.useBias&&(d=Iq(d,this.bias.read()));let[h,p,f,m]=Mz(d,4,d.rank-1);s=this.recurrentActivation.apply(h),i=this.recurrentActivation.apply(p),o=IF(TF(i,a),TF(s,this.activation.apply(f))),l=this.recurrentActivation.apply(m);let g=TF(l,this.activation.apply(o));return[g,g,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:_Y(this.activation),recurrentActivation:_Y(this.recurrentActivation),useBias:this.useBias,kernelInitializer:qq(this.kernelInitializer),recurrentInitializer:qq(this.recurrentInitializer),biasInitializer:qq(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:PY(this.kernelRegularizer),recurrentRegularizer:PY(this.recurrentRegularizer),biasRegularizer:PY(this.biasRegularizer),activityRegularizer:PY(this.activityRegularizer),kernelConstraint:EK(this.kernelConstraint),recurrentConstraint:EK(this.recurrentConstraint),biasConstraint:EK(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};bQ.className="LSTMCell",DW.registerClass(bQ);var vQ=class extends hQ{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new bQ(e),super(e)}call(e,t){return uM((()=>{null!=this.cell.dropoutMask&&(cM(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cM(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};vQ.className="LSTM",DW.registerClass(vQ);var xQ=class extends pQ{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return uM((()=>{let n=e.slice(1),r=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a,s=[];for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(let e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;Xq(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{ZH(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){let e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=[];for(let a of t.cells)r.push(uX(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return nK(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}rK(t)}};function wQ(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):Cq(t(),n),o=()=>Nq(i,t,r);return!a||a<=1?dM(o().clone()):Array(a).fill(void 0).map(o).map((e=>dM(e.clone())))}xQ.className="StackedRNNCells",DW.registerClass(xQ);var kQ=class extends hQ{constructor(e){if(e.unroll)throw new gH("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new gH("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new aK({ndim:5})]}call(e,t){return uM((()=>{if(null!=this.cell.dropoutMask&&(cM(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cM(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new mH("ConvRNN2D cell does not support constants");let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return uM((()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=hL([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];uM((()=>{if(!this.stateful)throw new pH("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new mH("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>hL(a))):this.states_=[hL(a)];else if(null==e)cM(this.states_),null!=this.keptStates&&(cM(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>hL(a))):this.states_[0]=hL(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new mH(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):cM(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],r=a;if(!TR.arraysEqual(n.shape,r))throw new mH(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>dM(e.clone())))}))}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=qY(l,r[0],a,s[0],i[0]),d=qY(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}};kQ.className="ConvRNN2D";var SQ=class extends bQ{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,FH(this.filters,"filters"),this.kernelSize=HY(n,2,"kernelSize"),this.kernelSize.forEach((e=>FH(e,"kernelSize"))),this.strides=HY(r||1,2,"strides"),this.strides.forEach((e=>FH(e,"strides"))),this.padding=a||"valid",XH(this.padding),this.dataFormat=s||"channelsLast",KH(this.dataFormat),this.dilationRate=HY(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>FH(e,"dilationRate")))}build(e){var t;e=Jq(e);let n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new mH(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,r=this.filters;e=new((t=class extends Aq{apply(e,t){return gq([n.apply([r]),pL([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return uM((()=>{if(3!==e.length)throw new mH(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=wQ({ones:()=>SL(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?TF(t[n],e):e,l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),d=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=wQ({ones:()=>SL(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,p=o(a,h,0),f=o(a,h,1),m=o(a,h,2),g=o(a,h,3),[y,b,v,x]=Mz(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?Mz(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,v,S,this.padding),d=this.inputConv(d,x,I,this.padding);let[C,N,T,E]=Mz(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,C),f=this.recurrentConv(f,N),m=this.recurrentConv(m,T),g=this.recurrentConv(g,E);let A=this.recurrentActivation.apply(IF(l,p)),_=this.recurrentActivation.apply(IF(u,f)),$=IF(TF(_,s),TF(A,this.activation.apply(IF(c,m)))),R=TF(this.recurrentActivation.apply(IF(d,g)),this.activation.apply($));return[R,R,$]}))}getConfig(){let e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let a=EO(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Iq(a,n,this.dataFormat):a}recurrentConv(e,t){return EO(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};SQ.className="ConvLSTM2DCell",DW.registerClass(SQ);var IQ=class extends kQ{constructor(e){let t=new SQ(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};IQ.className="ConvLSTM2D",DW.registerClass(IQ);var CQ=class extends uK{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return uM((()=>{this.invokeCallHook(e,t);let n=Qq(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,r=this.getNoiseShape(n);return Nq((()=>Cq(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};CQ.className="Dropout",DW.registerClass(CQ);var NQ=class extends CQ{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};NQ.className="SpatialDropout1D",DW.registerClass(NQ);var TQ=class extends uK{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,FH(this.units,"units"),this.activation=RY(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Kq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Kq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=_K(e.kernelConstraint),this.biasConstraint=_K(e.biasConstraint),this.kernelRegularizer=zY(e.kernelRegularizer),this.biasRegularizer=zY(e.biasRegularizer),this.activityRegularizer=zY(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){let t=(e=Jq(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){let t=(e=Jq(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return uM((()=>{this.invokeCallHook(e,t);let n,r=Qq(e),a=PH(this.activation.getClassName());return null!=a?n=xq(r,this.kernel.read(),a,this.bias?this.bias.read():null):(n=xq(r,this.kernel.read()),null!=this.bias&&(n=Iq(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n}))}getConfig(){let e={units:this.units,activation:_Y(this.activation),useBias:this.useBias,kernelInitializer:qq(this.kernelInitializer),biasInitializer:qq(this.biasInitializer),kernelRegularizer:PY(this.kernelRegularizer),biasRegularizer:PY(this.biasRegularizer),activityRegularizer:PY(this.activityRegularizer),kernelConstraint:EK(this.kernelConstraint),biasConstraint:EK(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};TQ.className="Dense",DW.registerClass(TQ);var EQ=class extends uK{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Jq(e);for(let t of e.slice(1))if(null==t)throw new mH(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],iq(e,1)]}call(e,t){return uM((()=>{this.invokeCallHook(e,t);let n=Qq(e);if("channelsFirst"===this.dataFormat&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=uB(n,e)}return function(e){if(e.rank<=1)throw new mH(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],iq(e.shape,1)];return nO(e,t)}(n)}))}getConfig(){let e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};EQ.className="Flatten",DW.registerClass(EQ);var AQ=class extends uK{constructor(e){super(e),this.supportsMasking=!0,this.activation=RY(e.activation)}call(e,t){return uM((()=>{this.invokeCallHook(e,t);let n=Qq(e);return this.activation.apply(n)}))}getConfig(){let e={activation:_Y(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};AQ.className="Activation",DW.registerClass(AQ);var _Q=class extends uK{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return uM((()=>function(e,t){return uM((()=>{if(2!==e.shape.length)throw new mH(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return bq(hq(e,1),[1,t,1])}))}(e=Qq(e),this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};_Q.className="RepeatVector",DW.registerClass(_Q);var $Q=class extends uK{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let o=0;o<r.length;++o){let e=r[o];if(this.isUnknown(e)){if(null!==s)throw new mH("Can only specifiy one unknown dimension.");s=o}else a*=e}let i=iq(e);if(null!==s){if(0===a||i%a!==0)throw new mH(n);r[s]=i/a}else if(i!==a)throw new mH(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return uM((()=>{this.invokeCallHook(e,t);let n=Qq(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return nO(n,a)}))}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};$Q.className="Reshape",DW.registerClass($Q);var RQ=class extends uK{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=uq(1,e.dims.length+1);if(!TR.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new aK({ndim:this.dims.length+1})]}computeOutputShape(e){let t=(e=Jq(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return uB(Qq(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};RQ.className="Permute",DW.registerClass(RQ);var DQ=class extends uK{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Qq(e);return DF(wL(n,this.maskValue),-1)}call(e,t){return uM((()=>{this.invokeCallHook(e,t);let n=Qq(e),r=DF(wL(n,this.maskValue),-1,!0);return TF(n,wF(r,n.dtype))}))}};DQ.className="Masking",DW.registerClass(DQ);var MQ=class extends uK{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(SH(e.inputLength))}this.inputDim=e.inputDim,FH(this.inputDim,"inputDim"),this.outputDim=e.outputDim,FH(this.outputDim,"outputDim"),this.embeddingsInitializer=Kq(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=zY(e.embeddingsRegularizer),this.activityRegularizer=zY(e.activityRegularizer),this.embeddingsConstraint=_K(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return uM((()=>this.maskZero?(e=Qq(e),wL(e,YO(e))):null))}computeOutputShape(e){if(e=Jq(e),null==this.inputLength)return[...e,this.outputDim];let t=SH(this.inputLength);if(t.length!==e.length-1)throw new mH(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new mH(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return uM((()=>{this.invokeCallHook(e,t);let n=Qq(e);"int32"!==n.dtype&&(n=dq(n,"int32"));let r=wq(this.embeddings.read(),nO(n,[n.size]));return nO(r,Jq(this.computeOutputShape(n.shape)))}))}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:qq(this.embeddingsInitializer),embeddingsRegularizer:PY(this.embeddingsRegularizer),activityRegularizer:PY(this.activityRegularizer),embeddingsConstraint:EK(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};MQ.className="Embedding",DW.registerClass(MQ);var FQ=class extends uK{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new gH}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new mH("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Jq(e)]),e.length<2)throw new mH(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=$H(t),t.length>1)throw new mH(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){let t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}let r=e.map((e=>e.length));-1===e.indexOf(null)&&1===$H(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return uM((()=>{if(this.reshapeRequired){let t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){let r=lq(n);for(let n of e){let e=n.rank;for(let t=0;t<r-e;++t)n=hq(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(let s of e){let e=s.rank;if(null==e){let e=s.shape,r=e[0],a=e.slice(1).concat([r]),i=nO(s,[r].concat(iq(e.slice(1))));i=uB(i,[1,0]),i=nO(i,a),t.push(i),n=!0}else if(e>1){let r=uq(1,e).concat([0]);t.push(uB(s,r)),n=!0}else t.push(s)}let r=this.mergeFunction(t),a=r.rank;if(n)if(null==a){let e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=nO(uB(nO(r,[-1,t]),[1,0]),n)}else if(a>1){let e=[a-1].concat(uq(0,a-1));r=uB(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){let n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(let r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=$H(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return uM((()=>{if(null==t)return null;if(!Array.isArray(t))throw new mH("`mask` should be an Array");if(!Array.isArray(e))throw new mH("`inputs` should be an Array");if(t.length!==e.length)throw new mH(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:kP(e,0))))[0];for(let e=1;e<t.length-1;++e)n=eL(n,t[e]);return n}))}},OQ=class extends FQ{constructor(e){super(e)}mergeFunction(e){return uM((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=IF(t,e[n]);return t}))}};OQ.className="Add",DW.registerClass(OQ);var PQ=class extends FQ{constructor(e){super(e)}mergeFunction(e){return uM((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=TF(t,e[n]);return t}))}};PQ.className="Multiply",DW.registerClass(PQ);var LQ=class extends FQ{constructor(e){super(e)}mergeFunction(e){return uM((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=IF(t,e[n]);return TF(1/e.length,t)}))}};LQ.className="Average",DW.registerClass(LQ);var zQ=class extends FQ{constructor(e){super(e)}mergeFunction(e){return uM((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=cL(t,e[n]);return t}))}};zQ.className="Maximum",DW.registerClass(zQ);var BQ=class extends FQ{constructor(e){super(e)}mergeFunction(e){return uM((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=mL(t,e[n]);return t}))}};BQ.className="Minimum",DW.registerClass(BQ);var WQ=class extends FQ{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new mH("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(let r of e)if(null!=r){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let t=e[r].slice();t.splice(this.axis,1);let a=!1;for(let e of n)if(TR.arraysEqual(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new mH("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return uM((()=>gq(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new mH("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new mH("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new mH("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new mH(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return uM((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;let r=[];for(let s=0;s<e.length;++s)null==t[s]?r.push(wF(SL(e[s]),"bool")):t[s].rank<e[s].rank?r.push(kP(t[s],-1)):r.push(t[s]);let a=sO(r,this.axis);return RF(a,-1,!1)}))}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function VQ(e,t){for(;e<0;)e+=t;return e}WQ.className="Concatenate",DW.registerClass(WQ);var UQ=class extends FQ{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){TR.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new gH("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new mH(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new mH(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>VQ(t,e[n].shape.length))):[VQ(this.axes,n.shape.length),VQ(this.axes,r.shape.length)],this.normalize&&(n=cX(n,t[0]),r=cX(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new gH("batchDot is not implemented for tensors of 4D or higher rank yet");if(TR.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),TR.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new gH("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);let s=n;return uM((()=>{let n,i;if(r>a){n=r-a;let e=[];for(let t=0;t<n;++t)e.push(1);t=nO(t,t.shape.concat(e))}else if(a>r){n=a-r;let t=[];for(let e=0;e<n;++e)t.push(1);e=nO(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?yP(TF(e,t),s[0]):yP(TF(uB(e,[1,0]),t),s[1]);else{let n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;i=iO(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;let t=[];for(let r=e;r<e+n;++r)t.push(r);i=Pz(i,t)}return 1===i.shape.length&&(i=kP(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[VQ(this.axes,e.length),VQ(this.axes,t.length)],n}computeOutputShape(e){TR.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new gH("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};UQ.className="Dot",DW.registerClass(UQ);var jQ=class extends uK{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return uM((()=>{this.invokeCallHook(e,t);let n=Qq(e);return Nq((()=>IF(vq(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}};jQ.className="GaussianNoise",DW.registerClass(jQ);var GQ=class extends uK{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return uM((()=>{this.invokeCallHook(e,t);let n=Qq(e);return this.rate>0&&this.rate<1?Nq((()=>{let e=Math.sqrt(this.rate/(1-this.rate));return TF(n,vq(n.shape,1,e))}),(()=>n),t.training||!1):n}))}};GQ.className="GaussianDropout",DW.registerClass(GQ);var HQ=class extends uK{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Qq(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return uM((()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Nq((()=>{let t=Qq(e),r=-1.7580993408473766,a=AP(iz(n),this.rate);a=dq(a,"float32");let s=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-s*r*this.rate,o=IF(TF(t,a),TF(IF(a,-1),r));return IF(TF(o,s),i)}),(()=>Qq(e)),t.training||!1)}return e}))}};function qQ(e,t,n,r,a){let s,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)s=fO(e,t,n,r,a,i);else if(3===e.rank)s=mO(e,t,n,r,a,i);else{if(4!==e.rank)throw new gH(`batchNormalization is not implemented for array of rank ${e.rank} yet`);s=gO(e,t,n,r,a,i)}return s}function KQ(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return TR.arraysEqual(r.slice().sort(),uq(0,e.rank-1))?function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return uM((()=>{let s=bL(e,r),i=s.mean,o=s.variance;return[qQ(e,i,o,n,t,a),i,o]}))}(e,t,n,r,a):function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return uM((()=>{let s=bL(e,r),i=s.mean,o=s.variance,l=[];for(let t of uq(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);let u=nO(i,l),c=nO(o,l),d=null==t?null:nO(t,l),h=null==n?null:nO(n,l);return[qQ(e,u,c,h,d,a),i,o]}))}(e,t,n,r,a)}HQ.className="AlphaDropout",DW.registerClass(HQ);var XQ=class extends uK{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Kq(e.betaInitializer||"zeros"),this.gammaInitializer=Kq(e.gammaInitializer||"ones"),this.movingMeanInitializer=Kq(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Kq(e.movingVarianceInitializer||"ones"),this.betaConstraint=_K(e.betaConstraint),this.gammaConstraint=_K(e.gammaConstraint),this.betaRegularizer=zY(e.betaRegularizer),this.gammaRegularizer=zY(e.gammaRegularizer)}build(e){e=Jq(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new mH(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new aK({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return uM((()=>{let n=null!=t.training&&t.training,r=Qq(e),a=r.shape,s=a.length,i=uq(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=vH(1,s);l[o]=a[o];let u=i.slice();u.sort();let c=!TR.arraysEqual(u,uq(0,s).slice(0,s-1));if(!n)return(()=>{if(c){let e=nO(this.movingMean.read(),l),t=nO(this.movingVariance.read(),l),n=this.center?nO(this.beta.read(),l):null,a=this.scale?nO(this.gamma.read(),l):null;return qQ(r,e,t,n,a,this.epsilon)}return qQ(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();let[d,h,p]=KQ(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{uM((()=>{let r=1-n,a=e.read(),s=TF(QP(a,t),r);e.write(QP(a,s))}))};return f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum),d}))}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:qq(this.betaInitializer),gammaInitializer:qq(this.gammaInitializer),movingMeanInitializer:qq(this.movingMeanInitializer),movingVarianceInitializer:qq(this.movingVarianceInitializer),betaRegularizer:PY(this.betaRegularizer),gammaRegularizer:PY(this.gammaRegularizer),betaConstraint:EK(this.betaConstraint),gammaConstraint:EK(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};XQ.className="BatchNormalization",DW.registerClass(XQ);var YQ=class extends uK{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Kq(e.betaInitializer||"zeros"),this.gammaInitializer=Kq(e.gammaInitializer||"ones"),this.betaRegularizer=zY(e.betaRegularizer),this.gammaRegularizer=zY(e.gammaRegularizer),this.supportsMasking=!0}build(e){let t=(e=Jq(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==$H(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Qq(e),r=n.shape,a=r.length;return uM((()=>{let{mean:e,variance:t}=bL(n,this.axis,!0),s=vH(1,a);for(let n of this.axis)s[n]=r[n];let i=e=>null!=e&&e.shape.length!==a?nO(e,s):e,o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null,u=[],c=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=IP(e,u),t=IP(t,u),null!=o&&(o=IP(o,c)),null!=l&&(l=IP(l,c)),qQ(n,e,t,l,o,this.epsilon)}))}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:qq(this.betaInitializer),gammaInitializer:qq(this.gammaInitializer),betaRegularizer:PY(this.betaRegularizer),gammaRegularizer:PY(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};YQ.className="LayerNormalization",DW.registerClass(YQ);var QQ=class extends uK{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new mH(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new mH(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new mH(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new aK({ndim:4})]}computeOutputShape(e){let t,n;return e=Jq(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return uM((()=>function(e,t,n){return uM((()=>{if(4!==e.rank)throw new mH(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new mH("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new mH(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],CL(e,r)}))}(Qq(e),this.padding,this.dataFormat)))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function JQ(e,t,n,r,a,s){return uM((()=>{KH(a),YH(s),XH(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=XY(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?oL(e,t,n,o):rO(e,t,n,o),"channelsFirst"===a&&(i=uB(i,[0,3,1,2])),i}))}function ZQ(e,t,n,r,a,s){return uM((()=>{KH(a),YH(s),XH(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=YY(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?lL(e,t,n,o):aO(e,t,n,o),"channelsFirst"===a&&(i=uB(i,[0,4,1,2,3])),i}))}QQ.className="ZeroPadding2D",DW.registerClass(QQ);var eJ=class extends uK{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new mH(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(FH(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new mH(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}FH(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,XH(this.padding),this.inputSpec=[new aK({ndim:3})]}computeOutputShape(e){let t=qY((e=Jq(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return uM((()=>{this.invokeCallHook(e,t),e=hq(Qq(e),2);let n=this.poolingFunction(Qq(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Pz(n,[2])}))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},tJ=class extends eJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KH(a),XH(r),JQ(e,t,n,r,a,"max")}};tJ.className="MaxPooling1D",DW.registerClass(tJ);var nJ=class extends eJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KH(a),XH(r),JQ(e,t,n,r,a,"avg")}};nJ.className="AveragePooling1D",DW.registerClass(nJ);var rJ=class extends uK{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new mH(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];FH(this.poolSize,"poolSize"),FH(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,KH(this.dataFormat),XH(this.padding),this.inputSpec=[new aK({ndim:4})]}computeOutputShape(e){e=Jq(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=qY(t,this.poolSize[0],this.padding,this.strides[0]),n=qY(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return uM((()=>(this.invokeCallHook(e,t),this.poolingFunction(Qq(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},aJ=class extends rJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KH(a),XH(r),JQ(e,t,n,r,a,"max")}};aJ.className="MaxPooling2D",DW.registerClass(aJ);var sJ=class extends rJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KH(a),XH(r),JQ(e,t,n,r,a,"avg")}};sJ.className="AveragePooling2D",DW.registerClass(sJ);var iJ=class extends uK{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new mH(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];FH(this.poolSize,"poolSize"),FH(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,KH(this.dataFormat),XH(this.padding),this.inputSpec=[new aK({ndim:5})]}computeOutputShape(e){e=Jq(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=qY(t,this.poolSize[0],this.padding,this.strides[0]),n=qY(n,this.poolSize[1],this.padding,this.strides[1]),r=qY(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return uM((()=>(this.invokeCallHook(e,t),this.poolingFunction(Qq(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},oJ=class extends iJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KH(a),XH(r),ZQ(e,t,n,r,a,"max")}};oJ.className="MaxPooling3D",DW.registerClass(oJ);var lJ=class extends iJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KH(a),XH(r),ZQ(e,t,n,r,a,"avg")}};lJ.className="AveragePooling3D",DW.registerClass(lJ);var uJ=class extends uK{constructor(e){super(e),this.inputSpec=[new aK({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new gH}},cJ=class extends uJ{constructor(e){super(e||{})}call(e,t){return uM((()=>{let t=Qq(e);return dL(t,1)}))}};cJ.className="GlobalAveragePooling1D",DW.registerClass(cJ);var dJ=class extends uJ{constructor(e){super(e||{})}call(e,t){return uM((()=>{let t=Qq(e);return dP(t,1)}))}};dJ.className="GlobalMaxPooling1D",DW.registerClass(dJ);var hJ=class extends uK{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,KH(this.dataFormat),this.inputSpec=[new aK({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new gH}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},pJ=class extends hJ{call(e,t){return uM((()=>{let t=Qq(e);return"channelsLast"===this.dataFormat?dL(t,[1,2]):dL(t,[2,3])}))}};pJ.className="GlobalAveragePooling2D",DW.registerClass(pJ);var fJ=class extends hJ{call(e,t){return uM((()=>{let t=Qq(e);return"channelsLast"===this.dataFormat?dP(t,[1,2]):dP(t,[2,3])}))}};fJ.className="GlobalMaxPooling2D",DW.registerClass(fJ);var mJ=class extends uK{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=uX(t.layer,n);delete t.layer;let a={layer:r};return Object.assign(a,t),new e(a)}},gJ=class extends mJ{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Jq(e)).length<3)throw new mH(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){let t=[(e=Jq(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return uM((()=>dQ(((e,n)=>[Qq(this.layer.call(e,t)),[]]),e=Qq(e),[],!1,null,null,!1,!0)[1]))}};gJ.className="TimeDistributed",DW.registerClass(gJ);var yJ=class extends mJ{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=uX(n),t.goBackwards=!0!==t.goBackwards;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=uX(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function(e){DH(HH,"BidirectionalMergeMode",e)}(this.mergeMode),e.weights)throw new gH("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState&&(r=a.slice(1)),t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):kH(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=cQ(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);let s=[],i=[];if(null!=n){let e=n.length;if(e%2>0)throw new mH("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let r=n.map((e=>new aK({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new gH("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof sK;for(let l of s)if(l instanceof sK!==o)throw new mH("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return uM((()=>{let n,r,a,s,i=t.initialState;if(null==i)n=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let a=i.slice(0,i.length/2),s=i.slice(i.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return this.returnState&&(Array.isArray(n)&&(a=n.slice(1).concat(r.slice(1))),n=n[0],r=r[0]),this.returnSequences&&(r=pz(r,1)),"concat"===this.mergeMode?s=gq([n,r]):"sum"===this.mergeMode?s=IF(n,r):"ave"===this.mergeMode?s=TF(.5,IF(n,r)):"mul"===this.mergeMode?s=TF(n,r):null==this.mergeMode&&(s=[n,r]),this.returnState?null==this.mergeMode?s.concat(a):[s].concat(a):s}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ZH(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),ZH(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){let e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=uX(t.layer);if(delete t.layer,null!=t.numConstants)throw new gH("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};yJ.className="Bidirectional",DW.registerClass(yJ);var bJ=class extends uK{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return uM((()=>("float32"!==(e=Qq(e)).dtype&&(e=dq(e,"float32")),IF(TF(e,this.scale),this.offset))))}};bJ.className="Rescaling",DW.registerClass(bJ);var{resizeBilinear:vJ,cropAndResize:xJ}=EW,wJ=class extends uK{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return uM((()=>{let l,u=!1,c=[t/s,n/i,(r+t)/s,(a+n)/i],d=[];3===e.rank?(u=!0,l=Lz([e])):l=e;for(let e=0;e<l.shape[0];e++)d.push(c);let h=JD(d,[d.length,4]),p=lz(0,d.length,1,"int32"),f=xJ(l,h,p,[r,a],"nearest");return dq(u?Qq(rB(f)):f,o)}))}upsize(e,t,n,r){return uM((()=>dq(vJ(e,[t,n]),r)))}call(e,t){return uM((()=>{let t=Qq(e),n=t.dtype,r=t.shape,a=r[r.length-3],s=r[r.length-2],i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let o=0;return s!==this.width&&(o=Math.floor((s-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,a,s,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=Jq(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};wJ.className="CenterCrop",DW.registerClass(wJ);var kJ=class extends uK{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=Jq(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return uM((()=>{let n;if("int32"!==(e=Qq(e)).dtype&&(e=dq(e,"int32")),"undefined"!=typeof t.countWeights){if("count"!==this.outputMode)throw new mH(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=Qq(t.countWeights)}let r=dP(e),a=hP(e),s=EP(this.numTokens,r).bufferSync().get(0),i=AP(a,0).bufferSync().get(0);if(!s||!i)throw new mH(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let a=Qq(e);if("int32"!==a.dtype&&(a=dq(a,"int32")),"int"===t)return a;let s=a.shape;if(0===a.rank&&(a=kP(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=kP(a,-1)),a.rank>2)throw new mH(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);let i,o=["multiHot","oneHot"].includes(t),l=a;if(i=zO(l,"undefined"!=typeof r&&"count"===t?r:[],n,o),"tfIdf"!==t)return i;if(r)return TF(i,r);throw new mH("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}};kJ.className="CategoryEncoding",DW.registerClass(kJ);var SJ=new Set(["bilinear","nearest"]),IJ=class extends uK{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!SJ.has(e.interpolation))throw new mH(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){let t=(e=Jq(e))[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return uM((()=>{let t=[this.height,this.width];if("bilinear"===this.interpolation)return EW.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return EW.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...SJ]} are supported`)}))}};IJ.className="Resizing",DW.registerClass(IJ);var CJ=class{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}};CJ.className="RandomSeed";var NJ=class extends uK{constructor(e){super(e),this.randomGenerator=new CJ(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};NJ.className="BaseRandomLayer";var TJ=new Set(["bilinear","nearest"]),EJ=class extends NJ{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new mH(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new mH(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new mH(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!TJ.has(n))throw new mH(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=Jq(e))[2];return[this.imgHeight,-1,t]}call(e,t){return uM((()=>{let t=Qq(e);this.imgHeight=t.shape[t.shape.length-3];let n=t.shape[t.shape.length-2];this.widthFactor=iz([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);let a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return EW.resizeBilinear(e,a);case"nearest":return EW.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...TJ]} are supported`)}}))}};function AJ(e){return new dK(e)}function _J(e){return new UY(e)}function $J(e){return new BY(e)}function RJ(e){return new WY(e)}function DJ(e){return new VY(e)}function MJ(e){return new GY(e)}function FJ(e){return new jY(e)}function OJ(e){return new iQ(e)}function PJ(e){return new eQ(e)}function LJ(e){return new nQ(e)}function zJ(e){return new tQ(e)}function BJ(e){return new rQ(e)}function WJ(e){return new sQ(e)}function VJ(e){return new oQ(e)}function UJ(e){return new lQ(e)}function jJ(e){return new uQ(e)}function GJ(e){return new AQ(e)}function HJ(e){return new TQ(e)}function qJ(e){return new CQ(e)}function KJ(e){return new NQ(e)}function XJ(e){return new EQ(e)}function YJ(e){return new _Q(e)}function QJ(e){return new $Q(e)}function JJ(e){return new RQ(e)}function ZJ(e){return new MQ(e)}function eZ(e){return new OQ(e)}function tZ(e){return new LQ(e)}function nZ(e){return new WQ(e)}function rZ(e){return new zQ(e)}function aZ(e){return new BQ(e)}function sZ(e){return new PQ(e)}function iZ(e){return new UQ(e)}function oZ(e){return new XQ(e)}function lZ(e){return new YQ(e)}function uZ(e){return new QQ(e)}function cZ(e){return new nJ(e)}function dZ(e){return cZ(e)}function hZ(e){return cZ(e)}function pZ(e){return new sJ(e)}function fZ(e){return pZ(e)}function mZ(e){return pZ(e)}function gZ(e){return new lJ(e)}function yZ(e){return gZ(e)}function bZ(e){return gZ(e)}function vZ(e){return new cJ(e)}function xZ(e){return new pJ(e)}function wZ(e){return new dJ(e)}function kZ(e){return new fJ(e)}function SZ(e){return new tJ(e)}function IZ(e){return new aJ(e)}function CZ(e){return new oJ(e)}function NZ(e){return new yQ(e)}function TZ(e){return new gQ(e)}function EZ(e){return new vQ(e)}function AZ(e){return new bQ(e)}function _Z(e){return new mQ(e)}function $Z(e){return new fQ(e)}function RZ(e){return new IQ(e)}function DZ(e){return new SQ(e)}function MZ(e){return new hQ(e)}function FZ(e){return new xQ(e)}function OZ(e){return new yJ(e)}function PZ(e){return new gJ(e)}EJ.className="RandomWidth",DW.registerClass(EJ);var LZ=wZ,zZ=kZ,BZ=SZ,WZ=IZ;function VZ(e){return new jQ(e)}function UZ(e){return new GQ(e)}function jZ(e){return new HQ(e)}function GZ(e){return new DQ(e)}function HZ(e){return new bJ(e)}function qZ(e){return new wJ(e)}function KZ(e){return new IJ(e)}function XZ(e){return new kJ(e)}function YZ(e){return new EJ(e)}var QZ={};function JZ(e,t){return xX(e,t)}function ZZ(e,t){return CX(e,t)}function e0(e,t){return NX(e,t)}function t0(e,t){return wX(e,t)}function n0(e,t){return TX(e,t)}function r0(e,t){return SX(e,t)}function a0(e,t){return IX(e,t)}function s0(e,t){return yX(e,t)}function i0(e,t){return hX(e,t)}function o0(e,t){return pX(e,t)}function l0(e,t){return pX(e,t)}function u0(e,t){return pX(e,t)}function c0(e,t){return dX(e,t)}function d0(e,t){return dX(e,t)}function h0(e,t){return dX(e,t)}kT(QZ,{MAPE:()=>l0,MSE:()=>d0,binaryAccuracy:()=>JZ,binaryCrossentropy:()=>ZZ,categoricalAccuracy:()=>t0,categoricalCrossentropy:()=>n0,cosineProximity:()=>s0,mape:()=>u0,meanAbsoluteError:()=>i0,meanAbsolutePercentageError:()=>o0,meanSquaredError:()=>c0,mse:()=>h0,precision:()=>r0,recall:()=>a0,sparseCategoricalAccuracy:()=>e0});var p0={};kT(p0,{modelFromJSON:()=>lY});var f0={};function m0(e){return new FY(e)}function g0(e){return function(e){return DY(e),new FY({l1:null!=e?e.l1:null,l2:0})}(e)}function y0(e){return function(e){return DY(e),new FY({l2:null!=e?e.l2:null,l1:0})}(e)}kT(f0,{l1:()=>g0,l1l2:()=>m0,l2:()=>y0});var b0=class extends tX{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof iY))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function v0(e,t){return e<t}function x0(e,t){return e>t}var w0=class extends b0{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new gH("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=v0:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=x0:this.monitorFunc=v0,this.monitorFunc===v0&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===v0?1/0:-1/0}async onEpochEnd(e,t){await ZK(t);let n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});let t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};var k0,S0,I0={earlyStopping:function(e){return new w0(e)}};GE().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(k0||(k0={})),function(e){let t;var n;(n=t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"}(S0||(S0={}));var C0={};function N0(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};C0[e]=n}function T0(e){return C0[e]}function E0(e){delete C0[e]}function A0(e,t,n,r,a){let s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){let e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return _0(t.inputNames[o],n,r,a);if("tensors"===s.type){let s=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=s[t])||void 0===n?void 0:n.op)})).map((e=>_0(e,n,r,a)))}let l=_0(t.inputNames[o],n,r,a),u=l.dataSync();return"number"===s.type?u[0]:TR.toNestedArray(l.shape,u)}let i=t.attrParams[e];return i&&i.value}function _0(e,t,n,r){let[a,s]=M0(e,n);if(null!=r){let e=r.getHashTableHandleByName(a);if(null!=e)return e}let i=n.currentContextIds.find((e=>!!t[D0(a,e)]));return void 0!==i?t[D0(a,i)][s]:void 0}function $0(e,t,n){return t[D0(e,n.currentContextId)]}function R0(e,t){let[n,r,a]=M0(e,t);return[D0(n,t&&t.currentContextId),r,a]}function D0(e,t){return t?`${e}-${t}`:e}function M0(e,t){if(""===e)return["",0,void 0];let n=null!=t&&null!=t.parseNodeNameCache;if(n){let n=t.parseNodeNameCache.get(e);if(null!=n)return n}let r,a=e.split(":");if(1===a.length)r=[e,0,void 0];else{let e=a[0],t=3===a.length?a[1]:void 0;r=[e,Number(a[a.length-1]),t]}return n&&t.parseNodeNameCache.set(e,r),r}function F0(e,t,n){let r=A0("pad",e,t,n);if("explicit"===r){r=A0("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function O0(e){return e.kept?e:kF(e)}var P0={};kT(P0,{json:()=>L0});var L0=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],z0={};kT(z0,{json:()=>B0});var B0=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],W0={};kT(W0,{json:()=>V0});var V0=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],U0={};kT(U0,{json:()=>j0});var j0=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],G0={};kT(G0,{json:()=>H0});var H0=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],q0={};kT(q0,{json:()=>K0});var K0=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],X0={};kT(X0,{json:()=>Y0});var Y0=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Q0={};kT(Q0,{json:()=>J0});var J0=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Z0={};kT(Z0,{json:()=>e1});var e1=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],t1={};kT(t1,{json:()=>n1});var n1=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],r1={};kT(r1,{json:()=>a1});var a1=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],s1={};kT(s1,{json:()=>i1});var i1=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],o1={};kT(o1,{json:()=>l1});var l1=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],u1={};kT(u1,{json:()=>c1});var c1=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],d1={};kT(d1,{json:()=>h1});var h1=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],p1={};kT(p1,{json:()=>f1});var f1=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],m1={};kT(m1,{json:()=>g1});var g1=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],y1={};kT(y1,{json:()=>b1});var b1=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],v1={};kT(v1,{json:()=>x1});var x1=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],w1=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[].concat(...[P0,z0,W0,U0,G0,q0,X0,Q0,Z0,t1,r1,s1,o1,u1,d1,p1,m1,y1,v1].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.node,r=[],a=[],s=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):(null==t.input||0===t.input.length)&&s.push(e[t.name]),e)),{}),o=[],l=[],u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach((e=>{let t=i[e];t.inputNames.forEach(((e,n)=>{let[r,,a]=R0(e),s=i[r];if(null!=s.outputs){let e=s.outputs.indexOf(a);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{let t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{let[t]=R0(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{let[t]=R0(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));let p={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:h};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){let t=T0(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{let r,a=n.type;switch(n.type){case"string":r=S1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=S1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=D1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=D1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=C1(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=C1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=R1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=R1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=I1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=I1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=F1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=F1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=$1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=$1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=M1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=M1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=E1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=E1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=A1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=A1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=T1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=T1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){let t=e.nodeDef,n=[],r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));let a=[],s=[];e.signature.inputArg.forEach((e=>{let[t]=R0(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:N1(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,a.push(n),r[t]=n})),Object.keys(r).forEach((e=>{let t=r[e];t.inputNames.forEach(((e,n)=>{let[a,,s]=R0(e),i=r[a];if(null!=i.outputs){let e=i.outputs.indexOf(s);if(-1!==e){let r=`${a}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));let i=e.ret;e.signature.outputArg.forEach((e=>{let[t,n]=R0(i[e.name]),a=r[t];null!=a&&(a.defaultOutput=n,s.push(a))}));let o=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:s,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function k1(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){let t=GE().global;if("undefined"!=typeof t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function S1(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e[t];return null!=a?k1(a.s,r):n}function I1(e,t,n){let r=e[t];return r?r.b:n}function C1(e,t,n){let r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function N1(e){switch("string"==typeof e&&(e=k0[e]),e){case k0.DT_FLOAT:case k0.DT_HALF:return"float32";case k0.DT_INT32:case k0.DT_INT64:case k0.DT_INT8:case k0.DT_UINT8:return"int32";case k0.DT_BOOL:return"bool";case k0.DT_DOUBLE:return"float32";case k0.DT_STRING:return"string";case k0.DT_COMPLEX64:case k0.DT_COMPLEX128:return"complex64";default:return null}}function T1(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function E1(e,t,n){let r=e[t];return r&&r.type?N1(r.type):n}function A1(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>N1(e))):n}function _1(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function $1(e,t,n){let r=e[t];return r&&r.shape?_1(r.shape):n}function R1(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function D1(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>k1(e,r))):n}function M1(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>_1(e))):n}function F1(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var O1=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return _0(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(null!=n.tensor)return _0(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return C1(this.node.rawAttrs,e,t);if(null!=n.s)return S1(this.node.rawAttrs,e,t);if(null!=n.b)return I1(this.node.rawAttrs,e,t);if(null!=n.shape)return $1(this.node.rawAttrs,e,t);if(null!=n.type)return E1(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return R1(this.node.rawAttrs,e,t);if(null!=n.list.s)return D1(this.node.rawAttrs,e,t);if(null!=n.list.shape)return M1(this.node.rawAttrs,e,t);if(null!=n.list.b)return F1(this.node.rawAttrs,e,t);if(null!=n.list.type)return A1(this.node.rawAttrs,e,t)}return t}},P1={};kT(P1,{OP_SCOPE_SUFFIX:()=>KD,abs:()=>EF,acos:()=>AF,acosh:()=>_F,add:()=>IF,addN:()=>$F,all:()=>RF,any:()=>DF,argMax:()=>MF,argMin:()=>FF,asin:()=>OF,asinh:()=>PF,atan:()=>LF,atan2:()=>zF,atanh:()=>BF,avgPool:()=>rO,avgPool3d:()=>aO,basicLSTMCell:()=>cO,batchNorm:()=>pO,batchNorm2d:()=>fO,batchNorm3d:()=>mO,batchNorm4d:()=>gO,batchToSpaceND:()=>dO,bincount:()=>yO,bitwiseAnd:()=>bO,booleanMaskAsync:()=>lB,broadcastArgs:()=>vO,broadcastTo:()=>xO,buffer:()=>xF,cast:()=>wF,ceil:()=>wO,clipByValue:()=>SO,clone:()=>kF,complex:()=>YD,concat:()=>sO,concat1d:()=>IO,concat2d:()=>CO,concat3d:()=>NO,concat4d:()=>TO,conv1d:()=>AO,conv2d:()=>EO,conv2dTranspose:()=>$O,conv3d:()=>RO,conv3dTranspose:()=>MO,cos:()=>FO,cosh:()=>OO,cosineWindow:()=>gB,cumprod:()=>PO,cumsum:()=>LO,denseBincount:()=>zO,depthToSpace:()=>BO,depthwiseConv2d:()=>WO,diag:()=>VO,dilation2d:()=>UO,div:()=>NF,divNoNan:()=>QO,dot:()=>JO,dropout:()=>fB,einsum:()=>ZO,elu:()=>eP,enclosingPowerOfTwo:()=>mB,ensureShape:()=>tP,equal:()=>KO,erf:()=>nP,euclideanNorm:()=>xP,exp:()=>wP,expandDims:()=>kP,expm1:()=>SP,eye:()=>CP,fft:()=>$z,fill:()=>kO,floor:()=>NP,floorDiv:()=>CF,fused:()=>bB,gather:()=>TP,gatherND:()=>pB,greater:()=>EP,greaterEqual:()=>AP,ifft:()=>Rz,imag:()=>_P,image:()=>EW,inTopKAsync:()=>yB,irfft:()=>Dz,isFinite:()=>$P,isInf:()=>RP,isNaN:()=>DP,leakyRelu:()=>MP,less:()=>FP,lessEqual:()=>OP,linalg:()=>AW,linspace:()=>PP,localResponseNormalization:()=>LP,log:()=>zP,log1p:()=>BP,logSigmoid:()=>YP,logSoftmax:()=>JP,logSumExp:()=>ZP,logicalAnd:()=>eL,logicalNot:()=>tL,logicalOr:()=>nL,logicalXor:()=>rL,losses:()=>_W,lowerBound:()=>iL,matMul:()=>iO,max:()=>dP,maxPool:()=>oL,maxPool3d:()=>lL,maxPoolWithArgmax:()=>uL,maximum:()=>cL,mean:()=>dL,meshgrid:()=>fL,min:()=>hP,minimum:()=>mL,mirrorPad:()=>gL,mod:()=>yL,moments:()=>bL,movingAverage:()=>cB,mul:()=>TF,multiRNNCell:()=>vL,multinomial:()=>xL,neg:()=>KP,norm:()=>vP,notEqual:()=>wL,oneHot:()=>kL,ones:()=>pL,onesLike:()=>SL,op:()=>XD,outerProduct:()=>IL,pad:()=>CL,pad1d:()=>NL,pad2d:()=>TL,pad3d:()=>EL,pad4d:()=>AL,pool:()=>$L,pow:()=>pP,prelu:()=>RL,print:()=>SF,prod:()=>DL,raggedGather:()=>ML,raggedRange:()=>FL,raggedTensorToTensor:()=>OL,rand:()=>PL,randomGamma:()=>rz,randomNormal:()=>az,randomStandardNormal:()=>sz,randomUniform:()=>iz,randomUniformInt:()=>oz,range:()=>lz,real:()=>uz,reciprocal:()=>cz,relu:()=>dz,relu6:()=>hz,reshape:()=>nO,reverse:()=>pz,reverse1d:()=>fz,reverse2d:()=>mz,reverse3d:()=>gz,reverse4d:()=>yz,rfft:()=>Fz,round:()=>bz,rsqrt:()=>vz,scalar:()=>fP,scatterND:()=>dB,searchSorted:()=>sL,selu:()=>xz,separableConv2d:()=>wz,setdiff1dAsync:()=>kz,sigmoid:()=>oO,sign:()=>Sz,signal:()=>TW,sin:()=>Iz,sinh:()=>Cz,slice:()=>lO,slice1d:()=>Nz,slice2d:()=>Tz,slice3d:()=>Ez,slice4d:()=>Az,softmax:()=>_z,softplus:()=>XP,spaceToBatchND:()=>_L,sparse:()=>$W,sparseToDense:()=>hB,spectral:()=>NW,split:()=>Mz,sqrt:()=>mP,square:()=>gP,squaredDifference:()=>Oz,squeeze:()=>Pz,stack:()=>Lz,step:()=>zz,stridedSlice:()=>Bz,string:()=>RW,sub:()=>QP,sum:()=>yP,tan:()=>Wz,tanh:()=>uO,tensor:()=>JD,tensor1d:()=>Vz,tensor2d:()=>Uz,tensor3d:()=>jz,tensor4d:()=>Gz,tensor5d:()=>Hz,tensor6d:()=>qz,tensorScatterUpdate:()=>Jz,tile:()=>IP,topk:()=>Zz,transpose:()=>uB,truncatedNormal:()=>eB,unique:()=>tB,unsortedSegmentSum:()=>nB,unstack:()=>rB,upperBound:()=>aB,variable:()=>sB,where:()=>XO,whereAsync:()=>oB,zeros:()=>hL,zerosLike:()=>YO});function L1(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!=typeof e&&"number"!=typeof t){TR.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){let a=e[r],s=t[r];TR.assert(a<0||s<0||a===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function z1(e){return!("number"==typeof e||e.some((e=>e<0)))}function B1(e,t,n){let r=W1(e,n),a=!z1(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=W1(e.shape,r)})),!z1(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function W1(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var V1=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=fP(0),dM(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),L1(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,dM(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return JD([],[0].concat(this.elementShape));let n=this.readMany(e);return L1(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Lz(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return JD([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return L1(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),sO(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,rB(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=0===n?0:t.size/n,s=[];uM((()=>{t=nO(t,[1,n,a]);for(let n=0;n<e.length;++n){let i=[0,0===n?0:r[n-1],0],o=[1,e[n],a];s[n]=nO(lO(t,i,o),this.elementShape)}return s}));let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},U1=class e{get id(){return this.idTensor.id}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);L1(t,e.shape,"TensorList shape mismatch: "),dM(e)})),this.idTensor=fP(0),this.maxNumElements=r,dM(this.idTensor)}copy(){return new e([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.id))&&t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);L1(e,this.elementShape,"TensorList shape mismatch: ");let r=B1(this.elementShape,this.tensors,e);return uM((()=>{let e=this.tensors.map((e=>nO(e,r)));return Lz(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");let n=B1(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,L1(r.shape,e,"TensorList shape mismatch: "),nO(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(L1(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");dM(e),this.tensors.push(e)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new e([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let e=0;e<Math.min(this.tensors.length,t);++e)n.tensors[e]=this.tensors[e];return n}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);L1(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=B1(this.elementShape,this.tensors,t);return nO(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);L1(this.elementShape,t.shape,"TensorList shape mismatch: "),dM(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);L1(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=B1(this.elementShape,this.tensors,n);return 0===e.length?JD([],[0].concat(r)):uM((()=>{let t=e.map((e=>nO(this.tensors[e],r)));return Lz(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);L1(this.elementShape,t,"TensorList shape mismatch: ");let n=B1(this.elementShape,this.tensors,t);return 0===this.size()?JD([],[0].concat(n)):uM((()=>{let e=this.tensors.map((e=>nO(e,n)));return sO(e,0)}))}};var j1=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=A0("thenBranch",e,t,n),a=A0("elseBranch",e,t,n),s=A0("cond",e,t,n),i=A0("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=A0("body",e,t,n),a=A0("cond",e,t,n),s=A0("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map((e=>e.id)),l=await i[0].data();i.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&e.dispose()}));let u=s;for(;l[0];){let e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let t=u.map((e=>e.id));e.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}));let s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}))}return u}case"LoopCond":return[O0(A0("pred",e,t,n))];case"Switch":{let r=A0("pred",e,t,n),a=A0("data",e,t,n);return a.kept||(a=O0(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find((e=>void 0!==_0(e,t,n)));if(r){return[O0(_0(r,t,n))]}return}case"Enter":{let r=A0("frameName",e,t,n),a=A0("tensor",e,t,n);return n.enterFrame(r),[O0(a)]}case"Exit":{let r=A0("tensor",e,t,n);return n.exitFrame(),[O0(r)]}case"NextIteration":{let r=A0("tensor",e,t,n);return n.nextIteration(),[O0(r)]}case"TensorArrayV3":{let r=A0("size",e,t,n),a=A0("dtype",e,t,n),s=A0("elementShape",e,t,n),i=A0("dynamicSize",e,t,n),o=A0("clearAfterRead",e,t,n),l=A0("identicalElementShapes",e,t,n),u=A0("name",e,t,n),c=new V1(u,a,r,s,l,i,o);return n.addTensorArray(c),[c.idTensor,fP(1)]}case"TensorArrayWriteV3":{let r=A0("tensorArrayId",e,t,n),a=A0("index",e,t,n),s=A0("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=A0("tensorArrayId",e,t,n),a=A0("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=A0("tensorArrayId",e,t,n),a=A0("indices",e,t,n),s=A0("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=A0("tensorArrayId",e,t,n),a=A0("indices",e,t,n),s=A0("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=A0("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=A0("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=A0("tensorArrayId",e,t,n),a=A0("tensor",e,t,n),s=A0("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=A0("tensorArrayId",e,t,n);return[fP(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{let r=A0("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=A0("tensorListId",e,t,n),a=A0("index",e,t,n),s=A0("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=A0("tensorListId",e,t,n),a=A0("index",e,t,n),s=A0("elementShape",e,t,n),i=A0("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=A0("indices",e,t,n),a=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new U1([],n,e.dtype,r),i=rB(e,0);return t.forEach(((e,t)=>{s.setItem(e,i[t])})),s}(A0("tensor",e,t,n),r,A0("elementShape",e,t,n),A0("numElements",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r,a=A0("elementShape",e,t,n),s=A0("elementDType",e,t,n);r="TensorListReserve"===e.op?"numElements":"maxNumElements";let i=A0(r,e,t,n),o=function(e,t,n,r){return new U1([],e,t,r)}(a,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{let r=A0("tensorListId",e,t,n),a=A0("indices",e,t,n),s=A0("elementShape",e,t,n),i=A0("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=A0("tensorListId",e,t,n),a=A0("elementShape",e,t,n),s=A0("elementDType",e,t,n),i=A0("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=function(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);L1(e.shape.slice(1),t,"TensorList shape mismatch: ");let a=rB(e);return new U1(a,t,r)}(A0("tensor",e,t,n),A0("elementShape",e,t,n),A0("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=A0("tensorListId",e,t,n),a=n.getTensorList(r.id),s=A0("dtype",e,t,n),i=A0("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=A0("tensorListId",e,t,n),a=A0("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=A0("tensorListId",e,t,n),a=A0("elementShape",e,t,n),s=A0("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=A0("tensor",e,t,n),a=A0("elementShape",e,t,n),s=function(e,t,n){let r=0,a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);let s=W1(e.shape.slice(1),n),i=0===r?0:e.size/r,o=uM((()=>{let n=[];e=nO(e,[1,r,i]);for(let r=0;r<t.length;++r){let o=[0,0===r?0:a[r-1],0],l=[1,t[r],i];n[r]=nO(lO(e,o,l),s)}return e.dispose(),n})),l=new U1([],n,e.dtype,t.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(r,A0("lengths",e,t,n),a);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{let r=A0("tensorListId",e,t,n);return[fP(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{let r=A0("tensorListId",e,t,n),a=A0("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function G1(e,t,n){let[r,a]=A0("fusedOps",e,t,n),s="biasadd"===r,i=!s,o="prelu"===a,l="fusedbatchnorm"===r,u=A0("numArgs",e,t,n);if(s){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=A0("strides",e,t,n),d=F0(e,t,n),h=A0("dataFormat",e,t,n).toUpperCase(),p=A0("dilations",e,t,n),[f,m]=A0("args",e,t,n);return i&&(m=f,f=void 0),{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:A0("leakyreluAlpha",e,t,n)}}function H1(e,t,n){return{boxes:A0("boxes",e,t,n),scores:A0("scores",e,t,n),maxOutputSize:A0("maxOutputSize",e,t,n),iouThreshold:A0("iouThreshold",e,t,n),scoreThreshold:A0("scoreThreshold",e,t,n),softNmsSigma:A0("softNmsSigma",e,t,n)}}var q1=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=fP(0),this.tensorMap=new Map,dM(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return fP(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),uM((()=>{let e=rB(t),r=n.length,a=e.length;TR.assert(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){let r=n[t],a=e[t];dM(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return uM((()=>{let e=[];for(let r=0;r<n.length;r++){let a=n[r],s=this.findWithDefault(a,t);e.push(s)}return Lz(e)}))}findWithDefault(e,t){let n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};function K1(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:uM,s=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(A0("a",e,t,n),A0("b",e,t,n))];case"AddN":return[r.addN(A0("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(A0("a",e,t,n),A0("b",e,t,n))];case"Mul":return[r.mul(A0("a",e,t,n),A0("b",e,t,n))];case"RealDiv":case"Div":return[r.div(A0("a",e,t,n),A0("b",e,t,n))];case"DivNoNan":return[r.divNoNan(A0("a",e,t,n),A0("b",e,t,n))];case"FloorDiv":return[r.floorDiv(A0("a",e,t,n),A0("b",e,t,n))];case"Sub":return[r.sub(A0("a",e,t,n),A0("b",e,t,n))];case"Minimum":return[r.minimum(A0("a",e,t,n),A0("b",e,t,n))];case"Maximum":return[r.maximum(A0("a",e,t,n),A0("b",e,t,n))];case"Pow":return[r.pow(A0("a",e,t,n),A0("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(A0("a",e,t,n),A0("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"basic_math":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(A0("x",e,t,n))];case"Acos":return[r.acos(A0("x",e,t,n))];case"Acosh":return[r.acosh(A0("x",e,t,n))];case"Asin":return[r.asin(A0("x",e,t,n))];case"Asinh":return[r.asinh(A0("x",e,t,n))];case"Atan":return[r.atan(A0("x",e,t,n))];case"Atan2":return[r.atan2(A0("x",e,t,n),A0("y",e,t,n))];case"Atanh":return[r.atanh(A0("x",e,t,n))];case"Ceil":return[r.ceil(A0("x",e,t,n))];case"Complex":return[r.complex(A0("real",e,t,n),A0("imag",e,t,n))];case"Cos":return[r.cos(A0("x",e,t,n))];case"Cosh":return[r.cosh(A0("x",e,t,n))];case"Elu":return[r.elu(A0("x",e,t,n))];case"Erf":return[r.erf(A0("x",e,t,n))];case"Exp":return[r.exp(A0("x",e,t,n))];case"Expm1":return[r.expm1(A0("x",e,t,n))];case"Floor":return[r.floor(A0("x",e,t,n))];case"Log":return[r.log(A0("x",e,t,n))];case"Log1p":return[r.log1p(A0("x",e,t,n))];case"Imag":return[r.imag(A0("x",e,t,n))];case"Neg":return[r.neg(A0("x",e,t,n))];case"Reciprocal":return[r.reciprocal(A0("x",e,t,n))];case"Real":return[r.real(A0("x",e,t,n))];case"Relu":return[r.relu(A0("x",e,t,n))];case"Round":return[r.round(A0("x",e,t,n))];case"Selu":return[r.selu(A0("x",e,t,n))];case"Sigmoid":return[r.sigmoid(A0("x",e,t,n))];case"Sin":return[r.sin(A0("x",e,t,n))];case"Sign":return[r.sign(A0("x",e,t,n))];case"Sinh":return[r.sinh(A0("x",e,t,n))];case"Softplus":return[r.softplus(A0("x",e,t,n))];case"Sqrt":return[r.sqrt(A0("x",e,t,n))];case"Square":return[r.square(A0("x",e,t,n))];case"Tanh":return[r.tanh(A0("x",e,t,n))];case"Tan":return[r.tan(A0("x",e,t,n))];case"ClipByValue":return[r.clipByValue(A0("x",e,t,n),A0("clipValueMin",e,t,n),A0("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(A0("x",e,t,n))];case"Rsqrt":return[r.rsqrt(_0(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(A0("x",e,t,n),A0("alpha",e,t,n))];case"Prelu":return[r.prelu(A0("x",e,t,n),A0("alpha",e,t,n))];case"IsNan":return[r.isNaN(_0(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(_0(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(_0(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"control":return j1(e,t,n);case"convolution":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"Conv1D":{let a=A0("stride",e,t,n),s=A0("pad",e,t,n),i=A0("dataFormat",e,t,n).toUpperCase(),o=A0("dilation",e,t,n);return[r.conv1d(A0("x",e,t,n),A0("filter",e,t,n),a,s,i,o)]}case"Conv2D":{let a=A0("strides",e,t,n),s=F0(e,t,n),i=A0("dataFormat",e,t,n).toUpperCase(),o=A0("dilations",e,t,n);return[r.conv2d(A0("x",e,t,n),A0("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=G1(e,t,n);return[r.fused.conv2d({x:A0("x",e,t,n),filter:A0("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=G1(e,t,n);return[r.fused.depthwiseConv2d({x:A0("x",e,t,n),filter:A0("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=A0("outputShape",e,t,n),s=A0("strides",e,t,n),i=F0(e,t,n);return[r.conv2dTranspose(A0("x",e,t,n),A0("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=A0("strides",e,t,n),s=F0(e,t,n),i=A0("dilations",e,t,n),o=A0("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(A0("input",e,t,n),A0("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let a=A0("strides",e,t,n),s=A0("pad",e,t,n),i=A0("dataFormat",e,t,n).toUpperCase(),o=A0("dilations",e,t,n);return[r.conv3d(A0("x",e,t,n),A0("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let a=A0("strides",e,t,n),s=A0("pad",e,t,n),i=A0("kernelSize",e,t,n);return[r.avgPool(A0("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{let a=A0("strides",e,t,n),s=A0("pad",e,t,n),i=A0("kernelSize",e,t,n);return[r.maxPool(A0("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{let a=A0("strides",e,t,n),s=A0("pad",e,t,n),i=A0("kernelSize",e,t,n),o=A0("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(A0("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,u]}case"AvgPool3D":{let a=A0("strides",e,t,n),s=A0("pad",e,t,n),i=A0("kernelSize",e,t,n);return[r.avgPool3d(A0("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{let a=A0("strides",e,t,n),s=A0("pad",e,t,n),i=A0("kernelSize",e,t,n);return[r.maxPool3d(A0("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{let a=A0("strides",e,t,n),s=A0("pad",e,t,n),i=A0("dilations",e,t,n),o=a[1],l=a[2],u=i[1],c=i[2];return[r.dilation2d(A0("x",e,t,n),A0("filter",e,t,n),[o,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"creation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"Fill":{let a=A0("shape",e,t,n),s=A0("dtype",e,t,n),i=A0("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{let a=A0("start",e,t,n),s=A0("stop",e,t,n),i=A0("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{let a=A0("logits",e,t,n),s=A0("numSamples",e,t,n),i=A0("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{let a=A0("indices",e,t,n),s=A0("depth",e,t,n),i=A0("onValue",e,t,n),o=A0("offValue",e,t,n),l=A0("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(A0("shape",e,t,n),A0("dtype",e,t,n))];case"OnesLike":return[r.onesLike(A0("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(A0("shape",e,t,n),A0("dtype",e,t,n),A0("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(A0("shape",e,t,n),A0("minval",e,t,n),A0("maxval",e,t,n),A0("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(A0("shape",e,t,n),A0("minval",e,t,n),A0("maxval",e,t,n),A0("seed",e,t,n))];case"Range":{let a=A0("start",e,t,n),s=A0("stop",e,t,n),i=A0("step",e,t,n);return[r.range(a,s,i,A0("dtype",e,t,n))]}case"TruncatedNormal":{let a=A0("shape",e,t,n),s=A0("mean",e,t,n),i=A0("stdDev",e,t,n),o=A0("seed",e,t,n);return[r.truncatedNormal(a,s,i,A0("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(A0("shape",e,t,n),A0("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(A0("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"dynamic":return async function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:P1;switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=H1(e,t,n),c=await a.image.nonMaxSuppressionWithScoreAsync(r,s,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=H1(e,t,n),u=A0("padToMaxOutputSize",e,t,n),c=await a.image.nonMaxSuppressionPaddedAsync(r,s,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=H1(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,s,i,o,l)]}case"Where":{let r=a.cast(A0("condition",e,t,n),"bool"),s=[await a.whereAsync(r)];return r.dispose(),s}case"ListDiff":return a.setdiff1dAsync(A0("x",e,t,n),A0("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n);case"evaluation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"LowerBound":{let a=A0("sortedSequence",e,t,n),s=A0("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{let a=A0("x",e,t,n),s=A0("k",e,t,n),i=A0("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{let a=A0("sortedSequence",e,t,n),s=A0("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{let a=A0("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{let a=A0("x",e,t,n),s=A0("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"image":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"ResizeBilinear":{let a=A0("images",e,t,n),s=A0("size",e,t,n),i=A0("alignCorners",e,t,n),o=A0("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let a=A0("images",e,t,n),s=A0("size",e,t,n),i=A0("alignCorners",e,t,n),o=A0("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{let a=A0("image",e,t,n),s=A0("boxes",e,t,n),i=A0("boxInd",e,t,n),o=A0("cropSize",e,t,n),l=A0("method",e,t,n),u=A0("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{let a=A0("images",e,t,n),s=A0("transforms",e,t,n),i=A0("outputShape",e,t,n),o=A0("fillValue",e,t,n),l=A0("interpolation",e,t,n),u=A0("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"graph":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=A0("default",e,t,n);return[_0(e.name,t,n)||a];case"Placeholder":return[_0(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[O0(A0("x",e,t,n))];case"IdentityN":return A0("x",e,t,n).map((e=>O0(e)));case"Shape":return[r.tensor1d(A0("x",e,t,n).shape,"int32")];case"ShapeN":return A0("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(A0("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(A0("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let s=A0("x",e,t,n),i=A0("data",e,t,n),o=A0("message",e,t,n),l=A0("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"logical":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"Equal":return[r.equal(A0("a",e,t,n),A0("b",e,t,n))];case"NotEqual":return[r.notEqual(A0("a",e,t,n),A0("b",e,t,n))];case"Greater":return[r.greater(A0("a",e,t,n),A0("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(A0("a",e,t,n),A0("b",e,t,n))];case"Less":return[r.less(A0("a",e,t,n),A0("b",e,t,n))];case"LessEqual":return[r.lessEqual(A0("a",e,t,n),A0("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(A0("a",e,t,n),A0("b",e,t,n))];case"LogicalNot":return[r.logicalNot(A0("a",e,t,n))];case"LogicalOr":return[r.logicalOr(A0("a",e,t,n),A0("b",e,t,n))];case"Select":case"SelectV2":return[r.where(A0("condition",e,t,n),A0("a",e,t,n),A0("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(A0("a",e,t,n),A0("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"matrices":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(A0("a",e,t,n),A0("b",e,t,n),A0("transposeA",e,t,n),A0("transposeB",e,t,n))];case"Einsum":return[r.einsum(A0("equation",e,t,n),...A0("tensors",e,t,n))];case"Transpose":return[r.transpose(A0("x",e,t,n),A0("perm",e,t,n))];case"_FusedMatMul":let[a,s]=A0("fusedOps",e,t,n),i="biasadd"===a,o="prelu"===s,l=A0("numArgs",e,t,n),u=A0("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,d]=A0("args",e,t,n);return[r.fused.matMul({a:A0("a",e,t,n),b:A0("b",e,t,n),transposeA:A0("transposeA",e,t,n),transposeB:A0("transposeB",e,t,n),bias:c,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(A0("a",e,t,n),A0("numLower",e,t,n),A0("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"normalization":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(A0("x",e,t,n),A0("axis",e,t,n),A0("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(A0("x",e,t,n),A0("mean",e,t,n),A0("variance",e,t,n),A0("offset",e,t,n),A0("scale",e,t,n),A0("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(A0("x",e,t,n),A0("radius",e,t,n),A0("bias",e,t,n),A0("alpha",e,t,n),A0("beta",e,t,n))];case"Softmax":return[r.softmax(A0("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(A0("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"ragged":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(A0("paramsNestedSplits",e,t,n),A0("paramsDenseValues",e,t,n),A0("indices",e,t,n),A0("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(A0("starts",e,t,n),A0("limits",e,t,n),A0("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(A0("shape",e,t,n),A0("values",e,t,n),A0("defaultValue",e,t,n),A0("rowPartitionTensors",e,t,n),A0("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"reduction":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"Max":{let a=A0("axis",e,t,n),s=A0("keepDims",e,t,n);return[r.max(A0("x",e,t,n),a,s)]}case"Mean":{let a=A0("axis",e,t,n),s=A0("keepDims",e,t,n);return[r.mean(A0("x",e,t,n),a,s)]}case"Min":{let a=A0("axis",e,t,n),s=A0("keepDims",e,t,n);return[r.min(A0("x",e,t,n),a,s)]}case"Sum":{let a=A0("axis",e,t,n),s=A0("keepDims",e,t,n);return[r.sum(A0("x",e,t,n),a,s)]}case"All":{let a=A0("axis",e,t,n),s=A0("keepDims",e,t,n);return[r.all(A0("x",e,t,n),a,s)]}case"Any":{let a=A0("axis",e,t,n),s=A0("keepDims",e,t,n);return[r.any(A0("x",e,t,n),a,s)]}case"ArgMax":{let a=A0("axis",e,t,n);return[r.argMax(A0("x",e,t,n),a)]}case"ArgMin":{let a=A0("axis",e,t,n);return[r.argMin(A0("x",e,t,n),a)]}case"Prod":{let a=A0("axis",e,t,n),s=A0("keepDims",e,t,n);return[r.prod(A0("x",e,t,n),a,s)]}case"Cumprod":{let a=A0("axis",e,t,n),s=A0("exclusive",e,t,n),i=A0("reverse",e,t,n);return[r.cumprod(A0("x",e,t,n),a,s,i)]}case"Cumsum":{let a=A0("axis",e,t,n),s=A0("exclusive",e,t,n),i=A0("reverse",e,t,n);return[r.cumsum(A0("x",e,t,n),a,s,i)]}case"Bincount":let a=A0("x",e,t,n),s=A0("weights",e,t,n),i=A0("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{let a=A0("x",e,t,n),s=A0("weights",e,t,n),i=A0("size",e,t,n),o=A0("binaryOutput",e,t,n);return[r.denseBincount(a,s,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"slice_join":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"ConcatV2":case"Concat":{let a=A0("n",e,t,n),s=A0("axis",e,t,n),i=A0("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{let a=A0("x",e,t,n),s=A0("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{let a=A0("axis",e,t,n),s=A0("batchDims",e,t,n),i=A0("x",e,t,n),o=A0("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{let a=A0("dims",e,t,n),s=[];for(let e=0;e<a.length;e++)a[e]&&s.push(e);let i=A0("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{let a=A0("axis",e,t,n),s=A0("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{let a=A0("begin",e,t,n),s=A0("size",e,t,n);return[r.slice(A0("x",e,t,n),a,s)]}case"StridedSlice":{let a=A0("begin",e,t,n),s=A0("end",e,t,n),i=A0("strides",e,t,n),o=A0("beginMask",e,t,n),l=A0("endMask",e,t,n),u=A0("ellipsisMask",e,t,n),c=A0("newAxisMask",e,t,n),d=A0("shrinkAxisMask",e,t,n),h=A0("x",e,t,n);return[r.stridedSlice(h,a,s,i,o,l,u,c,d)]}case"Pack":return uM((()=>{let a=A0("axis",e,t,n),s=A0("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map((e=>{let t=TR.arraysEqual(e.shape,i);if(!t&&!TR.arraysEqual(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,a)]}));case"Unpack":{let a=A0("axis",e,t,n),s=A0("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{let a=A0("reps",e,t,n);return[r.tile(A0("x",e,t,n),a)]}case"Split":case"SplitV":{let a=A0("axis",e,t,n),s=A0("numOrSizeSplits",e,t,n),i=A0("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{let a=A0("indices",e,t,n),s=A0("values",e,t,n),i=A0("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{let a=A0("x",e,t,n),s=A0("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{let a=A0("sparseIndices",e,t,n),s=A0("outputShape",e,t,n),i=A0("sparseValues",e,t,n),o=A0("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let a=A0("indices",e,t,n),s=A0("values",e,t,n),i=A0("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"sparse":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(A0("indices",e,t,n),A0("values",e,t,n),A0("denseShape",e,t,n),A0("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{let{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(A0("inputIndices",e,t,n),A0("inputShape",e,t,n),A0("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(A0("data",e,t,n),A0("indices",e,t,n),A0("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(A0("data",e,t,n),A0("indices",e,t,n),A0("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"spectral":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"FFT":return[r.fft(A0("x",e,t,n))];case"IFFT":return[r.ifft(A0("x",e,t,n))];case"RFFT":return[r.rfft(A0("x",e,t,n))];case"IRFFT":return[r.irfft(A0("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"string":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(A0("input",e,t,n),A0("pattern",e,t,n),A0("rewrite",e,t,n),A0("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(A0("data",e,t,n),A0("dataSplits",e,t,n),A0("separator",e,t,n),A0("nGramWidths",e,t,n),A0("leftPad",e,t,n),A0("rightPad",e,t,n),A0("padWidth",e,t,n),A0("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{let{indices:a,values:s,shape:i}=r.string.stringSplit(A0("input",e,t,n),A0("delimiter",e,t,n),A0("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(A0("input",e,t,n),A0("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"transformation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P1;switch(e.op){case"Cast":return[r.cast(A0("x",e,t,n),A0("dtype",e,t,n))];case"ExpandDims":{let a=A0("axis",e,t,n);return[r.expandDims(A0("x",e,t,n),a)]}case"Squeeze":{let a=A0("axis",e,t,n);return[r.squeeze(A0("x",e,t,n),a)]}case"Reshape":return[r.reshape(A0("x",e,t,n),A0("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(A0("x",e,t,n),A0("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(A0("x",e,t,n),A0("padding",e,t,n),A0("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(A0("x",e,t,n),A0("padding",e,t,n),A0("constantValue",e,t,n))];case"SpaceToBatchND":{let a=A0("blockShape",e,t,n),s=A0("paddings",e,t,n);return[r.spaceToBatchND(A0("x",e,t,n),a,s)]}case"BatchToSpaceND":{let a=A0("blockShape",e,t,n),s=A0("crops",e,t,n);return[r.batchToSpaceND(A0("x",e,t,n),a,s)]}case"DepthToSpace":{let a=A0("blockSize",e,t,n),s=A0("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(A0("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(A0("x",e,t,n),A0("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(A0("s0",e,t,n),A0("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(null!=a)return[a];{let a=A0("keyDType",e,t,n),s=A0("valueDType",e,t,n),i=new q1(a,s);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=A0("tableHandle",e,t,n,r),s=A0("keys",e,t,n),i=A0("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=A0("tableHandle",e,t,n,r),s=A0("keys",e,t,n),i=A0("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=A0("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":let s=T0(e.op);if(s&&s.customExecutor)return s.customExecutor(new O1(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return TR.isPromise(s)?s.then((e=>[].concat(e))):[].concat(s)}var X1=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function Y1(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map((e=>M0(e)[0])));r=r||[];let c=new Set(r.map((e=>M0(e.name)[0]))),d=[...t];for(;d.length>0;){let e=d.pop();if((n2(e)||r2(e)||a2(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&!u.has(e.name)&&!c.has(e.name)){if(0===e.inputs.length){s.push(e.name);continue}e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))}))}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function Q1(e,t){let{usedNodes:n,inputs:r}=t,a=Object.keys(r).map((e=>M0(e)[0])).map((t=>e.nodes[t])),s=e.initNodes||[],i=e=>n.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}let l=o([...a,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map((e=>[e.name,e]))),d={};for(let m of u){d[m.name]=d[m.name]||0;for(let e of m.children)i(e)||(d[e.name]=Number.POSITIVE_INFINITY),d[e.name]=(d[e.name]||0)+1}let h=Object.entries(d).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...h];for(;h.length>0;){let e=h.pop(),t=c.get(e);for(let n of t.children.filter(i))0===--d[n.name]&&(p.push(n.name),h.push(n.name))}let f=function(e,t){let n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),a=new Set(r);for(;r.length>0;){let e=r.pop(),t=n.get(e);for(let s of t.children)!n.has(s.name)||a.has(s.name)||(a.add(s.name),r.push(s.name))}return e.filter((e=>a.has(e.name)))}(p.map((e=>c.get(e))),l);return function(e,t){let n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),a=e=>r.has("string"==typeof e?e:e.name),s=new Set(e.map((e=>e.name))),i=e=>s.has("string"==typeof e?e:e.name);for(let o of e){for(let e of o.children.filter(i)){if(!n.has(e.name))throw new J1(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new J1(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!a(o))for(let e of o.inputs){if(!n.has(e.name))throw new J1(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new J1(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}var J1=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};var Z1=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),e2=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),t2=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function n2(e){return Z1.has(e.op)}function r2(e){return e2.has(e.op)}function a2(e){return t2.has(e.op)}var s2=class e{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((n=>{this._functionExecutorMap[n]=new e(t.functions[n],this)}))}getCompilationKey(e,t){let n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){let n=Y1(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){let n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}let i=Q1(this.graph,n),o=function(e){let t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>n2(e)?n:t)),a=e=>{let n=r[t.get(e.name)];return null==n?-1:n},s=e.map(((e,t)=>e.children.map(a).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){let t=s[o];if(t===n)continue;let r=e[o],a=e[t];i.has(a.name)||i.set(a.name,[]),i.get(a.name).push(r)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;let t=e.clone();return dM(t),t}cloneTensorList(e){return e?e.map((e=>this.cloneAndKeepTensor(e))):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map((e=>this.graph.nodes[M0(e)[0]])),a=t.map((e=>M0(e)[0])),s=new Set(a),i=a.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);let o=this.getCompilationKey(r,i),l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=GE().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let u={},c={};return uM((()=>{let n=new X1(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{let[a,s]=M0(t,n),i=[];i[s]=e[t],r[a]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(i))}));let a=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(let e of i){if(r[e.name])continue;let t=K1(e,r,n,this._resourceManager);if(TR.isPromise(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,a,s,o.get(e.name))}return null==this.parent&&n.dispose(a),t.map((e=>_0(e,r,n)))}))}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,i){if(!n2(t)&&!s.has(e)){for(let r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(let e of t.inputs){if(n2(e))continue;let t=$0(e.name,n,r);if(null!=t)for(let e of t){if(!e||e.kept||a.has(e.id))continue;let t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,a,s){function i(e){return n2(e)||a.has(e.name)}if(!n2(e)&&null!=s)for(let o of s){if(i(o))continue;let e=$0(o.name,t,n);for(let t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=GE().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let s=new X1(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let i=await this.executeWithControlFlow(e,s,t,n),o=t.map((e=>_0(e,i,s))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{e&&!e.isDisposed&&!c.has(e.id)&&e.dispose()}))})),null==this.parent&&s.dispose(c),o}async executeFunctionAsync(e,t,n){let r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let a=Object.keys(e),s=a.map((e=>this.graph.nodes[M0(e)[0]])),i=n.map((e=>M0(e)[0])),o=new Set(i),l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);let{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:h}=Y1(e,l,this.weightMap,this._initNodes),p=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{let[n,r]=M0(t),a=[];a[r]=e[t],f[n]=a}));let m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){let e=this.processStack(s,p,t,f,y,g,o,m,u);await Promise.all(e)}null==d&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=l.filter((e=>!n2(e)&&!_0(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,a,s,i,o,l){let u=[];for(;t.length>0;){let e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&A0("isConstant",e.node,r,n)&&([c]=R0(e.node.name,n)),null==r[e.node.name]){let d=K1(e.node,r,n,this._resourceManager);c||([c]=R0(e.node.name,n));let h=n.currentContext;TR.isPromise(d)?u.push(d.then((u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=h,this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{let[i]=R0(e.name,n);a[i]||!s.has(e.name)||("Merge"===e.op?e.inputNames.some((e=>!!_0(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!_0(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{let n=e[t],[r]=M0(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){let e=a.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));TR.assert(t,(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&TR.assert(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;let r={};for(let a in e){let s=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[a];null!=s?r[s.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){let t=Object.keys(e).filter((e=>{let[t]=M0(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;let r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{let[t]=M0(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}},i2=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},o2="?tfjs-format=file",l2="model.json",u2=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:XW;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new i2}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return TR.isPromise(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");let t=await AM(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new s2(w1.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=w1.Instance.transformGraph(e.modelInitializer);this.initializer=new s2(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){let t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t={};return(e instanceof dD?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof dD)&&!Array.isArray(e)){let n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(let t in n){let r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var a,s,i;let o=null===(i=null===(s=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===s?void 0:s[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=t[n[r]];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&cM(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function c2(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:XW;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){return e.endsWith("/")||(e+="/"),`${e}${l2}${o2}`}(e));let r=new u2(e,t,n);return await r.load(),r}function d2(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");let a=XW.getWeightSpecs(n.weightsManifest),s=XW.getModelArtifactsForJSONSync(n,a,r);t=XW.fromMemorySync(s)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=XW.fromMemorySync(e)}let n=new u2(t);return n.load(),n}var h2="4.16.0",p2={};kT(p2,{CSVDataset:()=>s3,Dataset:()=>H2,FileDataSource:()=>b3,TextLineDataset:()=>J2,URLDataSource:()=>v3,array:()=>K2,csv:()=>x3,func:()=>w3,generator:()=>k3,microphone:()=>I3,version_data:()=>C3,webcam:()=>S3,zip:()=>X2});var f2=ST(FT()),m2=ST(FT());function g2(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(w2(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let s in e){let i=g2(e[s],t,n,r);a[s]=i}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function y2(e){return b2(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:v2)}function b2(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set,r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(w2(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let s in r){let r=b2(e.map((e=>e[s])),t,n);a[s]=r}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function v2(e){return null===e?null:w2(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function x2(e,t){let n=new Map;g2(e,t,n);for(let r of Array.from(n.keys())){let e=n.get(r);if(TR.isPromise(e)){let t=await e;n.set(r,t)}}return g2(e,t,n)}function w2(e){let t=!1;if(GE().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=OT();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof dD)&&!(e instanceof Promise)&&!t)}function k2(e){return function(e,t){return g2(e,t)}(e,S2)}function S2(e){return e instanceof dD?{value:e.clone(),recurse:!1}:w2(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var I2=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},C2=class e extends I2{constructor(){super(e.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};function N2(e){return new _2(e)}function T2(e){return new $2(e)}C2.INITIAL_CAPACITY=32;var E2,A2=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new L2(this,e)}filter(e){return new O2(this,e)}map(e){return new P2(this,e)}mapAsync(e){return new z2(this,e)}serialMapAsync(e){return new z2(this,e).serial()}flatmap(e){return new W2(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new F2(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:v2;return this.rowMajorBatch(e,t).map((e=>y2(e,n)))}concatenate(e,t){return new V2(N2([this,e]),t)}take(e){return e<0||null==e?this:new M2(this,e)}skip(e){return e<0||null==e?this:new D2(this,e)}prefetch(e){return new j2(this,e)}shuffle(e,t){return new G2(this,e,t)}serial(){return new R2(this)}},_2=class extends A2{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:k2(e),done:!1}}},$2=class extends A2{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(mD){throw mD.message=`Error thrown while iterating through a dataset: ${mD.message}`,mD}}},R2=class extends A2{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}},D2=class extends A2{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;cM(e.value)}return this.upstream.next()}},M2=class extends A2{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},F2=class extends A2{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},O2=class extends A2{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;cM(e.value)}}},P2=class extends A2{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=xD.getTensorsInContainer(e.value),n=this.transform(e.value),r=xD.getTensorsInContainer(n);for(let a of t)xD.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},L2=class extends A2{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(mD){if(!this.handler(mD))return{value:null,done:!0}}}},z2=class extends A2{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=xD.getTensorsInContainer(e.value),n=await this.transform(e.value),r=xD.getTensorsInContainer(n);for(let a of t)xD.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},B2=class extends A2{constructor(){super(),this.outputQueue=new C2,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},W2=class extends B2{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=xD.getTensorsInContainer(e.value),n=this.transform(e.value),r=xD.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)xD.isTensorInList(a,r)||a.dispose();return!0}},V2=class extends A2{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(E2||(E2={}));var U2=class extends A2{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:E2.FAIL;super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;let r=await x2(this.iterators,(function(e){return e instanceof A2?{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}:{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case E2.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case E2.SHORTEST:return{value:null,done:!0};case E2.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},j2=class extends A2{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new I2(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},G2=class extends j2{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=m2.alea(n||TR.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},H2=class{constructor(){this.size=null}batch(e){let t,n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=this;return TR.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),t=this.size===1/0||null==this.size?this.size:n?Math.ceil(this.size/e):Math.floor(this.size/e),q2((async()=>(await r.iterator()).columnMajorBatch(e,n,Y2)),t)}concatenate(e){let t,n=this;return t=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,q2((async()=>(await n.iterator()).concatenate(await e.iterator())),t)}filter(e){let t,n=this;return t=this.size===1/0?1/0:null,q2((async()=>(await n.iterator()).filter((t=>uM((()=>e(t)))))),t)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return q2((async()=>(await t.iterator()).map((t=>uM((()=>e(t)))))),this.size)}mapAsync(e){let t=this;return q2((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return q2((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){let t,n=this;return t=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,q2((async()=>function(e,t){return new V2(e,t)}(T2((async()=>({value:await n.iterator(),done:!1}))).take(e))),t)}skip(e){let t,n=this;return t=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,q2((async()=>(await n.iterator()).skip(e)),t)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=f2.alea(t||TR.now().toString());return q2((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){let t,n=this;return t=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,q2((async()=>(await n.iterator()).take(e)),t)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function q2(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends H2{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function K2(e){return q2((async()=>N2(e)),e.length)}function X2(e){if(!w2(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return q2((async()=>function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:E2.FAIL;return new U2(e,t)}(await x2(e,(e=>{if(e instanceof H2)return{value:e.iterator(),recurse:!1};if(w2(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),E2.SHORTEST)),t)}function Y2(e){if(null===e)return null;return function(e){return null==e||function(e){return null===e||"object"!=typeof e&&"function"!=typeof e}(e)||Array.isArray(e)||"object"==typeof e&&e instanceof dD||TR.isTypedArray(e)}(e[0])?{value:Q2(e),recurse:!1}:{value:null,recurse:!0}}function Q2(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof dD?Lz(e):JD(e)}H2.MAX_BUFFER_SIZE=1e4;var J2=class extends H2{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}},Z2='"',e3=Symbol("out"),t3=Symbol("field"),n3=Symbol("quote"),r3=Symbol("quoteafterquote"),a3=Symbol("quoteinquote"),s3=class extends H2{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&TR.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(TR.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(let r of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(r))throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new J2(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(TR.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||i){let o=t[a],l=null;if(""===o)if(i&&void 0!==i.default)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let e=Number(o);if(isNaN(e))l=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o)}else l=e}i&&i.isLabel?r[s]=l:n[s]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=[],r=0,a=e.length,s=e3;for(let i=0;i<a;i++)switch(s){case e3:switch(e.charAt(i)){case Z2:r=i+1,s=n3;break;case this.delimiter:if(r=i+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=e3;break;default:s=t3,r=i}break;case t3:if(e.charAt(i)===this.delimiter)n.push(e.substring(r,i)),s=e3,r=i+1;break;case n3:if(e.charAt(i)===Z2)s=r3;break;case r3:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),s=e3,r=i+1;break;case Z2:s=n3;break;default:s=a3}break;case a3:if(e.charAt(i)===Z2)s=n3}if(s===r3?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},i3=class e extends A2{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!GE().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new e(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise((r=>{let a=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(TR.sizeFromShape(t));return n.set(e,n.length-e.length),JD(n,t)}},o3=class e extends A2{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Vz([0],"int32"),this.webcamConfig.centerCrop){let e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,a=n+e,s=t+r;this.cropBox=Uz([r,n,s,a],[1,4])}else this.cropBox=Uz([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!GE().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new e(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&TR.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=bV.fromPixels(this.webcamVideoElement)}catch(Pye){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(Pye)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(Pye){throw new Error(`Error thrown cropping the video: ${Pye.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return uM((()=>{let t,n=kP(wF(e,"float32"),0);t=EW.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=t.shape;return nO(t,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},l3=class{},u3=class extends A2{split(e){return new c3(this,e)}},c3=class extends u3{constructor(e,t){super(),this.upstream=e,this.impl=new d3(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},d3=class extends B2{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},h3=class extends A2{decodeUTF8(){return new p3(this)}},p3=class extends u3{constructor(e){super(),this.upstream=e,this.impl=new f3(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},f3=class extends B2{constructor(e){if(super(),this.upstream=e,GE().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=OT();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e,t,n=await this.upstream.next();return!n.done&&(e=n.value,t=GE().get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(t),!0)}},m3=class extends h3{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.file=e,this.options=t,TR.assert(e instanceof Uint8Array||!!GE().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise(((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=n=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(a)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n})),done:!1}}};var g3=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function y3(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var b3=class extends l3{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.input=e,this.options=t}async iterator(){if(y3(this.input)&&GE().get("IS_NODE")){let e=PT();this.input=e.readFileSync(this.input.slice(7))}return new m3(this.input,this.options)}},v3=class extends l3{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.url=e,this.fileOptions=t}async iterator(){return y3(this.url)?new b3(this.url,this.fileOptions).iterator():async function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2?arguments[2]:void 0;"string"==typeof e?t=e:(t=e.url,n=g3(e));let s=await(a||TR.fetch)(t,n);if(s.ok){let e=new Uint8Array(await s.arrayBuffer());return new m3(e,r)}throw new Error(s.statusText)}(this.url,this.fileOptions)}};function x3(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new s3(new v3(e),t)}function w3(e){let t=T2(e);return q2((async()=>t))}function k3(e){return q2((async()=>{let t=await e();return T2((()=>t.next()))}))}async function S3(e,t){return o3.create(e,t)}async function I3(e){return i3.create(e)}var C3="4.16.0";function N3(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&TR.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}var T3=lj.whereImpl,E3=class e extends HT{nextDataId(){return e.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new GT(this,iM())}write(e,t,n){this.firstUse&&(this.firstUse=!1,GE().get("IS_NODE")&&nU.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&TR.isString(n[0])){let a=n.map((e=>TR.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return nU.mergeRealAndImagArrays(e,t)}return TR.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>TR.decodeString(e)));return xF(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return xF(e.shape,e.dtype,t)}makeOutput(e,t,n){return iM().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=TR.now();return e(),{kernelMs:TR.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){N3([e],"where");let t=this.readSync(e.dataId);return T3(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};E3.nextDataId=0;var A3={};function _3(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}kT(A3,{addImpl:()=>G3,bincountImpl:()=>X3,bincountReduceImpl:()=>Y3,bitwiseAndImpl:()=>Q3,castImpl:()=>B3,ceilImpl:()=>r4,concatImpl:()=>i4,equalImpl:()=>o4,expImpl:()=>c4,expm1Impl:()=>p4,floorDivImpl:()=>v4,floorImpl:()=>g4,gatherNdImpl:()=>k4,gatherV2Impl:()=>S4,greaterEqualImpl:()=>T4,greaterImpl:()=>I4,lessEqualImpl:()=>D4,lessImpl:()=>_4,linSpaceImpl:()=>O4,logImpl:()=>P4,maxImpl:()=>B4,maximumImpl:()=>W4,minimumImpl:()=>j4,multiplyImpl:()=>q4,negImpl:()=>Q4,notEqualImpl:()=>Z4,prodImpl:()=>s5,raggedGatherImpl:()=>c5,raggedRangeImpl:()=>h5,raggedTensorToTensorImpl:()=>y5,rangeImpl:()=>b5,rsqrtImpl:()=>v5,scatterImpl:()=>k5,sigmoidImpl:()=>S5,simpleAbsImpl:()=>_3,sliceImpl:()=>N5,sparseFillEmptyRowsImpl:()=>A5,sparseReshapeImpl:()=>_5,sparseSegmentReductionImpl:()=>$5,sqrtImpl:()=>R5,squaredDifferenceImpl:()=>F5,staticRegexReplaceImpl:()=>L5,stridedSliceImpl:()=>W5,stringNGramsImpl:()=>U5,stringSplitImpl:()=>G5,stringToHashBucketFastImpl:()=>H5,subImpl:()=>q5,tileImpl:()=>Q5,topKImpl:()=>e6,transposeImpl:()=>n5,uniqueImpl:()=>t6});var $3={kernelName:YE,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend;N3(t,"abs");let r=new Float32Array(TR.sizeFromShape(t.shape));return r=_3(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function R3(e){return(t,n,r,a,s)=>{let i=nU.assertAndGetBroadcastShape(t,n),o=i.length,l=TR.computeStrides(i),u=TR.sizeFromShape(i),c=TR.getTypedArrayFromDType(s,u),d=t.length,h=n.length,p=TR.computeStrides(t),f=TR.computeStrides(n),m=nU.getBroadcastDims(t,i),g=nU.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<c.length;++y){let t=TR.indexToLoc(y,o,l),n=t.slice(-d);m.forEach((e=>n[e]=0));let s=TR.locToIndex(n,d,p),i=t.slice(-h);g.forEach((e=>i[e]=0));let u=TR.locToIndex(i,h,f);c[y]=e(r[s],a[u])}return[c,i]}}function D3(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var M3={kernelName:SA,backendName:"cpu",kernelFunc:D3};function F3(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return D3({inputs:{real:F3(e,t,"float32"),imag:F3(e,t,"float32")},backend:e})}let r=TR.makeZerosTypedArray(TR.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function O3(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var P3={kernelName:h_,backendName:"cpu",kernelFunc:O3};function L3(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var z3={kernelName:c$,backendName:"cpu",kernelFunc:L3};function B3(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){let r=TR.toTypedArray([0],n),[a,s]=R3(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function W3(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return O3({inputs:{x:a},backend:n});let e=F3(n,a.shape,a.dtype),t=W3({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=D3({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=L3({inputs:{input:a},backend:n}),t=W3({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!TR.hasEncodingLoss(a.dtype,s)){let e=O3({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}let i=n.data.get(a.dataId).values,[o,l,u]=B3(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,u)}var V3={kernelName:xA,backendName:"cpu",kernelFunc:W3};function U3(e,t,n,r){return null==n?n=>{let{inputs:a,backend:s}=n,{a:i,b:o}=a,l=s;N3([i,o],e);let u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d="string"===i.dtype?nU.fromUint8ToStringArray(u):u,h="string"===i.dtype?nU.fromUint8ToStringArray(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:e=>{let{inputs:a,backend:s}=e,{a:i,b:o}=a,l=s;if("complex64"===i.dtype||"complex64"===o.dtype){let e=W3({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,s=l.data.get(r.dataId).values,u=l.data.get(a.dataId).values,c=W3({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=l.data.get(h.dataId).values,m=l.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,s,u,f,m),v=l.makeTensorInfo(b,"float32",g),x=l.makeTensorInfo(b,"float32",y),w=D3({inputs:{real:v,imag:x},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(x),w}{let e=l.data.get(i.dataId).values,n=l.data.get(o.dataId).values,a=r||i.dtype,[s,u]=t(i.shape,o.shape,e,n,a);return l.makeTensorInfo(u,a,s)}}}function j3(e){return(t,n,r,a,s,i)=>{let o=nU.assertAndGetBroadcastShape(t,n),l=TR.sizeFromShape(o),u=o.length,c=TR.computeStrides(o),d=TR.getTypedArrayFromDType("float32",l),h=TR.getTypedArrayFromDType("float32",l),p=nU.getBroadcastDims(t,o),f=nU.getBroadcastDims(n,o),m=nU.mergeRealAndImagArrays(r,a),g=nU.mergeRealAndImagArrays(s,i),y=t.length,b=TR.computeStrides(t),v=n.length,x=TR.computeStrides(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){let t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=r.real,h[w]=r.imag}else for(let w=0;w<d.length;w++){let t=TR.indexToLoc(w,u,c),n=t.slice(-y);p.forEach((e=>n[e]=0));let r=TR.locToIndex(n,y,b),a=t.slice(-v);f.forEach((e=>a[e]=0));let s=TR.locToIndex(a,v,x),i=e(m[2*r],m[2*r+1],g[2*s],g[2*s+1]);d[w]=i.real,h[w]=i.imag}return[d,h,o]}}var G3=R3(((e,t)=>e+t)),H3=j3(((e,t,n,r)=>({real:e+n,imag:t+r}))),q3=U3(ZE,G3,H3),K3={kernelName:ZE,backendName:"cpu",kernelFunc:q3};function X3(e,t,n,r,a){let s=TR.sizeFromShape(r),i=TR.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=s>0?t[o]:1)}return i}function Y3(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e.shape[0],s=e.shape[1],i=xF([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){let s=e.get(o,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}var Q3=R3(((e,t)=>e&t)),J3=U3(yA,Q3),Z3={kernelName:yA,backendName:"cpu",kernelFunc:J3};function e4(e){return(t,n,r)=>{let a=TR.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function t4(e,t,n){return n4(e,e4(t),n)}function n4(e,t,n){return r=>{let{inputs:a,attrs:s,backend:i}=r,{x:o}=a;N3(o,e);let l,u=i,c=u.data.get(o.dataId).values;if("string"===o.dtype){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");l=nU.fromUint8ToStringArray(c)}else l=c;let d=n||o.dtype,h=t(l,d,s);return u.makeTensorInfo(o.shape,d,h)}}var r4=e4((e=>Math.ceil(e))),a4=n4(wA,r4),s4={kernelName:wA,backendName:"cpu",kernelFunc:a4};function i4(e,t,n,r){let a=TR.getArrayFromDType(n,TR.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{let n=TR.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{let s="string"===n?nU.fromUint8ToStringArray(e.vals):e.vals,i=0;for(let n=0;n<e.shape[0];++n){let o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]}))}return a}var o4=R3(((e,t)=>e===t?1:0)),l4=U3(JA,o4,null,"bool"),u4={kernelName:JA,backendName:"cpu",kernelFunc:l4},c4=e4((e=>Math.exp(e))),d4=n4(ZA,c4,"float32"),h4={kernelName:ZA,backendName:"cpu",kernelFunc:d4},p4=e4((e=>Math.expm1(e))),f4=n4(t_,p4),m4={kernelName:t_,backendName:"cpu",kernelFunc:f4},g4=e4((e=>Math.floor(e))),y4=n4(s_,g4),b4={kernelName:s_,backendName:"cpu",kernelFunc:y4},v4=R3(((e,t)=>Math.floor(e/t))),x4=U3(i_,v4,null,"int32"),w4={kernelName:i_,backendName:"cpu",kernelFunc:x4};function k4(e,t,n,r,a,s,i,o,l){let u=xF([r,s],n);for(let c=0;c<r;c++){let n=[],r=0;for(let t=0;t<a;t++){let s=e[c*a+t];r+=s*i[t],n.push(s)}if(r<0||r>=l/s)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<s;e++)u.values[c*s+e]=t.get(...t.indexToLoc(r*s+e))}return u}function S4(e,t,n){let r=xF(n,e.dtype);for(let a=0;a<r.size;++a){let n=r.indexToLoc(a).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];let l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}var I4=R3(((e,t)=>e>t?1:0)),C4=U3(c_,I4,null,"bool"),N4={kernelName:c_,backendName:"cpu",kernelFunc:C4},T4=R3(((e,t)=>e>=t?1:0)),E4=U3(d_,T4,null,"bool"),A4={kernelName:d_,backendName:"cpu",kernelFunc:E4},_4=R3(((e,t)=>e<t?1:0)),$4=U3(v_,_4,null,"bool"),R4={kernelName:v_,backendName:"cpu",kernelFunc:$4},D4=R3(((e,t)=>e<=t?1:0)),M4=U3(x_,D4,null,"bool"),F4={kernelName:x_,backendName:"cpu",kernelFunc:M4};function O4(e,t,n){let r=(t-e)/(n-1),a=TR.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}var P4=e4((e=>Math.log(e))),L4=n4(k_,P4),z4={kernelName:k_,backendName:"cpu",kernelFunc:L4};function B4(e,t,n,r){let a=TR.getTypedArrayFromDType(r,TR.sizeFromShape(n));for(let s=0;s<a.length;++s){let n=s*t,r=e[n];for(let a=0;a<t;++a){let t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[s]=r}return a}var W4=R3(((e,t)=>Math.max(e,t))),V4=U3(M_,W4),U4={kernelName:M_,backendName:"cpu",kernelFunc:V4},j4=R3(((e,t)=>Math.min(e,t))),G4=U3(V_,j4),H4={kernelName:V_,backendName:"cpu",kernelFunc:G4},q4=R3(((e,t)=>e*t)),K4=j3(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),X4=U3(H_,q4,K4),Y4={kernelName:H_,backendName:"cpu",kernelFunc:X4};function Q4(e,t,n){let r=TR.createScalarValue(-1,n);return q4([],t,r,e,n)}var J4={kernelName:q_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t;N3(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=Q4(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}},Z4=R3(((e,t)=>e!==t?1:0)),e5=U3(K_,Z4,null,"bool"),t5={kernelName:K_,backendName:"cpu",kernelFunc:e5};function n5(e,t,n,r,a){let s=t.length,i=TR.sizeFromShape(t),o=TR.computeStrides(t),l=TR.computeStrides(a),u=TR.getTypedArrayFromDType(n,TR.sizeFromShape(a));for(let c=0;c<i;++c){let t=TR.indexToLoc(c,s,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[TR.locToIndex(n,s,l)]=e[c]}return u}function r5(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;N3(a,"transpose");let i=a.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=a.shape[s[u]];let l=n5(r.data.get(a.dataId).values,a.shape,a.dtype,s,o);return{dataId:r.write(l,o,a.dtype),shape:o,dtype:a.dtype}}var a5={kernelName:nR,backendName:"cpu",kernelFunc:r5};function s5(e,t,n,r){let[a,s]=nU.computeOutAndReduceShapes(e,r),i=kD(t,"int32"),o=TR.makeZerosTypedArray(TR.sizeFromShape(a),i),l=TR.sizeFromShape(s);for(let u=0;u<o.length;++u){let e=u*l,t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:a,outDtype:i}}var i5={kernelName:s$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;N3(a,"prod");let o=a.shape.length,l=TR.parseAxisParam(s,a.shape),u=nU.getAxesPermutation(l,o),c=l,d=a,h=[];null!=u&&(d=r5({inputs:{x:a},backend:n,attrs:{perm:u}}),h.push(d),c=nU.getInnerMostAxes(c.length,o));let p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=s5(d.shape,d.dtype,p,c),y=m;return i&&(y=nU.expandShapeToKeepDim(m,l)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function o5(e,t,n,r){let a=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){let a=n[e],s=e+t.length-1;if(s>=0){let e=o[s],t=e[e.length-1]-a[r];for(let n=r;n<i;++n)o[s].push(a[n+1]+t)}r=a[r],i=a[i]}i!==r&&(a.push([r,i]),s+=i-r)}return{outSplits:o,valueSlices:a,numValues:s}}function l5(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function u5(e,t,n,r,a){let s=t.slice();s[0]=a;let i=TR.getArrayFromDType(n,TR.sizeFromShape(s)),o=e.length;return function(e,t,n,r,a,s){let i=l5(t,2)[1],o=l5(s,2)[1],l=0;for(let u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)a[l*o+n]=e[t*i+n];++l}}(e,t,r,0===o?0:o/t[0],i,s),[i,s]}function c5(e,t,n,r,a,s,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){let a=TR.indexToLoc(r,t.length,TR.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(s,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");let l=r[0],{outSplits:u,valueSlices:c,numValues:d}=o5(s,i,e,l),h=function(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=TR.getArrayFromDType("int32",r);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(u),p=u5(n,r,a,c,d);return[h,p[0],p[1]]}var d5=2147483647;function h5(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=0===t.length,l=0===a.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(a[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");let d=0===c.length?1:c[0],h=TR.getArrayFromDType("int32",d+1);h[0]=0;for(let g=0;g<d;++g){let t,n=o?e[0]:e[g],a=l?r[0]:r[g],i=u?s[0]:s[g];if(0===i)throw new Error("Requires delta != 0");if(i>0&&a<n||i<0&&a>n)t=0;else if(t=Math.ceil(Math.abs((a-n)/i)),t>d5)throw new Error(`Requires ((limit - start) / delta) <= ${d5}`);h[g+1]=h[g]+t}let p=h[d],f=TR.getArrayFromDType(n,p),m=0;for(let g=0;g<d;++g){let t=h[g+1]-h[g],n=o?e[0]:e[g],r=u?s[0]:s[g];for(let e=0;e<t;++e)f[m++]=n,n+=r}return[h,f]}var p5=nU.RowPartitionType,f5=class e{constructor(e,t,n,r,a,s,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=nU.getRowPartitionTypesHelper(u),this.raggedRank=nU.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===p5.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===p5.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case p5.VALUE_ROWIDS:return e.getMaxWidthValueRowID(n);case p5.ROW_SPLITS:return e.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${p5[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){let t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){let t=e[s];t!==r&&(r=t,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return g5(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;nU.validateDefaultValueShape(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=nU.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let s=1;s<=this.raggedRank;++s)a[s]<0&&(a[s]=this.getMaxWidth(s));return a}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),a=[],s=0;for(let i=0;i<r;++i,s+=t)a.push(s);for(let i=r;i<e;++i)a.push(-1);return TR.assert(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){let a=e.length,s=[];for(let i=0;i<a-1;++i){let a=e[i+1]-e[i],o=Math.min(r,a),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)s.push(l),l+=n;for(let e=0;e<a-o;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){let a=e.length,s=[];if(0===a)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let u=1;u<a;++u){let a=e[u];if(a===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}s.push(l)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){let a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case p5.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case p5.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${p5[s]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case p5.FIRST_DIM_SIZE:return e[0];case p5.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case p5.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${p5[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];let r=g5(t,!1),a=TR.getArrayFromDType(this.valuesDType,TR.sizeFromShape(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)s=this.calculateOutputIndex(e-1,s,n[e],t[e]);this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;let a=this.values,s=n,i=r.slice();i=i.slice(e+1);let o=TR.sizeFromShape(i),l=t.length,u=this.defaultValue;if(u.length!==o&&1!==u.length){let e=this.defaultValueShape;uM((()=>{let t=nO(u,e);u=xO(t,i).dataSync()}))}let c=0,d=0,h=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==h){if(d<h){let e=a.subarray(c*o);m5(s.subarray(d*o),e,(h-d)*o)}if(p>=l){let t=n.length;e=Math.floor(t/o)}if(e>h)if(1===this.defaultValue.length)s.subarray(h*o,e*o).fill(this.defaultValue[0]),h=e;else for(;e>h;){m5(s.slice(h*o),u,o),++h}e<0?(c=p+1,d=h):(c=p,d=h,h=d+1)}else++h}}};function m5(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function g5(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function y5(e,t,n,r,a,s,i,o,l,u){return new f5(e,t,n,r,a,s,i,o,l,u).compute()}function b5(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return TR.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((t-e)/n)),s=TR.makeZerosTypedArray(a,r);t<e&&1===n&&(n=-1),s[0]=e;for(let i=1;i<s.length;i++)s[i]=s[i-1]+n;return s}var v5=e4((e=>1/Math.sqrt(e))),x5=n4(w$,v5),w5={kernelName:w$,backendName:"cpu",kernelFunc:x5};function k5(e,t,n,r,a,s,i,o,l,u){let c=[r/a,a],d=e.values,h=t.values;if(0===r)return xF(n,t.dtype);let p=l instanceof lD?l:xF(c,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let f=0;f<s;f++){let e=[],s=0;for(let t=0;t<i;t++){let n=d[f*i+t];e.push(n),s+=n*o[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?p.values[s*a+n]+=h[f*a+n]:p.values[s*a+n]=0===t.rank?h[0]:h[f*a+n]}return p}var S5=e4((e=>1/(1+Math.exp(-e)))),I5=t4($$,(e=>1/(1+Math.exp(-e)))),C5={kernelName:$$,backendName:"cpu",kernelFunc:I5};function N5(e,t,n,r,a){let s=_V.isSliceContinous(r,t,n),i=TR.sizeFromShape(n),o=TR.computeStrides(r);if(s){let n=_V.computeFlatOffset(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}let l=xF(r,a,"string"===a?nU.fromUint8ToStringArray(e):e),u=xF(n,a);for(let c=0;c<u.size;++c){let e=u.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===a?nU.fromStringArrayToUint8(u.values):u.values}function T5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;N3(a,"slice");let[o,l]=_V.parseSliceParams(a,s,i);_V.assertParamsValid(a,o,l);let u=N5(n.data.get(a.dataId).values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var E5={kernelName:T$,backendName:"cpu",kernelFunc:T5};function A5(e,t,n,r,a,s,i){let o=t[0],l=s[0],u=new Array(l),c=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(nU.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[TR.getArrayFromDType(n,0),[0,d],TR.getArrayFromDType(a,0),u,c]}let h=!0,p=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let t=e[g*d];if(t<0)throw new Error(nU.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,t));if(t>=l)throw new Error(nU.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,t,l));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<l;++g){let e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){let t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,d],n,u,c]}{let t=f[l-1],s=TR.getArrayFromDType(n,t*d),h=TR.getArrayFromDType(a,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){let t=e[n*d],a=p[t],i=(0===t?0:f[t-1])+a;p[t]++;for(let r=0;r<d;++r)s[i*d+r]=e[n*d+r];h[i]=r[n],c[n]=i}for(let e=0;e<l;++e)if(0===p[e]){let t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;h[t]=i}return[s,[t,d],h,u,c]}}function _5(e,t,n,r,a){let s=TR.sizeFromShape(r),i=t[0],o=a.length,l=[],u=1,c=-1;for(let m=0;m<o;++m){let e=a[m];if(-1===e){if(-1!==c)throw new Error(nU.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,m));c=m,l.push(1)}else{if(e<0)throw new Error(nU.getSparseReshapeNegativeOutputDimErrorMessage(m,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error(nU.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(s/u);if(u*e!==s)throw new Error(nU.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=e}if(TR.sizeFromShape(l)!==s)throw new Error(nU.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}let p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}let f=TR.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],l]}function $5(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?a[o-1]+1:0;if(c<0)throw new Error(nU.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=c;let h=d.reduce(((e,t)=>e*t),1),p=TR.getArrayFromDType(n,h);if(0===o)return c>0&&p.fill(i),[p,d];if(c<=0)throw new Error(nU.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let t=0;if(m<o){if(t=a[m],y===t){++m;continue}if(y>=t)throw new Error(nU.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=c)throw new Error(nU.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,c));y>g&&p.fill(i,g*u,y*u);for(let n=f;n<m;++n){let t=r[n];if(t<0||t>=l[0])throw new Error(nU.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,r[n],l[0]));for(let n=0;n<u;n++)p[y*u+n]+=e[t*u+n]}if(s)for(let e=0;e<u;e++)p[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<c&&p.fill(i,g*u,c*u),[p,d]}var R5=e4((e=>Math.sqrt(e))),D5=t4(D$,(e=>Math.sqrt(e))),M5={kernelName:D$,backendName:"cpu",kernelFunc:D5},F5=R3(((e,t)=>{let n=e-t;return n*n})),O5=U3(U$,F5),P5={kernelName:U$,backendName:"cpu",kernelFunc:O5},L5=e4(((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),z5=n4(G$,L5),B5={kernelName:G$,backendName:"cpu",kernelFunc:z5};function W5(e,t,n,r){let a=xF(e,t.dtype);for(let s=0;s<a.size;s++){let e=a.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}var V5=class{constructor(e,t,n,r,a,s){this.separator=TR.encodeString(e),this.nGramWidths=t,this.leftPad=TR.encodeString(n),this.rightPad=TR.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),c=s-(l+u),d=t+(l>0?0:i-o),h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length,h+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(h);let p=n[r+i],f=0,m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}let a=r-1,s=TR.getArrayFromDType("int32",r);if(0===n||0===r){let e=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[e,s]}s[0]=0;for(let o=1;o<=a;++o){let e=t[o]-t[o-1],n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[o]=s[o-1]+n}let i=new Array(s[a]);for(let o=0;o<a;++o){let n=t[o],r=s[o];if(this.nGramWidths.forEach((a=>{let s=t[o+1]-t[o],l=this.getNumNGrams(s,a);this.createNGrams(e,n,i,r,l,a),r+=l})),this.preserveShort&&r===s[o]){let a=t[o+1]-t[o];if(0===a)continue;let s=a+2*this.padWidth;this.createNGrams(e,n,i,r,1,s)}}return[i,s]}};function U5(e,t,n,r,a,s,i,o){return new V5(n,r,a,s,i,o).compute(e,t)}function j5(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],s=e.indexOf(a);for(;-1!==s;){let t=e.subarray(0,s);(!n||0!==t.length)&&r.push(t),s=(e=e.subarray(s+1)).indexOf(a)}return void((!n||0!==e.length)&&r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){let t=e.subarray(a,s);(!n||0!==t.length)&&r.push(t),a=s+1}}function G5(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let h=0;h<r;++h){let r=a.length;j5(e[h],t,n,a);let l=a.length-r;o[h]=l,s+=l,i=Math.max(i,l)}let l=TR.getArrayFromDType("int32",2*s),u=new Array(s),c=[r,i],d=0;for(let h=0;h<r;++h)for(let e=0;e<o[h];++e)l[2*d]=h,l[2*d+1]=e,u[d]=a[d],++d;return[l,u,c]}function H5(e,t){let n=TR.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=TR.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var q5=R3(((e,t)=>e-t)),K5=j3(((e,t,n,r)=>({real:e-n,imag:t-r}))),X5=U3(Y$,q5,K5),Y5={kernelName:Y$,backendName:"cpu",kernelFunc:X5};function Q5(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=xF(n,e.dtype);for(let a=0;a<r.values.length;++a){let t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];let s=e.locToIndex(n);r.values[a]=e.values[s]}return r}var J5=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function Z5(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){let a=r-n+1,s=t-n+1,i=Math.log(a),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(a-o)/a)*Math.sign(s-a/2);Z5(e,t,Math.max(n,Math.floor(t-s*o/a+l)),Math.min(r,Math.floor(t+(a-s)*o/a+l)))}let a=e[t],s=n,i=r;for(TR.swap(e,n,t),J5(e[r],a)>0&&TR.swap(e,n,r);s<i;){for(TR.swap(e,s,i),s++,i--;J5(e[s],a)<0;)s+=1;for(;J5(e[i],a)>0;)i-=1}0===J5(e[n],a)?TR.swap(e,n,i):(i+=1,TR.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function e6(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=TR.getTypedArrayFromDType(n,i*r),u=TR.getTypedArrayFromDType("int32",i*r);for(let d=0;d<i;d++){let t=d*o,n=e.subarray(t,t+o),s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(Z5(s,r),s=s.slice(0,r)),a&&s.sort(J5);let i=d*r,c=l.subarray(i,i+r),h=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=s[e].value,h[e]=s[e].index}let c=t.slice();return c[c.length-1]=r,[xF(c,n,l),xF(c,"int32",u)]}function t6(e,t,n,r){let a=TR.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];let i=new Map,o=new Int32Array(n[a]),l=new lD(s,r,e),u=[],c=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let t;if(c)t=e[f].toString();else{let e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(l.get(t,f,n));t=e.join(",")}let n=i.get(t);if(null!=n)o[f]=n;else{let e=i.size;i.set(t,e),o[f]=e,u.push(f)}}let d=s.slice();d[1]=i.size;let h=new lD(d,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)h.set(l.get(n,e,r),n,t,r)}));let p=n.slice();return p[a]=d[1],{outputValues:h.values,outputShape:p,indices:o}}var n6="4.16.0";vM("cpu",(()=>new E3),1);var r6=t4(XA,(e=>e>=0?e:Math.exp(e)-1)),a6={kernelName:XA,backendName:"cpu",kernelFunc:r6};function s6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;N3([a],"leakyRelu");let i=TR.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=TR.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}var i6={kernelName:b_,backendName:"cpu",kernelFunc:s6},o6=R3(((e,t)=>e<0?t*e:e));function l6(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;N3([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=o6(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var u6={kernelName:a$,backendName:"cpu",kernelFunc:l6},c6=t4(h$,(e=>Math.max(0,e))),d6={kernelName:h$,backendName:"cpu",kernelFunc:c6},h6=t4(b$,(e=>Math.min(Math.max(0,e),6))),p6={kernelName:b$,backendName:"cpu",kernelFunc:h6};function f6(e,t,n,r,a){if("linear"===n)return O3({inputs:{x:t},backend:e});if("relu"===n)return c6({inputs:{x:t},backend:e});if("elu"===n)return r6({inputs:{x:t},backend:e});if("relu6"===n)return h6({inputs:{x:t},backend:e});if("prelu"===n)return l6({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return s6({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return I5({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function m6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=TR.sizeFromShape(a.shape),o=TR.inferFromImplicitShape(s,i),l=TR.sizeFromShape(o);TR.assert(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){let e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var g6={kernelName:p$,backendName:"cpu",kernelFunc:m6};function y6(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;N3([a,s],"matMul");let l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=TR.sizeFromShape(f),y=TR.sizeFromShape(m),b=jO.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);TR.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let v=o?[y,p,d]:[y,d,p],x=m6({inputs:{x:a},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=m6({inputs:{x:s},backend:n,attrs:{shape:v}}),k=i?x.shape[1]:x.shape[2],S=i?x.shape[2]:x.shape[1],I=o?w.shape[1]:w.shape[2],C=Math.max(g,y),N=n.data.get(x.dataId).values,T=n.data.get(w.dataId).values,E=TR.computeStrides(x.shape),A=TR.computeStrides(w.shape),[_,$,R]=i?[E[0],1,E[1]]:[E[0],E[1],1],[D,M,F]=o?[1,A[1],A[0]]:[A[1],1,A[0]],O=S*I,P=xF([C,S,I],x.dtype),L=P.values,z=n.blockSize;for(let B=0;B<C;B++){let e=B%g,t=B%y;for(let n=0;n<S;n+=z){let r=Math.min(n+z,S);for(let a=0;a<I;a+=z){let s=Math.min(a+z,I);for(let i=0;i<k;i+=z){let o=Math.min(i+z,k);for(let l=n;l<r;l++)for(let n=a;n<s;n++){let r=0;for(let a=i;a<o;a++){r+=N[e*_+l*$+a*R]*T[a*D+n*M+t*F]}L[B*O+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,P.dtype,P.values)}var b6={kernelName:fA,backendName:"cpu",kernelFunc:y6};var v6={kernelName:dR,backendName:"cpu",kernelFunc:function(e){let t,n,r,{inputs:a,backend:s,attrs:i}=e,{a:o,b:l,bias:u,preluActivationWeights:c}=a,{transposeA:d,transposeB:h,activation:p,leakyreluAlpha:f}=i,m=[];t=y6({inputs:{a:o,b:l},attrs:{transposeA:d,transposeB:h},backend:s}),u&&(n=q3({inputs:{a:t,b:u},backend:s}),m.push(t),t=n),p&&(r=f6(s,t,p,c,f),m.push(t),t=r);for(let g of m)s.disposeIntermediateTensorInfo(g);return t}},x6=t4(QE,(e=>Math.acos(e))),w6={kernelName:QE,backendName:"cpu",kernelFunc:x6},k6=t4(JE,(e=>Math.acosh(e))),S6={kernelName:JE,backendName:"cpu",kernelFunc:k6};var I6={kernelName:eA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,r=t;N3(t,"addN");let a=r.map((e=>n.data.get(e.dataId).values)),s=xF(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){let e=a[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};var C6={kernelName:tA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;N3(a,"all");let o=TR.parseAxisParam(s,a.shape),l=o,u=nU.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=r5({inputs:{x:a},backend:n,attrs:{perm:u}}),l=nU.getInnerMostAxes(l.length,a.shape.length)),nU.assertAxesAreInnerMostDims("all",l,c.shape.length);let[d,h]=nU.computeOutAndReduceShapes(c.shape,l),p=TR.sizeFromShape(h),f=TR.makeZerosTypedArray(TR.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*p,t=m[e];for(let n=0;n<p;++n){let r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let e=m6({inputs:{x:g},backend:n,attrs:{shape:nU.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var N6={kernelName:nA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;N3(a,"any");let o=TR.parseAxisParam(s,a.shape),l=o,u=nU.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=r5({inputs:{x:a},backend:n,attrs:{perm:u}}),l=nU.getInnerMostAxes(l.length,a.shape.length)),nU.assertAxesAreInnerMostDims("any",l,c.shape.length);let[d,h]=nU.computeOutAndReduceShapes(c.shape,l),p=TR.sizeFromShape(h),f=TR.makeZerosTypedArray(TR.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*p,t=m[e];for(let n=0;n<p;++n){let r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let e=m6({inputs:{x:g},backend:n,attrs:{shape:nU.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var T6={kernelName:rA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;N3(a,"argMax");let i=TR.parseAxisParam(s,a.shape),o=nU.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=r5({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=nU.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],nU.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,d]=nU.computeOutAndReduceShapes(l.shape,i),h=TR.sizeFromShape(c),p=TR.makeZerosTypedArray(h,"int32"),f=TR.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a>t&&(t=a,n=r)}p[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}};var E6={kernelName:aA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;N3(a,"argMin");let i=TR.parseAxisParam(s,a.shape),o=nU.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=r5({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=nU.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],nU.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,d]=nU.computeOutAndReduceShapes(l.shape,i),h=TR.sizeFromShape(c),p=TR.makeZerosTypedArray(h,"int32"),f=TR.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a<t&&(t=a,n=r)}p[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}},A6=t4(sA,(e=>Math.asin(e))),_6={kernelName:sA,backendName:"cpu",kernelFunc:A6},$6=t4(iA,(e=>Math.asinh(e))),R6={kernelName:iA,backendName:"cpu",kernelFunc:$6},D6=t4(oA,(e=>Math.atan(e))),M6={kernelName:oA,backendName:"cpu",kernelFunc:D6},F6=R3(((e,t)=>Math.atan2(e,t))),O6=U3(uA,F6),P6={kernelName:uA,backendName:"cpu",kernelFunc:O6},L6=t4(lA,(e=>Math.atanh(e))),z6={kernelName:lA,backendName:"cpu",kernelFunc:L6};function B6(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,c=a.effectiveFilterHeight,d=a.effectiveFilterWidth,h=a.padInfo.top,p=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=xF(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let x=0;x<a.batchSize;++x){let t=x*y,n=x*r[0];for(let m=0;m<a.inChannels;++m)for(let y=0;y<a.outHeight;++y){let x=y*i-h,w=Math.max(0,x),k=Math.min(a.inHeight,c+x),S=t+y*b;for(let t=0;t<a.outWidth;++t){let i=t*o-p,c=Math.max(0,i),h=Math.min(a.inWidth,d+i),y=f,b=0,x=0;for(let t=w;t<k;t+=l){let a=n+t*r[1];for(let t=c;t<h;t+=u){let n=e[a+t*r[2]+m];"max"===s&&n>y?y=n:"avg"===s&&(b+=n,x++)}if(isNaN(y))break}g[S+t*v+m]="avg"===s?b/x:y}}}return m}function W6(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=xF(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=xF(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){let n=t*o-p,y=n;for(;y<0;)y+=u;let b=Math.min(r.inHeight,d+n);for(let o=0;o<r.outWidth;++o){let d=o*l-f,p=d;for(;p<0;)p+=c;let v=Math.min(r.inWidth,h+d),x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=u){let i=t-n;for(let n=p;n<v;n+=c){let o=n-d,l=m.get(g,t,n,e);l>x&&(x=l,w=a?s?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*h+o)}}i.set(w,g,t,o,e)}}return i}function V6(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,c=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=xF(a.outShape,n),x=v.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let C=0;C<a.batchSize;++C){let t=C*w,n=C*r[0];for(let v=0;v<a.inChannels;++v)for(let w=0;w<a.outDepth;++w){let C=w*i-m,N=C;for(;N<0;)N+=u;let T=Math.min(a.inDepth,h+C),E=t+w*k;for(let t=0;t<a.outHeight;++t){let i=t*o-g,h=i;for(;h<0;)h+=c;let m=Math.min(a.inHeight,p+i),w=E+t*S;for(let t=0;t<a.outWidth;++t){let i=t*l-y,o=i;for(;o<0;)o+=d;let p=Math.min(a.inWidth,f+i),g=w+t*I,k=b,S=0,C=0;for(let t=N;t<T;t+=u){let a=n+t*r[1];for(let t=h;t<m;t+=c){let n=a+t*r[2];for(let t=o;t<p;t+=d){let a=e[n+t*r[3]+v];if("max"===s&&a>k?k=a:"avg"===s&&(S+=a,C++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===s?S/Math.max(C,1):k}}}}return v}var U6={kernelName:cA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;N3(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;TR.assert(nU.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u,c=nU.computePool2DInfo(a.shape,s,i,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&TR.arraysEqual(c.inShape,c.outShape))u=O3({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=TR.computeStrides(a.shape),r=B6(e,a.shape,a.dtype,t,c,"avg");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};var j6={kernelName:hA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;N3(a,"avgPool3d");let c=nU.computePool3DInfo(a.shape,s,i,1,o,l,u),d=V6(n.data.get(a.dataId).values,a.shape,a.dtype,TR.computeStrides(a.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};var G6={kernelName:pA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;N3([a,s],"avgPool3DGrad");let c=nU.computePool3DInfo(s.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=x-1-c.padInfo.front,I=k-1-c.padInfo.left,C=w-1-c.padInfo.top,N=xF(s.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(a);for(let A=0;A<c.batchSize;++A)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){let a=t-S,s=n-C,i=r-I,o=0;for(let t=0;t<x;t+=y){let n=(a+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){let r=(s+t)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){let a=(i+t)/p;a<0||a>=c.outWidth||Math.floor(a)!==a||(o+=E.get(A,n,r,a,e))}}}N.set(o*T,A,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};var H6={kernelName:dA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;N3([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=nU.computePool2DInfo(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=xF(i.shape,"float32"),k=1/(p*f),S=n.data.get(a.dataId).values,I=xF(a.shape,"float32",S);for(let C=0;C<c.batchSize;++C)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){let r=t-x,a=n-v,s=0;for(let t=0;t<y;t+=m){let n=(r+t)/d;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){let r=(a+t)/h;r<0||r>=c.outWidth||Math.floor(r)!==r||(s+=I.get(C,n,r,e))}}w.set(s*k,C,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};var q6={kernelName:o_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;TR.assert(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),TR.assert(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),TR.assert(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),N3([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);let c=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,v=d.length,x=0,w=0,k=0,S=0;for(let I=0;I<c.length;++I)m[I]=f[x++]+(c[I]-d[w++])*p[k++]/Math.sqrt(h[S++]+u),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,m)}};var K6={kernelName:mA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;N3([a],"batchToSpaceND");let o=s.reduce(((e,t)=>e*t)),l=nU.getReshaped(a.shape,s,o),u=nU.getPermuted(l.length,s.length),c=nU.getReshapedPermuted(a.shape,s,o),d=nU.getSliceBeginCoords(i,s.length),h=nU.getSliceSize(c,i,s.length),p=m6({inputs:{x:a},backend:n,attrs:{shape:l}}),f=r5({inputs:{x:p},backend:n,attrs:{perm:u}}),m=m6({inputs:{x:f},backend:n,attrs:{shape:c}}),g=T5({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};var X6={kernelName:gA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=X3(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}};var Y6={kernelName:vA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=nU.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},Q6=t4(kA,((e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),J6={kernelName:kA,backendName:"cpu",kernelFunc:Q6},Z6={kernelName:IA,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(TR.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function e8(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var t8={kernelName:f_,backendName:"cpu",kernelFunc:e8};function n8(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=TR.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));nU.assertParamsConsistent(i,s);let o=nU.computeOutShape(t.map((e=>e.shape)),s);if(0===TR.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>TR.sizeFromShape(e.shape)>0));if(1===l.length)return O3({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){let e=l.map((e=>L3({inputs:{input:e},backend:n}))),t=l.map((e=>e8({inputs:{input:e},backend:n}))),r=n8({inputs:e,backend:n,attrs:{axis:s}}),a=n8({inputs:t,backend:n,attrs:{axis:s}}),i=D3({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}let u=l.map((e=>{let t=[-1,TR.sizeFromShape(e.shape.slice(s))];return m6({inputs:{x:e},backend:n,attrs:{shape:t}})})),c=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=nU.computeOutShape(u.map((e=>e.shape)),1);let d=1===u[0].shape[0],h=i4(c,o,t[0].dtype,d),p=nU.computeOutShape(l.map((e=>e.shape)),s),f=n.makeTensorInfo(p,t[0].dtype,h);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var r8={kernelName:CA,backendName:"cpu",kernelFunc:n8};function a8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;N3([a,s],"conv2d");let d=nU.convertConv2DDataFormat(l),h=nU.computeConv2DInfo(a.shape,s.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new lD(h.outShape,a.dtype),w=TR.computeStrides(a.shape),k=TR.computeStrides(s.shape),S=w[0],I=v?w[1]:w[2],C=v?w[2]:1,N=v?1:w[1],T=x.strides[0],E=v?x.strides[1]:x.strides[2],A=v?x.strides[2]:1,_=v?1:x.strides[1],$=n.data.get(a.dataId).values,R=n.data.get(s.dataId).values,D=x.values;for(let M=0;M<h.batchSize;++M){let e=M*S,t=M*T;for(let n=0;n<h.outHeight;++n){let r=t+n*E,a=n*h.strideHeight-b;for(let t=0;t<p;++t){let n=a+t*m;if(n<0||n>=h.inHeight)continue;let s=t*k[0],i=e+n*I;for(let e=0;e<h.outWidth;++e){let t=r+e*A,n=e*h.strideWidth-y;for(let e=0;e<f;++e){let r=n+e*g;if(r<0||r>=h.inWidth)continue;let a=i+r*C,o=s+e*k[1];for(let e=0;e<h.inChannels;++e){let n=$[a+e*N];for(let e=0;e<h.outChannels;++e)D[t+e*_]+=n*R[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,D)}var s8={kernelName:NA,backendName:"cpu",kernelFunc:a8};var i8={kernelName:TA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;N3([a,s],"conv2dBackpropFilter");let d=nU.convertConv2DDataFormat(l),h=nU.computeConv2DInfo(a.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new lD(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=new lD(a.shape,a.dtype,w),I=new lD(s.shape,s.dtype,k);for(let C=0;C<m;++C){let e=Math.max(0,Math.ceil((x-C)/p)),t=Math.min(h.outHeight,(h.inHeight+x-C)/p);for(let n=0;n<g;++n){let r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(h.outWidth,(h.inWidth+v-n)/f);for(let s=0;s<h.inChannels;++s)for(let i=0;i<h.outChannels;++i){let o=0;for(let l=0;l<h.batchSize;++l)for(let u=e;u<t;++u){let e=C+u*p-x;for(let t=r;t<a;++t){let r=n+t*f-v;o+=y?S.get(l,e,r,s)*I.get(l,u,t,i):S.get(l,s,e,r)*I.get(l,i,u,t)}}b.set(o,C,n,s,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var o8={kernelName:EA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;N3([a,s],"conv2dBackpropInput");let d=TR.computeStrides(s.shape),h=TR.computeStrides(a.shape),p=nU.convertConv2DDataFormat(u),f=nU.computeConv2DInfo(i,s.shape,o,1,l,c,!1,p),m=new lD(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[v,x,w]=d,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:C,inHeight:N,inWidth:T,outChannels:E,outHeight:A,outWidth:_,strideHeight:$,strideWidth:R}=f;p=f.dataFormat;let D=S-1-f.padInfo.top,M=I-1-f.padInfo.left,F="channelsLast"===p,O=m.strides[0],P=F?m.strides[1]:m.strides[2],L=F?m.strides[2]:1,z=F?1:m.strides[1],B=h[0],W=F?h[1]:h[2],V=F?h[2]:1,U=F?1:h[1];for(let j=0;j<k;++j)for(let e=0;e<C;++e)for(let t=0;t<N;++t){let n=t-D,r=Math.max(0,Math.ceil(n/$)),a=Math.min(A,(S+n)/$);for(let s=0;s<T;++s){let i=s-M,o=Math.max(0,Math.ceil(i/R)),l=Math.min(_,(I+i)/R),u=0;for(let t=r;t<a;++t){let r=t*$-n;for(let n=o;n<l;++n){let a=B*j+W*t+V*n,s=v*(S-1-r)+x*(I-1-(n*R-i))+w*e;for(let e=0;e<E;++e){u+=y[a+U*e]*b[s+e]}}}g[O*j+P*t+L*s+z*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};var l8={kernelName:AA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;N3([a,s],"conv3d");let u=nU.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new lD(u.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=x.values,I=TR.computeStrides(a.shape),C=TR.computeStrides(s.shape);for(let N=0;N<u.batchSize;++N){let e=N*I[0],t=N*x.strides[0];for(let n=0;n<u.outDepth;++n){let r=t+n*x.strides[1],a=n*u.strideDepth-y;for(let t=0;t<c;++t){let n=a+t*p;if(n<0||n>=u.inDepth)continue;let s=t*C[0],i=e+n*I[1];for(let e=0;e<u.outHeight;++e){let t=r+e*x.strides[2],n=e*u.strideHeight-v;for(let e=0;e<d;++e){let r=n+e*f;if(r<0||r>=u.inHeight)continue;let a=s+e*C[1],o=i+r*I[2];for(let e=0;e<u.outWidth;++e){let n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<h;++e){let t=r+e*m;if(t<0||t>=u.inWidth)continue;let s=a+e*C[2],i=o+t*u.inChannels,l=s;for(let e=0;e<u.inChannels;++e){let t=w[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};var u8={kernelName:_A,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;N3([a,s],"conv3dBackpropFilterV2");let u=TR.computeStrides(a.shape),c=TR.computeStrides(s.shape),d=nU.computeConv3DInfo(a.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new lD(d.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,I=n.data.get(s.dataId).values,[C,N,T,E]=c,A=n.data.get(a.dataId).values,[_,$,R,D]=u,M=d.padInfo.front,F=d.padInfo.left,O=d.padInfo.top;for(let P=0;P<m;++P){let e=Math.max(0,Math.ceil((M-P)/h)),t=Math.min(d.outDepth,(d.inDepth+M-P)/h),n=P*x;for(let r=0;r<g;++r){let a=Math.max(0,Math.ceil((O-r)/p)),s=Math.min(d.outHeight,(d.inHeight+O-r)/p),i=r*w+n;for(let n=0;n<y;++n){let o=Math.max(0,Math.ceil((F-n)/f)),l=Math.min(d.outWidth,(d.inWidth+F-n)/f),u=n*k+i;for(let i=0;i<d.inChannels;++i){let c=i*S+u;for(let u=0;u<d.outChannels;++u){let m=0;for(let c=0;c<d.batchSize;++c){let d=c*_,g=c*C;for(let c=e;c<t;++c){let e=(P+c*h-M)*$+d,t=c*N+g;for(let c=a;c<s;++c){let a=(r+c*p-O)*R+e,s=c*T+t;for(let e=o;e<l;++e){let t=e*E+s;m+=A[(n+e*f-F)*D+a+i]*I[t+u]}}}}v[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var c8={kernelName:$A,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;N3([a],"conv3dBackpropInputV2");let u=TR.computeStrides(a.shape),c=TR.computeStrides(s.shape),d=nU.computeConv3DInfo(l,s.shape,o,1,i),h=new lD(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(a.dataId).values,[v,x,w,k]=u,S=n.data.get(s.dataId).values,[I,C,N,T]=c,{batchSize:E,filterDepth:A,filterHeight:_,filterWidth:$,inChannels:R,inDepth:D,inHeight:M,inWidth:F,outChannels:O,outDepth:P,outHeight:L,outWidth:z,strideDepth:B,strideHeight:W,strideWidth:V}=d,U=A-1-d.padInfo.front,j=_-1-d.padInfo.top,G=$-1-d.padInfo.left;for(let H=0;H<E;++H)for(let e=0;e<R;++e)for(let t=0;t<D;++t){let n=t-U,r=Math.max(0,Math.ceil(n/B)),a=Math.min(P,(A+n)/B);for(let s=0;s<M;++s){let i=s-j,o=Math.max(0,Math.ceil(i/W)),l=Math.min(L,(_+i)/W);for(let u=0;u<F;++u){let c=u-G,d=Math.max(0,Math.ceil(c/V)),h=Math.min(z,($+c)/V),E=0;for(let t=r;t<a;++t){let r=t*B-n;for(let n=o;n<l;++n){let a=n*W-i;for(let s=d;s<h;++s){let i=v*H+x*t+w*n+k*s,o=I*(A-1-r)+C*(_-1-a)+N*($-1-(s*V-c))+T*e;for(let e=0;e<O;++e){E+=b[i+e]*S[o+e]}}}}p[f*H+m*t+g*s+y*u+e]=E}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},d8=t4(RA,(e=>Math.cos(e))),h8={kernelName:RA,backendName:"cpu",kernelFunc:d8},p8=t4(DA,(e=>Math.cosh(e))),f8={kernelName:DA,backendName:"cpu",kernelFunc:p8};var m8={kernelName:OA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=a.shape,f=s.shape[0],[m,g]=o,y=xF([f,m,g,p],"float32"),b=n.data.get(s.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,w=TR.computeStrides(a.shape),k=TR.computeStrides(y.shape);for(let S=0;S<f;S++){let e=4*S,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],s=v[S];if(s>=c)continue;let i=m>1?(r-t)*(d-1)/(m-1):0,o=g>1?(a-n)*(h-1)/(g-1):0;for(let c=0;c<m;c++){let e=m>1?t*(d-1)+c*i:.5*(t+r)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){let n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}else if("bilinear"===l){let t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){let l=g>1?n*(h-1)+e*o:.5*(n+a)*(h-1);if(l<0||l>h-1){for(let t=0;t<p;t++){let n=t+e*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}let d=Math.floor(l),f=Math.ceil(l),m=l-d;for(let n=0;n<p;n++){let a=n+d*w[2]+t*w[1]+s*w[0],o=x[a];a=n+f*w[2]+t*w[1]+s*w[0];let l=x[a];a=n+d*w[2]+r*w[1]+s*w[0];let u=x[a];a=n+f*w[2]+r*w[1]+s*w[0];let h=o+(l-o)*m,p=u+(x[a]-u)*m;a=n+e*k[2]+c*k[1]+S*k[0],y.values[a]=h+(p-h)*i}}}else for(let t=0;t<g;++t){let r=g>1?n*(h-1)+t*o:.5*(n+a)*(h-1);if(r<0||r>h-1){for(let e=0;e<p;e++){let n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}let i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++){let n=e+i*w[2]+l*w[1]+s*w[0],r=e+t*k[2]+c*k[1]+S*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};var g8={kernelName:MA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;N3(a,"cumprod");let l=nU.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=r5({inputs:{x:a},backend:n,attrs:{perm:l}}));let c=nU.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=kD(u.dtype,"int32"),h=TR.makeOnesTypedArray(TR.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)h[t]=i?1:p[t];else{let n=m(y,e-1);h[t]=i?p[n]*h[n]:p[t]*h[n]}}let g=n.makeTensorInfo(u.shape,d,h);if(null!=l){let e=r5({inputs:{x:g},backend:n,attrs:{perm:nU.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};var y8={kernelName:FA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;N3(a,"cumsum");let l=nU.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=r5({inputs:{x:a},backend:n,attrs:{perm:l}}));let c=nU.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=kD(u.dtype,"int32"),h=TR.makeZerosTypedArray(TR.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)h[t]=i?0:p[t];else{let n=m(y,e-1);h[t]=i?p[n]+h[n]:p[t]+h[n]}}let g=n.makeTensorInfo(u.shape,d,h);if(null!=l){let e=r5({inputs:{x:g},backend:n,attrs:{perm:nU.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};var b8={kernelName:PA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=X3(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){let e=Y3(n.bufferSync(a),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};var v8={kernelName:LA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;TR.assert("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));let o=a.shape[0],l=a.shape[1],u=a.shape[2],c=a.shape[3],d=l*s,h=u*s,p=c/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*d*h*p),g=0;for(let y=0;y<o;++y)for(let e=0;e<d;++e){let t=Math.floor(e/s),n=e%s;for(let e=0;e<h;++e){let r=Math.floor(e/s),a=(n*s+e%s)*p;for(let e=0;e<p;++e){let n=e+a+c*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,d,h,p],a.dtype,m)}};function x8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;N3([a,s],"depthwiseConv2DNative");let c=TR.computeStrides(a.shape),d=TR.computeStrides(s.shape),h=l;null==h&&(h=[1,1]),TR.assert(nU.eitherStridesOrDilationsAreOne(i,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`));let p=nU.computeConv2DInfo(a.shape,s.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new lD(p.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,C=k.values;for(let N=0;N<p.batchSize;++N){let e=N*c[0],t=N*k.strides[0];for(let n=0;n<p.outHeight;++n){let r=t+n*k.strides[1],a=n*p.strideHeight-x;for(let t=0;t<f;++t){let n=a+t*g;if(n<0||n>=p.inHeight)continue;let s=t*d[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){let t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){let r=n+e*y;if(r<0||r>=p.inWidth)continue;let a=s+e*d[1],o=i+r*p.inChannels,l=t,u=a;for(let e=0;e<p.inChannels;++e){let t=S[o+e];for(let e=0;e<w;++e)C[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var w8={kernelName:zA,backendName:"cpu",kernelFunc:x8};var k8={kernelName:BA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;N3([a,s],"depthwiseConv2dNativeBackpropFilter");let d=nU.computeConv2DInfo(a.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new lD(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,x=n.data.get(a.dataId).values,w=new lD(a.shape,a.dtype,x),k=n.data.get(s.dataId).values,S=new lD(s.shape,s.dtype,k);for(let I=0;I<f;++I){let e=Math.max(0,Math.ceil((b-I)/h)),t=Math.min(d.outHeight,(d.inHeight+b-I)/h);for(let n=0;n<m;++n){let r=Math.max(0,Math.ceil((y-n)/p)),a=Math.min(d.outWidth,(d.inWidth+y-n)/p);for(let s=0;s<d.outChannels;++s){let i=Math.trunc(s/v),o=s%v,l=0;for(let u=0;u<d.batchSize;++u)for(let o=e;o<t;++o){let e=I+o*h-b;for(let t=r;t<a;++t){let r=n+t*p-y;l+=w.get(u,e,r,i)*S.get(u,o,t,s)}}g.set(l,I,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};var S8={kernelName:WA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;N3([a,s],"depthwiseConv2DNativeBackpropInput");let d=TR.computeStrides(a.shape),h=TR.computeStrides(s.shape),p=nU.computeConv2DInfo(c,s.shape,i,o,l,u,!0),f=new lD(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(a.dataId).values,[x,w,k]=d,S=n.data.get(s.dataId).values,[I,C,N]=h,{batchSize:T,filterHeight:E,filterWidth:A,inChannels:_,inHeight:$,inWidth:R,outChannels:D,outHeight:M,outWidth:F,strideHeight:O,strideWidth:P}=p,L=E-1-p.padInfo.top,z=A-1-p.padInfo.left,B=D/_;for(let W=0;W<T;++W)for(let e=0;e<_;++e)for(let t=0;t<$;++t){let n=t-L,r=Math.max(0,Math.ceil(n/O)),a=Math.min(M,(E+n)/O);for(let s=0;s<R;++s){let i=s-z,o=Math.max(0,Math.ceil(i/P)),l=Math.min(F,(A+i)/P),u=0;for(let t=r;t<a;++t){let r=t*O-n;for(let n=o;n<l;++n){let a=x*W+w*t+k*n,s=I*(E-1-r)+C*(A-1-(n*P-i))+N*e;for(let t=0;t<B;++t){u+=v[a+(e*B+t)]*S[s+t]}}}m[g*W+y*t+b*s+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};var I8={kernelName:VA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=TR.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=xF([a,a],r.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*a+u]=s[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},C8={kernelName:UA,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=n,c=u.data.get(a.dataId).values,d=a.shape.length,h=u.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:C,dilationWidth:N,outShape:T}=nU.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),E=TR.sizeFromShape(T),A=T.length,_=TR.getArrayFromDType(a.dtype,E);for(let $=0;$<f;++$)for(let e=0;e<b;++e){let t=e*w-x.top;for(let n=0;n<v;++n){let r=n*k-x.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){let n=t+e*C;if(n>=0&&n<m)for(let t=0;t<I;++t){let l=r+t*N;if(l>=0&&l<g){let r=TR.locToIndex([$,n,l,i],d,TR.computeStrides(a.shape)),u=TR.locToIndex([e,t,i],p,TR.computeStrides(s.shape)),f=c[r]+h[u];f>o&&(o=f)}}}_[TR.locToIndex([$,e,n,i],A,TR.computeStrides(T))]=o}}}return{dataId:u.write(TR.toTypedArray(_,a.dtype),T,a.dtype),shape:T,dtype:a.dtype}}},N8={kernelName:GA,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=TR.toNestedArray(a.shape,c.data.get(a.dataId).values),h=TR.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=nU.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u);TR.assert(i.rank===N.length,(()=>`Error in ${GA}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));let T=TR.toNestedArray(N,c.data.get(i.dataId).values),E=TR.makeZerosNestedTypedArray(s.shape,s.dtype);for(let A=0;A<p;++A)for(let e=0;e<y;++e){let t=e*x-v.top;for(let n=0;n<b;++n){let r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){let n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){let l=r+t*C;if(l>=0&&l<m){let r=d[A][n][l][a]+h[e][t][a];r>s&&(s=r,i=e,o=t)}}}E[i][o][a]+=T[A][e][n][a]}}}return{dataId:c.write(TR.toTypedArray(E,a.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},T8={kernelName:jA,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=TR.toNestedArray(a.shape,c.data.get(a.dataId).values),h=TR.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=nU.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u);TR.assert(i.rank===N.length,(()=>`Error in ${jA}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));let T=TR.toNestedArray(N,c.data.get(i.dataId).values),E=TR.makeZerosNestedTypedArray(a.shape,a.dtype);for(let A=0;A<p;++A)for(let e=0;e<y;++e){let t=e*x-v.top;for(let n=0;n<b;++n){let r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<k;++e){let n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){let l=r+t*C;if(l>=0&&l<m){let r=d[A][n][l][a]+h[e][t][a];r>s&&(s=r,i=n,o=l)}}}E[A][i][o][a]+=T[A][e][n][a]}}}return{dataId:c.write(TR.toTypedArray(E,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};var E8={kernelName:HA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null==l?void 0:l.alpha)||1,c=(null==o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let d=s.getContext(c,(null==o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);let[h,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(p*h*4);for(let v=0;v<h*p;++v){let e=[0,0,0,255*u];for(let n=0;n<f;n++){let t=m[v*f+n];if("float32"===a.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===a.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}let t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}s.width=p,s.height=h;let b=new ImageData(y,p,h);return d.putImageData(b,0,0),a}};function A8(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a;N3(s,"sum"),t="bool"===s.dtype?W3({inputs:{x:s},backend:r,attrs:{dtype:"int32"}}):O3({inputs:{x:s},backend:r});let l=t.shape.length,u=TR.parseAxisParam(i,t.shape),c=nU.getAxesPermutation(u,l),d=u,h=t;null!=c&&(h=r5({inputs:{x:t},backend:r,attrs:{perm:c}}),d=nU.getInnerMostAxes(d.length,l)),nU.assertAxesAreInnerMostDims("sum",d,h.shape.length);let[p,f]=nU.computeOutAndReduceShapes(h.shape,d),m=F3(r,p,nU.upcastType(h.dtype,"int32")),g=TR.sizeFromShape(f),y=r.data.get(m.dataId).values,b=r.data.get(h.dataId).values;for(let v=0;v<y.length;++v){let e=v*g,t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(o){let e=m;m=m6({inputs:{x:m},backend:r,attrs:{shape:nU.expandShapeToKeepDim(m.shape,u)}}),r.disposeIntermediateTensorInfo(e)}return r.disposeIntermediateTensorInfo(t),null!=c&&r.disposeIntermediateTensorInfo(h),m}var _8={kernelName:M$,backendName:"cpu",kernelFunc:A8};var $8={kernelName:KA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=nU.decodeEinsumEquation(a,s.length);nU.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=nU.getEinsumComputePath(o,l),d=c.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let e of c[m]){let t,{permutationIndices:r,expandDims:a}=nU.getEinsumPermutation(p,l[e]);nU.isIdentityPermutation(r)?t=s[e]:(t=r5({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);TR.arraysEqual(t.shape,i)||(t=m6({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===h?h=t:(h=X4({inputs:{a:t,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=A8({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};var R8={kernelName:YA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;N3([r,a],"eluGrad");let s=new Float32Array(TR.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let e=i[l];s[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",s)}},D8=nU.ERF_P,M8=nU.ERF_A1,F8=nU.ERF_A2,O8=nU.ERF_A3,P8=nU.ERF_A4,L8=nU.ERF_A5,z8=t4(QA,(e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+D8*n);return t*(1-((((L8*r+P8)*r+O8)*r+F8)*r+M8)*r*Math.exp(-n*n))})),B8={kernelName:QA,backendName:"cpu",kernelFunc:z8};function W8(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(TR.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),m6({inputs:{x:a},backend:n,attrs:{shape:o}})}var V8={kernelName:e_,backendName:"cpu",kernelFunc:W8},U8=R3(((e,t)=>e/t)),j8=U3(qA,U8),G8={kernelName:qA,backendName:"cpu",kernelFunc:j8};function H8(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],c=TR.sizeFromShape(u),d=TR.getTypedArrayFromDType("float32",c),h=TR.getTypedArrayFromDType("float32",c);for(let g=0;g<a;g++){let e=T5({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=T5({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=D3({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=q8(a,t,n),c=nU.mergeRealAndImagArrays(i,u);for(let t=0;t<s;t++){let e=nU.getComplexWithIndex(c,t);d[g*s+t]=e.real,h[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}let p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=D3({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function q8(e,t,n){let r=TR.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(function(e){return 0===(e&e-1)}(r)){let a=K8(s,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),s=n.makeTensorInfo([],"float32",TR.createScalarValue(r,"float32")),i=O3({inputs:{x:s},backend:n}),l=G8.kernelFunc({inputs:{a:e,b:s},backend:n}),u=G8.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return a}{let e=function(e,t,n){let r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){let o=nU.exponent(a*r,t,n),l=nU.getComplexWithIndex(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),nU.assignToTypedArray(r,s,i,a)}return r}(nU.mergeRealAndImagArrays(s,i),r,t);return nU.splitRealAndImagArrays(e)}}function K8(e,t,n,r,a){if(1===n)return{real:e,imag:t};let s=nU.mergeRealAndImagArrays(e,t),i=n/2,o=nU.complexWithEvenIndex(s),l=o.real,u=o.imag,c=[l.length],d=a.makeTensorInfo(c,"float32",l),h=a.makeTensorInfo(c,"float32",u),p=D3({inputs:{real:d,imag:h},backend:a}),f=nU.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),v=a.makeTensorInfo(y,"float32",g),x=D3({inputs:{real:b,imag:v},backend:a}),w=K8(l,u,i,r,a),k=w.real,S=w.imag,I=[k.length],C=a.makeTensorInfo(I,"float32",k),N=a.makeTensorInfo(I,"float32",S),T=D3({inputs:{real:C,imag:N},backend:a}),E=K8(m,g,i,r,a),A=E.real,_=E.imag,$=[A.length],R=a.makeTensorInfo($,"float32",A),D=a.makeTensorInfo($,"float32",_),M=D3({inputs:{real:R,imag:D},backend:a}),F=nU.exponents(n,r),O=[F.real.length],P=a.makeTensorInfo(O,"float32",F.real),L=a.makeTensorInfo(O,"float32",F.imag),z=D3({inputs:{real:P,imag:L},backend:a}),B=X4({inputs:{a:z,b:M},backend:a}),W=q3({inputs:{a:T,b:B},backend:a}),V=X5({inputs:{a:T,b:B},backend:a}),U=L3({inputs:{input:W},backend:a}),j=L3({inputs:{input:V},backend:a}),G=e8({inputs:{input:W},backend:a}),H=e8({inputs:{input:V},backend:a}),q=n8({inputs:[U,j],backend:a,attrs:{axis:0}}),K=n8({inputs:[G,H],backend:a,attrs:{axis:0}}),X=a.data.get(q.dataId).values,Y=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}var X8={kernelName:n_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=TR.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=m6({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=H8(i,!1,n),l=m6({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function Y8(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||TR.inferDtype(a),o=TR.getArrayFromDType(i,TR.sizeFromShape(r));return function(e,t){e.fill(t)}(o,a),t.makeTensorInfo(r,i,o)}var Q8={kernelName:r_,backendName:"cpu",kernelFunc:Y8};var J8={kernelName:a_,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,s=r,i=TR.getTypedArrayFromDType(a.dtype,TR.sizeFromShape(a.shape)),[o,l,u,c]=a.shape,d=s.data.get(a.dataId).values;for(let h=0;h<o;h++){let e=h*u*l*c;for(let t=0;t<l;t++){let n=t*(u*c);for(let t=0;t<u;t++){let r=t*c;for(let a=0;a<c;a++){let s=Math.round(u-t-1),o=e+n+r+a,l=d[o];if(s>=0&&s<u){l=d[e+n+s*c+a]}i[o]=l}}}}return{dataId:s.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};var Z8={kernelName:hR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=a8({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){let e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){let e=m6({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=q3({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=q3({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){let e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){let e=m6({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=f6(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=f6(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};var e7={kernelName:pR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=x8({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){let e=m;m=q3({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){let e=m;m=f6(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};var t7={kernelName:u_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=TR.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,u,c,d]=nU.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);let h=k4(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,o,c,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,h.values)}};var n7={kernelName:l_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;N3([a,s],"gatherV2");let l=TR.parseAxisParam(i,a.shape)[0],u=n.data.get(s.dataId).values,c=a.shape[l];for(let v=0;v<u.length;++v){let e=u[v];TR.assert(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let d=o;null==o&&(d=0);let h=TR.sizeFromShape(s.shape),p=nU.segment_util.collectGatherOpShapeInfo(a,s,l,d),f=m6({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=m6({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=S4(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}};var r7={kernelName:p_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=TR.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=m6({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=H8(i,!0,n),l=m6({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},a7=t4(m_,(e=>Number.isFinite(e)?1:0),"bool"),s7={kernelName:m_,backendName:"cpu",kernelFunc:a7},i7=t4(g_,(e=>Math.abs(e)===1/0?1:0),"bool"),o7={kernelName:g_,backendName:"cpu",kernelFunc:i7},l7=t4(y_,(e=>Number.isNaN(e)?1:0),"bool"),u7={kernelName:y_,backendName:"cpu",kernelFunc:l7};var c7={kernelName:w_,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=O4(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},d7=t4(S_,(e=>Math.log1p(e))),h7={kernelName:S_,backendName:"cpu",kernelFunc:d7},p7=R3(((e,t)=>e&&t)),f7=U3(I_,p7,null,"bool"),m7={kernelName:I_,backendName:"cpu",kernelFunc:f7},g7=t4(C_,(e=>e?0:1),"bool"),y7={kernelName:C_,backendName:"cpu",kernelFunc:g7},b7=R3(((e,t)=>e||t)),v7=U3(N_,b7,null,"bool"),x7={kernelName:N_,backendName:"cpu",kernelFunc:v7};var w7={kernelName:__,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;N3(a,"LRN");let u=a.shape[3],c=u-1,d=n.data.get(a.dataId).values,h=TR.sizeFromShape(a.shape),p=new Float32Array(h);function f(e){let t=e%u,n=e-t+Math.max(0,t-s),r=e-t+Math.min(t+s,c),a=0;for(;n<=r;n++){let e=d[n];a+=e*e}return a}for(let m=0;m<h;m++){let e=f(m),t=d[m]*Math.pow(i+o*e,-l);p[m]=t}return n.makeTensorInfo(a.shape,a.dtype,p)}};var k7={kernelName:$_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;N3(i,"LRNGrad");let d=TR.sizeFromShape(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){let e=b%h,t=b-e+Math.max(0,e-o),n=b-e+Math.min(h,e+o+1),r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*c*f[a]*m[b]/r;b===a&&(e+=Math.pow(r,-c)),e*=p[b],g[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,g)}};function S7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,u=l.length,c=TR.parseAxisParam(s,l),d=c,h=nU.getAxesPermutation(d,u),p=o.data.get(a.dataId).values;if(null!=h){let e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];p=n5(p,l,a.dtype,h,e),d=nU.getInnerMostAxes(d.length,u),l=e}N3(a,"max"),nU.assertAxesAreInnerMostDims("max",d,u);let[f,m]=nU.computeOutAndReduceShapes(l,d),g=B4(p,TR.sizeFromShape(m),f,a.dtype),y=o.write(g,f,a.dtype),b=f;return i&&(b=nU.expandShapeToKeepDim(f,c)),{dataId:y,shape:b,dtype:a.dtype}}var I7={kernelName:D_,backendName:"cpu",kernelFunc:S7};var C7={kernelName:F_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;N3(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;TR.assert(nU.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u,c=nU.computePool2DInfo(a.shape,s,i,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&TR.arraysEqual(c.inShape,c.outShape))u=O3({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=TR.computeStrides(a.shape),r=B6(e,a.shape,a.dtype,t,c,"max");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};var N7={kernelName:P_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;N3(a,"maxPool3d");let c=nU.computePool3DInfo(a.shape,s,i,1,o,l,u),d=V6(n.data.get(a.dataId).values,a.shape,a.dtype,TR.computeStrides(a.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};var T7={kernelName:L_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;N3([a,s],"maxPool3DGrad");let c=nU.computePool3DInfo(s.shape,i,o,1,l,u),d=function(e,t){let n=xF(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-h,v=b;for(;v<0;)v+=i;let x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){let u=r*a-p,h=u;for(;h<0;)h+=o;let w=Math.min(t.inHeight,c+u);for(let a=0;a<t.outWidth;++a){let p=a*s-f,k=p;for(;k<0;)k+=l;let S=Math.min(t.inWidth,d+p),I=Number.NEGATIVE_INFINITY,C=-1;for(let t=v;t<x;t+=i){let n=t-b;for(let r=h;r<w;r+=o){let a=r-u;for(let s=k;s<S;s+=l){let i=s-p,o=e.get(m,t,r,s,g);o>=I&&(I=o,C=n*c*d+a*c+i)}}}n.set(C,m,y,r,a,g)}}}return n}(n.bufferSync(s),c),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=x-1-c.padInfo.left,S=v-1-c.padInfo.top,I=xF(s.shape,"float32"),C=n.bufferSync(a);for(let N=0;N<c.batchSize;++N)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){let a=t-w,s=n-S,i=r-k,o=0;for(let t=0;t<b;t+=m){let n=(a+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){let a=(s+r)/p;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let s=0;s<x;s+=y){let l=(i+s)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;let u=b*v*x-1-d.get(N,n,a,l,e)===t*v*x+r*x+s?1:0;0!==u&&(o+=C.get(N,n,a,l,e)*u)}}}I.set(o,N,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};var E7={kernelName:O_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;N3([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=nU.computePool2DInfo(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=xF(h.outShape,o.dtype,W6(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,k=v-1-h.padInfo.top,S=xF(o.shape,"float32"),I=n.data.get(a.dataId).values,C=xF(a.shape,"float32",I);for(let N=0;N<h.batchSize;++N)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){let r=t-k,a=n-w,s=0;for(let t=0;t<v;t+=y){let n=(r+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){let i=(a+r)/g;if(i<0||i>=h.outWidth||Math.floor(i)!==i)continue;let o=v*x-1-f.get(N,n,i,e)===t*x+r?1:0;0!==o&&(s+=C.get(N,n,i,e)*o)}}S.set(s,N,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};var A7={kernelName:z_,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;N3(a,"MaxPoolWithArgmax");let c=u.data.get(a.dataId).values,d=nU.computePool2DInfo(a.shape,s,i,[1,1],o),[h,p]=function(e,t,n,r,a){let s=B6(e,0,n,TR.computeStrides(t),a,"max"),i=W6(e,t,n,a,!0,r);return[s.values,i.values]}(c,a.shape,a.dtype,l,d),f=u.write(h,d.outShape,a.dtype),m=u.write(p,d.outShape,a.dtype);return[{dataId:f,shape:d.outShape,dtype:a.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};var _7={kernelName:B_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=TR.parseAxisParam(s,a.shape),l=nU.computeOutAndReduceShapes(a.shape,o)[1],u=TR.sizeFromShape(l),c=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(d);let h=W3({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});c.push(h);let p=j8({inputs:{a:h,b:d},backend:n});c.push(p);let f=A8({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:i}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};var $7={kernelName:W_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;N3(a,"min");let o=TR.parseAxisParam(s,a.shape),l=o,u=nU.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=r5({inputs:{x:a},backend:n,attrs:{perm:u}}),l=nU.getInnerMostAxes(l.length,a.shape.length)),nU.assertAxesAreInnerMostDims("min",l,c.shape.length);let[d,h]=nU.computeOutAndReduceShapes(c.shape,l),p=TR.sizeFromShape(h),f=TR.makeZerosTypedArray(TR.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*p,t=m[e];for(let n=0;n<p;++n){let r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let e=m6({inputs:{x:g},backend:n,attrs:{shape:nU.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var R7={kernelName:U_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;N3(a,"mirrorPad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),c="reflect"===i?0:1,d=n.data.get(a.dataId).values,h=a.shape.length,p=TR.computeStrides(a.shape),f=TR.sizeFromShape(o),m=o.length,g=TR.computeStrides(o),y=TR.getTypedArrayFromDType(a.dtype,f);for(let b=0;b<f;b++){let e=TR.indexToLoc(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));let t=TR.locToIndex(e,h,p);y[b]=d[t]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}},D7=R3(((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),M7=U3(j_,D7),F7={kernelName:j_,backendName:"cpu",kernelFunc:M7},O7=ST(FT());function P7(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=TR.parseAxisParam([o],a.shape),u=S7({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=nU.expandShapeToKeepDim(u.shape,l),d=m6({inputs:{x:u},backend:n,attrs:{shape:c}}),h=X5({inputs:{a:a,b:d},backend:n}),p=d4({inputs:{x:h},backend:n}),f=A8({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=m6({inputs:{x:f},backend:n,attrs:{shape:c}}),g=j8({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var L7={kernelName:P$,backendName:"cpu",kernelFunc:P7};var z7={kernelName:G_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;N3(a,"multinomial");let l=o?a:P7({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,s],p=TR.makeZerosTypedArray(TR.sizeFromShape(h),"int32");for(let f=0;f<u;++f){let e=f*c,t=new Float32Array(c-1);t[0]=d[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+d[e+a];let n=O7.alea(i.toString()),r=f*s;for(let a=0;a<s;++a){let e=n();p[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+a]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}},B7=lj.nonMaxSuppressionV3Impl;var W7={kernelName:X_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;N3(a,"NonMaxSuppression");let u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d}=B7(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},V7=lj.nonMaxSuppressionV4Impl;var U7={kernelName:Y_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;N3(a,"NonMaxSuppressionPadded");let c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=V7(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},j7=lj.nonMaxSuppressionV5Impl;var G7={kernelName:Q_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;N3(a,"NonMaxSuppressionWithScore");let c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=j7(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};var H7={kernelName:Z_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;N3(a,"oneHot");let u=TR.sizeFromShape(a.shape),c=new Float32Array(u*i);c.fill(l);let d=n.data.get(a.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...a.shape,i],s,c)}};function q7(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){let e=L3({inputs:{input:r},backend:n}),t=q7({inputs:{x:e},backend:n}),a=e8({inputs:{input:r},backend:n}),s=q7({inputs:{x:a},backend:n}),i=D3({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return Y8({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var K7={kernelName:oR,backendName:"cpu",kernelFunc:q7};var X7={kernelName:J_,backendName:"cpu",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){let t=L3({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=e8({inputs:{input:a},backend:r}),i=q7({inputs:{x:s},backend:r}),o=D3({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return Y8({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function Y7(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return W8({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{TR.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),TR.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=W8({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=n8({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}var Q7={kernelName:e$,backendName:"cpu",kernelFunc:Y7};var J7={kernelName:t$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;N3(a,"pad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,c=TR.sizeFromShape(a.shape),d=a.shape.length,h=TR.computeStrides(a.shape),p=TR.sizeFromShape(o),f=o.length,m=TR.computeStrides(o),g=TR.getTypedArrayFromDType(a.dtype,p);0!==i&&g.fill(i);for(let y=0;y<c;y++){let e=TR.indexToLoc(y,d,h).map(((e,t)=>e+l[t]));g[TR.locToIndex(e,f,m)]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},Z7=R3(((e,t)=>Math.pow(e,t))),e9=U3(r$,Z7),t9={kernelName:r$,backendName:"cpu",kernelFunc:e9};var n9={kernelName:i$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.data.get(e.dataId).values)),u=a.map((e=>e.shape)),c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=c5(l,u,c,s.shape,s.dtype,d,i.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};var r9={kernelName:o$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=h5(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var a9={kernelName:l$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,h=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=y5(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}};var s9={kernelName:u$,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=b5(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}},i9=t4(d$,(e=>1/e)),o9={kernelName:d$,backendName:"cpu",kernelFunc:i9};var l9={kernelName:g$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;N3(a,"resizeBilinear");let l=TR.computeStrides(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(TR.sizeFromShape([d,u,c,f])),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=0,x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<d;k++)for(let e=0;e<u;e++){let t;t=i?x*(e+.5)-.5:x*e;let n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(h-1,Math.ceil(t)),s=k*l[0]+n*l[1],o=k*l[0]+a*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;let n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(p-1,Math.ceil(t)),c=s+n*l[2],d=o+n*l[2],h=s+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){let t=m[c+e],n=m[d+e],s=t+(m[h+e]-t)*a,i=s+(n+(m[y+e]-n)*a-s)*r;g[v++]=i}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}};var u9={kernelName:y$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;N3([s,a],"resizeBilinearGrad");let o=TR.computeStrides(a.shape),[l,u,c,d]=a.shape,[,h,p]=s.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(s.dataId).values,x=0;for(let w=0;w<l;w++){let e=w*o[0];for(let t=0;t<h;t++){let n=t*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=e+r*o[1],i=e+a*o[1],l=n-r,h=1-l;for(let e=0;e<p;e++){let t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),a=t-n,u=1-a,p=s+n*o[2],m=s+r*o[2],g=i+n*o[2],y=i+r*o[2],w=h*u,k=h*a,S=l*u,I=l*a;for(let e=0;e<d;e++){let t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*I}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}};var c9={kernelName:f$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;N3(a,"resizeNearestNeighbor");let l=TR.computeStrides(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(d*u*c*f),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1],w=0;for(let k=0;k<d;k++){let e=k*l[0];for(let t=0;t<u;t++){let n=i?v*(t+.5):v*t,r=Math.min(h-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));let a=e+r*l[1];for(let e=0;e<c;e++){let t=i?x*(e+.5):x*e,n=Math.min(p-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));let r=a+n*l[2];for(let e=0;e<f;e++){let t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([d,u,c,f],a.dtype,g)}};var d9={kernelName:m$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;N3([s,a],"resizeNearestNeighborGrad");let o=TR.computeStrides(a.shape),l=TR.computeStrides(s.shape),[u,c,d,h]=a.shape,[,p,f]=s.shape,m=new Float32Array(u*c*d*h),g=n.data.get(s.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let C=0;C<u;C++){let e=C*o[0];for(let t=0;t<c;t++){let n=e+t*o[1],r=Math.floor(t*w),a=Math.floor(r-S/2);for(let s=0;s<d;s++){let r=n+s*o[2],u=Math.floor(s*k),y=Math.floor(u-I/2);for(let n=0;n<h;n++){let o=0;for(let r=0;r<S;r++){let u=r+a;if(u<0||u>=p)continue;let h=e+u*l[1],m=u*v;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){let t=e+y;if(t<0||t>=f)continue;let r=h+t*l[2],a=t*x;s===Math.min(d-1,i?Math.round(a):Math.floor(a))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}};var h9={kernelName:v$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;N3(a,"reverse");let i=a.shape.length,o=TR.parseAxisParam(s,a.shape);if(0===i)return O3({inputs:{x:a},backend:n});let l=new lD(a.shape,a.dtype),u=n.bufferSync(a);for(let c=0;c<l.size;c++){let e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},p9={kernelName:cR,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=TR.getTypedArrayFromDType(a.dtype,TR.sizeFromShape(a.shape)),[c,d,h,p]=a.shape,[f,m]=nU.getImageCenter(o,d,h),g=Math.sin(s),y=Math.cos(s),b=l.data.get(a.dataId).values;for(let v=0;v<c;v++){let e=v*h*d*p;for(let t=0;t<d;t++){let n=t*(h*p);for(let r=0;r<h;r++){let a=r*p;for(let s=0;s<p;s++){let o=[c,t,r,s],l=o[2],v=o[1],x=(l-f)*y-(v-m)*g,w=(l-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=i;if("number"!=typeof i&&(k=3===s?255:i[s]),x>=0&&x<h&&w>=0&&w<d){k=b[e+w*(h*p)+x*p+s]}u[e+n+a+s]=k}}}}return{dataId:l.write(u,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},f9=t4(x$,(e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),m9={kernelName:x$,backendName:"cpu",kernelFunc:f9};var g9={kernelName:k$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=nU.calculateShapes(s,a,i),h=k5(n.bufferSync(a),n.bufferSync(s),i,d,u,l,o,c,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function y9(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function b9(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}var v9={kernelName:I$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=function(e,t,n,r,a,s){let i=TR.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?y9(n,t[e+l]):b9(n,t[e+l])}return i}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",o)}};var x9={kernelName:C$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;N3([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=kD(a.dtype,s.dtype),d=TR.makeZerosTypedArray(TR.sizeFromShape(a.shape),c),h=0,p=0===i||i>1||1===a.shape.length?1:TR.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(a.shape,c,d)}},w9=nU.SELU_SCALEALPHA,k9=nU.SELU_SCALE,S9=t4(N$,(e=>e>=0?k9*e:w9*(Math.exp(e)-1))),I9={kernelName:N$,backendName:"cpu",kernelFunc:S9},C9=t4(_$,(e=>e<0?-1:e>0?1:0)),N9={kernelName:_$,backendName:"cpu",kernelFunc:C9},T9=t4(E$,(e=>Math.sin(e))),E9={kernelName:E$,backendName:"cpu",kernelFunc:T9},A9=t4(A$,(e=>Math.sinh(e))),_9={kernelName:A$,backendName:"cpu",kernelFunc:A9},$9=Math.log(1.1920928955078125e-7)+2,R9=t4(R$,(e=>{let t,n=e>-$9,r=e<$9,a=Math.exp(e);return t=r?a:n?e:Math.log(1+a),t})),D9={kernelName:R$,backendName:"cpu",kernelFunc:R9};var M9={kernelName:F$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;N3([a],"spaceToBatchND");let o=TR.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=J7.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=nU.getReshaped(u.shape,s,o,!1),d=nU.getPermuted(c.length,s.length,!1),h=nU.getReshapedPermuted(u.shape,s,o,!1),p=m6({inputs:{x:u},backend:n,attrs:{shape:c}}),f=r5({inputs:{x:p},backend:n,attrs:{perm:d}}),m=m6({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};var F9={kernelName:L$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=A5(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var O9={kernelName:z$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,d]=_5(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var P9={kernelName:B$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=$5(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};var L9={kernelName:W$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=$5(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};var z9={kernelName:V$,backendName:"cpu",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{sparseIndices:s,sparseValues:i,defaultValue:o}=n,{outputShape:l}=a,{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=nU.calculateShapes(i,s,l),f=!1,m=r.bufferSync(s);switch(i.dtype){case"bool":t=k5(m,r.bufferSync(i),l,p,d,c,u,h,!!r.data.get(o.dataId).values[0],f);break;case"float32":case"int32":t=k5(m,r.bufferSync(i),l,p,d,c,u,h,r.data.get(o.dataId).values[0],f);break;case"string":t=k5(m,r.bufferSync(i),l,p,d,c,u,h,TR.decodeString(r.data.get(o.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return r.makeTensorInfo(l,t.dtype,t.values)}};var B9={kernelName:O$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=TR.parseAxisParam(i,a.shape)[0],l=nU.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{let t=[...c];t[o]=e;let r=T5({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},W9={kernelName:j$,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e,{x:r}=t,a=n;N3(r,"square");let s=a.data.get(r.dataId).values,i=new Float32Array(s.length);for(let o=0;o<s.length;++o){let e=s[o];i[o]=e*e}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},V9=t4(lR,((e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),U9={kernelName:lR,backendName:"cpu",kernelFunc:V9};var j9={kernelName:H$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;N3(a,"stridedSlice");let p,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=_V.sliceInfo(a.shape,s,i,o,l,u,c,d,h);if(g)p=m6({inputs:{x:a},backend:n,attrs:{shape:m}});else if(y||b){TR.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));let e=_V.computeOutShape(v,x,w),t=T5({inputs:{x:a},backend:n,attrs:{begin:v,size:e}});p=m6({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{let e=W5(f,n.bufferSync(a),w,v);p=n.makeTensorInfo(m,e.dtype,e.values)}return p}};var G9={kernelName:q$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=U5(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var H9={kernelName:K$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=G5(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var q9={kernelName:X$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=H5(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",i)}},K9=t4(Q$,(e=>Math.tan(e))),X9={kernelName:Q$,backendName:"cpu",kernelFunc:K9},Y9=t4(J$,(e=>Math.tanh(e)));var Q9={kernelName:S$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=nU.calculateShapes(s,a,r.shape),d=n.bufferSync(a),h=n.bufferSync(s),p=n.bufferSync(r),f=k5(d,h,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};var J9={kernelName:Z$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;N3(a,"tile");let i=Q5(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}};var Z9={kernelName:eR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;N3(a,"topk");let o=n.data.get(a.dataId).values,[l,u]=e6(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};var eee={kernelName:tR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=[c,f,m,p],y=TR.computeStrides(a.shape),b=y[0],v=y[1],x=y[2],w=TR.computeStrides(g),k=w[0],S=w[1],I=w[2],C=TR.getTypedArrayFromDType(a.dtype,TR.sizeFromShape(g));C.fill(l);let N=r.data.get(a.dataId).values,T=r.data.get(s.dataId).values;for(let E=0;E<c;++E){let e=1===s.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let a,s=e[6]*n+e[7]*t+1;if(0===s)continue;let u=(e[0]*n+e[1]*t+e[2])/s,c=(e[3]*n+e[4]*t+e[5])/s,p=tee(u,h,o),f=tee(c,d,o);switch(i){case"nearest":a=ree(N,d,h,b,v,x,E,f,p,r,l);break;case"bilinear":a=aee(N,d,h,b,v,x,E,f,p,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}C[E*k+t*S+n*I+r]=a}return r.makeTensorInfo(g,a.dtype,C)}return{dataId:r.write(C,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function tee(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{let e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return TR.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{let e=t-1;n-=t*Math.trunc(n/e)}return TR.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return TR.clamp(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function nee(e,t,n,r,a,s,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*a+l*s+u]:c}function ree(e,t,n,r,a,s,i,o,l,u,c){return nee(e,t,n,r,a,s,i,Math.round(o),Math.round(l),u,c)}function aee(e,t,n,r,a,s,i,o,l,u,c){let d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1;return(p-o)*((f-l)*nee(e,t,n,r,a,s,i,d,h,u,c)+(l-h)*nee(e,t,n,r,a,s,i,d,f,u,c))+(o-d)*((f-l)*nee(e,t,n,r,a,s,i,p,h,u,c)+(l-h)*nee(e,t,n,r,a,s,i,p,f,u,c))}var see={kernelName:rR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;N3(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=t6(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};var iee={kernelName:aR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),u=0;for(let p=0;p<i;p++)p!==s&&(l[u++]=a.shape[p]);let c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let h=new Array(o);for(let p=0;p<h.length;p++){c[s]=p;let e=T5({inputs:{x:a},backend:n,attrs:{begin:c,size:d}});h[p]=m6({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return h}};var oee={kernelName:sR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;N3(a,"unsortedSegmentSum");let o=[],l=[],u=a.shape.length-s.shape.length,c=s;for(let h=0;h<u;++h){let e=W8({inputs:{input:c},backend:n,attrs:{dim:h+1}});c=e,l.push(e)}for(let h=0;h<i;++h){let e=TR.createScalarValue(h,"int32"),t=n.makeTensorInfo([],"int32",e),r=l4({inputs:{a:t,b:c},backend:n}),s=W3({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=X4({inputs:{a:s,b:a},backend:n}),u=A8({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(s),l.push(i),l.push(u)}let d=Y7({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},lee=[v6,$3,w6,S6,K3,I6,C6,N6,T6,E6,_6,R6,M6,P6,z6,U6,j6,G6,H6,b6,q6,K6,X6,Z3,Y6,V3,s4,J6,M3,Z6,r8,s8,i8,o8,l8,u8,c8,h8,f8,m8,g8,y8,b8,v8,w8,k8,S8,I8,C8,N8,T8,E8,$8,a6,R8,u4,B8,h4,V8,m4,X8,Q8,J8,b4,w4,Z8,e7,t7,n7,N4,A4,P3,r7,t8,s7,o7,u7,i6,R4,F4,c7,z4,h7,m7,y7,x7,w7,k7,I7,U4,C7,N7,T7,E7,A7,_7,$7,H4,R7,F7,z7,Y4,J4,W7,U7,G7,t5,H7,X7,Q7,J7,t9,u6,i5,n9,r9,a9,s9,z3,G8,o9,d6,p6,g6,l9,u9,c9,d9,h9,p9,m9,w5,g9,v9,x9,I9,C5,N9,E9,_9,E5,L7,D9,M9,F9,O9,P9,L9,z9,B9,M5,W9,P5,B5,U9,j9,G9,H9,q9,Y5,_8,X9,{kernelName:J$,backendName:"cpu",kernelFunc:Y9},Q9,J9,Z9,eee,a5,see,iee,oee,K7];for(let n of lee)wR(n);var uee={};kT(uee,{assertNotComplex:()=>bte,bindCanvasToFramebuffer:()=>Kee,bindColorTextureToFramebuffer:()=>Xee,bindTextureToProgramUniformSampler:()=>qee,bindTextureUnit:()=>Uee,bindVertexBufferToProgramAttribute:()=>Vee,callAndCheck:()=>wee,canBeRepresented:()=>Iee,createFragmentShader:()=>Eee,createFramebuffer:()=>Wee,createProgram:()=>Dee,createStaticIndexBuffer:()=>Pee,createStaticVertexBuffer:()=>Oee,createTexture:()=>zee,createVertexShader:()=>Tee,getBatchDim:()=>tte,getExtensionOrThrow:()=>Nee,getFramebufferErrorMessage:()=>Jee,getMaxTexturesInShader:()=>cte,getNumChannels:()=>Lee,getProgramUniformLocation:()=>Hee,getProgramUniformLocationOrThrow:()=>Gee,getRowsCols:()=>nte,getShapeAs3D:()=>rte,getTextureShapeFromLogicalShape:()=>ate,getWebGLDisjointQueryTimerVersion:()=>dte,getWebGLErrorMessage:()=>Cee,getWebGLMaxTextureSize:()=>ote,hasExtension:()=>hte,isCapableOfRenderingToFloatTexture:()=>fte,isDownloadFloatTextureEnabled:()=>mte,isReshapeFree:()=>ite,isWebGLFenceEnabled:()=>yte,isWebGLVersionEnabled:()=>pte,linkProgram:()=>Mee,logShaderSourceAndInfoLog:()=>Ree,resetMaxTextureSize:()=>lte,resetMaxTexturesInShader:()=>ute,unbindColorTextureFromFramebuffer:()=>Yee,unbindTextureUnit:()=>jee,validateFramebuffer:()=>Qee,validateProgram:()=>Fee,validateTextureSize:()=>Bee});var cee,dee,hee,pee={},fee={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function mee(e,t){pee[e]=t}function gee(e,t){if(!(e in pee)||null!=t){let n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=null==t?function(e){if(!GE().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete pee[e]}),!1),GE().getBool("SOFTWARE_WEBGL_ENABLED")&&(fee.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",fee)||n.getContext("experimental-webgl",fee):n.getContext("webgl2",fee)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;pee[e]=n}let n=pee[e];return null==n||n.isContextLost()?(delete pee[e],gee(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),pee[e])}function yee(e,t){return[t,e]}function bee(e){let t=TR.sizeFromShape(e),n=Math.ceil(t/4);return TR.sizeToSquarishShape(n)}function vee(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function xee(e,t){let n,r,a,s,i,o,l,u,c,d,h=e;return 2===GE().getNumber("WEBGL_VERSION")?(n=h.R32F,r=h.R16F,a=h.RGBA16F,s=h.RGBA32F,i=h.RED,l=4,u=1,c=h.HALF_FLOAT,d=h.FLOAT,o=h.RGBA8):(n=e.RGBA,r=e.RGBA,a=e.RGBA,s=h.RGBA,i=e.RGBA,l=4,u=4,c=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,o=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:o,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:c,textureTypeFloat:d}}function wee(e,t){let n=t();return GE().getBool("DEBUG")&&function(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+Cee(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(cee||(cee={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(dee||(dee={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(hee||(hee={}));var kee=5.96e-8,See=65504;function Iee(e){return!!(GE().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||kee<Math.abs(e)&&Math.abs(e)<See)}function Cee(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Nee(e,t){return Zee(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function Tee(e,t){let n=Zee(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(wee(e,(()=>e.shaderSource(n,t))),wee(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function Eee(e,t){let n=Zee(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(wee(e,(()=>e.shaderSource(n,t))),wee(e,(()=>e.compileShader(n))),GE().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw Ree(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var Aee,_ee,$ee=/ERROR: [0-9]+:([0-9]+):/g;function Ree(e,t){let n=$ee.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);let r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map(((e,t)=>TR.rightPad((t+1).toString(),s)+e)),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${TR.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function Dee(e){return Zee(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function Mee(e,t){if(wee(e,(()=>e.linkProgram(t))),!GE().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Fee(e,t){if(wee(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Oee(e,t){let n=Zee(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return wee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),wee(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function Pee(e,t){let n=Zee(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return wee(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),wee(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function Lee(){return 2===GE().getNumber("WEBGL_VERSION")?1:4}function zee(e){return Zee(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function Bee(e,t){let n=GE().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){throw new Error("Requested texture size "+`[${e}x${t}]`+" is invalid.")}if(e>n||t>n){throw new Error("Requested texture size "+`[${e}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}function Wee(e){return Zee(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function Vee(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return-1!==o&&(wee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),wee(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i))),wee(e,(()=>e.enableVertexAttribArray(o))),!0)}function Uee(e,t,n){ete(e,n),wee(e,(()=>e.activeTexture(e.TEXTURE0+n))),wee(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function jee(e,t){ete(e,t),wee(e,(()=>e.activeTexture(e.TEXTURE0+t))),wee(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Gee(e,t,n){return Zee(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function Hee(e,t,n){return e.getUniformLocation(t,n)}function qee(e,t,n,r){wee(e,(()=>Uee(e,t,r))),wee(e,(()=>e.uniform1i(n,r)))}function Kee(e){wee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),wee(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),wee(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function Xee(e,t,n){wee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),wee(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function Yee(e,t){wee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),wee(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function Qee(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Jee(e,t))}function Jee(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Zee(e,t,n){let r=wee(e,(()=>t()));if(null==r)throw new Error(n);return r}function ete(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function tte(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return TR.sizeFromShape(e.slice(0,e.length-t))}function nte(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function rte(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[tte(e),...nte(e)]),t}function ate(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=GE().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=GE().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&GE().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?TR.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length&&(e=TR.squeezeShape(e).newShape);let a=TR.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){let t=tte(e),n=2,r=2;e.length&&([n,r]=nte(e)),a=t*(n/2)*(r/2),s=TR.sizeToSquarishShape(a).map((e=>2*e))}else s=TR.sizeToSquarishShape(a);return s}function ste(e){return e%2===0}function ite(e,t){if(e=e.slice(-2),t=t.slice(-2),TR.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||ste(n)&&ste(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&ste(e[0])&&ste(t[0])}function ote(e){if(null==Aee){let t=gee(e);Aee=t.getParameter(t.MAX_TEXTURE_SIZE)}return Aee}function lte(){Aee=null}function ute(){_ee=null}function cte(e){if(null==_ee){let t=gee(e);_ee=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,_ee)}function dte(e){if(0===e)return 0;let t,n=gee(e);return t=hte(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:hte(n,"EXT_disjoint_timer_query")?1:0,t}function hte(e,t){return null!=e.getExtension(t)}function pte(e){try{if(null!=gee(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function fte(e){if(0===e)return!1;let t=gee(e);if(1===e){if(!hte(t,"OES_texture_float"))return!1}else if(!hte(t,"EXT_color_buffer_float"))return!1;return gte(t)}function mte(e){if(0===e)return!1;let t=gee(e);if(1!==e){if(hte(t,"EXT_color_buffer_float"))return gte(t);let e="EXT_color_buffer_half_float";if(hte(t,e)){let n=t.getExtension(e);return function(e,t){let n=xee(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),s}(t,n)}return!1}return!(!hte(t,"OES_texture_float")||!hte(t,"WEBGL_color_buffer_float"))&&gte(t)}function gte(e){let t=xee(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function yte(e){return 2===e&&null!=gee(e).fenceSync}function bte(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&TR.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var vte=GE();function xte(){let e,t,n,r,a,s,i,o,l,u;return 2===GE().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=GE().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function wte(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=TR.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${t}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function kte(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=TR.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / outShapeStrides[${a}]`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function Ste(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=function(e,t){let n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${r[a]}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}function Ite(e){let t=TR.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}vte.registerFlag("HAS_WEBGL",(()=>vte.getNumber("WEBGL_VERSION")>0)),vte.registerFlag("WEBGL_VERSION",(()=>pte(2)?2:pte(1)?1:0)),vte.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),vte.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===vte.get("WEBGL_VERSION"))),vte.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),vte.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),vte.registerFlag("WEBGL_PACK",(()=>vte.getBool("HAS_WEBGL"))),vte.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>vte.getBool("WEBGL_PACK"))),vte.registerFlag("WEBGL_PACK_CLIP",(()=>vte.getBool("WEBGL_PACK"))),vte.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>vte.getBool("WEBGL_PACK"))),vte.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>vte.getBool("WEBGL_PACK"))),vte.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>vte.getBool("WEBGL_PACK"))),vte.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>vte.getBool("WEBGL_PACK"))),vte.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>vte.getBool("WEBGL_PACK"))),vte.registerFlag("WEBGL_PACK_REDUCE",(()=>vte.getBool("WEBGL_PACK"))),vte.registerFlag("WEBGL_LAZILY_UNPACK",(()=>vte.getBool("WEBGL_PACK"))),vte.registerFlag("WEBGL_CONV_IM2COL",(()=>vte.getBool("WEBGL_PACK"))),vte.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>vte.getBool("WEBGL_PACK"))),vte.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>ote(vte.getNumber("WEBGL_VERSION")))),vte.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>cte(vte.getNumber("WEBGL_VERSION")))),vte.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{let e=vte.getNumber("WEBGL_VERSION");return 0===e?0:dte(e)})),vte.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>vte.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!LD.isMobile())),vte.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>fte(vte.getNumber("WEBGL_VERSION")))),vte.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!vte.getBool("WEBGL_FORCE_F16_TEXTURES")&&vte.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),vte.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>mte(vte.getNumber("WEBGL_VERSION")))),vte.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>yte(vte.getNumber("WEBGL_VERSION")))),vte.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>vte.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),vte.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),vte.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>LD.isMobile()?1:-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),vte.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),vte.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),vte.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),vte.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),vte.registerFlag("WEBGL_EXP_CONV",(()=>!1)),vte.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>vte.getBool("IS_TEST"))),vte.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),vte.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),vte.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),vte.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var Cte="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Nte}=nU;function Tte(e,t,n){let r=[];if(e.forEach((e=>{let t=TR.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){let{uniformShape:t}=Lte(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));let a,s,i=r.join("\n"),o=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?Ate(e,r):Ete(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(a+=n?function(e,t){let n,r=e.name,a=r.charAt(0).toUpperCase()+r.slice(1),s="get"+a+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=Nte(e.shapeInfo.logicalShape,t.logicalShape),u=Pte(o),c=o-i,d=["x","y","z","w","u","v"];n=0===i?"":o<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${d[e+c]} = 0;`)).join("\n");let h="";h=o<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+c]}`)).join(", ");let p="return outputValue;",f=1===TR.sizeFromShape(e.shapeInfo.logicalShape),m=1===TR.sizeFromShape(t.logicalShape);if(1!==i||f||m){if(f&&!m)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){let e=i-2,t=i-1;l.indexOf(e)>-1&&l.indexOf(t)>-1?p="return vec4(outputValue.x);":l.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${n}\n      vec4 outputValue = get${a}(${h});\n      ${p}\n    }\n  `}(e,t):function(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&TR.arraysEqual(i,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let u,c=Pte(l),d=Nte(e.shapeInfo.logicalShape,t.logicalShape),h=l-o,p=["x","y","z","w","u","v"];u=0===o?"":l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${p[e+h]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+h]}`)).join(", "),`\n    float ${a}() {\n      ${c} coords = getOutputCoords();\n      ${u}\n      return get${r}(${f});\n    }\n  `}(e,t)),a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),l=t.texShape,u=xte(),c=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u),d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${_te}\n    ${$te}\n    ${Rte}\n  `}(u);return t.isPacked?(a=function(e,t,n){switch(e.length){case 0:return Mte();case 1:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(TR.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;let a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,l,n.enableShapeUniforms),s=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(a=function(e,t,n){switch(e.length){case 0:return Mte();case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return TR.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${kte(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;let r=wte(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${kte(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let r=wte(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){let n=wte(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){let n=wte(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,l,n.enableShapeUniforms),s=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),n.packedInputs&&(d+=Dte),[d,c,s,i,a,o,n.userCode].join("\n")}function Ete(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let i=Fte(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Ote(e)}\n      }\n    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=Fte(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&TR.arraysEqual(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;let e=s[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}let{newShape:i,keptDims:o}=TR.squeezeShape(n),l=i;if(l.length<n.length){let n=["row","col"];return`\n      ${Ete(zte(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${Bte(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${Ote(e)}\n      }\n    `;let u=s[0],c=s[1],d=Fte(r);return 1===c?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=TR.squeezeShape(n),u=o;if(u.length<n.length){let n=["row","col","depth"];return`\n        ${Ete(zte(e,u),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${Bte(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${Ote(e)}\n      }\n    `;let c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;let f=Fte(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=TR.squeezeShape(n);if(l.length<n.length){let n=["row","col","depth","depth2"];return`\n      ${Ete(zte(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${Bte(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${Ote(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===s&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;let y=Fte(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=TR.squeezeShape(t);if(l.length<t.length){let t=["row","col","depth","depth2","depth3"];return`\n      ${Ete(zte(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Bte(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${a})) +\n          depth3;\n        ${Ote(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let f=Fte(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=TR.squeezeShape(t);if(a.length<t.length){let t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Ete(zte(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Bte(t,s)});\n      }\n    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Ote(e)}\n      }\n    `;let d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let m=Fte(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function Ate(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=xte();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=xte();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=xte();if(null!=s&&TR.arraysEqual(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){let r=[1,2],s=["b","row","col"];return`\n        ${Ate(zte(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${Bte(s,r)});\n        }\n      `}let o=xte();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;let l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=xte();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(s[i-1]/2),h=d*Math.ceil(s[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=s[i-m-1],f=`b${m} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}var _te="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$te="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Rte="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Dte="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Mte(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function Fte(e){return`offset${e}`}function Ote(e){let t=e.name,n=TR.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Pte(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Lte(e,t,n){let{newShape:r,keptDims:a}=TR.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!TR.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function zte(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Bte(e,t){return t.map((t=>e[t])).join(", ")}function Wte(e,t,n){let r,a,s,i=[],o=[],l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===GE().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let d of t.variableNames){let r={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,`${d}Shape`,c),r.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),i.push(r)}if(t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",c),s=e.getUniformLocation(n,"outShapeStrides",c),a=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(let d of t.customUniforms)o.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:i,customUniformLocations:o,infLoc:l,nanLoc:u,outShapeLocation:r,outShapeStridesLocation:s,outTexShapeLocation:a}}function Vte(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{let r=e.logicalShape,a=t[n],s=a.shape;if(!TR.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;let i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!TR.arraysEqual(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function Ute(e){return GE().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var jte=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=cee.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=xte();this.outputShape=e,this.enableShapeUniforms=Ute(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?kte(["r","c","d"],e):wte(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},Gte=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=cee.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=xte();this.outputShape=e,this.enableShapeUniforms=Ute(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?kte(["r","c","d"],e):wte(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},Hte=class{constructor(e){this.variableNames=["A"],this.outTexUsage=dee.DOWNLOAD;let t=xte();this.outputShape=e,this.userCode=`\n      ${Cte}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},qte=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=dee.DOWNLOAD;let t=xte();this.outputShape=e,this.userCode=`\n      ${Cte}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},Kte={R:0,G:1,B:2,A:3},Xte=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=xte();this.outputShape=e,this.enableShapeUniforms=Ute(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let e=n[i];s+=`\n          if(offset == ${i}) {\n            result = values[${Kte[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Ite(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${s}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}},Yte=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=xte();this.outputShape=e,this.enableShapeUniforms=Ute(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){let a=2*s+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Ite(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}},Qte={};function Jte(e){let t=xte();return Tee(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function Zte(e){return Oee(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function ene(e){return Pee(e,new Uint16Array([0,1,2,2,1,3]))}function tne(e,t,n,r,a,s){Bee(t,n);let i=zee(e),o=e.TEXTURE_2D;return wee(e,(()=>e.bindTexture(o,i))),wee(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),wee(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),wee(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),wee(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===GE().getNumber("WEBGL_VERSION")?wee(e,(()=>e.texImage2D(o,0,r,t,n,0,a,s,null))):wee(e,(()=>e.texStorage2D(o,1,r,t,n))),wee(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function nne(e){return e.internalFormatFloat}function rne(e,t,n,r){let[a,s]=yee(t,n);return tne(e,a,s,nne(r),r.textureFormatFloat,e.FLOAT)}function ane(e){return e.internalFormatHalfFloat}function sne(e,t,n,r){let[a,s]=yee(t,n);return tne(e,a,s,ane(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function ine(e){return e.downloadTextureFormat}function one(e,t,n,r){let[a,s]=yee(t,n);return tne(e,a,s,ine(r),e.RGBA,e.UNSIGNED_BYTE)}function lne(e){return e.internalFormatPackedFloat}function une(e,t,n,r){let[a,s]=vee(t,n);return tne(e,a,s,lne(r),e.RGBA,e.FLOAT)}function cne(e){return e.internalFormatPackedHalfFloat}function dne(e,t,n,r){let[a,s]=vee(t,n);return tne(e,a,s,cne(r),e.RGBA,r.textureTypeHalfFloat)}function hne(e,t,n){return wee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),Vee(e,t,"clipSpacePos",n,3,20,0)&&Vee(e,t,"uv",n,2,20,12)}function pne(e,t,n,r,a,s){let i,o,l;wee(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===GE().getNumber("WEBGL_VERSION")?wee(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):wee(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),wee(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function fne(e,t,n){wee(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===GE().getNumber("WEBGL_VERSION")?wee(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):wee(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===GE().getNumber("WEBGL_VERSION")?wee(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):wee(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),wee(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function mne(e,t,n,r){let a=e.createBuffer();wee(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));let s=16*t*n;return wee(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),wee(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),wee(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}function gne(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function yne(e,t,n,r){let[a,s]=yee(t,n),i=new Uint8Array(function(e,t){return e*t}(t*n,4));return wee(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}function bne(e,t,n,r,a,s,i,o){let l=e,u=new Float32Array(function(e,t){let[n,r]=vee(e,t);return n*r*4}(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function vne(e,t,n){let r=new Float32Array(t*n*4);return wee(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}kT(Qte,{bindVertexProgramAttributeStreams:()=>hne,createBufferFromOutputTexture:()=>mne,createFloat16MatrixTexture:()=>sne,createFloat16PackedMatrixTexture:()=>dne,createFloat32MatrixTexture:()=>rne,createIndexBuffer:()=>ene,createPackedMatrixTexture:()=>une,createUnsignedBytesMatrixTexture:()=>one,createVertexBuffer:()=>Zte,createVertexShader:()=>Jte,downloadByteEncodedFloatMatrixFromOutputTexture:()=>yne,downloadFloat32MatrixFromBuffer:()=>gne,downloadMatrixFromPackedOutputTexture:()=>vne,downloadPackedMatrixFromBuffer:()=>bne,getInternalFormatForFloat16MatrixTexture:()=>ane,getInternalFormatForFloat16PackedMatrixTexture:()=>cne,getInternalFormatForFloat32MatrixTexture:()=>nne,getInternalFormatForPackedMatrixTexture:()=>lne,getInternalFormatForUnsignedBytesMatrixTexture:()=>ine,uploadDenseMatrixToTexture:()=>pne,uploadPixelDataToTexture:()=>fne});var xne=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=GE().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,mee(t,e)):this.gl=gee(t),e=this.gl,2===GE().getNumber("WEBGL_VERSION")){let t=e;this.createVertexArray=()=>wee(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>wee(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>wee(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>wee(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){let t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>wee(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>wee(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>wee(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>wee(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===GE().getNumber("WEBGL_VERSION")){let e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=Nee(this.gl,e),hte(this.gl,t))this.textureHalfFloatExtension=Nee(this.gl,t);else if(GE().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),hte(this.gl,r))this.colorBufferHalfFloatExtension=Nee(this.gl,r);else if(GE().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",hte(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!hte(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=Zte(this.gl),this.indexBuffer=ene(this.gl),this.framebuffer=Wee(this.gl),this.textureConfig=xee(this.gl,this.textureHalfFloatExtension)}get debug(){return GE().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;wee(e,(()=>e.finish())),wee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),wee(e,(()=>e.deleteFramebuffer(this.framebuffer))),wee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),wee(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),wee(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),rne(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),sne(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),one(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),fne(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),pne(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),dne(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),une(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Yee(this.gl,this.framebuffer),this.outputTexture=null),wee(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>yne(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return bne(this.gl,e,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return gne(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=mne(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(GE().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>vne(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=Jte(t));let n=Dee(t);wee(t,(()=>t.attachShader(n,this.vertexShader))),wee(t,(()=>t.attachShader(n,e))),Mee(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&Fee(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;wee(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),hne(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(wee(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&Fee(this.gl,this.program),wee(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?Gee(this.gl,e,t):Hee(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),wee(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),qee(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=vee(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Fee(this.gl,this.program),Qee(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}wee(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),wee(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Nee(this.gl,2===GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await TR.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){let e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in GE().platform&&(n=GE().platform.setTimeoutCustom.bind(GE().platform)),TR.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Xee(this.gl,e,this.framebuffer),this.debug&&Qee(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Xee(this.gl,this.outputTexture,this.framebuffer),this.debug&&Qee(this.gl)):Yee(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;Xee(r,e,this.framebuffer),this.debug&&Qee(r),this.outputTexture=e,wee(r,(()=>r.viewport(0,0,t,n))),wee(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),wee(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}};var{addImpl:wne,bincountImpl:kne,bincountReduceImpl:Sne,bitwiseAndImpl:Ine,castImpl:Cne,ceilImpl:Nne,concatImpl:Tne,equalImpl:Ene,expImpl:Ane,expm1Impl:_ne,floorImpl:$ne,gatherNdImpl:Rne,gatherV2Impl:Dne,greaterImpl:Mne,greaterEqualImpl:Fne,lessImpl:One,lessEqualImpl:Pne,linSpaceImpl:Lne,logImpl:zne,maxImpl:Bne,maximumImpl:Wne,minimumImpl:Vne,multiplyImpl:Une,negImpl:jne,notEqualImpl:Gne,prodImpl:Hne,raggedGatherImpl:qne,raggedRangeImpl:Kne,raggedTensorToTensorImpl:Xne,rangeImpl:Yne,rsqrtImpl:Qne,scatterImpl:Jne,sigmoidImpl:Zne,simpleAbsImpl:ere,sliceImpl:tre,sparseFillEmptyRowsImpl:nre,sparseReshapeImpl:rre,sparseSegmentReductionImpl:are,sqrtImpl:sre,staticRegexReplaceImpl:ire,stridedSliceImpl:ore,stringNGramsImpl:lre,stringSplitImpl:ure,stringToHashBucketFastImpl:cre,subImpl:dre,tileImpl:hre,topKImpl:pre,transposeImpl:fre,uniqueImpl:mre}=A3;function gre(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function yre(e,t){return 1===t?[e]:gre(e,t)}var bre=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Ute(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{let e=yre("rc",this.rank),t=Pte(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}},vre=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Ute(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2===1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${function(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?Ste(["r","c","d"],"inputShape"):wte(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Ite(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};var xre=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=kre(t,n),a=Sre(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s,i=wre(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}return r===hee.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===hee.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===hee.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===hee.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===hee.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(s),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),s}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;let a=kre(n,r),s=Sre(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=wre(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=GE().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(let e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function wre(e,t,n,r,a){let s,i=function(e,t){switch(e){case hee.PACKED_2X2_FLOAT32:return lne(t);case hee.PACKED_2X2_FLOAT16:return cne(t);case hee.UNPACKED_FLOAT32:return nne(t);case hee.UNPACKED_FLOAT16:return ane(t);case hee.PACKED_4X1_UNSIGNED_BYTE:return ine(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);if(a){let[t,n]=vee(e[0],e[1]);s=t*n}else{let[t,n]=yee(e[0],e[1]);s=t*n}let o=function(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,i);return s*o}function kre(e,t){if(e===dee.UPLOAD)return hee.PACKED_2X2_FLOAT32;if(e===dee.RENDER||null==e)return function(e){return GE().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?hee.PACKED_2X2_FLOAT32:hee.UNPACKED_FLOAT32:e?hee.PACKED_2X2_FLOAT16:hee.UNPACKED_FLOAT16}(t);if(e===dee.DOWNLOAD||e===dee.PIXELS)return hee.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Sre(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var Ire=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Ute(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},Cre="if (isnan(x)) return x;",Nre="return x;",Tre="return abs(x);",Ere="return (x >= 0.0) ? x : (exp(x) - 1.0);",Are=Cre+"\n  return (x < 0.0) ? 0.0 : x;\n",_re=Cre+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",$re="return x;",Rre="return 1.0 / (1.0 + exp(-1.0 * x));",Dre="return x;",Mre="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Fre="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Ore="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Pre="return 1.0 / (1.0 + exp(-1.0 * x));",Lre=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Ute(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},zre=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Ute(this.outputShape.length);let t=e.length,n=yre("rc",t),r=Pte(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}},Bre=lj.whereImpl,Wre={};var Vre=GE().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");var Ure=class e extends HT{nextDataId(){return e.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!GE().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof xne)t=e;else{let n=gee(GE().getNumber("WEBGL_VERSION"),e);t=new xne(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=gee(GE().getNumber("WEBGL_VERSION"));t=new xne(e),this.binaryCache=function(e){return e in Wre||(Wre[e]={}),Wre[e]}(GE().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new xre(this.gpgpu),this.numMBBeforeWarning=null==GE().global.screen?1024:GE().global.screen.height*GE().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new GT(this,iM())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,s){let i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];let l=rte(t),u=new Xte(l,!1,s),c=this.runWebGLProgram(u,[i],n,[[r,a]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((GE().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||GE().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:dee.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if(GE().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:dee.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new Lre(i,$re):new Ire(i,$re);let n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;let l,u,c=null!=this.activeTimers;if(c&&(l=TR.now()),"complex64"===r){let e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);u=nU.mergeRealAndImagArrays(e,t)}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=TR.now()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}let t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=a){let t;t=o?new Lre(r,$re):new Ire(r,$re);let n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(GE().getBool("DEBUG")&&!GE().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===GE().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==s&&GE().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);let t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...bee(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){let e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),t=e[0],n=e[1];u=nU.mergeRealAndImagArrays(t,n)}else if(null==c)u=this.getValuesFromTexture(e);else{let e=TR.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){let e=this.gpgpu.gl;wee(e,(()=>e.deleteBuffer(c)))}let d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&iM().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new Lre(a,$re):new Ire(a,$re);let r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(e,t.customTexShape),c=iM().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>TR.decodeString(e)));return xF(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return xF(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let n=e[t];if(!Iee(n))throw GE().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=TR.sizeFromShape(t);if(GE().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...bee(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}let s=GE().getBool("WEBGL_PACK")&&!0===r,i=s?rte(t):t,o=s?new qte(i):new Hte(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let a=TR.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=TR.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(a);i.kernelMs=TR.sum(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:TR.now(),endMs:null}}endTimer(e){return GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=TR.now(),e)}async getQueryTime(e){if(GE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Vre;return GE().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&TR.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){nU.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return Bre(e.shape,t)}packedUnaryOp(e,t,n){let r=new Lre(e.shape,t),a=this.compileAndRun(r,[e],n);return iM().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=ere(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(GE().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Tre,e.dtype);let t=new Ire(e.shape,Tre),n=this.compileAndRun(t,[e]);return iM().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&TR.isString(n[0])){let a=n.map((e=>TR.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return iM().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new zre(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new bre(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let n=[tte(e.shape),...nte(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[tte(t),...nte(t)],s=new vre(a,n),i=[n],o=this.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){let e=TR.sizeFromShape(a),n=t[0]*t[1]*4;TR.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}let i,o=rte(a);i=r?new Gte(o):new jte(o);let l=[null!=t?t:bee(o)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0,i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===cee.DENSE){let t=null!=s?s:bee(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===TR.sizeFromShape(i.shape))return o.values=TR.getTypedArrayFromDType(i.dtype,0),i;let l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&TR.sizeFromShape(t.shape)<=GE().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!ite(n.shape,t.shape)){let e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);let c,d={shape:i.shape,texData:o,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach((t=>{let a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=Lte(e.packedInputs,t.shape,s),u="",c="",d="";if(1===o.length&&e.packedInputs){let e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){let e=TR.computeStrides(o);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;let h=t.shape.length,p=2===o.length&&TR.arraysEqual(t.shape,s),f=1===TR.sizeFromShape(t.shape),m=nU.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&TR.arraysEqual(s,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${h}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${d}_${y}_${a}`}else{let e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${GE().getNumber("WEBGL_VERSION")}`,s}(e,u,d),p=this.getAndSaveBinary(h,(()=>function(e,t,n,r){let a=n.map(((e,n)=>{let r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=Tte(a,i,t),l=Eee(e.gl,o),u=e.createProgram(l);return GE().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},Wte(e,t,u)))}(this.gpgpu,e,u,d))),f=null!=this.activeTimers;f&&(c=this.startTimer()),GE().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(Vte(t.inShapeInfos,n),Vte([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===GE().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let r=n[l],{uniform:a,offset:s,shape:i,texShape:o}=t.variablesLocations[l];if(i){let{uniformShape:n}=Lte(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=a){if(r.isUniform){if(TR.sizeFromShape(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}continue}null!=r.texData.slice&&null!=s&&e.gl.uniform1i(s,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){let n=TR.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){let n=t.program.customUniforms[l],r=t.customUniformLocations[l],s=a[l];if("float"===n.type)e.gl.uniform1fv(r,s);else if("vec2"===n.type)e.gl.uniform2fv(r,s);else if("vec3"===n.type)e.gl.uniform3fv(r,s);else if("vec4"===n.type)e.gl.uniform4fv(r,s);else if("int"===n.type)e.gl.uniform1iv(r,s);else if("ivec2"===n.type)e.gl.uniform2iv(r,s);else if("ivec3"===n.type)e.gl.uniform3iv(r,s);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,s)}}e.executeProgram()}(this.gpgpu,p,u,d,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),f&&(c=this.endTimer(c),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(c)}));let m=GE().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){let e=TR.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!GE().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){let e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(GE().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=uM((()=>{if(!GE().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=GE().getBool("DEBUG");GE().set("DEBUG",!1);let t=this.abs(fP(1e-8)).dataSync()[0];if(GE().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;let l,u=null!=this.activeTimers;u&&(l=TR.now());let c=t.texShape;if(null==c&&(c=ate(n,o),t.texShape=c),null!=a){let e,s=rte(n),i=c[1],d=c[0],h=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(o||!h)&&([i,d]=vee(c[0],c[1])),e=o?new Yte(s,h):new Xte(s,h);let p=h?[d,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=h?dee.PIXELS:dee.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,a);let g=[[d,i]],y=this.runWebGLProgram(e,[f],r,g,!0),b=this.texData.get(y.dataId);t.texShape=b.texShape,t.isPacked=b.isPacked,t.usage=b.usage,GE().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=b.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=TR.now()-l)}else{let e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*TR.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await eU(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(Ree(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=Wte(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:r,height:a,width:s,channels:i}=e,o=iM().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=o.writeTexture(r,t,n,a,s,i);return iM().makeTensorFromDataId(l,t,n,o)}};Ure.nextDataId=0;var jre="4.16.0";function Gre(){GE().set("WEBGL_FORCE_F16_TEXTURES",!0)}LD.isBrowser()&&vM("webgl",(()=>new Ure),2);var Hre={forceHalfFloat:Gre},qre="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",Kre=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=nU.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Ute(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},Xre="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",Yre=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=nU.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=Ute(a);let s="";if(r)if(0===a||1===TR.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${Pte(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let e=yre("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}};function Qre(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Jre={kernelName:h_,backendName:"webgl",kernelFunc:Qre};function Zre(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=Qre({inputs:{x:r},backend:n}),l=Qre({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var eae={kernelName:SA,backendName:"webgl",kernelFunc:Zre},tae="return (a < 0.) ? b * a : a;",nae="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var rae={kernelName:b_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",TR.createScalarValue(s,"float32")),o=GE().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Yre(nae,a.shape,i.shape):new Kre(tae,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},aae="return (a < 0.) ? b * a : a;",sae="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var iae={kernelName:a$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=GE().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Yre(sae,r.shape,a.shape):new Kre(aae,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},oae="if (isnan(x)) return x;";function lae(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=e;return e=>{let s,{inputs:i,backend:o}=e,{x:l}=i,u=o,c=a||l.dtype;if(u.shouldExecuteOnCPU([l])&&null!=r){let e=u.texData.get(l.dataId),t=r(e.values,c);return u.makeTensorInfo(l.shape,c,t)}return s=GE().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new Lre(l.shape,n):new Ire(l.shape,t),u.runWebGLProgram(s,[l],c)}}function uae(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:s,dtype:i}=e;return e=>{let{inputs:o,backend:l}=e,{a:u,b:c}=o,d=l;if(a&&"complex64"===u.dtype){let e=d.texData.get(u.dataId),n=d.texData.get(c.dataId),[r,a]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{let[n,r]=e,a={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:r.dataId,dtype:r.dtype,shape:c.shape},i=new Kre(t,u.shape,c.shape);return d.runWebGLProgram(i,[a,s],kD(n.dtype,r.dtype))})),s=Zre({inputs:{real:r,imag:a},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(a),s}let h,p=i||kD(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=s){let e=d.texData.get(u.dataId).values,t=d.texData.get(c.dataId).values,n="string"===u.dtype?nU.fromUint8ToStringArray(e):e,r="string"===u.dtype?nU.fromUint8ToStringArray(t):t,[a,i]=s(u.shape,c.shape,n,r,p),o=d.makeTensorInfo(i,p);return d.texData.get(o.dataId).values=a,o}return h=GE().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Yre(n,u.shape,c.shape,r):new Kre(t,u.shape,c.shape),d.runWebGLProgram(h,[u,c],p)}}function cae(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?Dre:Nre;if("relu"===e)return t?Fre:Are;if("elu"===e)return t?Mre:Ere;if("relu6"===e)return t?Ore:_re;if("prelu"===e)return t?sae:aae;if("leakyrelu"===e)return t?nae:tae;if("sigmoid"===e)return t?Pre:Rre;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var dae=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Ute(this.outputShape.length);let u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},hae={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},pae=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=nU.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},fae="return a * b;";function mae(e){let t,{inputs:n,backend:r}=e,{a:a,b:s}=n,i=nU.upcastType(a.dtype,s.dtype);if("complex64"===a.dtype){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),n=new pae(hae.REAL,a.shape,s.shape),i=new pae(hae.IMAG,a.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=r.runWebGLProgram(n,o,"float32"),u=r.runWebGLProgram(i,o,"float32"),c=Zre({inputs:{real:l,imag:u},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(u),c}if(r.shouldExecuteOnCPU([a,s])){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),[n,o]=Une(a.shape,s.shape,e.values,t.values,i),l=r.makeTensorInfo(o,i);return r.texData.get(l.dataId).values=n,l}return t=GE().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Yre(fae,a.shape,s.shape):new Kre(fae,a.shape,s.shape),r.runWebGLProgram(t,[a,s],i)}var gae={kernelName:H_,backendName:"webgl",kernelFunc:mae};function yae(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=TR.sizeFromShape(a.shape),l=TR.inferFromImplicitShape(s,o),u=TR.sizeFromShape(l);TR.assert(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));let c=i.texData.get(a.dataId);return!c.isPacked||ite(a.shape,l)||null!==c.texture&&ite(c.shape,l)?(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){let r=[tte(e.shape),...nte(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[tte(t),...nte(t)],i=new vre(s,r),o=[r],l=n.runWebGLProgram(i,[a],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(a,l,i)}var bae={kernelName:p$,backendName:"webgl",kernelFunc:yae},vae=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=4*Math.floor(n/4),o=n%4,l="sumValue += dot(values, ones);";if(null!=t){let e=1/t;l=`sumValue += dot(values * ${TR.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},xae=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");let u=4*Math.floor(n/4),c=n%4,d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function wae(e,t,n,r){let a=function(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],r=nU.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape),s=e;for(let i=0;i<a.length;i++){let o,l,{inSize:u,windowSize:c,outSize:d}=a[i];o="mean"===n?0===i?new vae({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:d},u):new vae({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:d}):new xae({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:d},n),l=s,s=r.runWebGLProgram(o,[s],t),l.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(l)}return s}var kae=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let r=Pte(this.rank),a=function(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}};var Sae=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=Pte(this.rank),a=gre("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function Iae(e,t,n){let r=GE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Sae(e.shape,t):new kae(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function Cae(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return function(e,t,n,r){let a=t,s=e.shape.length,i=TR.parseAxisParam(a,e.shape),o=i,l=nU.getAxesPermutation(o,s),u=null!=l,c=e;u&&(c=Iae(e,l,r),o=nU.getInnerMostAxes(o.length,s)),nU.assertAxesAreInnerMostDims("sum",o,s);let[d,h]=nU.computeOutAndReduceShapes(c.shape,o),p=d;n&&(p=nU.expandShapeToKeepDim(d,i));let f=TR.sizeFromShape(h),m=yae({inputs:{x:c},attrs:{shape:[TR.sizeFromShape(e.shape)/f,f]},backend:r}),g=wae(m,SD(e.dtype),"sum",r),y=yae({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),y}(a,s,i,n)}var Nae={kernelName:M$,backendName:"webgl",kernelFunc:Cae};function Tae(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{perm:i}=a,o=r,l=s.shape.length,u=new Array(l);for(let c=0;c<u.length;c++)u[c]=s.shape[i[c]];if(o.shouldExecuteOnCPU([s])){let e=o.texData.get(s.dataId).values,n=fre(e,s.shape,s.dtype,i,u);t=o.makeTensorInfo(u,s.dtype),o.texData.get(t.dataId).values=n}else t=Iae(s,i,o);return t}var Eae={kernelName:nR,backendName:"webgl",kernelFunc:Tae},Aae=1e3;function _ae(e){let{a:t,b:n,transposeA:r,transposeB:a,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e,c=t.shape.length,d=n.shape.length,h=r?t.shape[c-2]:t.shape[c-1],p=a?n.shape[d-1]:n.shape[d-2],f=r?t.shape[c-1]:t.shape[c-2],m=a?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=TR.sizeFromShape(g),v=TR.sizeFromShape(y),x=jO.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);TR.assert(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${a} must match.`));let w,k=r?[b,h,f]:[b,f,h],S=a?[v,m,p]:[v,p,m],I=yae({inputs:{x:t},backend:s,attrs:{shape:k}}),C=yae({inputs:{x:n},backend:s,attrs:{shape:S}}),N=[I,C],T=Math.max(b,v),E=r?I.shape[1]:I.shape[2],A=null!=i,_=null!=o,$="leakyrelu"===u,R=null!=u?cae(u,!0):null;if((1===f||1===m)&&E>Aae&&!1===(A||_||$||null!=R)){let e=I,t=C;r&&(e=Tae({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(e)),a&&(t=Tae({inputs:{x:C},backend:s,attrs:{perm:[0,2,1]}}),N.push(t));let n=1===m,i=e;1!==m&&(i=yae({inputs:{x:e},backend:s,attrs:{shape:[T,E,1]}}),N.push(i));let o=1===m?2:1,l=t;n&&(l=yae({inputs:{x:t},backend:s,attrs:{shape:[T,1,E]}}),N.push(l));let u=mae({inputs:{a:i,b:l},backend:s});w=Cae({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),N.push(u)}else{let e=kD(t.dtype,n.dtype),u=new dae(k,S,[T,f,m],r,a,A,R,_,$),c=[I,C];if(null!=i&&c.push(i),_&&c.push(o),$){let e=s.makeTensorInfo([],"float32",TR.createScalarValue(l,"float32"));c.push(e),N.push(e)}w=s.runWebGLProgram(u,c,e)}let D=yae({inputs:{x:w},backend:s,attrs:{shape:x}});N.push(w);for(let M of N)s.disposeIntermediateTensorInfo(M);return D}var $ae={kernelName:dR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return _ae({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},Rae="return abs(x);";var Dae={kernelName:YE,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=r.texData.get(a.dataId),t=ere(e.values);return r.makeTensorInfo(a.shape,a.dtype,t)}return t=GE().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Lre(a.shape,Rae):new Ire(a.shape,Rae),r.runWebGLProgram(t,[a],a.dtype)}},Mae=lae({opSnippet:Cre+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Fae={kernelName:QE,backendName:"webgl",kernelFunc:Mae},Oae=lae({opSnippet:Cre+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Pae={kernelName:JE,backendName:"webgl",kernelFunc:Oae},Lae="return a + b;",zae=uae({opSnippet:Lae,packedOpSnippet:Lae,supportsComplex:!0,cpuKernelImpl:wne}),Bae={kernelName:ZE,backendName:"webgl",kernelFunc:zae},Wae=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}},Vae=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}};var Uae={kernelName:eA,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,a=n;if(1===a.length)return Qre({inputs:{x:a[0]},backend:r});if(a.length>GE().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),s=e({inputs:a.slice(t),backend:r});return e({inputs:[n,s],backend:r})}let s=a.map((e=>e.dtype)).reduce(((e,t)=>kD(e,t))),i=a.map((e=>e.shape)),o=GE().getBool("WEBGL_PACK")?new Vae(a[0].shape,i):new Wae(a[0].shape,i);return r.runWebGLProgram(o,a,s)}};var jae={kernelName:tA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=TR.parseAxisParam(s,a.shape),u=l,c=nU.getAxesPermutation(u,o),d=a;null!=c&&(d=Tae({inputs:{x:a},backend:n,attrs:{perm:c}}),u=nU.getInnerMostAxes(u.length,o)),nU.assertAxesAreInnerMostDims("all",u,o);let h,[p,f]=nU.computeOutAndReduceShapes(d.shape,u),m=yae({inputs:{x:d},backend:n,attrs:{shape:[-1,TR.sizeFromShape(f)]}}),g=wae(m,m.dtype,"all",n);if(i){h=yae({inputs:{x:g},backend:n,attrs:{shape:nU.expandShapeToKeepDim(p,l)}})}else h=yae({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),h}};var Gae={kernelName:nA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=TR.parseAxisParam(s,a.shape),u=l,c=nU.getAxesPermutation(u,o),d=a;null!=c&&(d=Tae({inputs:{x:a},backend:n,attrs:{perm:c}}),u=nU.getInnerMostAxes(u.length,o)),nU.assertAxesAreInnerMostDims("any",u,o);let h,[p,f]=nU.computeOutAndReduceShapes(d.shape,u),m=yae({inputs:{x:d},backend:n,attrs:{shape:[-1,TR.sizeFromShape(f)]}}),g=wae(m,m.dtype,"any",n);if(i){h=yae({inputs:{x:g},backend:n,attrs:{shape:nU.expandShapeToKeepDim(p,l)}})}else h=yae({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),h}},Hae=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},qae=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,TR.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i,o,l=this.outputShape,u=l.length,c=Pte(u),d=yre("coords",u);if(1===s){o=u+1;let e=Pte(o);i=`\n        ${e} sourceLocR = ${e}(${d.join()}, 0);\n        ++${d[u-1]};\n        ${e} sourceLocG = ${e}(${d.join()}, 0);\n        ++${d[u-2]};\n        ${e} sourceLocA = ${e}(${d.join()}, 0);\n        --${d[u-1]};\n        ${e} sourceLocB = ${e}(${d.join()}, 0);\n        --${d[u-2]};`}else o=u,i=`\n        ${c} sourceLocR = coords;\n        ++${d[u-1]};\n        ${c} sourceLocG = coords;\n        ++${d[u-2]};\n        ${c} sourceLocA = coords;\n        --${d[u-1]};\n        ${c} sourceLocB = coords;\n        --${d[u-2]};`;let h=["x","y","z","w","u","v"].slice(0,o),p="."+h[o-1],f=h.map((e=>"int "+e)),m=yre("sourceLocR",o-1).concat("inIdx.r"),g=yre("sourceLocG",o-1).concat("inIdx.g"),y=yre("sourceLocB",o-1).concat("inIdx.b"),b=yre("sourceLocA",o-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${d[u-1]} < ${l[u-1]-1};\n        bool hasNextRow = ${d[u-2]} < ${l[u-2]-1};\n        ${i}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function Kae(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);let i=nU.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new Hae(o,n,null==r),u=[t];null!=r&&u.push(r);let c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;let d=Kae(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function Xae(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=null!=r?r.shape:t.shape,s=a[a.length-1],i=nU.computeOptimalWindowSize(s),o=new qae(a,i,n,null==r),l=null==r?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let r=Xae(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function Yae(e,t,n,r){let a=[n];if(nU.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!GE().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let n=[],s=e.texData.get(t.dataId),i=t;null!==s&&s.isPacked&&(i=e.unpackTensor(t),n.push(i));let[o,l]=nU.computeOutAndReduceShapes(i.shape,a),u=TR.sizeFromShape(l),c=yae({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);let d=Kae(e,c,r);n.push(d);let h=yae({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return Xae(e,t,r)}var Qae={kernelName:rA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=TR.parseAxisParam(s,a.shape),o=nU.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=Tae({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=nU.getInnerMostAxes(i.length,l.shape.length)),nU.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=Yae(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};var Jae={kernelName:aA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=TR.parseAxisParam(s,a.shape),o=nU.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=Tae({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=nU.getInnerMostAxes(i.length,l.shape.length)),nU.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=Yae(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},Zae=lae({opSnippet:Cre+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),ese={kernelName:sA,backendName:"webgl",kernelFunc:Zae},tse=lae({opSnippet:Cre+"return log(x + sqrt(x * x + 1.0));"}),nse={kernelName:iA,backendName:"webgl",kernelFunc:tse},rse=lae({opSnippet:Cre+"\n  return atan(x);\n"}),ase={kernelName:oA,backendName:"webgl",kernelFunc:rse},sse=uae({opSnippet:qre+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Xre+"\n  return result;\n"}),ise={kernelName:uA,backendName:"webgl",kernelFunc:sse},ose=lae({opSnippet:Cre+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),lse={kernelName:lA,backendName:"webgl",kernelFunc:ose},use=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");let v=4*Math.floor(s/4),x=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}},cse=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b="avg"===t,v="0.0";if(b||(v="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");let w=4*Math.floor(s/4),k=s%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}};var dse={kernelName:cA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;bte(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;TR.assert(nU.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u=nU.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&TR.arraysEqual(u.inShape,u.outShape))return Qre({inputs:{x:a},backend:n});let c=new use(u,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}};var hse={kernelName:hA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=nU.computePool3DInfo(a.shape,s,i,[1,1,1],o,l,u),d=new cse(c,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}},pse=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},fse=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var mse={kernelName:pA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=nU.computePool3DInfo(i.shape,o,l,[1,1,1],u,c),h=new fse(d);return n.runWebGLProgram(h,[a],i.dtype)}};var gse={kernelName:dA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;bte([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=nU.computePool2DInfo(i.shape,o,l,1,u),d=new pse(c);return n.runWebGLProgram(d,[a],i.dtype)}};var yse={kernelName:fA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;return _ae({a:a,b:s,transposeA:i,transposeB:o,backend:n})}},bse=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],nU.assertAndGetBroadcastShape(e,t),nU.assertAndGetBroadcastShape(e,n);let i="0.0";null!=r&&(nU.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(nU.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},vse=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],nU.assertAndGetBroadcastShape(e,t),nU.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";null!=r&&(nU.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(nU.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},xse={kernelName:o_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,mean:s,variance:i,offset:o,scale:l}=t;TR.assert(s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),TR.assert(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),TR.assert(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=r;null==u&&(u=.001);let c=[a,s,i],d=null;null!=o&&(d=o.shape,c.push(o));let h=null;null!=l&&(h=l.shape,c.push(l));let p=GE().getBool("WEBGL_PACK_NORMALIZATION")?new vse(a.shape,s.shape,i.shape,d,h,u):new bse(a.shape,s.shape,i.shape,d,h,u);return n.runWebGLProgram(p,c,c[0].dtype)}},wse=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Pte(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return kse.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);n=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${kse[t]} = start[${t}] + coords.${kse[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${n}\n        setOutput(getSource(${r}));\n      }\n    `}},kse=["x","y","z","w","u","v"];var Sse=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Pte(this.rank),n=yre("coords",this.rank),r=yre("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}};function Ise(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=_V.parseSliceParams(a,s,i);if(_V.assertParamsValid(a,o,l),0===TR.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){let e=n.texData.get(a.dataId),t=tre(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}let{isPacked:u}=n.texData.get(a.dataId),c=_V.isSliceContinous(a.shape,o,l);if(u||!c){let e=GE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Sse(l):new wse(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=_V.computeFlatOffset(t,TR.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}(a,o,l,n)}var Cse={kernelName:T$,backendName:"webgl",kernelFunc:Ise},Nse={kernelName:mA,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;TR.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=nU.getReshaped(a.shape,s,o),u=nU.getPermuted(l.length,s.length),c=nU.getReshapedPermuted(a.shape,s,o),d=nU.getSliceBeginCoords(i,s.length),h=nU.getSliceSize(c,i,s.length),p=[],f=yae({inputs:{x:a},backend:n,attrs:{shape:l}}),m=Tae({inputs:{x:f},backend:n,attrs:{perm:u}}),g=yae({inputs:{x:m},backend:n,attrs:{shape:c}}),y=Ise({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};var Tse={kernelName:gA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=kne(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}};var Ese={kernelName:yA,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{a:a,b:s}=n,i=GE().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=GE().getNumber("WEBGL_VERSION");if(r.shouldExecuteOnCPU([a,s])||1===o){let e=r.texData.get(a.dataId).values,t=r.texData.get(s.dataId).values,[n,i]=Ine(a.shape,s.shape,e,t,a.dtype),o=r.makeTensorInfo(i,a.dtype);return r.texData.get(o.dataId).values=n,o}return t=i?new Yre("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,s.shape,!1):new Kre("\n  return float(int(a.r) & int(b.r));\n",a.shape,s.shape),r.runWebGLProgram(t,[a,s],a.dtype)}};var Ase={kernelName:vA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=nU.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},_se=uae({opSnippet:"return float(a != b);",cpuKernelImpl:Gne,dtype:"bool"}),$se={kernelName:K_,backendName:"webgl",kernelFunc:_se};function Rse(e){let{inputs:t,backend:n}=e,{input:r}=t;return Qre({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}var Dse={kernelName:c$,backendName:"webgl",kernelFunc:Rse},Mse="return float(int(x));";var Fse={kernelName:xA,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:i}=a;if("complex64"===i){if("complex64"===s.dtype)return Qre({inputs:{x:s},backend:r});let t=hL(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=Zre({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){let t=Rse({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!TR.hasEncodingLoss(s.dtype,i)){let e=Qre({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([s])){let e=r.texData.get(s.dataId).values,[t,n,a]=Cne(e,s.shape,s.dtype,i);return r.makeTensorInfo(t,n,a)}if("int32"===i)return function(e,t){let n=new Ire(e.shape,Mse),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===i){let e=r.makeTensorInfo([],"bool",TR.getTypedArrayFromDType("bool",1)),t=_se({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},Ose="return ceil(x);",Pse=lae({opSnippet:Ose,packedOpSnippet:Ose,cpuKernelImpl:Nne}),Lse={kernelName:wA,backendName:"webgl",kernelFunc:Pse},zse=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}},Bse=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}};var Wse={kernelName:kA,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{clipValueMin:i,clipValueMax:o}=a;t=GE().getBool("WEBGL_PACK_CLIP")?new Bse(s.shape):new zse(s.shape);let l=[[i],[o]];return r.runWebGLProgram(t,[s],s.dtype,l)}},Vse=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}};function Use(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}var jse={kernelName:IA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new Vse(r.shape),i=[Use(r,a.complexTensorInfos.real),Use(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}},Gse=class{constructor(e){this.outputShape=[],this.outputShape=nU.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let e=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${e}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}},Hse=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=nU.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=Pte(r),s=yre("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],u=i.slice(-2),c=i.join(),d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){let e=o[f-1];d+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${qse(i,l,e)}),\n            vec2(${qse(u,l,e)}));\n        }`}let h=o.length,p=o[o.length-1];d+=`\n        return getChannel(\n          getT${h}(${qse(i,l,p)}),\n          vec2(${qse(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}};function qse(e,t,n){let r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function Kse(e){let{inputs:t,backend:n}=e,{input:r}=t;return Qre({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}var Xse={kernelName:f_,backendName:"webgl",kernelFunc:Kse};function Yse(e,t,n){let r=e[0].dtype;if("complex64"===r){let r=e.map((e=>Rse({inputs:{input:e},backend:n}))),a=e.map((e=>Kse({inputs:{input:e},backend:n}))),s=Yse(r,t,n),i=Yse(a,t,n),o=Zre({inputs:{real:s,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){let a=e.map((e=>{let r=[-1,TR.sizeFromShape(e.shape.slice(t))];return yae({inputs:{x:e},backend:n,attrs:{shape:r}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=nU.computeOutShape(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=Tne(s,i,r,o),u=nU.computeOutShape(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}let s=e.filter((e=>TR.sizeFromShape(e.shape)>0)),i=GE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){let t=i?new Ire(e[0].shape,$re):new Lre(e[0].shape,$re);return n.runWebGLProgram(t,e,r)}let o=GE().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let e=[];for(let a=0;a<s.length;a+=o){let r=s.slice(a,a+o);e.push(Yse(r,t,n))}let r=Yse(e,t,n);for(let t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){let e=new Hse(s.map((e=>e.shape)),t);return n.runWebGLProgram(e,s,r)}let{tensors2D:l,outShape:u}=function(e,t,n){let r=nU.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>yae({inputs:{x:e},attrs:{shape:[-1,TR.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}(s,t,n),c=new Gse(l.map((e=>e.shape))),d=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));let h=yae({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function Qse(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=TR.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));nU.assertParamsConsistent(i,s);let o=nU.computeOutShape(t.map((e=>e.shape)),s);if(0===TR.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>TR.sizeFromShape(e.shape)>0));return 1===l.length?Qre({inputs:{x:l[0]},backend:n}):Yse(l,s,n)}var Jse={kernelName:CA,backendName:"webgl",kernelFunc:Qse},Zse=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1,v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}},eie=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},tie=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ute(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u,d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)d+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){let t=2*m;if(d+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,d+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){let e=s%2===0?TR.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,d+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):d+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(d+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(d+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(d+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}},nie=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Ute(this.outputShape.length);let{dataFormat:n}=t,r=xte(),a="channelsLast"===n,s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}};function rie(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function aie(e){let t,{x:n,filter:r,convInfo:a,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e,c=n.shape,d=s.texData.get(n.dataId),h=a.inChannels,p=c[0]*c[1]*c[2],f=a.outChannels,m="channelsLast"===a.dataFormat,g=!1,y=[];if(null!=o){let e=rie(o.shape,m);null!=e&&(o=yae({inputs:{x:o},backend:s,attrs:{shape:e}}),y.push(o))}if(null!=i){let e=rie(i.shape,m);null!=e&&(i=yae({inputs:{x:i},backend:s,attrs:{shape:e}}),y.push(i))}if((1!==p&&1!==f||!(h>Aae))&&d.isPacked&&m&&null!=d.texture&&c[2]%2!==0&&TR.arraysEqual(d.shape.slice(-3),c.slice(-3))){let e=c[0]*c[1]*(c[2]+1),h={dataId:n.dataId,shape:[1,e,a.inChannels],dtype:n.dtype},p=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,TR.assert(ite(d.shape,h.shape),(()=>`packed reshape ${d.shape} to ${h.shape} isn't free`));let f=yae({inputs:{x:r},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}});y.push(f);let m=_ae({a:h,b:f,backend:s,transposeA:false,transposeB:g,bias:i,activation:u,preluActivationWeights:o,leakyreluAlpha:l}),b=s.texData.get(m.dataId);TR.assert(b.isPacked,(()=>"batchMatMul result is expected to be packed")),d.shape=p,b.shape=a.outShape,t=Qre({inputs:{x:m},backend:s}),t.shape=a.outShape,y.push(m)}else{let e=a.outHeight*a.outWidth,c=yae({inputs:{x:n},backend:s,attrs:{shape:m?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),d=yae({inputs:{x:r},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}}),h=_ae({a:m?c:d,b:m?d:c,transposeA:!m,transposeB:g,backend:s,bias:i,activation:u,preluActivationWeights:o,leakyreluAlpha:l});t=yae({inputs:{x:h},backend:s,attrs:{shape:a.outShape}}),y.push(c),y.push(d),y.push(h)}for(let b of y)s.disposeIntermediateTensorInfo(b);return t}function sie(e){let{x:t,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e,{filterWidth:u,filterHeight:c,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=u*c*d,y=p*h,b=[r.batchSize,g,y],v=[];if(null!=i){let e=rie(i.shape,m);null!=e&&(i=yae({inputs:{x:i},backend:a,attrs:{shape:e}}),v.push(i))}if(null!=s){let e=rie(s.shape,m);null!=e&&(s=yae({inputs:{x:s},backend:a,attrs:{shape:e}}),v.push(s))}let x=yae({inputs:{x:n},backend:a,attrs:{shape:[1,g,TR.sizeFromShape(n.shape)/g]}});v.push(x);let w=new nie(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(w,[t],"float32",k),I=yae({inputs:{x:S},backend:a,attrs:{shape:b}});v.push(S),v.push(I);let C=null!=s,N=null!=i,T="leakyrelu"===l,E=l?cae(l,!0):null,A=new dae(m?I.shape:x.shape,m?x.shape:I.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,C,E,N,T),_=m?[I,x]:[x,I];if(s&&_.push(s),N&&_.push(i),T){let e=a.makeTensorInfo([],"float32",TR.createScalarValue(o,"float32"));_.push(e),v.push(e)}let $=a.runWebGLProgram(A,_,"float32"),R=yae({inputs:{x:$},backend:a,attrs:{shape:r.outShape}});v.push($);for(let D of v)a.disposeIntermediateTensorInfo(D);return R}var iie={kernelName:NA,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:d}=a,h=nU.convertConv2DDataFormat(u),p=nU.computeConv2DInfo(s.shape,i.shape,o,c,l,d,!1,h);if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(p.strideWidth<=2&&"channelsLast"===h&&GE().getBool("WEBGL_EXP_CONV")){let e=new tie(p),n=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];t=r.runWebGLProgram(e,[s,i],"float32",n)}else if(GE().getBool("WEBGL_CONV_IM2COL"))t=sie({x:s,filter:i,convInfo:p,backend:r});else{let e=new Zse(p);t=r.runWebGLProgram(e,[s,i],"float32")}else t=aie({x:s,filter:i,convInfo:p,backend:r});let f=yae({inputs:{x:t},backend:r,attrs:{shape:p.outShape}});return r.disposeIntermediateTensorInfo(t),f}},oie=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},lie=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},uie=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},cie=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var die={kernelName:TA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=nU.convertConv2DDataFormat(l),h=nU.computeConv2DInfo(a.shape,c,i,1,o,u,!1,d),p=new oie(h);return n.runWebGLProgram(p,[a,s],"float32")}},hie=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Ute(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}};var pie={kernelName:EA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=nU.convertConv2DDataFormat(u),h=nU.computeConv2DInfo(i,s.shape,o,1,l,c,!1,d);if(GE().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){let e=[[h.strideHeight,h.strideWidth]],t=new hie(h);return n.runWebGLProgram(t,[a,s],"float32",e)}{let e=new lie(h);return n.runWebGLProgram(e,[a,s],"float32")}}};var fie={kernelName:AA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=nU.computeConv3DInfo(a.shape,s.shape,i,l,o),c=new eie(u);return n.runWebGLProgram(c,[a,s],"float32")}};var mie={kernelName:_A,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=nU.computeConv3DInfo(a.shape,l,i,1,o),c=new uie(u);return n.runWebGLProgram(c,[a,s],"float32")}};var gie,yie={kernelName:$A,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=nU.computeConv3DInfo(l,s.shape,o,1,i),c=new cie(u);return n.runWebGLProgram(c,[a,s],"float32")}},bie=lae({opSnippet:oae+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Xre}\n  return result;\n`}),vie={kernelName:RA,backendName:"webgl",kernelFunc:bie},xie=lae({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),wie={kernelName:DA,backendName:"webgl",kernelFunc:xie},kie=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];let h="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,x]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},Sie={kernelName:OA,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new kie(a.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[a,s,i],"float32")}};!function(e){e.Prod="*",e.Sum="+"}(gie||(gie={}));var Iie=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===gie.Prod?"1.0":"0.0",i=n?s:`getX(${Cie(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Pte(a)} coords = getOutputCoords();\n        int end = ${Nie(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${Nie(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Cie(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function Cie(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Nie(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Tie(e,t,n,r,a,s){let i=t.shape.length,o=nU.getAxesPermutation([r],i),l=t;null!=o&&(l=Tae({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=nU.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let c=l.shape[u],d=Qre({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){let t=new Iie(e,l.shape,!1,s),r=[[h]],a=d;d=n.runWebGLProgram(t,[d],d.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){let t=new Iie(e,l.shape,a,s),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){let e=Tae({inputs:{x:d},backend:n,attrs:{perm:nU.getUndoAxesPermutation(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}var Eie={kernelName:MA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return Tie(gie.Prod,a,n,s,i,o)}};var Aie={kernelName:FA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return Tie(gie.Sum,a,n,s,i,o)}};var _ie={kernelName:PA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=kne(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(s),r=Sne(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},$ie=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};var Rie={kernelName:LA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,c=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d=new $ie("NHWC"===i?[o,l,u,c]:[o,c,l,u],s,i);return n.runWebGLProgram(d,[a],a.dtype)}},Die=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ute(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}},Mie=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ute(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c,h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)h+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){let e=2*g;if(h+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,h+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){let t=i%2===0?TR.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,h+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):h+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(h+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(h+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(h+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}};var Fie={kernelName:zA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r,c=l;null==c&&(c=[1,1]),TR.assert(nU.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));let d,h=nU.computeConv2DInfo(a.shape,s.shape,i,c,o,u,!0);d=GE().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new Mie(h):new Die(h);let p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[a,s],"float32",p)}},Oie=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Pie=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var Lie={kernelName:BA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=nU.computeConv2DInfo(a.shape,c,i,o,l,u,!0),h=new Oie(d);return n.runWebGLProgram(h,[a,s],"float32")}};var zie={kernelName:WA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=nU.computeConv2DInfo(c,s.shape,i,o,l,u,!0),h=new Pie(d);return n.runWebGLProgram(h,[a,s],"float32")}},Bie=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}};var Wie={kernelName:VA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=TR.sizeFromShape(r.shape),i=yae({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new Bie(s),l=n.runWebGLProgram(o,[i],i.dtype),u=yae({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}},Vie=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}};var Uie={kernelName:UA,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dilations:u}=a,c=nU.computeDilation2DInfo(s.shape,i.shape,o,l,"NHWC",u),d=new Vie(c);t=r.runWebGLProgram(d,[s,i],"float32");let h=yae({inputs:{x:t},backend:r,attrs:{shape:c.outShape}});return r.disposeIntermediateTensorInfo(t),h}};var jie={kernelName:KA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=nU.decodeEinsumEquation(a,s.length);nU.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=nU.getEinsumComputePath(o,l),d=c.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let e of c[m]){let t,{permutationIndices:r,expandDims:a}=nU.getEinsumPermutation(p,l[e]);nU.isIdentityPermutation(r)?t=s[e]:(t=Tae({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);TR.arraysEqual(t.shape,i)||(t=yae({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===h?h=t:(h=mae({inputs:{a:t,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=Cae({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},Gie=lae({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Hie={kernelName:XA,backendName:"webgl",kernelFunc:Gie},qie={kernelName:YA,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=GE().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Yre("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new Kre("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},Kie=uae({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Ene}),Xie={kernelName:JA,backendName:"webgl",kernelFunc:Kie},Yie=lae({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${nU.ERF_P};\n  float a1 = ${nU.ERF_A1};\n  float a2 = ${nU.ERF_A2};\n  float a3 = ${nU.ERF_A3};\n  float a4 = ${nU.ERF_A4};\n  float a5 = ${nU.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),Qie={kernelName:QA,backendName:"webgl",kernelFunc:Yie},Jie=lae({opSnippet:oae+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Ane,dtype:"float32"}),Zie={kernelName:ZA,backendName:"webgl",kernelFunc:Jie};function eoe(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(TR.assert(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),yae({inputs:{x:s},backend:r,attrs:{shape:o}})}var toe={kernelName:e_,backendName:"webgl",kernelFunc:eoe},noe="return exp(x) - 1.0;",roe=lae({opSnippet:noe,packedOpSnippet:noe,cpuKernelImpl:_ne}),aoe={kernelName:t_,backendName:"webgl",kernelFunc:roe},soe=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a,s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${r}.0`:"1.0";if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function ioe(e,t,n){let r=n.texData.get(e.dataId),a=TR.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=yae({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),o=i.shape,l=new soe("real",o,t),u=new soe("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(l,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),p=Zre({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);let f=yae({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}var ooe={kernelName:n_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return ioe(r,!1,n)}},loe=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};function uoe(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||TR.inferDtype(a),"string"===s){let e=TR.getArrayFromDType(s,TR.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{let e=new loe(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}var coe,doe={kernelName:r_,backendName:"webgl",kernelFunc:uoe},hoe=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},poe={kernelName:a_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{image:r}=t,a=n,s=new hoe(r.shape);return a.runWebGLProgram(s,[r],r.dtype)}},foe="return floor(x);",moe=lae({opSnippet:foe,packedOpSnippet:foe,cpuKernelImpl:$ne}),goe={kernelName:s_,backendName:"webgl",kernelFunc:moe},yoe=uae({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),boe={kernelName:i_,backendName:"webgl",kernelFunc:yoe},voe=class{constructor(e){this.variableNames=["A"];let t=xte(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},xoe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=xte(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},woe={kernelName:uR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],c=[u,l],d=[u,l,s];if(o||i){let e=GE().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==coe||e!==koe)&&(koe=e,coe=document.createElement("canvas").getContext("2d",{willReadFrequently:koe})),coe.canvas.width=l,coe.canvas.height=u,coe.drawImage(a,0,0,l,u),a=coe.canvas}let h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=dee.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);let p=GE().getBool("WEBGL_PACK")?new xoe(d):new voe(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}},koe=GE().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");var Soe={kernelName:hR,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=n,{strides:u,pad:c,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=a,g=nU.convertConv2DDataFormat(d),y=nU.computeConv2DInfo(s.shape,i.shape,u,h,c,p,!1,g),b=[],v=null!=o,x=null!=l,w="leakyrelu"===f,k=()=>{let e=[s,i],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=yae({inputs:{x:e},backend:r,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(o,d)),x&&e.push(t(l,d)),w){let t=r.makeTensorInfo([],"float32",TR.createScalarValue(m,"float32"));e.push(t),b.push(t)}return e};if(1!==y.filterHeight||1!==y.filterWidth||1!==y.dilationHeight||1!==y.dilationWidth||1!==y.strideHeight||1!==y.strideWidth||"SAME"!==y.padInfo.type&&"VALID"!==y.padInfo.type)if(y.strideWidth<=2&&"channelsLast"===g&&GE().getBool("WEBGL_EXP_CONV")){let e=f?cae(f,!0):null,n=new tie(y,v,e,x,w),a=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],s=k();t=r.runWebGLProgram(n,s,"float32",a)}else if(GE().getBool("WEBGL_CONV_IM2COL"))t=sie({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{let e=f?cae(f,!1):null,n=new Zse(y,v,e,x,w),a=k();t=r.runWebGLProgram(n,a,"float32")}else t=aie({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});let S=yae({inputs:{x:t},backend:r,attrs:{shape:y.outShape}});return b.push(t),b.forEach((e=>r.disposeIntermediateTensorInfo(e))),S}};var Ioe={kernelName:pR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[],m=c;null==m&&(m=[1,1]),TR.assert(nU.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));let g,y=nU.computeConv2DInfo(a.shape,s.shape,l,m,u,d,!0),b=GE().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,v=h?cae(h,b):null,x=[a,s],w=null!=i,k=null!=o,S="leakyrelu"===h;if(w&&x.push(i),k&&x.push(o),S){let e=n.makeTensorInfo([],"float32",TR.createScalarValue(p,"float32"));x.push(e),f.push(e)}g=b?new Mie(y,w,v,k,S):new Die(y,w,v,k,S);let I=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],C=n.runWebGLProgram(g,x,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),C}},Coe=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=Pte(n.length),s="\n    int index;";for(let i=0;i<this.sliceDim;i++)s+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}};var Noe={kernelName:u_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=TR.sizeFromShape(r.shape),[l,u,c,d]=nU.prepareAndValidate(r,a),h=yae({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),p=yae({inputs:{x:r},backend:n,attrs:{shape:[TR.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){let e=n.readSync(a.dataId),t=n.bufferSync(r),s=Rne(e,t,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}let f=new Coe(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=yae({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}},Toe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Pte(this.rank),r=function(e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}};function Eoe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=TR.parseAxisParam(i,a.shape)[0];if(GE().get("DEBUG")){let e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){let r=e[n];TR.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}let u=nU.segment_util.collectGatherOpShapeInfo(a,s,l,o),c=TR.sizeFromShape(s.shape),d=[],h=yae({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=yae({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);let f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){let e=n.bufferSync(p),t=n.bufferSync(h),r=Dne(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}let m=new Toe(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);let y=yae({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}var Aoe={kernelName:l_,backendName:"webgl",kernelFunc:Eoe},_oe=uae({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Mne,dtype:"bool"}),$oe={kernelName:c_,backendName:"webgl",kernelFunc:_oe},Roe=uae({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Fne}),Doe={kernelName:d_,backendName:"webgl",kernelFunc:Roe};var Moe={kernelName:p_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return ioe(r,!0,n)}},Foe=lae({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Ooe={kernelName:m_,backendName:"webgl",kernelFunc:Foe},Poe=lae({opSnippet:"return float(isinf(x));",dtype:"bool"}),Loe={kernelName:g_,backendName:"webgl",kernelFunc:Poe},zoe=lae({opSnippet:"return float(isnan(x));",dtype:"bool"}),Boe={kernelName:y_,backendName:"webgl",kernelFunc:zoe},Woe=uae({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:One,dtype:"bool"}),Voe={kernelName:v_,backendName:"webgl",kernelFunc:Woe},Uoe=uae({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Pne,dtype:"bool"}),joe={kernelName:x_,backendName:"webgl",kernelFunc:Uoe};var Goe={kernelName:w_,backendName:"webgl",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=Lne(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},Hoe=lae({opSnippet:oae+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:zne}),qoe={kernelName:k_,backendName:"webgl",kernelFunc:Hoe},Koe=lae({opSnippet:oae+"\n  return log(1.0 + x);\n"}),Xoe={kernelName:S_,backendName:"webgl",kernelFunc:Koe},Yoe=uae({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Qoe={kernelName:I_,backendName:"webgl",kernelFunc:Yoe},Joe=lae({opSnippet:"return float(!(x >= 1.0));"}),Zoe={kernelName:C_,backendName:"webgl",kernelFunc:Joe},ele=uae({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),tle={kernelName:N_,backendName:"webgl",kernelFunc:ele},nle=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}},rle=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}},ale={kernelName:__,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=GE().getBool("WEBGL_PACK_NORMALIZATION")?new rle(a.shape,s,i,o,l):new nle(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)}},sle=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},ile={kernelName:$_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new sle(a.shape,o,l,u,c);return n.runWebGLProgram(d,[a,s,i],a.dtype)}};function ole(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=TR.parseAxisParam(s,a.shape),u=l,c=nU.getAxesPermutation(u,o),d=null!=c,h=n.shouldExecuteOnCPU([a]),p=a;if(d){if(h){let e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=a.shape[c[n]];let r=fre(e,a.shape,a.dtype,c,t);p=n.makeTensorInfo(t,a.dtype),n.texData.get(p.dataId).values=r}else p=Iae(a,c,n);u=nU.getInnerMostAxes(u.length,o)}nU.assertAxesAreInnerMostDims("max",u,o);let f,[m,g]=nU.computeOutAndReduceShapes(p.shape,u),y=m;if(i&&(y=nU.expandShapeToKeepDim(m,l)),h){let e=n.texData.get(p.dataId).values,t=Bne(e,TR.sizeFromShape(g),y,a.dtype);f=n.makeTensorInfo(y,a.dtype),n.texData.get(f.dataId).values=t}else f=function(e,t,n,r){let a=TR.sizeFromShape(t),s=yae({inputs:{x:e},attrs:{shape:[TR.sizeFromShape(e.shape)/a,a]},backend:r}),i=wae(s,e.dtype,"max",r),o=yae({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(p,g,y,n);return d&&n.disposeIntermediateTensorInfo(p),f}var lle={kernelName:D_,backendName:"webgl",kernelFunc:ole},ule=uae({opSnippet:qre+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Xre+"\n  return result;\n",cpuKernelImpl:Wne}),cle={kernelName:M_,backendName:"webgl",kernelFunc:ule};var dle={kernelName:F_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;bte(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;TR.assert(nU.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u=nU.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&TR.arraysEqual(u.inShape,u.outShape))return Qre({inputs:{x:a},backend:n});let c=new use(u,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}};var hle={kernelName:P_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=nU.computePool3DInfo(a.shape,s,i,[1,1,1],o,u,l),d=new cse(c,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}},ple=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},fle=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var mle={kernelName:L_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=nU.computePool3DInfo(i.shape,o,l,[1,1,1],u,c),h=new cse(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new fle(d),m=n.runWebGLProgram(f,[a,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};var gle={kernelName:O_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;bte([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=nU.computePool2DInfo(o.shape,l,u,1,c,d),p=new use(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new ple(h),g=n.runWebGLProgram(m,[a,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};var yle={kernelName:z_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;TR.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));let c=[1,1];TR.assert(nU.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));let d=nU.computePool2DInfo(a.shape,s,i,c,o),[h,p]=function(e,t,n,r){let a=new use(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");return a=new use(n,"max",!0,!0,t),[s,r.runWebGLProgram(a,[e],"float32")]}(a,l,d,u);return[h,p]}};var ble={kernelName:B_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{keepDims:s,axis:i}=n,o=r,l=a.shape.length,u=TR.parseAxisParam(i,a.shape),c=u,d=nU.getAxesPermutation(c,l),h=null!=d,p=o.shouldExecuteOnCPU([a]),f=[],m=a;if(h){if(p){let e=o.texData.get(m.dataId).values,t=new Array(l);for(let r=0;r<t.length;r++)t[r]=a.shape[d[r]];let n=fre(e,a.shape,a.dtype,d,t);m=o.makeTensorInfo(t,a.dtype),o.texData.get(m.dataId).values=n}else m=Iae(a,d,o);f.push(m),c=nU.getInnerMostAxes(c.length,l)}nU.assertAxesAreInnerMostDims("sum",c,l);let[g,y]=nU.computeOutAndReduceShapes(m.shape,c),b=g;s&&(b=nU.expandShapeToKeepDim(g,u));let v=function(e,t,n,r){let a=TR.sizeFromShape(t),s=yae({inputs:{x:e},attrs:{shape:[TR.sizeFromShape(e.shape)/a,a]},backend:r}),i=wae(s,"float32","mean",r),o=yae({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(m,y,b,o);for(let x of f)o.disposeIntermediateTensorInfo(x);return v}};var vle={kernelName:W_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=TR.parseAxisParam(s,a.shape),u=l,c=nU.getAxesPermutation(u,o),d=a;null!=c&&(d=Tae({inputs:{x:a},backend:n,attrs:{perm:c}}),u=nU.getInnerMostAxes(u.length,a.shape.length)),nU.assertAxesAreInnerMostDims("min",u,o);let h,[p,f]=nU.computeOutAndReduceShapes(d.shape,u),m=yae({inputs:{x:d},backend:n,attrs:{shape:[-1,TR.sizeFromShape(f)]}}),g=wae(m,m.dtype,"min",n);if(i){h=yae({inputs:{x:g},backend:n,attrs:{shape:nU.expandShapeToKeepDim(p,l)}})}else h=yae({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),h}},xle=uae({opSnippet:qre+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Xre+"\n  return result;\n",cpuKernelImpl:Vne}),wle={kernelName:V_,backendName:"webgl",kernelFunc:xle},kle=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=Pte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}},Sle=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=Pte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=yre("rc",r),l=yre("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1,h="";if(1===r){let e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{let e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}},Ile={kernelName:U_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r,o=GE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Sle(a.shape,s,i):new kle(a.shape,s,i);return n.runWebGLProgram(o,[a],a.dtype)}},Cle=uae({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Xre+"\n  return result;\n"}),Nle={kernelName:j_,backendName:"webgl",kernelFunc:Cle},Tle=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},Ele=uae({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Ale={kernelName:qA,backendName:"webgl",kernelFunc:Ele},_le="return a - b;",$le=uae({opSnippet:_le,packedOpSnippet:_le,supportsComplex:!0,cpuKernelImpl:dre}),Rle={kernelName:Y$,backendName:"webgl",kernelFunc:$le};function Dle(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=TR.parseAxisParam([s],a.shape),o=ole({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=nU.expandShapeToKeepDim(o.shape,i),u=yae({inputs:{x:o},backend:n,attrs:{shape:l}}),c=$le({inputs:{a:a,b:u},backend:n}),d=Jie({inputs:{x:c},backend:n}),h=Cae({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=yae({inputs:{x:h},backend:n,attrs:{shape:l}}),f=Ele({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}var Mle={kernelName:P$,backendName:"webgl",kernelFunc:Dle};var Fle={kernelName:G_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:Dle({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new Tle(u,c,s),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}},Ole=Cre+"\n  return -x;\n";var Ple={kernelName:q_,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])){let e=r.texData.get(a.dataId),[t,n]=jne(e.values,a.shape,a.dtype);return r.makeTensorInfo(n,a.dtype,t)}return t=GE().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Lre(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Ire(a.shape,Ole),r.runWebGLProgram(t,[a],a.dtype)}},Lle=lj.nonMaxSuppressionV3Impl;var zle={kernelName:X_,backendName:"webgl",kernelFunc:function(e){nU.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=Lle(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Ble=lj.nonMaxSuppressionV4Impl;var Wle={kernelName:Y_,backendName:"webgl",kernelFunc:function(e){nU.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:p}=Ble(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},Vle=lj.nonMaxSuppressionV5Impl;var Ule={kernelName:Q_,backendName:"webgl",kernelFunc:function(e){nU.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=Vle(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},jle=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},Gle={kernelName:Z_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=TR.sizeFromShape(a.shape),c=new jle(u,i,o,l),d=yae({inputs:{x:a},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],s);n.disposeIntermediateTensorInfo(d);let p=yae({inputs:{x:h},backend:n,attrs:{shape:[...a.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function Hle(e){let{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){let e=Rse({inputs:{input:r},backend:n}),t=Hle({inputs:{x:e},backend:n}),a=Kse({inputs:{input:r},backend:n}),s=Hle({inputs:{x:a},backend:n}),i=Zre({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return uoe({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var qle={kernelName:oR,backendName:"webgl",kernelFunc:Hle};var Kle={kernelName:J_,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){let t=Rse({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=Kse({inputs:{input:a},backend:r}),i=Hle({inputs:{x:s},backend:r}),o=Zre({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return uoe({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};var Xle={kernelName:e$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return eoe({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{TR.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),TR.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=eoe({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=Qse({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},Yle=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=Pte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}},Qle=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=Pte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=yre("rc",r),l=yre("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${d[f]}\n        if (${h}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}},Jle=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===TR.sizeFromShape(a.shape)){let e=s.map(((e,t)=>e[0]+a.shape[t]+e[1]));return uoe({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}let o=GE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qle(a.shape,s,i):new Yle(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},Zle={kernelName:t$,backendName:"webgl",kernelFunc:Jle},eue=uae({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Xre+"\n  return result;\n"}),tue={kernelName:r$,backendName:"webgl",kernelFunc:eue};var nue={kernelName:s$,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a,l=s.shape.length,u=[],c=TR.parseAxisParam(i,s.shape),d=c,h=nU.getAxesPermutation(d,l),p=s;if(null!=h&&(p=Tae({inputs:{x:s},backend:r,attrs:{perm:h}}),d=nU.getInnerMostAxes(d.length,l),u.push(p)),nU.assertAxesAreInnerMostDims("prod",d,l),r.shouldExecuteOnCPU([p])){let e=r.texData.get(p.dataId).values,{outVals:n,outShape:a,outDtype:s}=Hne(p.shape,p.dtype,e,d);t=r.makeTensorInfo(a,s,n)}else{let[e,n]=nU.computeOutAndReduceShapes(p.shape,d),a=TR.sizeFromShape(n),i=yae({inputs:{x:p},backend:r,attrs:{shape:[-1,a]}}),o=wae(i,SD(s.dtype),"prod",r);t=yae({inputs:{x:o},backend:r,attrs:{shape:e}}),u.push(i),u.push(o)}if(o){u.push(t);let e=nU.expandShapeToKeepDim(t.shape,c);t=yae({inputs:{x:t},backend:r,attrs:{shape:e}})}return u.forEach((e=>r.disposeIntermediateTensorInfo(e))),t}};var rue={kernelName:i$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.readSync(e.dataId))),u=a.map((e=>e.shape)),c=n.readSync(s.dataId),d=n.readSync(i.dataId),[h,p,f]=qne(l,u,c,s.shape,s.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};var aue={kernelName:o$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=Kne(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var sue={kernelName:l$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),d=n.readSync(i.dataId),h=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=Xne(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}},iue=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=Yne(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},oue={kernelName:u$,backendName:"webgl",kernelFunc:iue},lue=lae({opSnippet:"return 1.0 / x;"}),uue={kernelName:d$,backendName:"webgl",kernelFunc:lue},cue=lae({opSnippet:Cre+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),due={kernelName:h$,backendName:"webgl",kernelFunc:cue},hue=lae({opSnippet:Cre+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),pue={kernelName:b$,backendName:"webgl",kernelFunc:hue},fue=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},mue=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}};var gue={kernelName:g$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=GE().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new mue(a.shape,l,u,s,i):new fue(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],"float32")}},yue=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};var bue={kernelName:y$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new yue(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}},vue=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";u=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},xue=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";u=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}};var wue={kernelName:f$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=GE().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new xue(a.shape,l,u,s,i):new vue(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],a.dtype)}},kue=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};var Sue={kernelName:m$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new kue(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}},Iue=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);let r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=Pte(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}},Cue=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=yre("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Pte(n);var o;function l(n){let r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o=r.slice(),l(o)};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",l(e)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}};var Nue={kernelName:v$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=TR.parseAxisParam(s,a.shape);if(0===i)return Qre({inputs:{x:a},backend:n});let l=GE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Cue(a.shape,o):new Iue(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}},Tue=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},Eue={kernelName:cR,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=new Tue(a.shape,i),[c,d]=nU.getImageCenter(o,a.shape[1],a.shape[2]),h=[[c,d,Math.sin(s),Math.cos(s)]];return l.runWebGLProgram(u,[a],a.dtype,h)}},Aue=lae({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),_ue={kernelName:x$,backendName:"webgl",kernelFunc:Aue},$ue=lae({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Qne}),Rue={kernelName:w$,backendName:"webgl",kernelFunc:$ue},Due=class{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let o=Pte(a.length),l=Pte(s.length),u="";1===n?u="i":2===n&&(u="i, j");let c=`getIndices(${u})`,d="";1===r?d="i":2===r&&(d="i, coords[1]");let h=`getUpdates(${d})`,p="";i&&(p="coords[0], coords[1]");let f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}},Mue=class{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let o=Pte(a.length),l=Pte(s.length),u="";1===n?u="i":2===n&&(u="i, j");let c=`getIndices(${u})`,d="";1===r?d="i":2===r&&(d="i, coords[1]");let h=`getUpdates(${d})`,p="";i&&(p="coords[0], coords[1]");let f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${g};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}};var Fue={kernelName:k$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=nU.calculateShapes(s,a,i),h=[d/u,u];if(0===d)return n.makeTensorInfo(i,a.dtype);let p,f=yae({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),m=yae({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));p=GE().getBool("WEBGL_PACK")?new Mue(l,o,f.shape.length,m.shape.length,c,h):new Due(l,o,f.shape.length,m.shape.length,c,h);let y=n.runWebGLProgram(p,[m,f,g],m.dtype),b=yae({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(g),b}},Oue=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===GE().getNumber("WEBGL_VERSION")?"while (left < right) {":a,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}};var Pue={kernelName:I$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new Oue(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}},Lue=class{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{let n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}let s=Pte(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}};var zue={kernelName:C$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new Lue(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],kD(a.dtype,s.dtype))}},Bue=lae({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${nU.SELU_SCALEALPHA};\n  float scale = ${nU.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),Wue={kernelName:N$,backendName:"webgl",kernelFunc:Bue},Vue=lae({opSnippet:oae+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Zne}),Uue={kernelName:$$,backendName:"webgl",kernelFunc:Vue},jue=lae({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Gue={kernelName:_$,backendName:"webgl",kernelFunc:jue},Hue=lae({opSnippet:oae+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Xre}\n  return result;\n`}),que={kernelName:E$,backendName:"webgl",kernelFunc:Hue},Kue=lae({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Xue={kernelName:A$,backendName:"webgl",kernelFunc:Kue},Yue=lae({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Que={kernelName:R$,backendName:"webgl",kernelFunc:Yue},Jue={kernelName:F$,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;TR.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let u=[],c=Jle({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=nU.getReshaped(c.shape,s,o,!1),h=nU.getPermuted(d.length,s.length,!1),p=nU.getReshapedPermuted(c.shape,s,o,!1),f=yae({inputs:{x:c},backend:n,attrs:{shape:d}}),m=Tae({inputs:{x:f},backend:n,attrs:{perm:h}}),g=yae({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};var Zue={kernelName:L$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=nre(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var ece={kernelName:z$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,d]=rre(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var tce={kernelName:B$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=are(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};var nce={kernelName:W$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=are(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};var rce={kernelName:V$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=nU.calculateShapes(s,a,o),p=!1;if("string"===s.dtype){let e=n.bufferSync(a),t=n.bufferSync(s),r=TR.decodeString(n.readSync(i.dataId)[0]),f=Jne(e,t,o,h,c,u,l,d,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}let f=new Due(u,l,a.shape.length,s.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=yae({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};var ace={kernelName:O$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=TR.parseAxisParam(i,a.shape)[0],l=nU.prepareSplitSize(a,s,o),u=a.shape.length,c=new Array(u).fill(0),d=a.shape.slice();return l.map((e=>{let t=[...d];t[o]=e;let r=Ise({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},sce="return sqrt(x);",ice=lae({opSnippet:sce,packedOpSnippet:sce,cpuKernelImpl:sre}),oce={kernelName:D$,backendName:"webgl",kernelFunc:ice},lce=lae({opSnippet:"return x * x;"}),uce={kernelName:j$,backendName:"webgl",kernelFunc:lce},cce="return (a - b) * (a - b);",dce=uae({opSnippet:cce,packedOpSnippet:cce}),hce={kernelName:U$,backendName:"webgl",kernelFunc:dce};var pce={kernelName:G$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");let s=n.readSync(a.dataId),i=nU.fromUint8ToStringArray(s),o=ire(i,"string",r);return n.makeTensorInfo(a.shape,"string",o)}};var fce={kernelName:lR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,s=Cre+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,i=new Ire(a.shape,s);return r.runWebGLProgram(i,[a],a.dtype)}},mce=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=Pte(n.length),s=Pte(n.length),i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}};var gce={kernelName:H$,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{begin:i,end:o,strides:l,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=_V.sliceInfo(s.shape,i,o,l,u,c,d,h,p);if(g)t=yae({inputs:{x:s},backend:r,attrs:{shape:m}});else if(y||b){TR.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=_V.computeOutShape(v,x,w),n=Ise({inputs:{x:s},backend:r,attrs:{begin:v,size:e}});t=yae({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeIntermediateTensorInfo(n)}else if(r.shouldExecuteOnCPU([s])){let e=r.readSync(s.dataId),n=xF(s.shape,s.dtype,e),a=ore(f,n,w,v);t=r.makeTensorInfo(m,s.dtype,a.values)}else{let e=new mce(v,w,f);t=r.runWebGLProgram(e,[s],s.dtype)}let k=yae({inputs:{x:t},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(t),k}};var yce={kernelName:q$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=lre(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var bce={kernelName:K$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=ure(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var vce={kernelName:X$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=cre(i,a);return n.makeTensorInfo(s.shape,"int32",o)}},xce=lae({opSnippet:"return tan(x);"}),wce={kernelName:Q$,backendName:"webgl",kernelFunc:xce},kce=lae({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Sce={kernelName:J$,backendName:"webgl",kernelFunc:kce};var Ice={kernelName:S$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=nU.calculateShapes(i,s,a.shape),h=[d/u,u];if(0===d)return n.makeTensorInfo(a.shape,s.dtype);let p=yae({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=yae({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=yae({inputs:{x:a},backend:n,attrs:{shape:h}}),g=new Due(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=yae({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}},Cce=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let r=Pte(this.rank),a=function(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}};function Nce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){let e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>TR.decodeString(e))):e,r=xF(a.shape,a.dtype,t),i=hre(r,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}let i=new Cce(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var Tce={kernelName:Z$,backendName:"webgl",kernelFunc:Nce},Ece=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}},Ace=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function _ce(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function $ce(e){let t=1;for(;t<e;)t*=2;return t}var Rce={kernelName:eR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=GE().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=GE().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([a])||c<o||s>l){let e=n.readSync(a.dataId),[t,r]=pre(e,u,a.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[a,uoe({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let d=n.texData.get(a.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(a):a,f=TR.sizeFromShape(u)/c,m=yae({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&_ce(n,p);let g=$ce(s),y=$ce(c),b=null,v=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{let a=v(),s=new Ece(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(s,a,"int32",i),_ce(n,o)};for(let C=1;C<g;C*=2){let e=2*C;for(let t=C;t>=1;t/=2)x(e,t,[f,y])}for(let C=y;C>g;C/=2){let e=v(),t=new Ace([f,C/2]),r=[[c],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(t,e,"int32",r),_ce(n,a);let s=g/2,i=2*s;for(let n=s;n>=1;n/=2)x(i,n,b.shape)}let w=b;b=Ise({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),_ce(n,w);let k=Eoe({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});_ce(n,m);let S=u.slice(0,-1);S.push(s),w=b,b=yae({inputs:{x:b},attrs:{shape:S},backend:n}),_ce(n,w);let I=k;return k=yae({inputs:{x:k},attrs:{shape:S},backend:n}),_ce(n,I),[k,b]}},Dce=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i,o="nearest"===n?1:2;switch(r){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}};var Mce={kernelName:tR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=new Dce(d,h,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[a,s],"float32")}};var Fce={kernelName:rR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;bte(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=mre(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};var Oce={kernelName:aR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1),c=0;for(let m=0;m<o;m++)m!==s&&(u[c++]=i.shape[m]);let d=[],h=new Array(o).fill(0),p=i.shape.slice();p[s]=1;let f=new Array(l);for(let m=0;m<f.length;m++){h[s]=m;let e=Ise({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),t=yae({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}},Pce=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ",c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}};var Lce,zce,Bce,Wce={kernelName:sR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],u=0,c=nU.getAxesPermutation([u],o),d=a;null!=c&&(d=Tae({inputs:{x:a},backend:n,attrs:{perm:c}}),l.push(d),u=nU.getInnerMostAxes(1,o)[0]);let h=nU.segment_util.computeOutShape(d.shape,u,i),p=TR.sizeFromShape([d.shape[u]]),f=yae({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);let m=SD(a.dtype),g=(e,t,r,a,s)=>{let i=e.shape[0],o=e.shape[1],u=nU.segment_util.segOpComputeOptimalWindowSize(o,s),c=new Pce({windowSize:u,inSize:o,batchSize:i,numSegments:s},t),d=n.compileAndRun(c,[e,r],a);if(l.push(d),d.shape[1]===s)return d;let h=iue({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=Nce({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});return l.push(h),l.push(p),g(d,t,p,a,s)},y=yae({inputs:{x:g(f,"unsortedSegmentSum",s,m,i)},backend:n,attrs:{shape:h}}),b=y;if(null!=c){l.push(y);let e=nU.getUndoAxesPermutation(c);b=Tae({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},Vce=[$ae,Dae,Fae,Pae,Bae,Uae,jae,Gae,Qae,Jae,ese,nse,ase,ise,lse,dse,hse,mse,gse,yse,xse,Nse,Tse,Ese,Ase,Fse,Lse,Wse,eae,jse,Jse,iie,die,pie,fie,mie,yie,vie,wie,Sie,Eie,Aie,_ie,Rie,Fie,Lie,zie,Wie,Uie,jie,Hie,qie,Xie,Qie,Zie,toe,aoe,ooe,doe,poe,goe,boe,woe,Soe,Ioe,Noe,Aoe,$oe,Doe,Jre,Moe,Xse,Ooe,Loe,Boe,rae,Voe,joe,Goe,qoe,Xoe,Qoe,Zoe,tle,ale,ile,lle,cle,dle,hle,mle,gle,yle,ble,vle,wle,Ile,Nle,Fle,gae,Ple,zle,Wle,Ule,$se,Gle,Kle,Xle,Zle,tue,iae,nue,rue,aue,sue,oue,Dse,Ale,uue,due,pue,bae,gue,bue,wue,Sue,Nue,Eue,_ue,Rue,Fue,Pue,zue,Wue,Uue,Gue,que,Xue,Cse,Mle,Que,Jue,Zue,ece,tce,nce,rce,ace,oce,uce,hce,pce,fce,gce,yce,bce,vce,Rle,Nae,wce,Sce,Ice,Tce,Rce,Mce,Eae,Fce,Oce,Wce,qle];for(let n of Vce)wR(n);!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(Lce||(Lce={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(zce||(zce={}));var Uce={kernelName:dR,backendName:"wasm",setupFunc:function(e){Bce=e.wasm.cwrap(dR,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,h=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=0;if(null!=i){let e=n.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}let m=null==o?0:n.dataIdMap.get(o.dataId).id,g=zce[c];if(null==g)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=u?s.shape[1]:s.shape[2],v=jO.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),x=n.makeOutput([...v,y,b],a.dtype),w=n.dataIdMap.get(x.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer),S=new Uint8Array(new Int32Array(s.shape).buffer);return Bce(h,k,a.shape.length,p,S,s.shape.length,l,u,g,f,m,d||0,w),x}};function jce(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){let{backend:r,inputs:{x:a}}=e,s=r.dataIdMap.get(a.dataId).id,i=r.makeOutput(a.shape,t||a.dtype),o=r.dataIdMap.get(i.dataId).id;return 0===TR.sizeFromShape(i.shape)||n(s,Lce[a.dtype],o),i}}}var Gce=jce(YE),Hce=jce(QE),qce=jce(JE);function Kce(e,t,n){let r;return{kernelName:e,backendName:"wasm",setupFunc:function(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:a}=e,{a:s,b:i}=a,o=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(i.dataId).id,u=null!=n?n:s.dtype,c=nU.assertAndGetBroadcastShape(s.shape,i.shape),d=t.makeOutput(c,u);if(0===TR.sizeFromShape(c))return d;let h=new Uint8Array(new Int32Array(s.shape).buffer),p=new Uint8Array(new Int32Array(i.shape).buffer),f=t.dataIdMap.get(d.dataId).id;return r(o,h,s.shape.length,l,p,i.shape.length,Lce[s.dtype],f),d}}}var Xce,Yce=Kce(ZE);var Qce={kernelName:eA,backendName:"wasm",setupFunc:function(e){Xce=e.wasm.cwrap(eA,null,["array","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===TR.sizeFromShape(r.shape))return r;let a=t.map((e=>n.dataIdMap.get(e.dataId).id)),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return Xce(s,a.length,Lce[r.dtype],i),r}};function Jce(e){let{inputs:{x:t},backend:n}=e;if("string"===t.dtype)return JD(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var Zce,ede={kernelName:h_,backendName:"wasm",kernelFunc:Jce};function tde(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=function(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let a=0;a<r.length;++a){let e=-1;for(let t=0;t<r.length;++t)r[t]>=a&&(-1===e||r[e]>r[t])&&(e=t);r[e]=a}return[n,r]}(t.x.shape,r.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=function(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let e=Jce({inputs:t,backend:n});return e.shape=o,e}let u=n.makeOutput(o,l.dtype),c=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,h=new Uint8Array(new Int32Array(s).buffer),p=new Uint8Array(new Int32Array(l.shape).buffer);return Zce(c,p,l.shape.length,Lce[l.dtype],d,h,s.length),u}var nde,rde={kernelName:nR,backendName:"wasm",kernelFunc:tde,setupFunc:function(e){Zce=e.wasm.cwrap(nR,null,["number","array","number","number","number","array","number"])}};function ade(e,t,n){let r=e.shape,a=e.shape.length,s=TR.parseAxisParam(t,r),i=s,o=nU.getAxesPermutation(i,a),l=null,u=!1;if(null!=o){let t=new Array(a);for(let e=0;e<t.length;e++)t[e]=r[o[e]];i=nU.getInnerMostAxes(i.length,a),l=tde({inputs:{x:e},attrs:{perm:o},backend:n});let s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==s&&(u=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:u}}var sde,ide={kernelName:tA,backendName:"wasm",setupFunc:function(e){nde=e.wasm.cwrap(tA,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=ade(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let p=l.shape.length;nU.assertAxesAreInnerMostDims("all",c,p);let[f,m]=nU.computeOutAndReduceShapes(l.shape,c),g=TR.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==TR.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;nde(o,g,e)}if(h&&t.disposeData(u.dataId),s){let e=nU.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}};var ode={kernelName:nA,backendName:"wasm",setupFunc:function(e){sde=e.wasm.cwrap(nA,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=ade(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let p=l.shape.length;nU.assertAxesAreInnerMostDims("any",c,p);let[f,m]=nU.computeOutAndReduceShapes(l.shape,c),g=TR.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==TR.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;sde(o,g,e)}if(h&&t.disposeData(u.dataId),s){let e=nU.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}};function lde(e){let t;return{kernelName:e,backendName:"wasm",setupFunc:function(n){t=n.wasm.cwrap(e,null,["number","number","number","number","number"])},kernelFunc:function(e){let{backend:n,inputs:r,attrs:a}=e,{axis:s}=a,{x:i}=r,o=n.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,inputWasTransposed:h}=ade(i,s,n);if(h){let e=n.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e)}let p=u.shape.slice(0,-1),f=n.makeOutput(p,"int32"),m=n.dataIdMap.get(f.dataId).id,g=TR.sizeFromShape(f.shape),y=u.shape[d[0]];return t(l,Lce[u.dtype],g,y,m),h&&n.disposeData(c.dataId),f}}}var ude,cde=lde(rA),dde=lde(aA),hde=jce(sA),pde=jce(iA),fde=jce(oA),mde=Kce(uA),gde=jce(lA);var yde,bde={kernelName:cA,backendName:"wasm",setupFunc:function(e){ude=e.wasm.cwrap(cA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=nU.computePool2DInfo(a.shape,i,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,b=c.strideWidth,v=c.inChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(1!==c.dilationWidth||1!==c.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let x=r.makeOutput(c.outShape,"float32"),w=r.dataIdMap.get(x.dataId).id;return ude(s,a.shape[0],a.shape[1],a.shape[2],d,h,p,f,m,g,y,b,v,w),x}};var vde,xde={kernelName:hA,backendName:"wasm",setupFunc:function(e){yde=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=nU.computePool3DInfo(a.shape,s,i,1,o,l,u),d=n.makeOutput(c.outShape,a.dtype);return yde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};var wde,kde={kernelName:pA,backendName:"wasm",setupFunc:function(e){vde=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=nU.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return vde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),d}};var Sde={kernelName:dA,backendName:"wasm",setupFunc:function(e){wde=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l}=r,u=nU.computePool2DInfo(s.shape,i,o,1,l),c=n.makeOutput(s.shape,s.dtype);return wde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),c}};function Ide(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=TR.sizeFromShape(r.shape),i=TR.inferFromImplicitShape(a,s);return TR.assert(s===TR.sizeFromShape(i),(()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var Cde,Nde={kernelName:p$,backendName:"wasm",kernelFunc:Ide};var Tde={kernelName:fA,backendName:"wasm",setupFunc:function(e){Cde=e.wasm.cwrap(fA,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=TR.sizeFromShape(f),y=TR.sizeFromShape(m),b=jO.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);TR.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let v=o?[y,p,d]:[y,d,p],x=Ide({inputs:{x:a},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=Ide({inputs:{x:s},backend:n,attrs:{shape:v}}),k=n.dataIdMap.get(x.dataId).id,S=n.dataIdMap.get(w.dataId).id,I=i?x.shape[2]:x.shape[1],C=o?w.shape[1]:w.shape[2],N=Math.max(g,y),T=n.makeOutput([N,I,C],x.dtype),E=n.dataIdMap.get(T.dataId).id,A=new Uint8Array(new Int32Array(x.shape).buffer),_=new Uint8Array(new Int32Array(w.shape).buffer);return Cde(k,A,x.shape.length,S,_,w.shape.length,i,o,E),n.disposeData(x.dataId),n.disposeData(w.dataId),T.shape=b,T}};function Ede(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=_V.parseSliceParams(t,n,r),o=_V.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),u=a.makeOutput(i,t.dtype),c=TR.computeStrides(t.shape),d=a.dataIdMap.get(u.dataId);if(o){let e=_V.computeFlatOffset(s,c);return"string"===t.dtype?d.stringBytes=l.slice(e,e+TR.sizeFromShape(i)):a.typedArrayFromHeap(u).set(l.subarray(e,e+TR.sizeFromShape(i))),u}if("string"===t.dtype){let e=N5(l,s,i,t.shape,t.dtype);return d.stringBytes=e,u}let h=a.typedArrayFromHeap(u),p=t.shape.length;if(2===p)!function(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let u=i;u<l;u++){let r=u*t+o;n.set(e.subarray(r,r+a[1]),s),s+=a[1]}}(l,c[0],h,s,i);else if(3===p)!function(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],u=a[2],c=o+s[0],d=l+s[1];for(let h=o;h<c;h++)for(let a=l;a<d;a++){let o=h*t+a*n+u;r.set(e.subarray(o,o+s[2]),i),i+=s[2]}}(l,c[0],c[1],h,s,i);else if(4===p)!function(e,t,n,r,a,s,i){let o=0,l=s[0],u=s[1],c=s[2],d=l+i[0],h=u+i[1],p=c+i[2],f=s[3];for(let m=l;m<d;m++)for(let s=u;s<h;s++)for(let l=c;l<p;l++){let u=m*t+s*n+l*r+f;a.set(e.subarray(u,u+i[3]),o),o+=i[3]}}(l,c[0],c[1],c[2],h,s,i);else{let e=N5(l,s,i,t.shape,t.dtype);h.set(e)}return u}var Ade={kernelName:T$,backendName:"wasm",kernelFunc:Ede};var _de,$de={kernelName:mA,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce(((e,t)=>e*t)),l=nU.getReshaped(a.shape,s,o),u=nU.getPermuted(l.length,s.length),c=nU.getReshapedPermuted(a.shape,s,o),d=nU.getSliceBeginCoords(i,s.length),h=nU.getSliceSize(c,i,s.length),p=Ide({inputs:{x:a},backend:n,attrs:{shape:l}}),f=tde({inputs:{x:p},backend:n,attrs:{perm:u}}),m=Ide({inputs:{x:f},backend:n,attrs:{shape:c}}),g=Ede({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}};var Rde={kernelName:gA,backendName:"wasm",setupFunc:function(e){_de=e.wasm.cwrap(gA,null,["number","number","boolean","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i}=r,o=0!==s.shape.reduce(((e,t)=>e*t),1),l=1===a.shape.length?[i]:[a.shape[0],i],u=t.makeOutput(l,s.dtype);function c(e){return t.dataIdMap.get(e.dataId).id}return _de(c(a),i,o,c(s),Lce[s.dtype],c(u)),u}},Dde=Kce(yA);var Mde={kernelName:vA,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(a),o=nU.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}};function Fde(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var Ode,Pde={kernelName:xA,backendName:"wasm",kernelFunc:Fde},Lde=jce(wA);var zde={kernelName:kA,backendName:"wasm",setupFunc:function(e){Ode=e.wasm.cwrap(kA,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return Ode(o,s,i,u),l}};function Bde(e){let{inputs:t,backend:n}=e,r=TR.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map((e=>e.shape));nU.assertParamsConsistent(a,r);let s=nU.computeOutShape(t.map((e=>e.shape)),r),i=t.filter((e=>TR.sizeFromShape(e.shape)>0));if(1===i.length)return Jce({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(0===TR.sizeFromShape(s))return o;if("string"===i[0].dtype){let e=i.map((e=>{let t=[-1,TR.sizeFromShape(e.shape.slice(r))];return Ide({inputs:{x:e},backend:n,attrs:{shape:t}})})),a=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));s=nU.computeOutShape(e.map((e=>e.shape)),1);let l=1===e[0].shape[0],u=i4(a,s,t[0].dtype,l),c=nU.computeOutShape(i.map((e=>e.shape)),r);return o.shape=c,n.dataIdMap.get(o.dataId).stringBytes=nU.fromStringArrayToUint8(u),e.forEach((e=>n.disposeData(e.dataId))),o}let l=TR.sizeFromShape(i[0].shape.slice(0,r)),u=0,c=i.map((e=>{let t=TR.sizeFromShape(e.shape.slice(r));return u+=t,t})),d=i.map((e=>n.typedArrayFromHeap(e))),h=n.typedArrayFromHeap(o);for(let p=0;p<l;p++){let e=p*u;for(let t=0;t<d.length;t++){let n=c[t],r=p*n,a=d[t].subarray(r,r+n);h.set(a,e),e+=n}}return o}var Wde,Vde={kernelName:CA,backendName:"wasm",kernelFunc:Bde};var Ude,jde={kernelName:NA,backendName:"wasm",setupFunc:function(e){Wde=e.wasm.cwrap(NA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d,dataFormat:h}=n,p=nU.convertConv2DDataFormat(h),f=nU.computeConv2DInfo(a.shape,s.shape,l,u,c,d,!1,p),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,v=f.padInfo.bottom,x=f.padInfo.left,w=f.dilationHeight,k=f.dilationWidth,S=f.strideHeight,I=f.strideWidth,C=f.inChannels,N=f.outChannels,T="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let E=r.makeOutput(f.outShape,"float32"),A=r.dataIdMap.get(E.dataId).id;return Wde(i,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,b,v,x,T,w,k,S,I,C,N,A),E}};var Gde,Hde={kernelName:EA,backendName:"wasm",setupFunc:function(e){Ude=e.wasm.cwrap(EA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:c}=r,d=nU.convertConv2DDataFormat(l),h=nU.computeConv2DInfo(c,s.shape,i,1,o,u,!1,d),{batchSize:p,filterHeight:f,filterWidth:m,inChannels:g,inHeight:y,inWidth:b,outChannels:v,outHeight:x,outWidth:w,strideHeight:k,strideWidth:S}=h,I=f-1-h.padInfo.top,C=m-1-h.padInfo.left,N="channelsLast"===h.dataFormat,T=TR.computeStrides(h.inShape),E=TR.computeStrides(a.shape),[A,_,$]=TR.computeStrides(s.shape),R=T[0],D=N?T[1]:T[2],M=N?T[2]:1,F=N?1:T[1],O=E[0],P=N?E[1]:E[2],L=N?E[2]:1,z=N?1:E[1],B=t.makeOutput(h.inShape,"float32"),W=t.dataIdMap.get(B.dataId).id,V=t.dataIdMap.get(a.dataId).id,U=t.dataIdMap.get(s.dataId).id;return Ude(V,U,p,f,m,y,b,g,x,w,v,k,S,I,C,A,_,$,R,D,M,F,O,P,L,z,W),B}};var qde,Kde={kernelName:AA,backendName:"wasm",setupFunc:function(e){Gde=e.wasm.cwrap(AA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=nU.computeConv3DInfo(a.shape,s.shape,i,l,o),c=n.makeOutput(u.outShape,a.dtype);return Gde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}};var Xde,Yde={kernelName:_A,backendName:"wasm",setupFunc:function(e){qde=e.wasm.cwrap(_A,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=nU.computeConv3DInfo(a.shape,l,i,1,o),c=n.makeOutput(u.filterShape,s.dtype);return qde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}};var Qde,Jde,Zde={kernelName:$A,backendName:"wasm",setupFunc:function(e){Xde=e.wasm.cwrap($A,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=nU.computeConv3DInfo(l,s.shape,o,1,i),c=n.makeOutput(u.inShape,a.dtype);return Xde(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}},ehe=jce(RA),the=jce(DA);!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(Qde||(Qde={}));var nhe,rhe={kernelName:OA,backendName:"wasm",setupFunc:function(e){Jde=e.wasm.cwrap(OA,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{method:s,extrapolationValue:i,cropSize:o}=a,{image:l,boxes:u,boxInd:c}=r,d=u.shape[0],[h,p]=o,f=[d,h,p,l.shape[3]],m=n.dataIdMap.get(l.dataId);"float32"!==l.dtype&&(t=Fde({backend:n,inputs:{x:l},attrs:{dtype:"float32"}}),m=n.dataIdMap.get(t.dataId));let g=m.id,y=n.dataIdMap.get(u.dataId).id,b=n.dataIdMap.get(c.dataId).id,v=n.makeOutput(f,"float32"),x=n.dataIdMap.get(v.dataId).id,w=new Uint8Array(new Int32Array(l.shape).buffer);return Jde(g,y,b,d,w,h,p,Qde[s],i,x),null!=t&&n.disposeData(t.dataId),v}};var ahe,she={kernelName:MA,backendName:"wasm",setupFunc:function(e){nhe=e.wasm.cwrap(MA,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;TR.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));let u=nU.getAxesPermutation([s],l),c=a;null!==u&&(c=tde({inputs:{x:a},attrs:{perm:u},backend:n}));let d=nU.getInnerMostAxes(1,l)[0];nU.assertAxesAreInnerMostDims("cumprod",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;nhe(f,i?1:0,o?1:0,p,m,Lce[a.dtype]);let g=h;if(null!==u){g=tde({inputs:{x:h},attrs:{perm:nU.getUndoAxesPermutation(u)},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return g}};var ihe,ohe={kernelName:FA,backendName:"wasm",setupFunc:function(e){ahe=e.wasm.cwrap(FA,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;TR.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));let u=nU.getAxesPermutation([s],l),c=a;null!==u&&(c=tde({inputs:{x:a},attrs:{perm:u},backend:n}));let d=nU.getInnerMostAxes(1,l)[0];nU.assertAxesAreInnerMostDims("cumsum",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;ahe(f,i?1:0,o?1:0,p,m,Lce[a.dtype]);let g=h;if(null!==u){g=tde({inputs:{x:h},attrs:{perm:nU.getUndoAxesPermutation(u)},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return g}};var lhe,uhe={kernelName:PA,backendName:"wasm",setupFunc:function(e){ihe=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i,binaryOutput:o}=r,l=0!==s.shape.reduce(((e,t)=>e*t),1),u=1===a.shape.length?[i]:[a.shape[0],i],c=t.makeOutput(u,s.dtype);function d(e){return t.dataIdMap.get(e.dataId).id}return ihe(d(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,i,l,d(s),Lce[s.dtype],o,d(c)),c}};var che,dhe={kernelName:LA,backendName:"wasm",setupFunc:function(e){lhe=e.wasm.cwrap(LA,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,c=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d="NHWC"===i?[o,l,u,c]:[o,c,l,u],h=t.makeOutput(d,"float32"),p=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(TR.computeStrides(a.shape)).buffer),m=new Uint8Array(new Int32Array(d).buffer),g=new Uint8Array(new Int32Array(TR.computeStrides(d)).buffer),y=t.dataIdMap.get(h.dataId).id;return lhe(p,s,"NHWC"===i?1:0,f,a.shape.length-1,m,g,d.length,y),h}};var hhe,phe={kernelName:zA,backendName:"wasm",setupFunc:function(e){che=e.wasm.cwrap(zA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d}=n,h=null==u?[1,1]:u,p=nU.computeConv2DInfo(a.shape,s.shape,l,h,c,d,!0),f=p.filterHeight,m=p.filterWidth,g=p.padInfo.top,y=p.padInfo.right,b=p.padInfo.bottom,v=p.padInfo.left,x=p.dilationHeight,w=p.dilationWidth,k=p.strideHeight,S=p.strideWidth,I=p.inChannels,C=p.outChannels,N="SAME"===p.padInfo.type?1:0;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let T=r.makeOutput(p.outShape,"float32"),E=r.dataIdMap.get(T.dataId).id;return che(i,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,b,v,N,x,w,k,S,I,C,E),T}};var fhe,mhe={kernelName:VA,backendName:"wasm",setupFunc:function(e){hhe=e.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=TR.sizeFromShape(r.shape),s=n.makeOutput([...r.shape,...r.shape],r.dtype);return hhe(n.dataIdMap.get(r.dataId).id,Lce[r.dtype],a,n.dataIdMap.get(s.dataId).id),s}};var ghe,yhe={kernelName:UA,backendName:"wasm",setupFunc:function(e){fhe=e.wasm.cwrap(UA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${s.dtype}`);let u=nU.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),c=n.makeOutput(u.outShape,a.dtype);return fhe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,Lce[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),c}};var bhe,vhe={kernelName:GA,backendName:"wasm",setupFunc:function(e){ghe=e.wasm.cwrap(GA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let c=nU.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),d=n.makeOutput(s.shape,s.dtype);return ghe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Lce[a.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}};var xhe,whe={kernelName:jA,backendName:"wasm",setupFunc:function(e){bhe=e.wasm.cwrap(jA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let c=nU.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),d=n.makeOutput(a.shape,a.dtype);return bhe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Lce[a.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}},khe=jce(XA);var She={kernelName:YA,backendName:"wasm",setupFunc:function(e){xhe=e.wasm.cwrap(YA,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=n.makeOutput(a.shape,"float32"),i=e=>n.dataIdMap.get(e.dataId).id;return xhe(i(a),i(r),i(s)),s}},Ihe=Kce(JA,0,"bool"),Che=jce(QA),Nhe=jce(ZA,"float32");function The(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(TR.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),Ide({inputs:{x:a},backend:r,attrs:{shape:o}})}var Ehe={kernelName:e_,backendName:"wasm",kernelFunc:The},Ahe=jce(t_,"float32");function _he(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:a}}=e;a=a||TR.inferDtype(n);let s=r.makeOutput(t,a);return r.typedArrayFromHeap(s).fill(n),s}var $he,Rhe={kernelName:r_,backendName:"wasm",kernelFunc:_he};var Dhe,Mhe={kernelName:a_,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,u,c]=r.shape;return $he(s,o,l,u,c,i),a},setupFunc:function(e){$he=e.wasm.cwrap(a_,null,["number","number","number","number","number","number"])}},Fhe=jce(s_),Ohe=Kce(i_);var Phe,Lhe={kernelName:o_,backendName:"wasm",setupFunc:function(e){Dhe=e.wasm.cwrap(o_,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:u}=n,c=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(o.dataId).id,p=null!=l?t.dataIdMap.get(l.dataId).id:0,f=null!=u?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(0===TR.sizeFromShape(s.shape))return m;let g=t.dataIdMap.get(m.dataId).id;return Dhe(c,d,h,p,f,a,g),m}};var zhe,Bhe={kernelName:hR,backendName:"wasm",setupFunc:function(e){Phe=e.wasm.cwrap(hR,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=nU.computeConv2DInfo(a.shape,s.shape,l,c,u,h),g=zce[p];if(null==g)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,v=m.outChannels,x=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==v)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${v})`);x=e.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,C=m.padInfo.bottom,N=m.padInfo.left,T=m.dilationHeight,E=m.dilationWidth,A=m.strideHeight,_=m.strideWidth,$=m.inChannels,R="SAME"===m.padInfo.type?1:0,D=m.batchSize,M=m.inHeight,F=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),P=r.dataIdMap.get(O.dataId).id,L=null==o?0:r.dataIdMap.get(o.dataId).id;return Phe(y,D,M,F,b,w,k,x,S,I,C,N,R,T,E,A,_,$,v,g,L,f||0,P),O}};var Whe,Vhe={kernelName:pR,backendName:"wasm",setupFunc:function(e){zhe=e.wasm.cwrap(pR,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=nU.computeConv2DInfo(a.shape,s.shape,l,c,u,h,!0),g=zce[p];if(null==g)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,v=m.outChannels,x=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==v)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${v})`);x=e.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,C=m.padInfo.bottom,N=m.padInfo.left,T=m.dilationHeight,E=m.dilationWidth,A=m.strideHeight,_=m.strideWidth,$=m.inChannels,R="SAME"===m.padInfo.type?1:0,D=m.batchSize,M=m.inHeight,F=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),P=r.dataIdMap.get(O.dataId).id,L=null==o?0:r.dataIdMap.get(o.dataId).id;return zhe(y,D,M,F,b,w,k,x,S,I,C,N,R,T,E,A,_,$,v,g,L,f||0,P),O}};var Uhe,jhe={kernelName:u_,backendName:"wasm",setupFunc:function(e){Whe=e.wasm.cwrap(u_,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=EV.prepareAndValidate(r,a),u=t.makeOutput(s,r.dtype);if(0===i)return u;let c=a.shape,d=c[c.length-1],h=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return Whe(h,Lce[r.dtype],p,i,d,o,f,m),u}};var Ghe,Hhe={kernelName:l_,backendName:"wasm",setupFunc:function(e){Uhe=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=TR.parseAxisParam(i,a.shape)[0],u=t.readSync(s.dataId),c=a.shape[l];for(let S=0;S<u.length;++S){let e=u[S];TR.assert(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let d=nU.segment_util.collectGatherOpShapeInfo(a,s,l,o),h=Ide({inputs:{x:a},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),p=TR.sizeFromShape(s.shape),f=Ide({inputs:{x:s},attrs:{shape:[d.batchSize,p/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize],g=t.makeOutput(m,a.dtype);if(0===TR.sizeFromShape(a.shape))return g;let y=h.shape.length-1,b=t.dataIdMap.get(h.dataId).id,v=t.dataIdMap.get(f.dataId).id,x=t.dataIdMap.get(g.dataId).id,w=new Uint8Array(new Int32Array(TR.computeStrides(h.shape)).buffer),k=new Uint8Array(new Int32Array(TR.computeStrides(m)).buffer);return Uhe(b,Lce[a.dtype],w,y,v,d.batchSize,k,x),t.disposeData(h.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}},qhe=Kce(c_,0,"bool"),Khe=Kce(d_,0,"bool"),Xhe=jce(m_,"bool"),Yhe=jce(g_,"bool"),Qhe=jce(y_,"bool");var Jhe,Zhe={kernelName:b_,backendName:"wasm",setupFunc:function(e){Ghe=e.wasm.cwrap(b_,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(0!==TR.sizeFromShape(t.shape)){let e=r.dataIdMap.get(s.dataId).id;Ghe(a,Lce[t.dtype],n,e)}return s}},epe=Kce(v_,0,"bool"),tpe=Kce(x_,0,"bool");var npe,rpe={kernelName:w_,backendName:"wasm",setupFunc:function(e){Jhe=e.wasm.cwrap(w_,null,["number","number","number","number"])},kernelFunc:function(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return Jhe(n.dataIdMap.get(o.dataId).id,r,a,i),o}},ape=jce(k_),spe=jce(S_),ipe=Kce(I_,0,"bool"),ope=jce(C_),lpe=Kce(N_,0,"bool"),upe=Kce(T_,0,"bool");var cpe,dpe={kernelName:__,backendName:"wasm",setupFunc:function(e){npe=e.wasm.cwrap(__,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;if("float32"!==a.dtype)throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(a.shape,a.dtype);return npe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,a.shape[3],s,i,o,l),u}};var hpe,ppe={kernelName:$_,backendName:"wasm",setupFunc:function(e){cpe=e.wasm.cwrap($_,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;if("float32"!==a.dtype||"float32"!==s.dtype||"float32"!==i.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(a.shape,a.dtype);return cpe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,l,u,c),d}};var fpe,mpe={kernelName:D_,backendName:"wasm",setupFunc:function(e){hpe=e.wasm.cwrap(D_,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=ade(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let p=l.shape.length;nU.assertAxesAreInnerMostDims("max",c,p);let[f,m]=nU.computeOutAndReduceShapes(l.shape,c),g=TR.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==TR.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;hpe(o,Lce[i.dtype],g,e)}if(h&&t.disposeData(u.dataId),s){let e=nU.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}},gpe=Kce(M_);var ype,bpe={kernelName:F_,backendName:"wasm",setupFunc:function(e){fpe=e.wasm.cwrap(F_,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;TR.assert("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=nU.computePool2DInfo(a.shape,i,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,b=c.dilationWidth,v=c.strideHeight,x=c.strideWidth,w=c.inChannels,k=c.outChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let S=r.makeOutput(c.outShape,"float32"),I=r.dataIdMap.get(S.dataId).id;return fpe(s,a.shape[0],a.shape[1],a.shape[2],d,h,p,f,m,g,y,b,v,x,w,k,I),S}};var vpe,xpe={kernelName:P_,backendName:"wasm",setupFunc:function(e){ype=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=nU.computePool3DInfo(a.shape,s,i,1,o,l,u),d=n.makeOutput(c.outShape,a.dtype);return ype(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};var wpe,kpe={kernelName:L_,backendName:"wasm",setupFunc:function(e){vpe=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=nU.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return vpe(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};var Spe,Ipe={kernelName:O_,backendName:"wasm",setupFunc:function(e){wpe=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=nU.computePool2DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return wpe(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),d}};var Cpe,Npe={kernelName:z_,backendName:"wasm",setupFunc:function(e){Spe=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=r;TR.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));let u=[1,1];TR.assert(nU.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let c=nU.computePool2DInfo(a.shape,s,i,[1,1],o),d=n.makeOutput(c.outShape,a.dtype),h=n.makeOutput(c.outShape,"int32");return Spe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(h.dataId).id,Lce[a.dtype],l,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[d,h]}};var Tpe,Epe={kernelName:B_,backendName:"wasm",setupFunc:function(e){Cpe=e.wasm.cwrap(B_,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=ade(i,a,t),f=d;if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=nU.getInnerMostAxes(f.length,u.shape.length))}nU.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=nU.computeOutAndReduceShapes(u.shape,f),y=TR.sizeFromShape(g),b=u;"float32"!==u.dtype&&(b=Fde({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let v=t.makeOutput(m,"float32");if(0!==TR.sizeFromShape(u.shape)){let e=t.dataIdMap.get(v.dataId).id;Cpe(l,y,e)}if(p&&t.disposeData(c.dataId),s){let e=nU.expandShapeToKeepDim(v.shape,h);v.shape=e}return"float32"!==u.dtype&&t.disposeData(b.dataId),v}};var Ape,_pe,$pe={kernelName:W_,backendName:"wasm",setupFunc:function(e){Tpe=e.wasm.cwrap(W_,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=ade(i,a,t);if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e)}let f=u.shape.length;nU.assertAxesAreInnerMostDims("min",d,f);let[m,g]=nU.computeOutAndReduceShapes(u.shape,d),y=TR.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==TR.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;Tpe(l,Lce[i.dtype],y,e)}if(p&&t.disposeData(c.dataId),s){let e=nU.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},Rpe=Kce(V_);!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(Ape||(Ape={}));var Dpe,Mpe={kernelName:U_,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1])),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),d=r.map((e=>e[1])),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return _pe(i,u,t.shape.length,Lce[t.dtype],h,p,Ape[a],l),o},setupFunc:function(e){_pe=e.wasm.cwrap(U_,null,["number","array","number","number","array","array","number","number"])}};function Fpe(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=TR.sizeFromShape(n.shape)/o;return 0===TR.sizeFromShape(s.shape)||Dpe(a,i,o,l),s}var Ope,Ppe={kernelName:P$,backendName:"wasm",setupFunc:function(e){Dpe=e.wasm.cwrap(P$,null,["number","number","number","number"])},kernelFunc:Fpe};var Lpe,zpe={kernelName:G_,backendName:"wasm",setupFunc:function(e){Ope=e.wasm.cwrap(G_,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;if("float32"!==a.dtype)throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=o?a:Fpe({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[u,c]=l.shape,d=n.makeOutput([u,s],"int32");return Ope(n.dataIdMap.get(l.dataId).id,u,c,s,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(l.dataId),d}},Bpe=Kce(j_),Wpe=Kce(H_),Vpe=jce(q_);function Upe(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}var jpe,Gpe={kernelName:X_,backendName:"wasm",setupFunc:function(e){Lpe=e.wasm.cwrap(X_,"number",["number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(l.dataId).id,d=Lpe(u,c,s,a,i),{pSelectedIndices:h,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=Upe(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",h)}};var Hpe,qpe={kernelName:Y_,backendName:"wasm",setupFunc:function(e){jpe=e.wasm.cwrap(Y_,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=jpe(c,d,s,a,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=Upe(t,h);return t.wasm._free(m),[t.makeOutput([f],"int32",p),t.makeOutput([],"int32",g)]}};var Kpe,Xpe={kernelName:Q_,backendName:"wasm",setupFunc:function(e){Hpe=e.wasm.cwrap(Q_,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=Hpe(c,d,s,a,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=Upe(t,h);return t.wasm._free(g),[t.makeOutput([f],"int32",p),t.makeOutput([f],"float32",m)]}},Ype=Kce(K_,0,"bool");var Qpe={kernelName:Z_,backendName:"wasm",setupFunc:function(e){Kpe=e.wasm.cwrap(Z_,null,["number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=n.makeOutput([...a.shape,i],s),c=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(a.dataId).id;return Kpe(d,i,o,l,c),u}};var Jpe={kernelName:J_,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}};var Zpe,efe={kernelName:e$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return The({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{TR.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),TR.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=The({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=Bde({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeData(e.dataId))),u}};var tfe,nfe={kernelName:t$,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===TR.sizeFromShape(t.shape))return _he({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),d=r.map((e=>e[1])),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return Zpe(i,u,t.shape.length,Lce[t.dtype],h,p,a,l),o},setupFunc:function(e){Zpe=e.wasm.cwrap(t$,null,["number","array","number","number","array","array","number","number"])}},rfe=Kce(r$);var afe,sfe={kernelName:a$,backendName:"wasm",setupFunc:function(e){tfe=e.wasm.cwrap(a$,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,u=l;"float32"!==l.dtype&&(u=Fde({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let c=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return tfe(o,i,d),"float32"!==l.dtype&&n.disposeData(u.dataId),c}};var ife,ofe={kernelName:s$,backendName:"wasm",setupFunc:function(e){afe=e.wasm.cwrap(s$,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=ade(i,a,t),f=d;if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=nU.getInnerMostAxes(f.length,u.shape.length))}nU.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=nU.computeOutAndReduceShapes(u.shape,f),y=TR.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==TR.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;afe(l,y,Lce[b.dtype],e)}if(p&&t.disposeData(c.dataId),s){let e=nU.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},lfe={kernelName:u$,backendName:"wasm",kernelFunc:e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=b5(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l}},ufe=Kce(qA),cfe=jce(d$),dfe=jce(h$),hfe=jce(b$);var pfe,ffe={kernelName:g$,backendName:"wasm",setupFunc:function(e){ife=e.wasm.cwrap(g$,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{images:s}=r,{alignCorners:i,halfPixelCenters:o,size:l}=a,[u,c]=l,[d,h,p,f]=s.shape,m=[d,u,c,f],g=n.dataIdMap.get(s.dataId);"float32"!==g.dtype&&(t=Fde({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),g=n.dataIdMap.get(t.dataId));let y=g.id,b=n.makeOutput(m,"float32");if(0===TR.sizeFromShape(s.shape))return b;let v=n.dataIdMap.get(b.dataId).id;return ife(y,d,h,p,f,u,c,i?1:0,o?1:0,v),null!=t&&n.disposeData(t.dataId),b}};var mfe,gfe={kernelName:y$,backendName:"wasm",setupFunc:function(e){pfe=e.wasm.cwrap(y$,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:s,dy:i}=n,{alignCorners:o}=a,l=r.makeOutput(s.shape,"float32"),u=r.dataIdMap.get(s.dataId);return"float32"!==u.dtype&&(t=Fde({backend:r,inputs:{x:s},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),pfe(r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}};var yfe,bfe={kernelName:f$,backendName:"wasm",setupFunc:function(e){mfe=e.wasm.cwrap(f$,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,[c,d,h,p]=a.shape,f=[c,l,u,p],m=t.makeOutput(f,"float32");if(0===TR.sizeFromShape(a.shape))return m;let g,y=t.dataIdMap.get(a.dataId);"float32"!==y.dtype&&(g=Fde({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),y=t.dataIdMap.get(g.dataId));let b=y.id,v=t.dataIdMap.get(m.dataId).id;return mfe(b,c,d,h,p,l,u,s?1:0,i?1:0,v),null!=g&&t.disposeData(g.dataId),m}};var vfe,xfe={kernelName:m$,backendName:"wasm",setupFunc:function(e){yfe=e.wasm.cwrap(m$,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:s,dy:i}=n,{alignCorners:o}=a,l=r.makeOutput(s.shape,"float32"),u=r.dataIdMap.get(s.dataId);return"float32"!==u.dtype&&(t=Fde({backend:r,inputs:{x:s},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),yfe(r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}};var wfe,kfe={kernelName:v$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=TR.parseAxisParam(s,a.shape);if(0===a.shape.length)return Jce({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(a.shape).buffer);vfe(l,c,i.length,d,a.shape.length,u);let h=Ide({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),h},setupFunc:function(e){vfe=e.wasm.cwrap(v$,null,["number","array","number","array","number","number"])}};var Sfe,Ife={kernelName:cR,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(l.dataId).id,[d,h,p,f]=a.shape,[m,g]=nU.getImageCenter(o,h,p),y="number"==typeof i?[i,i,i,0===i?0:255]:[...i,255],b=new Uint8Array(new Int32Array(y).buffer);return wfe(u,d,h,p,f,s,m,g,b,y.length,c),l},setupFunc:function(e){wfe=e.wasm.cwrap(cR,null,["number","number","number","number","number","number","number","number","array","number","number"])}},Cfe=jce(x$),Nfe=jce(w$);var Tfe,Efe={kernelName:k$,backendName:"wasm",setupFunc:function(e){Sfe=e.wasm.cwrap(k$,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(0===TR.sizeFromShape(i))return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Kz.calculateShapes(s,a,i),p=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return Sfe(p,f,Lce[s.dtype],l,u,c,m,h,g),o}};var Afe,_fe={kernelName:I$,backendName:"wasm",setupFunc:function(e){Tfe=e.wasm.cwrap(I$,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r;if(a.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(e){return n.dataIdMap.get(e.dataId).id}return Tfe(l(a),l(s),a.shape[0],a.shape[1],s.shape[1],Lce[a.dtype],"left"===i,l(o)),o}};var $fe,Rfe={kernelName:C$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(a.shape,a.dtype),c=n.dataIdMap.get(u.dataId).id,d=r.shape.length,h=a.shape.length,p=0===d||d>1||1===h?1:TR.sizeFromShape(a.shape.slice(1));return Afe(i,o,l,p,c),u},setupFunc:function(e){Afe=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},Dfe=jce(N$);var Mfe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){$fe=e.wasm.cwrap($$,null,["number","number"])},kernelFunc:function(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return 0===TR.sizeFromShape(a.shape)||$fe(r,s),a}},Ffe=jce(_$),Ofe=jce(E$),Pfe=jce(A$),Lfe=jce(R$);var zfe,Bfe={kernelName:F$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=TR.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=nfe.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=nU.getReshaped(u.shape,s,o,!1),d=nU.getPermuted(c.length,s.length,!1),h=nU.getReshapedPermuted(u.shape,s,o,!1),p=Ide({inputs:{x:u},backend:n,attrs:{shape:c}}),f=tde({inputs:{x:p},backend:n,attrs:{perm:d}}),m=Ide({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeData(u.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}};var Wfe,Vfe={kernelName:L$,backendName:"wasm",setupFunc:function(e){zfe=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r}=e,{indices:a,values:s,denseShape:i,defaultValue:o}=r,l=a.shape[0],u=a.shape[1],c=n.readSync(i.dataId)[0],d=[l+c,u],h=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=n.dataIdMap.get(o.dataId).id,m=n.makeOutput(d,a.dtype),g=n.dataIdMap.get(m.dataId).id,y=n.makeOutput(d.slice(0,1),s.dtype),b=n.dataIdMap.get(y.dataId).id,v=n.makeOutput([c],"bool"),x=n.dataIdMap.get(v.dataId).id,w=n.makeOutput([l],a.dtype),k=n.dataIdMap.get(w.dataId).id,S=n.makeOutput([4],"int32"),I=n.dataIdMap.get(S.dataId).id,C=zfe(h,p,Lce[s.dtype],l,c,u,f,g,b,x,k,I),N=n.readSync(S.dataId);switch(N[0]){case 1:t=nU.getSparseFillEmptyRowsIndicesDenseShapeMismatch(N[1]);break;case 2:t=nU.getSparseFillEmptyRowsNegativeIndexErrorMessage(N[1],N[2]);break;case 3:t=nU.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(N[1],N[2],N[3]);break;default:t=""}if(n.disposeData(S.dataId),t)throw n.disposeData(m.dataId),n.disposeData(y.dataId),n.disposeData(v.dataId),n.disposeData(w.dataId),new Error(t);let T=m,E=y;return C!==d[0]&&(T=Ede({inputs:{x:m},attrs:{begin:0,size:[C,u]},backend:n}),E=Ede({inputs:{x:y},attrs:{begin:0,size:C},backend:n}),n.disposeData(m.dataId),n.disposeData(y.dataId)),[T,E,v,w]}};var Ufe,jfe={kernelName:z$,backendName:"wasm",setupFunc:function(e){Wfe=e.wasm.cwrap(z$,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=r.shape[0],c=TR.sizeFromShape(s.shape),d=t.makeOutput([u,c],r.dtype),h=t.dataIdMap.get(d.dataId).id,p=t.makeOutput([c],s.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;Wfe(i,o,l,u,h,f,g);let y,b=t.readSync(m.dataId);switch(b[0]){case 0:y=nU.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break;case 1:y=nU.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break;case 2:y=nU.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(p.dataId));y=nU.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(p.dataId));y=nU.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(d.dataId),t.disposeData(p.dataId),new Error(y);return[d,p]}};function Gfe(e){Ufe=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Hfe(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(nU.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=a.shape.slice();c[0]=u;let d=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(c,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;Ufe(d,Lce[a.dtype],a.shape[0],h,p,m,y,t,0);let b,v=n.readSync(g.dataId);switch(v[0]){case 0:b=nU.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:b=nU.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:b=nU.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v[1],v[2]);break;case 3:b=nU.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v[1],v[2],v[3]);break;default:b=""}if(n.disposeData(g.dataId),b)throw n.disposeData(f.dataId),new Error(b);return f}var qfe={kernelName:B$,backendName:"wasm",setupFunc:Gfe,kernelFunc:function(e){return Hfe(e,!0)}};var Kfe,Xfe={kernelName:W$,backendName:"wasm",setupFunc:Gfe,kernelFunc:function(e){return Hfe(e,!1)}};var Yfe={kernelName:V$,backendName:"wasm",setupFunc:function(e){Kfe=e.wasm.cwrap(V$,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(0===TR.sizeFromShape(o))return l;let{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=nU.calculateShapes(s,a,o),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(h).buffer),b=t.dataIdMap.get(l.dataId).id;return Kfe(f,m,s.shape.length,g,Lce[i.dtype],u,c,d,y,p,b),l}};var Qfe,Jfe={kernelName:O$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=TR.parseAxisParam(i,a.shape)[0],l=nU.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{let t=[...c];t[o]=e;let n=Ede({inputs:{x:a},attrs:{begin:u,size:t},backend:r});return u[o]+=e,n}))}},Zfe=jce(D$),eme=jce(j$),tme=Kce(U$);var nme,rme={kernelName:lR,backendName:"wasm",setupFunc:function(e){Qfe=e.wasm.cwrap(lR,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return Qfe(i,a,Lce[s.dtype],l),o}};var ame={kernelName:H$,backendName:"wasm",setupFunc:function(e){nme=e.wasm.cwrap(H$,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{x:s}=r,{begin:i,end:o,strides:l,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=_V.sliceInfo(s.shape,i,o,l,u,c,d,h,p);if(g)t=Ide({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){TR.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=_V.computeOutShape(v,x,w),r=Ede({inputs:{x:s},backend:n,attrs:{begin:v,size:e}});t=Ide({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}else{let e=n.makeOutput(f,"float32"),r=n.dataIdMap.get(s.dataId).id,a=new Uint8Array(new Int32Array(TR.computeStrides(s.shape)).buffer),i=new Uint8Array(new Int32Array(v).buffer),o=new Uint8Array(new Int32Array(x).buffer),l=new Uint8Array(new Int32Array(w).buffer),u=new Uint8Array(new Int32Array(f).buffer),c=new Uint8Array(new Int32Array(TR.computeStrides(f)).buffer),d=n.dataIdMap.get(e.dataId).id;nme(r,a,s.shape.length,i,o,l,u,c,f.length,d),t=Ide({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeData(e.dataId)}return t}};var sme={kernelName:q$,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:d}=r,h=t.readSync(a.dataId),p=t.readSync(s.dataId),[f,m]=U5(h,p,i,o,l,u,c,d),g=t.makeOutput([f.length],"string");t.dataIdMap.get(g.dataId).stringBytes=f;let y=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(y).set(m),[g,y]}};var ime={kernelName:K$,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:i}=r,o=t.readSync(a.dataId),l=t.readSync(s.dataId),[u,c,d]=G5(o,l[0],i),h=c.length,p=t.makeOutput([h,2],"int32");t.typedArrayFromHeap(p).set(u);let f=t.makeOutput([h],"string");t.dataIdMap.get(f.dataId).stringBytes=c;let m=t.makeOutput([2],"int32");return t.typedArrayFromHeap(m).set(d),[p,f,m]}};var ome,lme={kernelName:X$,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,i=H5(t.readSync(a.dataId),s),o=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(o).set(i),o}},ume=Kce(Y$);var cme,dme={kernelName:M$,backendName:"wasm",setupFunc:function(e){ome=e.wasm.cwrap(M$,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=ade(i,a,t),f=d;if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=nU.getInnerMostAxes(f.length,u.shape.length))}nU.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=nU.computeOutAndReduceShapes(u.shape,f),y=TR.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==TR.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;ome(l,y,Lce[b.dtype],e)}if(p&&t.disposeData(c.dataId),s){let e=nU.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},hme=jce(Q$),pme=jce(J$);var fme,mme={kernelName:S$,backendName:"wasm",setupFunc:function(e){cme=e.wasm.cwrap(S$,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=n,{}=r,o=t.makeOutput(a.shape,a.dtype);if(0===TR.sizeFromShape(a.shape))return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Kz.calculateShapes(i,s,a.shape),p=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),y=t.dataIdMap.get(o.dataId).id;return cme(p,f,Lce[i.dtype],l,u,c,g,h,y,m),o}};var gme,yme={kernelName:Z$,backendName:"wasm",setupFunc:function(e){fme=e.wasm.cwrap(Z$,null,["number","array","number","array","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let h=0;h<o.length;h++)o[h]=a.shape[h]*i[h];let l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,a.dtype),d=n.dataIdMap.get(c.dataId).id;return fme(s,l,a.shape.length,u,o.length,Lce[c.dtype],d),c}};var bme,vme={kernelName:eR,backendName:"wasm",setupFunc:function(e){gme=e.wasm.cwrap(eR,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=n.dataIdMap.get(a.dataId).id,l=new Uint8Array(new Int32Array(a.shape).buffer),u=a.shape.slice();u[u.length-1]=s;let c=n.makeOutput(u,a.dtype),d=n.dataIdMap.get(c.dataId).id,h=n.makeOutput(u,"int32"),p=n.dataIdMap.get(h.dataId).id;return gme(o,l,a.shape.length,Lce[a.dtype],s,i,d,p),[c,h]}};var xme={kernelName:tR,backendName:"wasm",setupFunc:function(e){bme=e.wasm.cwrap(tR,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{image:s,transforms:i}=r,{interpolation:o,fillMode:l,fillValue:u,outputShape:c}=a,[d,h,p,f]=s.shape,[m,g]=null!=c?c:[h,p],y=[d,m,g,f],b=new Uint8Array(new Int32Array(TR.computeStrides(s.shape)).buffer),v=new Uint8Array(new Int32Array(TR.computeStrides(y)).buffer),x=n.makeOutput(y,s.dtype),w=n.dataIdMap.get(x.dataId).id,k=n.dataIdMap.get(s.dataId).id,S=n.dataIdMap.get(i.dataId).id,I="nearest"===o?1:2;switch(l){case"constant":default:t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4}return bme(k,S,i.shape[0]>1,d,m,g,f,p,h,b,s.shape.length-1,v,y.length-1,I,t,u,w),x}};var wme={kernelName:rR,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=t6(r.readSync(s.dataId),a,s.shape,s.dtype);return[r.makeOutput(o,s.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}};var kme={kernelName:aR,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),u=0;for(let p=0;p<o;p++)p!==s&&(l[u++]=a.shape[p]);let c=new Array(i),d=new Array(o).fill(0),h=a.shape.slice();h[s]=1;for(let p=0;p<c.length;p++)d[s]=p,c[p]=Ede({inputs:{x:a},attrs:{begin:d,size:h},backend:n});return c.map((e=>{let{dataId:t,dtype:n}=e;return{dataId:t,dtype:n,shape:l}}))}};var Sme={kernelName:oR,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}},Ime=[Uce,Gce,Hce,qce,Yce,Qce,ide,ode,cde,dde,hde,pde,fde,mde,gde,bde,Sde,xde,kde,Tde,$de,Rde,Dde,Mde,Pde,Lde,zde,Vde,jde,Hde,Kde,Yde,Zde,ehe,the,rhe,she,ohe,uhe,dhe,phe,mhe,yhe,vhe,whe,khe,She,Ihe,Che,Nhe,Ehe,Ahe,Rhe,Mhe,Fhe,Ohe,Lhe,Bhe,Vhe,jhe,Hhe,qhe,Khe,ede,Xhe,Yhe,Qhe,Zhe,epe,tpe,rpe,spe,ape,ipe,ope,lpe,upe,dpe,ppe,mpe,gpe,bpe,xpe,kpe,Ipe,Npe,Epe,$pe,Rpe,Mpe,zpe,Bpe,Wpe,Vpe,Gpe,qpe,Xpe,Ype,Qpe,Jpe,efe,nfe,rfe,sfe,ofe,lfe,ufe,cfe,dfe,hfe,Nde,ffe,gfe,bfe,xfe,kfe,Ife,Cfe,Nfe,Efe,_fe,Rfe,Dfe,Mfe,Ffe,Ofe,Pfe,Ade,Ppe,Lfe,Bfe,Vfe,jfe,qfe,Xfe,Yfe,Jfe,Zfe,eme,tme,rme,ame,sme,ime,lme,ume,dme,hme,pme,mme,yme,vme,xme,rde,wme,kme,Sme];for(let n of Ime)wR(n);var Cme=GE();Cme.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(mD){return!1}})),Cme.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(Cme.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(mD){return!1}}));var Nme=ST(VT()),Tme=ST(UT()),Eme=ST(jT()),Ame=Nme.default||Nme,_me=Eme.default||Eme,$me=class extends HT{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(Vme),Ume=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new GT(this,iM())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=TR.now();return e(),{kernelMs:TR.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if("string"===r){let i=t;return void this.dataIdMap.set(e,{id:s,stringBytes:i,shape:n,dtype:r,memoryOffset:null,refCount:a})}let i=TR.sizeFromShape(n),o=i*TR.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=i.length)?i.slice(t,n):i;t=t||0,n=n||TR.sizeFromShape(s);let o=TR.bytesPerElement(a);return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(r+t*o,r+n*o).buffer,a)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(null==n)a=this.write(null!=r?r:null,e,t);else{let r=this.dataIdNextNumber++;a={id:r},this.dataIdMap.set(a,{id:r,memoryOffset:n,shape:e,dtype:t,refCount:1});let s=TR.sizeFromShape(e);this.wasm.tfjs.registerTensor(r,s,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap(e){let{shape:t,dtype:n,dataId:r}=e,a=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(r),i=TR.sizeFromShape(t);switch(n){case"float32":return new Float32Array(a,s,i);case"int32":return new Int32Array(a,s,i);case"bool":return new Uint8Array(a,s,i);default:throw new Error(`Unknown dtype ${n}`)}}};function Rme(e,t,n){if(null!=Fme)return Fme;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=Pme&&null!=Pme[r]?Pme[r]:n+r}async function Dme(){let[e,t]=await Promise.all([GE().getAsync("WASM_HAS_SIMD_SUPPORT"),GE().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{let a={locateFile:(n,r)=>{if(n.endsWith(".worker.js")){let e=Tme.wasmWorkerContents.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?Rme(e,t,null!=Ome?Ome:r):r+n}};zme&&(a.instantiateWasm=function(e){return(t,n)=>(TR.fetch(e,{credentials:"same-origin"}).then((r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then((e=>{WebAssembly.instantiate(e,t).then((e=>{n(e.instance,e.module)}))}))})),{})}(Rme(e,t,null!=Ome?Ome:"")));let s,i=!1;a.onAbort=()=>{i||Lme||(Lme=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==Fme?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Ame.toString()],{type:"text/javascript"}),s=Ame(a)):s=_me(a),s.then((e=>{i=!0,Lme=!1;e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},n({wasm:e})})).catch(r)}))}var Mme=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Fme=null,Ome=null,Pme={},Lme=!1,zme=!1;function Bme(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(aM("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Lme)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Fme=e,zme=t}function Wme(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Lme)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)Ome=e;else{Pme=e;let t=Mme.filter((e=>null==Pme[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}zme=t}var Vme=-1,Ume=-1;function jme(e){Vme=e}function Gme(){if(-1===Ume)throw new Error("WASM backend not initialized.");return Ume}var Hme="4.16.0";vM("wasm",(async()=>{let{wasm:e}=await Dme();return new $me(e)}),2);var qme="4.16.0",Kme={tfjs:qme,"tfjs-core":qme,"tfjs-converter":"4.16.0","tfjs-backend-cpu":"4.16.0","tfjs-backend-webgl":"4.16.0","tfjs-backend-wasm":"4.16.0"},Xme={};function Yme(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(e.beginPath(),t.slice(1).forEach(((n,r)=>{let{x:a,y:s}=n,i=t[r];e.moveTo(i.x,i.y),e.lineTo(a,s)})),n){let n=t[t.length-1],r=t[0];if(!n||!r)return;e.moveTo(n.x,n.y),e.lineTo(r.x,r.y)}e.stroke()}fT(Xme,{AnchorPosition:()=>zge,DrawBox:()=>Uge,DrawBoxOptions:()=>Vge,DrawFaceLandmarks:()=>_ye,DrawFaceLandmarksOptions:()=>Aye,DrawTextField:()=>Wge,DrawTextFieldOptions:()=>Bge,drawContour:()=>Yme,drawDetections:()=>jge,drawFaceExpressions:()=>Nye,drawFaceLandmarks:()=>$ye});fT({},{computeReshapedDimensions:()=>oge,getCenterPoint:()=>lge,isDimensions:()=>ige,isEven:()=>age,isFloat:()=>rge,isTensor:()=>Jme,isTensor1D:()=>Zme,isTensor2D:()=>ege,isTensor3D:()=>tge,isTensor4D:()=>nge,isValidNumber:()=>cge,isValidProbablitiy:()=>dge,range:()=>uge,round:()=>sge});var Qme=class e{constructor(e,t){if(!cge(e)||!cge(t))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:t})}`);this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new e(1/this.width,1/this.height)}};function Jme(e,t){return e instanceof dD&&e.shape.length===t}function Zme(e){return Jme(e,1)}function ege(e){return Jme(e,2)}function tge(e){return Jme(e,3)}function nge(e){return Jme(e,4)}function rge(e){return e%1!==0}function age(e){return e%2===0}function sge(e){let t=10**(arguments.length>1&&void 0!==arguments[1]?arguments[1]:2);return Math.floor(e*t)/t}function ige(e){return e&&e.width&&e.height}function oge(e,t){let{width:n,height:r}=e,a=t/Math.max(r,n);return new Qme(Math.round(n*a),Math.round(r*a))}function lge(e){return e.reduce(((e,t)=>e.add(t)),new hge(0,0)).div(new hge(e.length,e.length))}function uge(e,t,n){return Array(e).fill(0).map(((e,r)=>t+r*n))}function cge(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||0===e}function dge(e){return cge(e)&&e>=0&&e<=1}var hge=class e{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(t){return new e(this.x+t.x,this.y+t.y)}sub(t){return new e(this.x-t.x,this.y-t.y)}mul(t){return new e(this.x*t.x,this.y*t.y)}div(t){return new e(this.x/t.x,this.y/t.y)}abs(){return new e(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new e(Math.floor(this.x),Math.floor(this.y))}},pge=class e{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every(cge)}static assertIsValidBox(t,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!e.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t){let n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=t||{},a=[r.left,r.top,r.right,r.bottom].every(cge),s=[r.x,r.y,r.width,r.height].every(cge);if(!s&&!a)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[i,o,l,u]=s?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];e.assertIsValidBox({x:i,y:o,width:l,height:u},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new hge(this.left,this.top)}get topRight(){return new hge(this.right,this.top)}get bottomLeft(){return new hge(this.left,this.bottom)}get bottomRight(){return new hge(this.right,this.bottom)}round(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map((e=>Math.round(e)));return new e({x:t,y:n,width:r,height:a})}floor(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map((e=>Math.floor(e)));return new e({x:t,y:n,width:r,height:a})}toSquare(){let{x:t,y:n,width:r,height:a}=this,s=Math.abs(r-a);return r<a&&(t-=s/2,r+=s),a<r&&(n-=s/2,a+=s),new e({x:t,y:n,width:r,height:a})}rescale(t){let n=ige(t)?t.width:t,r=ige(t)?t.height:t;return new e({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,a,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new e({x:r,y:a,width:s,height:i})}clipAtImageBorders(t,n){let{x:r,y:a,right:s,bottom:i}=this,o=Math.max(r,0),l=Math.max(a,0),u=s-o,c=i-l,d=Math.min(u,t-o),h=Math.min(c,n-l);return new e({x:o,y:l,width:d,height:h}).floor()}shift(t,n){let{width:r,height:a}=this,s=this.x+t,i=this.y+n;return new e({x:s,y:i,width:r,height:a})}padAtBorders(e,t){let n=this.width+1,r=this.height+1,a=n,s=r,i=this.left,o=this.top,l=this.right,u=this.bottom;return l>t&&(a=-l+t+n,l=t),u>e&&(s=-u+e+r,u=e),i<1&&(s=2-i,i=1),o<1&&(s=2-o,o=1),{dy:1,edy:s,dx:1,edx:a,y:o,ey:u,x:i,ex:l,w:n,h:r}}calibrate(t){return new e({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},fge=class extends pge{constructor(e,t,n,r){super({left:e,top:t,right:n,bottom:r},arguments.length>4&&void 0!==arguments[4]&&arguments[4])}},mge=class e{constructor(e,t,n,r,a){this._imageDims=new Qme(a.width,a.height),this._score=e,this._classScore=t,this._className=n,this._box=new pge(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new pge(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new e(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},gge=class e extends mge{constructor(e,t,n){super(e,e,"",t,n)}forSize(t,n){let{score:r,relativeBox:a,imageDims:s}=super.forSize(t,n);return new e(r,a,s)}};function yge(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left))*Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top));return n?r/(e.area+t.area-r):r/Math.min(e.area,t.area)}function bge(e,t){return uM((()=>{let[n,r,a]=t,s=kO([...e.shape.slice(0,3),1],n,"float32"),i=kO([...e.shape.slice(0,3),1],r,"float32"),o=kO([...e.shape.slice(0,3),1],a,"float32"),l=sO([s,i,o],3);return QP(e,l)}))}function vge(e){return 1/(1+Math.exp(-e))}var xge,wge=class extends pge{constructor(e,t,n,r){super({x:e,y:t,width:n,height:r},arguments.length>4&&void 0!==arguments[4]&&arguments[4])}},kge=class{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new hge(0,0),{width:r,height:a}=t;this._imgDims=new Qme(r,a),this._shift=n,this._positions=e.map((e=>e.mul(new hge(r,a)).add(n)))}get shift(){return new hge(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map((e=>e.sub(this._shift).div(new hge(this.imageWidth,this.imageHeight))))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new hge(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(e){let n=e instanceof gge?e.box.floor():new pge(e);return this.shiftBy(n.x,n.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=e=>r.sub(e).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/.45),o=lge(e),l=Math.floor(Math.max(0,o.x-.5*i)),u=Math.floor(Math.max(0,o.y-.43*i));return new wge(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=function(e){let t=e.map((e=>e.x)),n=e.map((e=>e.y)),r=t.reduce(((e,t)=>t<e?t:e),1/0),a=n.reduce(((e,t)=>t<e?t:e),1/0),s=t.reduce(((e,t)=>e<t?t:e),0),i=n.reduce(((e,t)=>e<t?t:e),0);return new fge(r,a,s,i)}(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},Sge=class extends kge{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(lge)}},Ige=class{constructor(e,t){this._label=e,this._distance=t}get label(){return this._label}get distance(){return this._distance}toString(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return`${this.label}${e?` (${sge(this.distance)})`:""}`}},Cge=class e{constructor(e,t){if("string"!=typeof e)throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(t)||t.some((e=>!(e instanceof Float32Array))))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=e,this._descriptors=t}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map((e=>Array.from(e)))}}static fromJSON(t){let n=t.descriptors.map((e=>new Float32Array(e)));return new e(t.label,n)}};function Nge(e){return e.detection instanceof gge}function Tge(e,t){return{...e,detection:t}}function Ege(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D:CanvasRenderingContext2D,Image:HTMLImageElement,ImageData:ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function Age(){return"object"==typeof n.g&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node}function _ge(e){let t="";if(!e&&Age())try{e=pT("fs")}catch(n){t=n.toString()}return{readFile:e?t=>new Promise(((n,r)=>{e.readFile(t,((e,t)=>e?r(e):n(t)))})):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function $ge(){let e=n.g.Canvas||n.g.HTMLCanvasElement,t=n.g.Image||n.g.HTMLImageElement,r=n.g.Video||n.g.HTMLVideoElement,a=n.g.fetch,s=_ge();return{Canvas:e||class{},CanvasRenderingContext2D:n.g.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:n.g.ImageData||class{},Video:n.g.HTMLVideoElement||class{},createCanvasElement:()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},createImageElement:()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},createVideoElement:()=>{if(r)return new r;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},fetch:a,...s}}function Rge(){return"object"==typeof window&&"undefined"!=typeof document&&"undefined"!=typeof HTMLImageElement&&"undefined"!=typeof HTMLCanvasElement&&"undefined"!=typeof HTMLVideoElement&&"undefined"!=typeof ImageData&&"undefined"!=typeof CanvasRenderingContext2D}function Dge(e){xge=e}function Mge(){return Rge()?Dge(Ege()):Age()?Dge($ge()):null}var Fge={getEnv:function(){if(!xge)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return xge},setEnv:Dge,initialize:Mge,createBrowserEnv:Ege,createFileSystem:_ge,createNodejsEnv:$ge,monkeyPatch:function(e){if(xge||Mge(),!xge)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=xge.Canvas,Image:n=xge.Image}=e;xge.Canvas=t,xge.Image=n,xge.createCanvasElement=e.createCanvasElement||(()=>new t),xge.createImageElement=e.createImageElement||(()=>new n),xge.ImageData=e.ImageData||xge.ImageData,xge.Video=e.Video||xge.Video,xge.fetch=e.fetch||xge.fetch,xge.readFile=e.readFile||xge.readFile},isBrowser:Rge,isNodejs:Age};function Oge(e){return Fge.isNodejs()||"string"!=typeof e?e:document.getElementById(e)}function Pge(e){let{Canvas:t,CanvasRenderingContext2D:n}=Fge.getEnv();if(e instanceof n)return e;let r=Oge(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d",{willReadFrequently:!0});if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}Mge();var Lge,zge=((Lge=zge||{}).TOP_LEFT="TOP_LEFT",Lge.TOP_RIGHT="TOP_RIGHT",Lge.BOTTOM_LEFT="BOTTOM_LEFT",Lge.BOTTOM_RIGHT="BOTTOM_RIGHT",Lge),Bge=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},Wge=class e{constructor(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.text="string"==typeof t?[t]:t instanceof e?t.text:t,this.anchor=n,this.options=new Bge(r)}measureWidth(e){let{padding:t}=this.options;return this.text.map((t=>e.measureText(t).width)).reduce(((e,t)=>e<t?t:e),0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,r="BOTTOM_RIGHT"===n||"TOP_RIGHT"===n,a="BOTTOM_LEFT"===n||"BOTTOM_RIGHT"===n,s=this.measureWidth(e),i=this.measureHeight(),o=r?this.anchor.x-s:this.anchor.x,l=a?this.anchor.y-i:this.anchor.y;if(t){let{width:e,height:n}=t;return{x:Math.max(Math.min(o,e-s),0),y:Math.max(Math.min(l,n-i),0)}}return{x:o,y:l}}draw(e){let t=Oge(e),n=Pge(t),{backgroundColor:r,fontColor:a,fontSize:s,fontStyle:i,padding:o}=this.options;n.font=`${s}px ${i}`;let l=this.measureWidth(n),u=this.measureHeight();n.fillStyle=r;let c=this.getUpperLeft(n,t);n.fillRect(c.x,c.y,l,u),n.fillStyle=a,this.text.forEach(((e,t)=>{let r=o+c.x,a=o+c.y+(t+1)*s;n.fillText(e,r,a)}))}},Vge=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new Bge({...s,...a})}},Uge=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.box=new pge(e),this.options=new Vge(t)}draw(e){let t=Pge(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new Wge([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function jge(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof gge?t.score:Nge(t)?t.detection.score:void 0,r=t instanceof gge?t.box:Nge(t)?t.detection.box:new pge(t),a=n?`${sge(n)}`:void 0;new Uge(r,{label:a}).draw(e)}))}function Gge(e){let{Image:t,Video:n}=Fge.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function Hge(e){let{Image:t,Video:n}=Fge.getEnv();return e instanceof t?new Qme(e.naturalWidth,e.naturalHeight):e instanceof n?new Qme(e.videoWidth,e.videoHeight):new Qme(e.width,e.height)}function qge(e){let{width:t,height:n}=e,{createCanvasElement:r}=Fge.getEnv(),a=r();return a.width=t,a.height=n,a}function Kge(e,t){let{ImageData:n}=Fge.getEnv();if(!(e instanceof n)&&!Gge(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||Hge(e),s=qge({width:r,height:a});return e instanceof n?Pge(s).putImageData(e,0,0):Pge(s).drawImage(e,0,0,r,a),s}function Xge(e){let{Image:t,Canvas:n,Video:r}=Fge.getEnv();return e instanceof t||e instanceof n||e instanceof r}var Yge=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach(((e,t)=>{if(tge(e))return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape);if(nge(e)){let n=e.shape[0];if(1!==n)throw new Error(`NetInput - tf.Tensor4D with batchSize ${n} passed, but not supported in input array`);return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape.slice(1))}let n=e instanceof Fge.getEnv().Canvas?e:Kge(e);this._canvases[t]=n,this._inputDimensions[t]=[n.height,n.width,3]}))}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return uge(this.batchSize,0,1).map(((e,t)=>this.getReshapedInputDimensions(t)))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if("number"!=typeof this.inputSize)throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");return oge({width:this.getInputWidth(e),height:this.getInputHeight(e)},this.inputSize)}toBatchTensor(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return this._inputSize=e,uM((()=>{let n=uge(this.batchSize,0,1).map((n=>{let r=this.getInput(n);if(r instanceof dD){let n=nge(r)?r:kP(r);return n=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return uM((()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=t=>{let n=e.shape.slice();return n[i]=t,kO(n,0,"float32")},l=o(s),u=a-l.shape[i],c=[t&&u?o(u):null,e,l].filter((e=>!!e)).map((e=>wF(e,"float32")));return sO(c,i)}))}(n,t),(n.shape[1]!==e||n.shape[2]!==e)&&(n=EW.resizeBilinear(n,[e,e],!1,!1)),n.as3D(e,e,3)}if(r instanceof Fge.getEnv().Canvas)return bV.fromPixels(function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{Image:r,Canvas:a}=Fge.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return qge({width:1,height:1});let s=Hge(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,u=qge({width:t,height:t}),c=e instanceof a?e:Kge(e),d=Math.abs(o-l)/2,h=n&&o<l?d:0,p=n&&l<o?d:0;return c.width>0&&c.height>0&&Pge(u).drawImage(c,h,p,o,l),u}(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${n}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)}));return Lz(n.map((e=>wF(e,"float32")))).as4D(this.batchSize,e,e,3)}))}};async function Qge(e){if(e instanceof Yge)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=t=>Array.isArray(e)?` at input index ${t}:`:"",r=t.map(Oge);return r.forEach(((e,r)=>{if(!Xge(e)&&!tge(e)&&!nge(e))throw"string"==typeof t[r]?new Error(`toNetInput -${n(r)} string passed, but could not resolve HTMLElement for element id ${t[r]}`):new Error(`toNetInput -${n(r)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(nge(e)){let t=e.shape[0];if(1!==t)throw new Error(`toNetInput -${n(r)} tf.Tensor4D with batchSize ${t} passed, but not supported in input array`)}})),await Promise.all(r.map((e=>Xge(e)&&function(e){return new Promise(((t,n)=>{function r(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),n(e))}function a(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),t(e))}(e instanceof Fge.getEnv().Canvas||Gge(e))&&t(null),e.addEventListener("load",a),e.addEventListener("error",r)}))}(e)))),new Yge(r,Array.isArray(e))}async function Jge(e,t){let{Canvas:n}=Fge.getEnv(),r=e;if(!(e instanceof n)){let t=await Qge(e);if(t.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let a=t.getInput(0);r=a instanceof n?a:await async function(e,t){let n=t||Fge.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(nge(e)?1:0),i=uM((()=>e.as3D(r,a,s).toInt()));return await bV.toPixels(i,n),i.dispose(),n}(a)}let a=Pge(r);return t.map((e=>e instanceof gge?e.forSize(r.width,r.height).box.floor():e)).map((e=>e.clipAtImageBorders(r.width,r.height))).map((e=>{let{x:t,y:n,width:r,height:s}=e,i=qge({width:r,height:s});return r>0&&s>0&&Pge(i).putImageData(a.getImageData(t,n,r,s),0,0),i}))}async function Zge(e,t){if(!tge(e)&&!nge(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(nge(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return uM((()=>{let[n,r,a]=e.shape.slice(nge(e)?1:0);return t.map((e=>e instanceof gge?e.forSize(r,n).box:e)).map((e=>e.clipAtImageBorders(r,n))).filter((e=>e.width>0&&e.height>0)).map((t=>{let{x:s,y:i,width:o,height:l}=t;return Ez(e.as3D(n,r,a),[i,s,0],[l,o,a])}))}))}async function eye(e,t){let{fetch:n}=Fge.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}function tye(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if("/"===e)return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"",a=(e=e.replace(r,"")).split("/").filter((e=>e)),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:"/"===i?`/${s}`:`${i}/${s}`}}async function nye(e,t){let{manifestUri:n,modelBaseUri:r}=tye(e,t),a=await async function(e){return(await eye(e)).json()}(n);return XW.loadWeights(a,r)}var rye=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map((e=>{let{paramPath:t}=e;return{path:t,tensor:this.getParamFromPath(t)}}))}getTrainableParams(){return this.getParamList().filter((e=>e.tensor instanceof pD))}getFrozenParams(){return this.getParamList().filter((e=>!(e.tensor instanceof pD)))}variable(){this.getFrozenParams().forEach((e=>{let{path:t,tensor:n}=e;this.reassignParamFromPath(t,n.variable())}))}freeze(){this.getTrainableParams().forEach((e=>{let{path:t,tensor:n}=e,r=JD(n.dataSync());n.dispose(),this.reassignParamFromPath(t,r)}))}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.getParamList().forEach((t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()})),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map((e=>{let{tensor:t}=e;return Array.from(t.dataSync())})).reduce(((e,t)=>e.concat(t))))}async load(e){e instanceof Float32Array?this.extractWeights(e):await this.loadFromUri(e)}async loadFromUri(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await nye(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=Fge.getEnv(),{manifestUri:n,modelBaseUri:r}=tye(e,this.getDefaultModelName()),a=XW.weightsLoaderFactory((e=>Promise.all(e.map((e=>t(e).then((e=>"string"==typeof e?Buffer.from(e):e.buffer))))))),s=JSON.parse((await t(n)).toString()),i=await a(s,r);this.loadFromWeightMap(i)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce(((t,n)=>{if(!t.nextObj.hasOwnProperty(n))throw new Error(`traversePropertyPath - object does not have property ${n}, for path ${e}`);return{obj:t.nextObj,objProp:n,nextObj:t.nextObj[n]}}),{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof dD))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function aye(e,t,n){return uM((()=>{let r=wz(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=IF(r,t.bias),r}))}function sye(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return uM((()=>{let r=dz(n?IF(EO(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):aye(e,t.conv0,[2,2])),a=aye(r,t.conv1,[1,1]),s=aye(dz(IF(r,a)),t.conv2,[1,1]);return dz(IF(r,IF(a,s)))}))}function iye(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];return uM((()=>{let a=dz(n?IF(EO(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):aye(e,t.conv0,r?[2,2]:[1,1])),s=aye(a,t.conv1,[1,1]),i=aye(dz(IF(a,s)),t.conv2,[1,1]),o=aye(dz(IF(a,IF(s,i))),t.conv3,[1,1]);return dz(IF(a,IF(s,IF(i,o))))}))}function oye(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"same",r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return uM((()=>{let a=IF(EO(e,t.filters,[1,1],n),t.bias);return r?dz(a):a}))}function lye(e,t){Object.keys(e).forEach((n=>{t.some((e=>e.originalPath===n))||e[n].dispose()}))}function uye(e,t){return(n,r,a,s)=>{let i=Gz(e(n*r*a*a),[a,a,n,r]),o=Vz(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function cye(e,t){return(n,r,a)=>{let s=Uz(e(n*r),[n,r]),i=Vz(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var dye=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function hye(e,t){return(n,r,a)=>{let s=Gz(e(9*n),[3,3,n,1]),i=Gz(e(n*r),[1,1,n,r]),o=Vz(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new dye(s,i,o)}}function pye(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new dye(n,r,a)}}function fye(e,t){return(n,r,a)=>{let s=e[n];if(!Jme(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function mye(e){let t=e;return{extractWeights:function(e){let n=t.slice(0,e);return t=t.slice(e),n},getRemainingWeights:function(){return t}}}function gye(e,t){let n=uye(e,t),r=hye(e,t);function a(e,t,a){return{conv0:arguments.length>3&&void 0!==arguments[3]&&arguments[3]?n(e,t,3,`${a}/conv0`):r(e,t,`${a}/conv0`),conv1:r(t,t,`${a}/conv1`),conv2:r(t,t,`${a}/conv2`)}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:function(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],{conv0:i,conv1:o,conv2:l}=a(e,t,n,s);return{conv0:i,conv1:o,conv2:l,conv3:r(t,t,`${n}/conv3`)}}}}function yye(e){return t=>({filters:e(`${t}/filters`,4),bias:e(`${t}/bias`,1)})}function bye(e,t){let n=fye(e,t),r=yye(n),a=pye(n);return{extractDenseBlock3Params:function(e){return{conv0:arguments.length>1&&void 0!==arguments[1]&&arguments[1]?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`)}},extractDenseBlock4Params:function(e){return{conv0:arguments.length>1&&void 0!==arguments[1]&&arguments[1]?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`),conv3:a(`${e}/conv3`)}}}}var vye=class extends rye{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return uM((()=>{let n=iye(bge(wF(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=iye(n,t.dense1),n=iye(n,t.dense2),n=iye(n,t.dense3),n=rO(n,[7,7],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await Qge(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock4Params:n}=bye(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return lye(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=mye(e),{extractDenseBlock4Params:a}=gye(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}(e)}};function xye(e,t){return uM((()=>IF(iO(e,t.weights),t.bias)))}function wye(e){let t={},n={};return Object.keys(e).forEach((r=>{(r.startsWith("fc")?n:t)[r]=e[r]})),{featureExtractorMap:t,classifierMap:n}}var kye=class extends rye{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return uM((()=>{let n=e instanceof Yge?this.faceFeatureExtractor.forwardInput(e):e;return xye(n.as2D(n.shape[0],-1),t.fc)}))}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=mye(e),i=cye(a,r)(t,n,"fc");if(0!==s().length)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=wye(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=fye(e,t),r={fc:(a="fc",{weights:n(`${a}/weights`,2),bias:n(`${a}/bias`,1)})};var a;return lye(e,t),{params:r,paramMappings:t}}(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},Sye=["neutral","happy","sad","angry","fearful","disgusted","surprised"],Iye=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,7!==e.length)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);Sye.forEach(((t,n)=>{this[t]=e[n]}))}asSortedArray(){return Sye.map((e=>({expression:e,probability:this[e]}))).sort(((e,t)=>t.probability-e.probability))}};function Cye(e,t){return{...e,expressions:t}}function Nye(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,r=arguments.length>3?arguments[3]:void 0;(Array.isArray(t)?t:[t]).forEach((t=>{let a=t instanceof Iye?t:function(e){return e.expressions instanceof Iye}(t)?t.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let s=a.asSortedArray().filter((e=>e.probability>n)),i=Nge(t)?t.detection.box.bottomLeft:r||new hge(0,0);new Wge(s.map((e=>`${e.expression} (${sge(e.probability)})`)),i).draw(e)}))}function Tye(e){return Nge(e)&&e.landmarks instanceof kge&&e.unshiftedLandmarks instanceof kge&&e.alignedRect instanceof gge}function Eye(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new gge(e.detection.score,a.rescale(s.reverse()),s),o=function(e){let t=e=>180*e/Math.PI,n=(e,t)=>Math.sqrt((e.x-t.x)**2+(e.y-t.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0};if(!e||!e.positions||68!==e.positions.length)return r;let a=e.positions;return r.roll=((e,n)=>{let r=Math.hypot(n.x-e.x,n.y-e.y),a=n.y-e.y,s=Math.asin(a/r),i=t(s);return Math.floor(90-i)*(n.x-e.x<0?-1:1)})(a[27],a[66]),r.pitch=((e,r,a)=>{let s=n(e,a),i=new hge((e.x+a.x)/2,(e.y+a.y)/2),o=n(r,i),l=Math.atan(o/s);return Math.floor(t(l))*(i.y-r.y<0?-1:1)})(a[14],a[30],a[2]),r.yaw=((e,t,n)=>Math.floor(e.x-t.x)-Math.floor(t.x-n.x))(a[14],a[33],a[2]),r}(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var Aye=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},_ye=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.faceLandmarks=e,this.options=new Aye(t)}draw(e){let t=Pge(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof Sge&&(t.strokeStyle=s,t.lineWidth=a,Yme(t,this.faceLandmarks.getJawOutline()),Yme(t,this.faceLandmarks.getLeftEyeBrow()),Yme(t,this.faceLandmarks.getRightEyeBrow()),Yme(t,this.faceLandmarks.getNose()),Yme(t,this.faceLandmarks.getLeftEye(),!0),Yme(t,this.faceLandmarks.getRightEye(),!0),Yme(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let e=e=>{t.beginPath(),t.arc(e.x,e.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(e)}}};function $ye(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof kge?t:Tye(t)?t.landmarks:void 0;if(!n)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new _ye(n).draw(e)}))}function Rye(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=mye(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=function(e,t){let n=uye(e,t),r=hye(e,t);return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:function(e,t,a){return{separable_conv0:r(e,t,`${a}/separable_conv0`),separable_conv1:r(t,t,`${a}/separable_conv1`),expansion_conv:n(e,t,1,`${a}/expansion_conv`)}},extractMainBlockParams:function(e,t){return{separable_conv0:r(e,e,`${t}/separable_conv0`),separable_conv1:r(e,e,`${t}/separable_conv1`),separable_conv2:r(e,e,`${t}/separable_conv2`)}}}}(r,n),u={conv_in:s(3,32,3,"entry_flow/conv_in"),reduction_block_0:o(32,64,"entry_flow/reduction_block_0"),reduction_block_1:o(64,128,"entry_flow/reduction_block_1")},c={};uge(t,0,1).forEach((e=>{c[`main_block_${e}`]=l(128,`middle_flow/main_block_${e}`)}));let d={reduction_block:o(128,256,"exit_flow/reduction_block"),separable_conv:i(256,512,"exit_flow/separable_conv")};if(0!==a().length)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:u,middle_flow:c,exit_flow:d}}}function Dye(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=function(e,t){let n=fye(e,t),r=yye(n),a=pye(n);return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),expansion_conv:r(`${e}/expansion_conv`)}},extractMainBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),separable_conv2:a(`${e}/separable_conv2`)}}}}(e,n),o={conv_in:r("entry_flow/conv_in"),reduction_block_0:s("entry_flow/reduction_block_0"),reduction_block_1:s("entry_flow/reduction_block_1")},l={};uge(t,0,1).forEach((e=>{l[`main_block_${e}`]=i(`middle_flow/main_block_${e}`)}));let u={reduction_block:s("exit_flow/reduction_block"),separable_conv:a("exit_flow/separable_conv")};return lye(e,n),{params:{entry_flow:o,middle_flow:l,exit_flow:u},paramMappings:n}}function Mye(e,t,n){return IF(EO(e,t.filters,n,"same"),t.bias)}function Fye(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?dz(e):e;return n=aye(n,t.separable_conv0,[1,1]),n=aye(dz(n),t.separable_conv1,[1,1]),n=oL(n,[3,3],[2,2],"same"),n=IF(n,Mye(e,t.expansion_conv,[2,2])),n}var Oye=class extends rye{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return uM((()=>{let n=bge(wF(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),r=dz(Mye(n,t.entry_flow.conv_in,[2,2]));return r=Fye(r,t.entry_flow.reduction_block_0,!1),r=Fye(r,t.entry_flow.reduction_block_1),uge(this._numMainBlocks,0,1).forEach((e=>{r=function(e,t){let n=aye(dz(e),t.separable_conv0,[1,1]);return n=aye(dz(n),t.separable_conv1,[1,1]),n=aye(dz(n),t.separable_conv2,[1,1]),n=IF(n,e),n}(r,t.middle_flow[`main_block_${e}`])})),r=Fye(r,t.exit_flow.reduction_block),r=dz(aye(r,t.exit_flow.separable_conv,[1,1])),r}))}async forward(e){return this.forwardInput(await Qge(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return Dye(e,this._numMainBlocks)}extractParams(e){return Rye(e,this._numMainBlocks)}};var Pye,Lye=((Pye=Lye||{}).FEMALE="female",Pye.MALE="male",Pye),zye=class extends kye{postProcess(e,t,n){let r=n.map((e=>{let{width:n,height:r}=e,a=t/Math.max(r,n);return{width:n*a,height:r*a}})),a=r.length;return uM((()=>{let n=(e,t)=>Lz([kO([68],e,"float32"),kO([68],t,"float32")],1).as2D(1,136).as1D(),s=(e,t)=>{let{width:n,height:a}=r[e];return t(n,a)?Math.abs(n-a)/2:0};return e.mul(kO([a,136],t,"float32")).sub(Lz(Array.from(Array(a),((e,t)=>n((e=>s(e,((e,t)=>e<t)))(t),(e=>s(e,((e,t)=>t<e)))(t)))))).div(Lz(Array.from(Array(a),((e,t)=>n(r[t].width,r[t].height)))))}))}forwardInput(e){return uM((()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map((e=>{let[t,n]=e;return{height:t,width:n}})))}))}async forward(e){return this.forwardInput(await Qge(e))}async detectLandmarks(e){let t=await Qge(e),n=uM((()=>rB(this.forwardInput(t)))),r=await Promise.all(n.map((async(e,n)=>{let r=Array.from(e.dataSync()),a=r.filter(((e,t)=>age(t))),s=r.filter(((e,t)=>!age(t)));return new Sge(Array(68).fill(0).map(((e,t)=>new hge(a[t],s[t]))),{height:t.getInputHeight(n),width:t.getInputWidth(n)})})));return n.forEach((e=>e.dispose())),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},Bye=class extends zye{constructor(){super("FaceLandmark68Net",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new vye)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};var Wye=class extends rye{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return uM((()=>{let n=sye(bge(wF(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=sye(n,t.dense1),n=sye(n,t.dense2),n=rO(n,[14,14],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await Qge(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock3Params:n}=bye(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return lye(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=mye(e),{extractDenseBlock3Params:a}=gye(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}(e)}};function Vye(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"same",{filters:s,bias:i}=t.conv,o=EO(e,s,n,a);return o=IF(o,i),o=function(e,t){return IF(TF(e,t.weights),t.biases)}(o,t.scale),r?dz(o):o}function Uye(e,t){return Vye(e,t,[1,1],!1)}function jye(e,t){return Vye(e,t,[2,2],!0,"valid")}function Gye(e,t){function n(n,r,a,s){let i=function(t,n,r){let a=e(t),s=a.length/(n*r*r);if(rge(s))throw new Error(`depth has to be an integer: ${s}, weights.length: ${a.length}, numFilters: ${n}, filterSize: ${r}`);return uM((()=>uB(Gz(a,[n,s,r,r]),[2,3,1,0])))}(n,r,a),o=Vz(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}function r(r,a,s,i){let o=n(r,a,s,`${i}/conv`),l=function(n,r){let a=Vz(e(n)),s=Vz(e(n));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/biases`}),{weights:a,biases:s}}(a,`${i}/scale`);return{conv:o,scale:l}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e,t,n,a){return{conv1:r((arguments.length>4&&void 0!==arguments[4]&&arguments[4]?.5:1)*e,t,n,`${a}/conv1`),conv2:r(e,t,n,`${a}/conv2`)}}}}function Hye(e,t){let n=fye(e,t);function r(e){let t=n(`${e}/conv/filters`,4),r=n(`${e}/conv/bias`,1),a=function(e){return{weights:n(`${e}/scale/weights`,1),biases:n(`${e}/scale/biases`,1)}}(e);return{conv:{filters:t,bias:r},scale:a}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e){return{conv1:r(`${e}/conv1`),conv2:r(`${e}/conv2`)}}}}function qye(e,t){let n=function(e,t){return Vye(e,t,[1,1],!0)}(e,t.conv1);return n=Uye(n,t.conv2),n=IF(n,e),n=dz(n),n}function Kye(e,t){let n=jye(e,t.conv1);n=Uye(n,t.conv2);let r=rO(e,2,2,"valid"),a=hL(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let e=[...n.shape];e[1]=1;let t=hL(e);n=sO([n,t],1);let r=[...n.shape];r[2]=1;let a=hL(r);n=sO([n,a],2)}return r=s?sO([r,a],3):r,n=IF(r,n),n=dz(n),n}var Xye=class extends rye{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return uM((()=>{let n=jye(bge(wF(e.toBatchTensor(150,!0),"float32"),[122.782,117.001,104.298]).div(255),t.conv32_down);n=oL(n,3,2,"valid"),n=qye(n,t.conv32_1),n=qye(n,t.conv32_2),n=qye(n,t.conv32_3),n=Kye(n,t.conv64_down),n=qye(n,t.conv64_1),n=qye(n,t.conv64_2),n=qye(n,t.conv64_3),n=Kye(n,t.conv128_down),n=qye(n,t.conv128_1),n=qye(n,t.conv128_2),n=Kye(n,t.conv256_down),n=qye(n,t.conv256_1),n=qye(n,t.conv256_2),n=Kye(n,t.conv256_down_out);let r=n.mean([1,2]);return iO(r,t.fc)}))}async forward(e){return this.forwardInput(await Qge(e))}async computeFaceDescriptor(e){var t;if(null!=(t=null==e?void 0:e.shape)&&t.some((e=>e<=0)))return new Float32Array(128);let n=await Qge(e),r=uM((()=>rB(this.forwardInput(n)))),a=await Promise.all(r.map((e=>e.data())));return r.forEach((e=>e.dispose())),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=Hye(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),c=r("conv64_2"),d=r("conv64_3"),h=r("conv128_down"),p=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:v}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!ege(v))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${v}`);let x={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:c,conv64_3:d,conv128_down:h,conv128_1:p,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:v};return lye(e,t),{params:x,paramMappings:t}}(e)}extractParams(e){return function(e){let{extractWeights:t,getRemainingWeights:n}=mye(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=Gye(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),u=s(9216,32,3,"conv32_3"),c=s(36864,64,3,"conv64_down",!0),d=s(36864,64,3,"conv64_1"),h=s(36864,64,3,"conv64_2"),p=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),v=s(589824,256,3,"conv256_2"),x=s(589824,256,3,"conv256_down_out"),w=uM((()=>uB(Uz(t(32768),[128,256]),[1,0])));if(r.push({paramPath:"fc"}),0!==n().length)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:c,conv64_1:d,conv64_2:h,conv64_3:p,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:v,conv256_down_out:x,fc:w},paramMappings:r}}(e)}};function Yye(e,t){return{...e,descriptor:t}}function Qye(e,t){return{...e,age:t}}function Jye(e,t,n){return{...e,gender:t,genderProbability:n}}function Zye(e,t){function n(n,r,a,s,i){let o=Gz(e(n*r*a*a),[a,a,n,r]),l=Vz(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/${i?"batch_norm_offset":"bias"}`}),{filters:o,bias:l}}function r(e,t,r,a){let{filters:s,bias:i}=n(e,t,r,a,!0);return{filters:s,batch_norm_offset:i}}function a(n,a,s){let i=function(n,r){let a=Gz(e(9*n),[3,3,n,1]),s=Vz(e(n)),i=Vz(e(n)),o=Vz(e(n)),l=Vz(e(n));return t.push({paramPath:`${r}/filters`},{paramPath:`${r}/batch_norm_scale`},{paramPath:`${r}/batch_norm_offset`},{paramPath:`${r}/batch_norm_mean`},{paramPath:`${r}/batch_norm_variance`}),{filters:a,batch_norm_scale:s,batch_norm_offset:i,batch_norm_mean:o,batch_norm_variance:l}}(n,`${s}/depthwise_conv`);return{depthwise_conv:i,pointwise_conv:r(n,a,1,`${s}/pointwise_conv`)}}return{extractMobilenetV1Params:function(){return{conv_0:r(3,32,3,"mobilenetv1/conv_0"),conv_1:a(32,64,"mobilenetv1/conv_1"),conv_2:a(64,128,"mobilenetv1/conv_2"),conv_3:a(128,128,"mobilenetv1/conv_3"),conv_4:a(128,256,"mobilenetv1/conv_4"),conv_5:a(256,256,"mobilenetv1/conv_5"),conv_6:a(256,512,"mobilenetv1/conv_6"),conv_7:a(512,512,"mobilenetv1/conv_7"),conv_8:a(512,512,"mobilenetv1/conv_8"),conv_9:a(512,512,"mobilenetv1/conv_9"),conv_10:a(512,512,"mobilenetv1/conv_10"),conv_11:a(512,512,"mobilenetv1/conv_11"),conv_12:a(512,1024,"mobilenetv1/conv_12"),conv_13:a(1024,1024,"mobilenetv1/conv_13")}},extractPredictionLayerParams:function(){return{conv_0:r(1024,256,1,"prediction_layer/conv_0"),conv_1:r(256,512,3,"prediction_layer/conv_1"),conv_2:r(512,128,1,"prediction_layer/conv_2"),conv_3:r(128,256,3,"prediction_layer/conv_3"),conv_4:r(256,128,1,"prediction_layer/conv_4"),conv_5:r(128,256,3,"prediction_layer/conv_5"),conv_6:r(256,64,1,"prediction_layer/conv_6"),conv_7:r(64,128,3,"prediction_layer/conv_7"),box_predictor_0:{box_encoding_predictor:n(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),class_predictor:n(512,9,1,"prediction_layer/box_predictor_0/class_predictor")},box_predictor_1:{box_encoding_predictor:n(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),class_predictor:n(1024,18,1,"prediction_layer/box_predictor_1/class_predictor")},box_predictor_2:{box_encoding_predictor:n(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),class_predictor:n(512,18,1,"prediction_layer/box_predictor_2/class_predictor")},box_predictor_3:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_3/class_predictor")},box_predictor_4:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_4/class_predictor")},box_predictor_5:{box_encoding_predictor:n(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),class_predictor:n(128,18,1,"prediction_layer/box_predictor_5/class_predictor")}}}}}function ebe(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=function(e,t){let n=fye(e,t);function r(e,t,r){return{filters:n(`${e}/Conv2d_${t}_pointwise/weights`,4,`${r}/filters`),batch_norm_offset:n(`${e}/Conv2d_${t}_pointwise/convolution_bn_offset`,1,`${r}/batch_norm_offset`)}}function a(e){let t=`mobilenetv1/conv_${e}`,a=`MobilenetV1/Conv2d_${e}_depthwise`,s=`${t}/depthwise_conv`,i=`${t}/pointwise_conv`;return{depthwise_conv:{filters:n(`${a}/depthwise_weights`,4,`${s}/filters`),batch_norm_scale:n(`${a}/BatchNorm/gamma`,1,`${s}/batch_norm_scale`),batch_norm_offset:n(`${a}/BatchNorm/beta`,1,`${s}/batch_norm_offset`),batch_norm_mean:n(`${a}/BatchNorm/moving_mean`,1,`${s}/batch_norm_mean`),batch_norm_variance:n(`${a}/BatchNorm/moving_variance`,1,`${s}/batch_norm_variance`)},pointwise_conv:r("MobilenetV1",e,i)}}function s(e,t){return{filters:n(`${e}/weights`,4,`${t}/filters`),bias:n(`${e}/biases`,1,`${t}/bias`)}}function i(e){return{box_encoding_predictor:s(`Prediction/BoxPredictor_${e}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${e}/box_encoding_predictor`),class_predictor:s(`Prediction/BoxPredictor_${e}/ClassPredictor`,`prediction_layer/box_predictor_${e}/class_predictor`)}}return{extractMobilenetV1Params:function(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}},extractPredictionLayerParams:function(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:i(0),box_predictor_1:i(1),box_predictor_2:i(2),box_predictor_3:i(3),box_predictor_4:i(4),box_predictor_5:i(5)}}}}(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!tge(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return lye(e,t),{params:s,paramMappings:t}}function tbe(e,t,n){return uM((()=>{let r=EO(e,t.filters,n,"same");return r=IF(r,t.batch_norm_offset),SO(r,0,6)}))}var nbe=.0010000000474974513;function rbe(e,t){return uM((()=>{let n,r=tbe(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach(((e,t)=>{let a=t+1,s=function(e){return[2,4,6,12].some((t=>t===e))?[2,2]:[1,1]}(a);r=function(e,t,n){return uM((()=>{let r=WO(e,t.filters,n,"same");return r=pO(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,nbe),SO(r,0,6)}))}(r,e.depthwise_conv,s),r=tbe(r,e.pointwise_conv,[1,1]),11===a&&(n=r)})),null===n)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}}))}function abe(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),c=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),h=(i-a)*(o-s),p=(c-l)*(d-u);if(h<=0||p<=0)return 0;let f=Math.max(a,l),m=Math.max(s,u),g=Math.min(i,c),y=Math.min(o,d),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(h+p-b)}function sbe(e,t){let{sizes:n,centers:r}=function(e){let t=rB(uB(e,[1,0])),n=[QP(t[2],t[0]),QP(t[3],t[1])];return{sizes:n,centers:[IF(t[0],NF(n[0],2)),IF(t[1],NF(n[1],2))]}}(e),a=rB(uB(t,[1,0])),s=NF(TF(wP(NF(a[2],5)),n[0]),2),i=IF(TF(NF(a[0],10),n[0]),r[0]),o=NF(TF(wP(NF(a[3],5)),n[1]),2),l=IF(TF(NF(a[1],10),n[1]),r[1]);return uB(Lz([QP(i,s),QP(l,o),IF(i,s),IF(l,o)]),[1,0])}function ibe(e,t){return uM((()=>{let n=e.shape[0];return{boxPredictionEncoding:nO(oye(e,t.box_encoding_predictor),[n,-1,1,4]),classPrediction:nO(oye(e,t.class_predictor),[n,-1,3])}}))}var obe=class{constructor(){let{minConfidence:e,maxResults:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,"number"!=typeof this._minConfidence||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if("number"!=typeof this._maxResults)throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},lbe=class extends rye{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return uM((()=>{let n=wF(e.toBatchTensor(512,!1),"float32"),r=rbe(QP(NF(n,127.5),1),t.mobilenetv1),{boxPredictions:a,classPredictions:s}=function(e,t,n){return uM((()=>{let r=tbe(e,n.conv_0,[1,1]),a=tbe(r,n.conv_1,[2,2]),s=tbe(a,n.conv_2,[1,1]),i=tbe(s,n.conv_3,[2,2]),o=tbe(i,n.conv_4,[1,1]),l=tbe(o,n.conv_5,[2,2]),u=tbe(l,n.conv_6,[1,1]),c=tbe(u,n.conv_7,[2,2]),d=ibe(t,n.box_predictor_0),h=ibe(e,n.box_predictor_1),p=ibe(a,n.box_predictor_2),f=ibe(i,n.box_predictor_3),m=ibe(l,n.box_predictor_4),g=ibe(c,n.box_predictor_5);return{boxPredictions:sO([d.boxPredictionEncoding,h.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),classPredictions:sO([d.classPrediction,h.classPrediction,p.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1)}}))}(r.out,r.conv11,t.prediction_layer);return function(e,t,n){return uM((()=>{let r=e.shape[0],a=sbe(nO(IP(n.extra_dim,[r,1,1]),[-1,4]),nO(e,[-1,4]));a=nO(a,[r,a.shape[0]/r,4]);let s=oO(lO(t,[0,0,1],[-1,-1,-1])),i=lO(s,[0,0,0],[-1,-1,1]);return i=nO(i,[r,i.shape[1]]),{boxes:rB(a),scores:rB(i)}}))}(a,s,t.output_layer)}))}async forward(e){return this.forwardInput(await Qge(e))}async locateFaces(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{maxResults:n,minConfidence:r}=new obe(t),a=await Qge(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let y=1;y<s.length;y++)s[y].dispose(),i[y].dispose();let u=Array.from(l.dataSync()),c=function(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map(((e,t)=>({score:e,boxIndex:t}))).filter((e=>e.score>a)).sort(((e,t)=>t.score-e.score)),l=e=>e<=r?1:0,u=[];return o.forEach((t=>{if(u.length>=i)return;let n=t.score;for(let r=u.length-1;r>=0;--r){let n=abe(e,t.boxIndex,u[r]);if(0!==n&&(t.score*=l(n),t.score<=a))break}n===t.score&&u.push(t.boxIndex)})),u}(o,u,n,.5,r),d=a.getReshapedInputDimensions(0),h=a.inputSize,p=h/d.width,f=h/d.height,m=o.arraySync(),g=c.map((e=>{let[t,n]=[Math.max(0,m[e][0]),Math.min(1,m[e][2])].map((e=>e*f)),[r,s]=[Math.max(0,m[e][1]),Math.min(1,m[e][3])].map((e=>e*p));return new gge(u[e],new wge(r,t,s-r,n-t),{height:a.getInputHeight(0),width:a.getInputWidth(0)})}));return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return ebe(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=mye(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=Zye(n,t),i=a(),o=s(),l={extra_dim:jz(n(20472),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}(e)}};var ube=[new hge(.738768,.874946),new hge(2.42204,2.65704),new hge(4.30971,7.04493),new hge(10.246,4.59428),new hge(12.6868,11.8741)],cbe=[new hge(1.603231,2.094468),new hge(6.041143,7.080126),new hge(2.882459,3.518061),new hge(4.266906,5.178857),new hge(9.041765,10.66308)],dbe=[117.001,114.697,97.404],hbe=e=>"number"==typeof e;function pbe(e){return uM((()=>{let t=TF(e,fP(.10000000149011612));return IF(dz(QP(e,t)),t)}))}function fbe(e,t){return uM((()=>{let n=CL(e,[[0,0],[1,1],[1,1],[0,0]]);return n=EO(n,t.conv.filters,[1,1],"valid"),n=QP(n,t.bn.sub),n=TF(n,t.bn.truediv),n=IF(n,t.conv.bias),pbe(n)}))}function mbe(e,t){return uM((()=>{let n=CL(e,[[0,0],[1,1],[1,1],[0,0]]);return n=wz(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=IF(n,t.bias),pbe(n)}))}function gbe(e,t){let n=uye(e,t);let r=hye(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:function(r,a,s){let i=n(r,a,3,`${s}/conv`),o=function(n,r){let a=Vz(e(n)),s=Vz(e(n));return t.push({paramPath:`${r}/sub`},{paramPath:`${r}/truediv`}),{sub:a,truediv:s}}(a,`${s}/bn`);return{conv:i,bn:o}},extractSeparableConvParams:r}}function ybe(e,t){let n=fye(e,t);function r(e){return{filters:n(`${e}/filters`,4),bias:n(`${e}/bias`,1)}}return{extractConvParams:r,extractConvWithBatchNormParams:function(e){let t=r(`${e}/conv`),a=function(e){return{sub:n(`${e}/sub`,1),truediv:n(`${e}/truediv`,1)}}(`${e}/bn`);return{conv:t,bn:a}},extractSeparableConvParams:pye(n)}}var bbe=class{constructor(){let{inputSize:e,scoreThreshold:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,"number"!=typeof this._inputSize||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if("number"!=typeof this._scoreThreshold||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},vbe=class e extends rye{constructor(e){super("TinyYolov2"),function(e){if(!e)throw new Error(`invalid config: ${e}`);if("boolean"!=typeof e.withSeparableConvs)throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!hbe(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every((e=>"string"==typeof e)))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map((e=>e||{})).every((e=>hbe(e.x)&&hbe(e.y))))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||3!==e.meanRgb.length||!e.meanRgb.every(hbe)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=fbe(e,t.conv0);return n=oL(n,[2,2],[2,2],"same"),n=fbe(n,t.conv1),n=oL(n,[2,2],[2,2],"same"),n=fbe(n,t.conv2),n=oL(n,[2,2],[2,2],"same"),n=fbe(n,t.conv3),n=oL(n,[2,2],[2,2],"same"),n=fbe(n,t.conv4),n=oL(n,[2,2],[2,2],"same"),n=fbe(n,t.conv5),n=oL(n,[2,2],[1,1],"same"),n=fbe(n,t.conv6),n=fbe(n,t.conv7),oye(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?pbe(oye(e,t.conv0,"valid",!1)):mbe(e,t.conv0);return n=oL(n,[2,2],[2,2],"same"),n=mbe(n,t.conv1),n=oL(n,[2,2],[2,2],"same"),n=mbe(n,t.conv2),n=oL(n,[2,2],[2,2],"same"),n=mbe(n,t.conv3),n=oL(n,[2,2],[2,2],"same"),n=mbe(n,t.conv4),n=oL(n,[2,2],[2,2],"same"),n=mbe(n,t.conv5),n=oL(n,[2,2],[1,1],"same"),n=t.conv6?mbe(n,t.conv6):n,n=t.conv7?mbe(n,t.conv7):n,oye(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return uM((()=>{let r=wF(e.toBatchTensor(t,!1),"float32");return r=this.config.meanRgb?bge(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)}))}async forward(e,t){return this.forwardInput(await Qge(e),t)}async detect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{inputSize:n,scoreThreshold:r}=new bbe(t),a=await Qge(e),s=await this.forwardInput(a,n),i=uM((()=>rB(s)[0].expandDims())),o={width:a.getInputWidth(0),height:a.getInputHeight(0)},l=await this.extractBoxes(i,a.getReshapedInputDimensions(0),r);s.dispose(),i.dispose();let u=l.map((e=>e.box)),c=l.map((e=>e.score)),d=l.map((e=>e.classScore)),h=l.map((e=>this.config.classes[e.label]));return function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=t.map(((e,t)=>({score:e,boxIndex:t}))).sort(((e,t)=>e.score-t.score)).map((e=>e.boxIndex)),s=[];for(;a.length>0;){let t=a.pop();s.push(t);let i=a,o=[];for(let n=0;n<i.length;n++){let a=i[n],s=e[t],l=e[a];o.push(yge(s,l,r))}a=a.filter(((e,t)=>o[t]<=n))}return s}(u.map((e=>e.rescale(n))),c,this.config.iouThreshold,!0).map((e=>new mge(c[e],d[e],h[e],u[e],o)))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return function(e,t){let n,r=[],{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}=ybe(e,r);if(t.withSeparableConvs){let e=t.filterSizes&&t.filterSizes.length||9;n={conv0:t.isFirstLayerConv2d?a("conv0"):i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:e>7?i("conv6"):void 0,conv7:e>8?i("conv7"):void 0,conv8:a("conv8")}}else n={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:a("conv8")};return lye(e,r),{params:n,paramMappings:r}}(e,this.config)}extractParams(t){let n=this.config.filterSizes||e.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(7!==r&&8!==r&&9!==r)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return function(e,t,n,r){let a,{extractWeights:s,getRemainingWeights:i}=mye(e),o=[],{extractConvParams:l,extractConvWithBatchNormParams:u,extractSeparableConvParams:c}=gbe(s,o);if(t.withSeparableConvs){let[e,s,i,o,u,d,h,p,f]=r;a={conv0:t.isFirstLayerConv2d?l(e,s,3,"conv0"):c(e,s,"conv0"),conv1:c(s,i,"conv1"),conv2:c(i,o,"conv2"),conv3:c(o,u,"conv3"),conv4:c(u,d,"conv4"),conv5:c(d,h,"conv5"),conv6:p?c(h,p,"conv6"):void 0,conv7:f?c(p,f,"conv7"):void 0,conv8:l(f||p||h,5*n,1,"conv8")}}else{let[e,t,s,i,o,c,d,h,p]=r;a={conv0:u(e,t,"conv0"),conv1:u(t,s,"conv1"),conv2:u(s,i,"conv2"),conv3:u(i,o,"conv3"),conv4:u(o,c,"conv4"),conv5:u(c,d,"conv5"),conv6:u(d,h,"conv6"),conv7:u(h,p,"conv7"),conv8:l(p,5*n,1,"conv8")}}if(0!==i().length)throw new Error(`weights remaing after extract: ${i().length}`);return{params:a,paramMappings:o}}(t,this.config,this.boxEncodingSize,n)}async extractBoxes(e,t,n){let{width:r,height:a}=t,s=Math.max(r,a),i=s/r,o=s/a,l=e.shape[1],u=this.config.anchors.length,[c,d,h]=uM((()=>{let t=e.reshape([l,l,u,this.boxEncodingSize]);return[t.slice([0,0,0,0],[l,l,u,4]),t.slice([0,0,0,4],[l,l,u,1]),this.withClassScores?_z(t.slice([0,0,0,5],[l,l,u,this.config.classes.length]),3):fP(0)]})),p=[],f=await d.array(),m=await c.array();for(let g=0;g<l;g++)for(let e=0;e<l;e++)for(let t=0;t<u;t++){let r=vge(f[g][e][t][0]);if(!n||r>n){let n=(e+vge(m[g][e][t][0]))/l*i,a=(g+vge(m[g][e][t][1]))/l*o,s=Math.exp(m[g][e][t][2])*this.config.anchors[t].x/l*i,u=Math.exp(m[g][e][t][3])*this.config.anchors[t].y/l*o,c=n-s/2,d=a-u/2,f={row:g,col:e,anchor:t},{classScore:y,label:b}=this.withClassScores?await this.extractPredictedClass(h,f):{classScore:1,label:0};p.push({box:new fge(c,d,c+s,d+u),score:r,classScore:r*y,label:b,...f})}}return c.dispose(),d.dispose(),h.dispose(),p}async extractPredictedClass(e,t){let{row:n,col:r,anchor:a}=t,s=await e.array();return Array(this.config.classes.length).fill(0).map(((e,t)=>s[n][r][a][t])).map(((e,t)=>({classScore:e,label:t}))).reduce(((e,t)=>e.classScore>t.classScore?e:t))}};vbe.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var xbe=vbe,wbe=class extends xbe{constructor(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];super({withSeparableConvs:e,iouThreshold:.4,classes:["face"],...e?{anchors:cbe,meanRgb:dbe}:{anchors:ube,withClassScores:!0}})}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new gge(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return this.withSeparableConvs?"tiny_yolov2_separable_conv_model":"tiny_yolov2_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}};var kbe=class extends bbe{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Sbe=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Ibe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:e=>{let{alignedRect:t}=e;return t},s=e.map((e=>Tye(e)?a(e):e.detection)),i=r||(t instanceof dD?await Zge(t,s):await Jge(t,s)),o=await n(i);return i.forEach((e=>e instanceof dD&&e.dispose())),o}async function Cbe(e,t,n,r,a){return Ibe([e],t,(async e=>n(e[0])),r,a)}var Nbe=[new hge(1.603231,2.094468),new hge(6.041143,7.080126),new hge(2.882459,3.518061),new hge(4.266906,5.178857),new hge(9.041765,10.66308)],Tbe=[117.001,114.697,97.404],Ebe=class extends xbe{constructor(){super({withSeparableConvs:!0,iouThreshold:.4,classes:["face"],anchors:Nbe,meanRgb:Tbe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]})}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new gge(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Abe={ssdMobilenetv1:new lbe,tinyFaceDetector:new Ebe,tinyYolov2:new wbe,faceLandmark68Net:new Bye,faceLandmark68TinyNet:new class extends zye{constructor(){super("FaceLandmark68TinyNet",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Wye)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}},faceRecognitionNet:new Xye,faceExpressionNet:new class extends kye{constructor(){super("FaceExpressionNet",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new vye)}forwardInput(e){return uM((()=>_z(this.runNet(e))))}async forward(e){return this.forwardInput(await Qge(e))}async predictExpressions(e){let t=await Qge(e),n=await this.forwardInput(t),r=await Promise.all(rB(n).map((async e=>{let t=e.dataSync();return e.dispose(),t})));n.dispose();let a=r.map((e=>new Iye(e)));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}},ageGenderNet:new class extends rye{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oye(2);super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return uM((()=>{let n=e instanceof Yge?this.faceFeatureExtractor.forwardInput(e):e,r=rO(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1);return{age:xye(r,t.fc.age).as1D(),gender:xye(r,t.fc.gender)}}))}forwardInput(e){return uM((()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:_z(n)}}))}async forward(e){return this.forwardInput(await Qge(e))}async predictAgeAndGender(e){let t=await Qge(e),n=await this.forwardInput(t),r=rB(n.age),a=rB(n.gender),s=r.map(((e,t)=>({ageTensor:e,genderTensor:a[t]}))),i=await Promise.all(s.map((async e=>{let{ageTensor:t,genderTensor:n}=e,r=t.dataSync()[0],a=n.dataSync()[0],s=a>.5,i=s?"male":"female",o=s?a:1-a;return t.dispose(),n.dispose(),{age:r,gender:i,genderProbability:o}})));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=mye(e),a=cye(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=wye(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=fye(e,t);function r(e){return{weights:n(`${e}/weights`,2),bias:n(`${e}/bias`,1)}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return lye(e,t),{params:a,paramMappings:t}}(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}}},_be=class extends Sbe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},$be=class extends _be{async run(){let e=await this.parentTask,t=await Ibe(e,this.input,(async e=>Promise.all(e.map((e=>Abe.faceExpressionNet.predictExpressions(e))))),this.extractedFaces);return e.map(((e,n)=>Cye(e,t[n])))}withAgeAndGender(){return new Obe(this,this.input)}},Rbe=class extends _be{async run(){let e=await this.parentTask;if(e)return Cye(e,await Cbe(e,this.input,(e=>Abe.faceExpressionNet.predictExpressions(e)),this.extractedFaces))}withAgeAndGender(){return new Pbe(this,this.input)}},Dbe=class extends $be{withAgeAndGender(){return new Lbe(this,this.input)}withFaceDescriptors(){return new Wbe(this,this.input)}},Mbe=class extends Rbe{withAgeAndGender(){return new zbe(this,this.input)}withFaceDescriptor(){return new Vbe(this,this.input)}},Fbe=class extends Sbe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Obe=class extends Fbe{async run(){let e=await this.parentTask,t=await Ibe(e,this.input,(async e=>Promise.all(e.map((e=>Abe.ageGenderNet.predictAgeAndGender(e))))),this.extractedFaces);return e.map(((e,n)=>{let{age:r,gender:a,genderProbability:s}=t[n];return Qye(Jye(e,a,s),r)}))}withFaceExpressions(){return new $be(this,this.input)}},Pbe=class extends Fbe{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await Cbe(e,this.input,(e=>Abe.ageGenderNet.predictAgeAndGender(e)),this.extractedFaces);return Qye(Jye(e,n,r),t)}withFaceExpressions(){return new Rbe(this,this.input)}},Lbe=class extends Obe{withFaceExpressions(){return new Dbe(this,this.input)}withFaceDescriptors(){return new Wbe(this,this.input)}},zbe=class extends Pbe{withFaceExpressions(){return new Mbe(this,this.input)}withFaceDescriptor(){return new Vbe(this,this.input)}},Bbe=class extends Sbe{constructor(e,t){super(),this.parentTask=e,this.input=t}},Wbe=class extends Bbe{async run(){let e=await this.parentTask;return(await Ibe(e,this.input,(e=>Promise.all(e.map((e=>Abe.faceRecognitionNet.computeFaceDescriptor(e))))),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0})))).map(((t,n)=>Yye(e[n],t)))}withFaceExpressions(){return new Dbe(this,this.input)}withAgeAndGender(){return new Lbe(this,this.input)}},Vbe=class extends Bbe{async run(){let e=await this.parentTask;if(e)return Yye(e,await Cbe(e,this.input,(e=>Abe.faceRecognitionNet.computeFaceDescriptor(e)),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0}))))}withFaceExpressions(){return new Mbe(this,this.input)}withAgeAndGender(){return new zbe(this,this.input)}},Ube=class extends Sbe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Abe.faceLandmark68TinyNet:Abe.faceLandmark68Net}},jbe=class extends Ube{async run(){let e=await this.parentTask,t=e.map((e=>e.detection)),n=this.input instanceof dD?await Zge(this.input,t):await Jge(this.input,t),r=await Promise.all(n.map((e=>this.landmarkNet.detectLandmarks(e))));return n.forEach((e=>e instanceof dD&&e.dispose())),e.filter(((e,t)=>r[t])).map(((e,t)=>Eye(e,r[t])))}withFaceExpressions(){return new Dbe(this,this.input)}withAgeAndGender(){return new Lbe(this,this.input)}withFaceDescriptors(){return new Wbe(this,this.input)}},Gbe=class extends Ube{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof dD?await Zge(this.input,[t]):await Jge(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach((e=>e instanceof dD&&e.dispose())),Eye(e,r)}withFaceExpressions(){return new Mbe(this,this.input)}withAgeAndGender(){return new zbe(this,this.input)}withFaceDescriptor(){return new Vbe(this,this.input)}},Hbe=class extends Sbe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new obe;super(),this.input=e,this.options=t}},qbe=class extends Hbe{async run(){let e,{input:t,options:n}=this;if(n instanceof kbe)e=Abe.tinyFaceDetector.locateFaces(t,n);else if(n instanceof obe)e=Abe.ssdMobilenetv1.locateFaces(t,n);else{if(!(n instanceof bbe))throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");e=Abe.tinyYolov2.locateFaces(t,n)}return e}runAndExtendWithFaceDetections(){return new Promise(((e,t)=>{this.run().then((t=>e(t.map((e=>Tge({},e)))))).catch((e=>t(e)))}))}withFaceLandmarks(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return new jbe(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new $be(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new Obe(this.runAndExtendWithFaceDetections(),this.input)}},Kbe=class extends Hbe{async run(){let e=await new qbe(this.input,this.options),t=e[0];return e.forEach((e=>{e.score>t.score&&(t=e)})),t}runAndExtendWithFaceDetection(){return new Promise((async e=>{let t=await this.run();e(t?Tge({},t):void 0)}))}withFaceLandmarks(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return new Gbe(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new Rbe(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new Pbe(this.runAndExtendWithFaceDetection(),this.input)}};function Xbe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new obe;return new qbe(e,t)}var Ybe=class e{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.6;this._distanceThreshold=t;let n=Array.isArray(e)?e:[e];if(!n.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let r=1,a=()=>"person "+r++;this._labeledDescriptors=n.map((e=>{if(e instanceof Cge)return e;if(e instanceof Float32Array)return new Cge(a(),[e]);if(e.descriptor&&e.descriptor instanceof Float32Array)return new Cge(a(),[e.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")}))}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(e,t){return t.map((t=>function(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),r=Array.from(t);return Math.sqrt(n.map(((e,t)=>e-r[t])).reduce(((e,t)=>e+t*t),0))}(t,e))).reduce(((e,t)=>e+t),0)/(t.length||1)}matchDescriptor(e){return this.labeledDescriptors.map((t=>{let{descriptors:n,label:r}=t;return new Ige(r,this.computeMeanDistance(e,n))})).reduce(((e,t)=>e.distance<t.distance?e:t))}findBestMatch(e){let t=this.matchDescriptor(e);return t.distance<this._distanceThreshold?t:new Ige("unknown",t.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map((e=>e.toJSON()))}}static fromJSON(t){let n=t.labeledDescriptors.map((e=>Cge.fromJSON(e)));return new e(n,t.distanceThreshold)}};function Qbe(e,t){let{width:n,height:r}=new Qme(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map((e=>Qbe(e,{width:n,height:r})));if(Tye(e)){let t=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(t.box.width,t.box.height);return Eye(Tge(e,t),a)}return Nge(e)?Tge(e,e.detection.forSize(n,r)):e instanceof kge||e instanceof gge?e.forSize(n,r):e}var Jbe=n(5879);function Zbe(e){return(0,yr.Ay)("MuiCircularProgress",e)}(0,gr.A)("MuiCircularProgress",["root","determinate","indeterminate","colorPrimary","colorSecondary","svg","circle","circleDeterminate","circleIndeterminate","circleDisableShrink"]);const eve=44,tve=dr`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`,nve=dr`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`,rve="string"!==typeof tve?cr`
        animation: ${tve} 1.4s linear infinite;
      `:null,ave="string"!==typeof nve?cr`
        animation: ${nve} 1.4s ease-in-out infinite;
      `:null,sve=(0,Gn.Ay)("span",{name:"MuiCircularProgress",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],t[`color${(0,jn.A)(n.color)}`]]}})((0,er.A)((e=>{let{theme:t}=e;return{display:"inline-block",variants:[{props:{variant:"determinate"},style:{transition:t.transitions.create("transform")}},{props:{variant:"indeterminate"},style:rve||{animation:`${tve} 1.4s linear infinite`}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars||t).palette[n].main}}}))]}}))),ive=(0,Gn.Ay)("svg",{name:"MuiCircularProgress",slot:"Svg",overridesResolver:(e,t)=>t.svg})({display:"block"}),ove=(0,Gn.Ay)("circle",{name:"MuiCircularProgress",slot:"Circle",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.circle,t[`circle${(0,jn.A)(n.variant)}`],n.disableShrink&&t.circleDisableShrink]}})((0,er.A)((e=>{let{theme:t}=e;return{stroke:"currentColor",variants:[{props:{variant:"determinate"},style:{transition:t.transitions.create("stroke-dashoffset")}},{props:{variant:"indeterminate"},style:{strokeDasharray:"80px, 200px",strokeDashoffset:0}},{props:e=>{let{ownerState:t}=e;return"indeterminate"===t.variant&&!t.disableShrink},style:ave||{animation:`${nve} 1.4s ease-in-out infinite`}}]}}))),lve=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiCircularProgress"}),{className:r,color:a="primary",disableShrink:s=!1,size:i=40,style:o,thickness:l=3.6,value:u=0,variant:c="indeterminate",...d}=n,h={...n,color:a,disableShrink:s,size:i,thickness:l,value:u,variant:c},p=(e=>{const{classes:t,variant:n,color:r,disableShrink:a}=e,s={root:["root",n,`color${(0,jn.A)(r)}`],svg:["svg"],circle:["circle",`circle${(0,jn.A)(n)}`,a&&"circleDisableShrink"]};return(0,Vn.A)(s,Zbe,t)})(h),f={},m={},g={};if("determinate"===c){const e=2*Math.PI*((eve-l)/2);f.strokeDasharray=e.toFixed(3),g["aria-valuenow"]=Math.round(u),f.strokeDashoffset=`${((100-u)/100*e).toFixed(3)}px`,m.transform="rotate(-90deg)"}return(0,hr.jsx)(sve,{className:(0,Bn.A)(p.root,r),style:{width:i,height:i,...m,...o},ownerState:h,ref:t,role:"progressbar",...g,...d,children:(0,hr.jsx)(ive,{className:p.svg,ownerState:h,viewBox:"22 22 44 44",children:(0,hr.jsx)(ove,{className:p.circle,style:f,ownerState:h,cx:eve,cy:eve,r:(eve-l)/2,fill:"none",strokeWidth:l})})})})),uve=lve;function cve(e){return(0,yr.Ay)("MuiLoadingButton",e)}const dve=(0,gr.A)("MuiLoadingButton",["root","label","loading","loadingIndicator","loadingIndicatorCenter","loadingIndicatorStart","loadingIndicatorEnd","endIconLoadingEnd","startIconLoadingStart"]),hve=(0,Gn.Ay)(hl,{shouldForwardProp:e=>(e=>"ownerState"!==e&&"theme"!==e&&"sx"!==e&&"as"!==e&&"classes"!==e)(e)||"classes"===e,name:"MuiLoadingButton",slot:"Root",overridesResolver:(e,t)=>[t.root,t.startIconLoadingStart&&{[`& .${dve.startIconLoadingStart}`]:t.startIconLoadingStart},t.endIconLoadingEnd&&{[`& .${dve.endIconLoadingEnd}`]:t.endIconLoadingEnd}]})((0,er.A)((e=>{let{theme:t}=e;return{display:"inline-flex",[`& .${dve.startIconLoadingStart}, & .${dve.endIconLoadingEnd}`]:{transition:t.transitions.create(["opacity"],{duration:t.transitions.duration.short}),opacity:0},variants:[{props:{loadingPosition:"center"},style:{transition:t.transitions.create(["background-color","box-shadow","border-color"],{duration:t.transitions.duration.short}),[`&.${dve.loading}`]:{color:"transparent"}}},{props:e=>{let{ownerState:t}=e;return"start"===t.loadingPosition&&t.fullWidth},style:{[`& .${dve.startIconLoadingStart}, & .${dve.endIconLoadingEnd}`]:{transition:t.transitions.create(["opacity"],{duration:t.transitions.duration.short}),opacity:0,marginRight:-8}}},{props:e=>{let{ownerState:t}=e;return"end"===t.loadingPosition&&t.fullWidth},style:{[`& .${dve.startIconLoadingStart}, & .${dve.endIconLoadingEnd}`]:{transition:t.transitions.create(["opacity"],{duration:t.transitions.duration.short}),opacity:0,marginLeft:-8}}}]}}))),pve=(0,Gn.Ay)("span",{name:"MuiLoadingButton",slot:"LoadingIndicator",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.loadingIndicator,t[`loadingIndicator${(0,jn.A)(n.loadingPosition)}`]]}})((0,er.A)((e=>{let{theme:t}=e;return{position:"absolute",visibility:"visible",display:"flex",variants:[{props:{loadingPosition:"start",size:"small"},style:{left:10}},{props:e=>{let{loadingPosition:t,ownerState:n}=e;return"start"===t&&"small"!==n.size},style:{left:14}},{props:{variant:"text",loadingPosition:"start"},style:{left:6}},{props:{loadingPosition:"center"},style:{left:"50%",transform:"translate(-50%)",color:(t.vars||t).palette.action.disabled}},{props:{loadingPosition:"end",size:"small"},style:{right:10}},{props:e=>{let{loadingPosition:t,ownerState:n}=e;return"end"===t&&"small"!==n.size},style:{right:14}},{props:{variant:"text",loadingPosition:"end"},style:{right:6}},{props:e=>{let{ownerState:t}=e;return"start"===t.loadingPosition&&t.fullWidth},style:{position:"relative",left:-10}},{props:e=>{let{ownerState:t}=e;return"end"===t.loadingPosition&&t.fullWidth},style:{position:"relative",right:-10}}]}}))),fve=(0,Gn.Ay)("span",{name:"MuiLoadingButton",slot:"Label",overridesResolver:(e,t)=>[t.label]})({display:"inherit",alignItems:"inherit",justifyContent:"inherit"}),mve=T.forwardRef((function(e,t){const n=T.useContext(sl),r=(0,xo.A)(n,e),a=(0,tr.b)({props:r,name:"MuiLoadingButton"}),{children:s,disabled:i=!1,id:o,loading:l=!1,loadingIndicator:u,loadingPosition:c="center",variant:d="text",...h}=a,p=(0,Jbe.A)(o),f=u??(0,hr.jsx)(uve,{"aria-labelledby":p,color:"inherit",size:16}),m={...a,disabled:i,loading:l,loadingIndicator:f,loadingPosition:c,variant:d},g=(e=>{const{loading:t,loadingPosition:n,classes:r}=e,a=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;const r={};for(const a in e){const s=e[a];let i="";for(let e=0;e<s.length;e+=1){const r=s[e];r&&(i+=t(r)+" ",n&&n[r]&&(i+=n[r]+" "))}r[a]=i}return r}({root:["root",t&&"loading"],label:["label"],startIcon:[t&&`startIconLoading${(0,jn.A)(n)}`],endIcon:[t&&`endIconLoading${(0,jn.A)(n)}`],loadingIndicator:["loadingIndicator",t&&`loadingIndicator${(0,jn.A)(n)}`]},cve,r);return{...r,...a}})(m),y=l?(0,hr.jsx)(pve,{className:g.loadingIndicator,ownerState:m,children:f}):null;return(0,hr.jsxs)(hve,{disabled:i||l,id:p,ref:t,...h,variant:d,classes:g,ownerState:m,children:["end"===m.loadingPosition?(0,hr.jsx)(fve,{className:g.label,children:s}):y,"end"===m.loadingPosition?y:(0,hr.jsx)(fve,{className:g.label,children:s})]})})),gve=mve;const yve=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{autoHideDuration:t=null,disableWindowBlurListener:n=!1,onClose:r,open:a,resumeHideDuration:s}=e,i=Ls();T.useEffect((()=>{if(a)return document.addEventListener("keydown",e),()=>{document.removeEventListener("keydown",e)};function e(e){e.defaultPrevented||"Escape"===e.key&&r?.(e,"escapeKeyDown")}}),[a,r]);const o=(0,xi.A)(((e,t)=>{r?.(e,t)})),l=(0,xi.A)((e=>{r&&null!=e&&i.start(e,(()=>{o(null,"timeout")}))}));T.useEffect((()=>(a&&l(t),i.clear)),[a,t,l,i]);const u=i.clear,c=T.useCallback((()=>{null!=t&&l(null!=s?s:.5*t)}),[t,s,l]),d=e=>t=>{const n=e.onFocus;n?.(t),u()},h=e=>t=>{const n=e.onMouseEnter;n?.(t),u()},p=e=>t=>{const n=e.onMouseLeave;n?.(t),c()};return T.useEffect((()=>{if(!n&&a)return window.addEventListener("focus",c),window.addEventListener("blur",u),()=>{window.removeEventListener("focus",c),window.removeEventListener("blur",u)}}),[n,a,c,u]),{getRootProps:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={...fs(e),...fs(t)};return{role:"presentation",...t,...n,onBlur:(r=n,e=>{const t=r.onBlur;t?.(e),c()}),onFocus:d(n),onMouseEnter:h(n),onMouseLeave:p(n)};var r},onClickAway:e=>{r?.(e,"clickaway")}}};function bve(e){return e.substring(2).toLowerCase()}function vve(e){const{children:t,disableReactTree:n=!1,mouseEvent:r="onClick",onClickAway:a,touchEvent:s="onTouchEnd"}=e,i=T.useRef(!1),o=T.useRef(null),l=T.useRef(!1),u=T.useRef(!1);T.useEffect((()=>(setTimeout((()=>{l.current=!0}),0),()=>{l.current=!1})),[]);const c=(0,Kr.A)(ls(t),o),d=(0,xi.A)((e=>{const t=u.current;u.current=!1;const r=(0,ii.A)(o.current);if(!l.current||!o.current||"clientX"in e&&function(e,t){return t.documentElement.clientWidth<e.clientX||t.documentElement.clientHeight<e.clientY}(e,r))return;if(i.current)return void(i.current=!1);let s;s=e.composedPath?e.composedPath().indexOf(o.current)>-1:!r.documentElement.contains(e.target)||o.current.contains(e.target),s||!n&&t||a(e)})),h=e=>n=>{u.current=!0;const r=t.props[e];r&&r(n)},p={ref:c};return!1!==s&&(p[s]=h(s)),T.useEffect((()=>{if(!1!==s){const e=bve(s),t=(0,ii.A)(o.current),n=()=>{i.current=!0};return t.addEventListener(e,d),t.addEventListener("touchmove",n),()=>{t.removeEventListener(e,d),t.removeEventListener("touchmove",n)}}}),[d,s]),!1!==r&&(p[r]=h(r)),T.useEffect((()=>{if(!1!==r){const e=bve(r),t=(0,ii.A)(o.current);return t.addEventListener(e,d),()=>{t.removeEventListener(e,d)}}}),[d,r]),(0,hr.jsx)(T.Fragment,{children:T.cloneElement(t,p)})}function xve(e){return(0,yr.Ay)("MuiSnackbarContent",e)}(0,gr.A)("MuiSnackbarContent",["root","message","action"]);const wve=(0,Gn.Ay)(Gr,{name:"MuiSnackbarContent",slot:"Root",overridesResolver:(e,t)=>t.root})((0,er.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?.8:.98,r=(0,Wn.tL)(t.palette.background.default,n);return{...t.typography.body2,color:t.vars?t.vars.palette.SnackbarContent.color:t.palette.getContrastText(r),backgroundColor:t.vars?t.vars.palette.SnackbarContent.bg:r,display:"flex",alignItems:"center",flexWrap:"wrap",padding:"6px 16px",borderRadius:(t.vars||t).shape.borderRadius,flexGrow:1,[t.breakpoints.up("sm")]:{flexGrow:"initial",minWidth:288}}}))),kve=(0,Gn.Ay)("div",{name:"MuiSnackbarContent",slot:"Message",overridesResolver:(e,t)=>t.message})({padding:"8px 0"}),Sve=(0,Gn.Ay)("div",{name:"MuiSnackbarContent",slot:"Action",overridesResolver:(e,t)=>t.action})({display:"flex",alignItems:"center",marginLeft:"auto",paddingLeft:16,marginRight:-8}),Ive=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiSnackbarContent"}),{action:r,className:a,message:s,role:i="alert",...o}=n,l=n,u=(e=>{const{classes:t}=e;return(0,Vn.A)({root:["root"],action:["action"],message:["message"]},xve,t)})(l);return(0,hr.jsxs)(wve,{role:i,square:!0,elevation:6,className:(0,Bn.A)(u.root,a),ownerState:l,ref:t,...o,children:[(0,hr.jsx)(kve,{className:u.message,ownerState:l,children:s}),r?(0,hr.jsx)(Sve,{className:u.action,ownerState:l,children:r}):null]})}));function Cve(e){return(0,yr.Ay)("MuiSnackbar",e)}(0,gr.A)("MuiSnackbar",["root","anchorOriginTopCenter","anchorOriginBottomCenter","anchorOriginTopRight","anchorOriginBottomRight","anchorOriginTopLeft","anchorOriginBottomLeft"]);const Nve=(0,Gn.Ay)("div",{name:"MuiSnackbar",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`anchorOrigin${(0,jn.A)(n.anchorOrigin.vertical)}${(0,jn.A)(n.anchorOrigin.horizontal)}`]]}})((0,er.A)((e=>{let{theme:t}=e;return{zIndex:(t.vars||t).zIndex.snackbar,position:"fixed",display:"flex",left:8,right:8,justifyContent:"center",alignItems:"center",variants:[{props:e=>{let{ownerState:t}=e;return"top"===t.anchorOrigin.vertical},style:{top:8,[t.breakpoints.up("sm")]:{top:24}}},{props:e=>{let{ownerState:t}=e;return"top"!==t.anchorOrigin.vertical},style:{bottom:8,[t.breakpoints.up("sm")]:{bottom:24}}},{props:e=>{let{ownerState:t}=e;return"left"===t.anchorOrigin.horizontal},style:{justifyContent:"flex-start",[t.breakpoints.up("sm")]:{left:24,right:"auto"}}},{props:e=>{let{ownerState:t}=e;return"right"===t.anchorOrigin.horizontal},style:{justifyContent:"flex-end",[t.breakpoints.up("sm")]:{right:24,left:"auto"}}},{props:e=>{let{ownerState:t}=e;return"center"===t.anchorOrigin.horizontal},style:{[t.breakpoints.up("sm")]:{left:"50%",right:"auto",transform:"translateX(-50%)"}}}]}}))),Tve=T.forwardRef((function(e,t){const n=(0,tr.b)({props:e,name:"MuiSnackbar"}),r=Zn(),a={enter:r.transitions.duration.enteringScreen,exit:r.transitions.duration.leavingScreen},{action:s,anchorOrigin:{vertical:i,horizontal:o}={vertical:"bottom",horizontal:"left"},autoHideDuration:l=null,children:u,className:c,ClickAwayListenerProps:d,ContentProps:h,disableWindowBlurListener:p=!1,message:f,onBlur:m,onClose:g,onFocus:y,onMouseEnter:b,onMouseLeave:v,open:x,resumeHideDuration:w,TransitionComponent:k=si,transitionDuration:S=a,TransitionProps:{onEnter:I,onExited:C,...N}={},...E}=n,A={...n,anchorOrigin:{vertical:i,horizontal:o},autoHideDuration:l,disableWindowBlurListener:p,TransitionComponent:k,transitionDuration:S},_=(e=>{const{classes:t,anchorOrigin:n}=e,r={root:["root",`anchorOrigin${(0,jn.A)(n.vertical)}${(0,jn.A)(n.horizontal)}`]};return(0,Vn.A)(r,Cve,t)})(A),{getRootProps:$,onClickAway:R}=yve({...A}),[D,M]=T.useState(!0),F=bs({elementType:Nve,getSlotProps:$,externalForwardedProps:E,ownerState:A,additionalProps:{ref:t},className:[_.root,c]});return!x&&D?null:(0,hr.jsx)(vve,{onClickAway:R,...d,children:(0,hr.jsx)(Nve,{...F,children:(0,hr.jsx)(k,{appear:!0,in:x,timeout:S,direction:"top"===i?"down":"up",onEnter:(e,t)=>{M(!1),I&&I(e,t)},onExited:e=>{M(!0),C&&C(e)},...N,children:u||(0,hr.jsx)(Ive,{message:f,action:s,...h})})})})}));var Eve=n(6111),Ave=n.n(Eve);const _ve=[],$ve=e=>{let{firstName:t,lastName:n,email:r,dateOfBirth:a,onBack:s}=e;const i=(0,T.useRef)(null),[o,l]=(0,T.useState)(0),[u,c]=(0,T.useState)(!1),[d,h]=(0,T.useState)(!1),[p,f]=(0,T.useState)(!1),m=vn(),g=async()=>{c(!0);try{const e=((e,t,n,r)=>Ave().AES.encrypt(e||"",`${t||""} ${n||""}`+r).toString())(r,t,n,a),s=((e,t,n,r)=>e.map((e=>Ave().AES.encrypt(JSON.stringify(e),`${t||""} ${n||""}`+r).toString())))(_ve,t,n,a),i={name:`${t||""} ${n||""}`,email:e,DOB:a||"",...s.reduce(((e,t,n)=>(e[`descriptors_${n}`]=t||[],e)),{})},o=await(async e=>await dv(Ab(mv,"users"),e))(i);console.log("Document written with ID: ",o.id),m(`/loggedUser?userId=${o.id}`)}catch(mD){console.error("Error adding document: ",mD)}finally{c(!1)}};return 5===o&&(g(),l((e=>e+1))),(0,hr.jsxs)(Br,{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",padding:2,height:"100vh",bgcolor:"#f5f5f5",children:[(0,hr.jsxs)(Gr,{elevation:3,sx:{padding:4,borderRadius:4,maxWidth:900,width:"100%"},children:[(0,hr.jsx)(Ir,{variant:"h5",gutterBottom:!0,textAlign:"center",children:"Capture Your Photo"}),(0,hr.jsx)(hl,{variant:"contained",color:"secondary",onClick:s,sx:{marginBottom:2,position:"absolute",left:20,top:20},children:"Back"}),(0,hr.jsxs)(Br,{display:"flex",flexDirection:{xs:"column",md:"row"},justifyContent:"center",gap:5,alignItems:"center",children:[(0,hr.jsx)(cT(),{audio:!1,ref:i,screenshotFormat:"image/jpeg",style:{borderRadius:10,width:"100%",maxWidth:650,height:"auto"}}),o<5&&(0,hr.jsxs)(Br,{display:"flex",flexDirection:"column",alignItems:"center",children:[(0,hr.jsx)(Br,{children:(0,hr.jsx)(Br,{component:"img",alt:"Face Snapshot Guide",src:`/snapshotGuide/face_${o+1}.jpg`,sx:{width:{xs:"80%",md:250},height:"auto",borderRadius:2,objectFit:"contain",boxShadow:2}})}),(0,hr.jsx)(gve,{variant:"contained",color:"primary",onClick:async()=>{try{h(!0);const e=i.current.getScreenshot(),t=new Image;t.src=e,await t.decode();const n=await function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new obe;return new Kbe(e,t)}(t,new kbe).withFaceLandmarks().withFaceDescriptor();n?(_ve.push(Array.from(n.descriptor)),l((e=>e+1))):f(!0)}catch(e){f(!0)}finally{h(!1)}},disabled:o>4,sx:{marginTop:3,width:"100%"},loading:d,children:"Capture Photo"})]})]})]}),(0,hr.jsx)(Tve,{open:p,autoHideDuration:3e3,onClose:()=>f(!1),anchorOrigin:{vertical:"top",horizontal:"center"},children:(0,hr.jsx)(_l,{variant:"filled",severity:"error",sx:{width:"30vw"},children:"Please re-take the image"})})]})},Rve=()=>{const[e,t]=(0,T.useState)({firstName:"",lastName:"",email:"",dateOfBirth:null}),[n,r]=(0,T.useState)({firstName:"",lastName:"",email:"",dateOfBirth:""}),[a,s]=(0,T.useState)(null),[i,o]=(0,T.useState)(!1),l=vn(),u=(n,r)=>{t({...e,[n]:r})},c=(0,T.useMemo)((()=>{switch(a){case"minDate":case"maxDate":return"Date of Birth cannot be in the future or an invalid range";case"invalidDate":return"Invalid date format";default:return""}}),[a]);var d;return i?(0,hr.jsx)($ve,{firstName:e.firstName,lastName:e.lastName,email:e.email,dateOfBirth:null===(d=e.dateOfBirth)||void 0===d?void 0:d.toISOString(),onBack:()=>o(!1)}):(0,hr.jsx)(Br,{display:"flex",justifyContent:"center",alignItems:"center",minHeight:"100vh",sx:{backgroundColor:"#f5f5f5"},children:(0,hr.jsxs)(wv,{variant:"outlined",sx:{width:"400px",p:2},children:[(0,hr.jsxs)(Iv,{children:[(0,hr.jsx)(Ir,{variant:"h5",component:"h2",gutterBottom:!0,align:"center",children:"Registration Form"}),(0,hr.jsxs)(Br,{component:"form",onSubmit:t=>{t.preventDefault(),(()=>{let t={...n};t.firstName=e.firstName?"":"First Name is required",t.lastName=e.lastName?"":"Last Name is required",t.email=/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e.email)?"":"Email is not valid",t.dateOfBirth=e.dateOfBirth?c:"Date of Birth is required",e.dateOfBirth&&qN()().diff(qN()(e.dateOfBirth),"year")<13&&(t.dateOfBirth="You must be at least 13 years old");return r(t),console.log(n),Object.values(t).every((e=>""===e))})()&&(console.log(e),o(!0))},noValidate:!0,sx:{mt:2},children:[(0,hr.jsx)(Mo,{label:"First Name",variant:"outlined",fullWidth:!0,value:e.firstName,onChange:e=>u("firstName",e.target.value),error:!!n.firstName,helperText:n.firstName,margin:"normal"}),(0,hr.jsx)(Mo,{label:"Last Name",variant:"outlined",fullWidth:!0,value:e.lastName,onChange:e=>u("lastName",e.target.value),error:!!n.lastName,helperText:n.lastName,margin:"normal"}),(0,hr.jsx)(Mo,{label:"Email",variant:"outlined",fullWidth:!0,value:e.email,onChange:e=>u("email",e.target.value),error:!!n.email,helperText:n.email,margin:"normal"}),(0,hr.jsx)(Tv,{dateAdapter:lT,children:(0,hr.jsx)(GN,{label:"Date of Birth",value:e.dateOfBirth,onChange:e=>u("dateOfBirth",e),onError:e=>s(e),slotProps:{textField:{helperText:n.dateOfBirth||c,error:!!n.dateOfBirth||!!a}},sx:{mt:2,mb:1,width:1},minDate:qN()().subtract(100,"year"),maxDate:qN()()})}),(0,hr.jsx)(hl,{type:"submit",variant:"contained",fullWidth:!0,sx:{mt:2},children:"Submit"})]})]}),(0,hr.jsxs)(Ir,{variant:"body2",textAlign:"center",children:["Already have an account \xa0",(0,hr.jsx)(Rr,{component:"button",variant:"body2",onClick:()=>{l("/login")},children:"Click here to Login"})]})]})})};class Dve{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Mve{refCount(e){return Fve("refCount")}incRef(e){return Fve("incRef")}timerAvailable(){return!0}time(e){return Fve("time")}read(e){return Fve("read")}readSync(e){return Fve("readSync")}readToGPU(e,t){return Fve("readToGPU")}numDataIds(){return Fve("numDataIds")}disposeData(e,t){return Fve("disposeData")}write(e,t,n){return Fve("write")}move(e,t,n,r,a){return Fve("move")}createTensorFromGPUData(e,t,n){return Fve("createTensorFromGPUData")}memory(){return Fve("memory")}floatPrecision(){return Fve("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Fve("dispose")}}function Fve(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Ove(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,zve(e,t,n)}function Pve(e,t,n){return Math.max(e,Math.min(t,n))}function Lve(e){return e%2===0?e:e+1}function zve(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function Bve(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function Wve(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Bve(jve(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function Vve(e){Bve(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Uve(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function jve(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Gve(e){return e%1===0}function Hve(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function qve(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Kve(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,s)=>{let i=0;const o=()=>{if(e())return void a();i++;const l=t(i);null!=n&&i>=n?s():null!=r?r(o,l):setTimeout(o,l)};o()}))}function Xve(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const a=e.slice();return a[r]=t/n,a}function Yve(e,t){const n=t.length;return Bve((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),Bve(e.every((e=>Gve(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function Qve(e,t){const n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:Yve(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function Jve(e,t){return Zve(e,t)}function Zve(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function exe(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function txe(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function nxe(e){return"string"===typeof e||e instanceof String}function rxe(e){return"number"===typeof e}function axe(e){return Array.isArray(e)?axe(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":rxe(e)?"float32":nxe(e)?"string":"boolean"===typeof e?"bool":"float32"}function sxe(e){return!!(e&&e.constructor&&e.call&&e.apply)}function ixe(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function oxe(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function lxe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===t.length){const s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{const s=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=lxe(e+t*o,i,n,r)}return a}function uxe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return lxe(0,e,t,n)}function cxe(e,t){const n=dxe(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function dxe(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function hxe(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return uxe(e,new Float32Array(n));if("int32"===t)return uxe(e,new Int32Array(n));if("bool"===t)return uxe(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function pxe(e){e.forEach((t=>{Bve(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function fxe(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function mxe(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function gxe(e){return e&&e.then&&"function"===typeof e.then}const yxe="tfjsflags";class bxe{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=vxe,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(xxe().getBool("IS_TEST")||xxe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];xxe().getBool("IS_TEST")||xxe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(gxe(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(yxe in e){e[yxe].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}}function vxe(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function xxe(){return kxe}let wxe,kxe=null;function Sxe(){if(null==wxe){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}wxe=e}return wxe}function Ixe(e,t){const n=function(){const e=Sxe();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const Cxe="Abs",Nxe="Acos",Txe="Acosh",Exe="Add",Axe="AddN",_xe="All",$xe="Any",Rxe="ArgMax",Dxe="ArgMin",Mxe="Asin",Fxe="Asinh",Oxe="Atan",Pxe="Atanh",Lxe="Atan2",zxe="AvgPool",Bxe="AvgPoolGrad",Wxe="AvgPool3D",Vxe="AvgPool3DGrad",Uxe="BatchMatMul",jxe="BatchToSpaceND",Gxe="Bincount",Hxe="BitwiseAnd",qxe="BroadcastArgs",Kxe="Cast",Xxe="Ceil",Yxe="ClipByValue",Qxe="Complex",Jxe="ComplexAbs",Zxe="Concat",ewe="Conv2D",twe="Conv2DBackpropFilter",nwe="Conv2DBackpropInput",rwe="Conv3D",awe="Conv3DBackpropFilterV2",swe="Conv3DBackpropInputV2",iwe="Cos",owe="Cosh",lwe="Cumprod",uwe="Cumsum",cwe="CropAndResize",dwe="DenseBincount",hwe="DepthToSpace",pwe="DepthwiseConv2dNative",fwe="DepthwiseConv2dNativeBackpropFilter",mwe="DepthwiseConv2dNativeBackpropInput",gwe="Diag",ywe="Dilation2D",bwe="Dilation2DBackpropInput",vwe="Dilation2DBackpropFilter",xwe="Draw",wwe="RealDiv",kwe="Einsum",Swe="Elu",Iwe="EluGrad",Cwe="Erf",Nwe="Equal",Twe="Exp",Ewe="ExpandDims",Awe="Expm1",_we="FFT",$we="Fill",Rwe="FlipLeftRight",Dwe="Floor",Mwe="FloorDiv",Fwe="FusedBatchNorm",Owe="GatherV2",Pwe="GatherNd",Lwe="Greater",zwe="GreaterEqual",Bwe="Identity",Wwe="IFFT",Vwe="Imag",Uwe="IsFinite",jwe="IsInf",Gwe="IsNan",Hwe="LeakyRelu",qwe="Less",Kwe="LessEqual",Xwe="LinSpace",Ywe="Log",Qwe="Log1p",Jwe="LogicalAnd",Zwe="LogicalNot",eke="LogicalOr",tke="LRN",nke="LRNGrad",rke="Max",ake="Maximum",ske="MaxPool",ike="MaxPoolGrad",oke="MaxPool3D",lke="MaxPool3DGrad",uke="MaxPoolWithArgmax",cke="Mean",dke="Min",hke="Minimum",pke="MirrorPad",fke="Mod",mke="Multinomial",gke="Multiply",yke="Neg",bke="NotEqual",vke="NonMaxSuppressionV3",xke="NonMaxSuppressionV4",wke="NonMaxSuppressionV5",kke="OnesLike",Ske="OneHot",Ike="Pack",Cke="PadV2",Nke="Pow",Tke="Prelu",Eke="Prod",Ake="RaggedGather",_ke="RaggedRange",$ke="RaggedTensorToTensor",Rke="Range",Dke="Real",Mke="Reciprocal",Fke="Relu",Oke="Reshape",Pke="ResizeNearestNeighbor",Lke="ResizeNearestNeighborGrad",zke="ResizeBilinear",Bke="ResizeBilinearGrad",Wke="Relu6",Vke="Reverse",Uke="Round",jke="Rsqrt",Gke="ScatterNd",Hke="TensorScatterUpdate",qke="SearchSorted",Kke="Select",Xke="Selu",Yke="Slice",Qke="Sin",Jke="Sinh",Zke="Sign",eSe="Sigmoid",tSe="Softplus",nSe="Sqrt",rSe="Sum",aSe="SpaceToBatchND",sSe="SplitV",iSe="Softmax",oSe="SparseFillEmptyRows",lSe="SparseReshape",uSe="SparseSegmentMean",cSe="SparseSegmentSum",dSe="SparseToDense",hSe="SquaredDifference",pSe="Square",fSe="StaticRegexReplace",mSe="StridedSlice",gSe="StringNGrams",ySe="StringSplit",bSe="StringToHashBucketFast",vSe="Sub",xSe="Tan",wSe="Tanh",kSe="Tile",SSe="TopK",ISe="Transform",CSe="Transpose",NSe="Unique",TSe="Unpack",ESe="UnsortedSegmentSum",ASe="ZerosLike",_Se="Step",$Se="FromPixels",RSe="RotateWithOffset",DSe="_FusedMatMul",MSe="FusedConv2D",FSe="FusedDepthwiseConv2D";function OSe(){xxe().getBool("IS_TEST")||xxe().getBool("PROD")||console.warn(...arguments)}function PSe(){xxe().getBool("IS_TEST")||xxe().getBool("PROD")||console.log(...arguments)}const LSe=Ixe("kernelRegistry",(()=>new Map)),zSe=Ixe("gradRegistry",(()=>new Map));function BSe(e,t){const n=GSe(e,t);return LSe.get(n)}function WSe(e){return zSe.get(e)}function VSe(e){const t=LSe.entries(),n=[];for(;;){const{done:r,value:a}=t.next();if(r)break;const[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function USe(e){const{kernelName:t,backendName:n}=e,r=GSe(t,n);LSe.has(r)&&OSe(`The kernel '${t}' for backend '${n}' is already registered`),LSe.set(r,e)}function jSe(e){const{kernelName:t}=e;zSe.has(t)&&xxe().getBool("DEBUG")&&OSe(`Overriding the gradient for '${t}'`),zSe.set(t,e)}function GSe(e,t){return`${t}_${e}`}function HSe(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var qSe=n(8818);const KSe=n.n(qSe)()||qSe;function XSe(e){return KSe.fromString(e,!0,16)}const YSe=XSe("c3a5c85c97cb3127"),QSe=XSe("b492b66fbe98f273"),JSe=XSe("9ae16a3b2f90404f");function ZSe(e){return e.xor(e.shru(47))}function eIe(e,t,n){const r=e.slice(t,t+n);return KSe.fromBytes(Array.from(r),!0,!0)}function tIe(e,t){return eIe(e,t,8)}function nIe(e,t){return eIe(e,t,4)}function rIe(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function aIe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:XSe("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function sIe(e,t,n,r){return function(e,t,n,r,a,s){a=a.add(e),s=rIe(s.add(a).add(r),21);const i=a;return a=(a=a.add(t)).add(n),s=s.add(rIe(a,44)),[a.add(r),s.add(i)]}(tIe(e,t),tIe(e,t+8),tIe(e,t+16),tIe(e,t+24),n,r)}function iIe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=KSe.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=JSe.add(2*t),r=tIe(e,0).add(JSe),a=tIe(e,t-8);return aIe(rIe(a,37).mul(n).add(r),rIe(r,25).add(a).mul(n),n)}if(t>=4){const n=JSe.add(2*t);return aIe(nIe(e,0).shl(3).add(t),nIe(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return ZSe(JSe.mul(n).xor(YSe.mul(r))).mul(JSe)}return JSe}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=JSe.add(2*t),r=tIe(e,0).mul(QSe),a=tIe(e,8),s=tIe(e,t-8).mul(n),i=tIe(e,t-16).mul(JSe);return aIe(rIe(r.add(a),43).add(rIe(s,30)).add(i),r.add(rIe(a.add(JSe),18)).add(s),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=JSe.add(2*t),r=tIe(e,0).mul(JSe),a=tIe(e,8),s=tIe(e,t-8).mul(n),i=tIe(e,t-16).mul(JSe),o=rIe(r.add(a),43).add(rIe(s,30)).add(i),l=aIe(o,r.add(rIe(a.add(JSe),18)).add(s),n),u=tIe(e,16).mul(n),c=tIe(e,24),d=o.add(tIe(e,t-32)).mul(n),h=l.add(tIe(e,t-24)).mul(n);return aIe(rIe(u.add(c),43).add(rIe(d,30)).add(h),u.add(rIe(c.add(r),18)).add(d),n)}(e,t);let r=n,a=n.mul(QSe).add(113),s=ZSe(a.mul(JSe).add(113)).mul(JSe),i=[KSe.UZERO,KSe.UZERO],o=[KSe.UZERO,KSe.UZERO];r=r.mul(JSe).add(tIe(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=rIe(r.add(a).add(i[0]).add(tIe(e,l+8)),37).mul(QSe),a=rIe(a.add(i[1]).add(tIe(e,l+48)),42).mul(QSe),r=r.xor(o[1]),a=a.add(i[0]).add(tIe(e,l+40)),s=rIe(s.add(o[0]),33).mul(QSe),i=sIe(e,l,i[1].mul(QSe),r.add(o[0])),o=sIe(e,l+32,s.add(o[1]),a.add(tIe(e,l+16))),[s,r]=[r,s],l+=64}while(l!==u);const d=QSe.add(s.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=rIe(r.add(a).add(i[0]).add(tIe(e,l+8)),37).mul(d),a=rIe(a.add(i[1]).add(tIe(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(tIe(e,l+40))),s=rIe(s.add(o[0]),33).mul(d),i=sIe(e,l,i[1].mul(d),r.add(o[0])),o=sIe(e,l+32,s.add(o[1]),a.add(tIe(e,l+16))),[s,r]=[r,s],aIe(aIe(i[0],o[0],d).add(ZSe(a).mul(YSe)).add(s),aIe(i[1],o[1],d).add(r),d)}function oIe(e,t){return"string"===t?dIe(e):lIe([e],t)}function lIe(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=fIe(e)),xxe().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function uIe(){return xxe().platform.now()}function cIe(e,t){return xxe().platform.fetch(e,t)}function dIe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",xxe().platform.encode(e,t)}function hIe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",xxe().platform.decode(e,t)}function pIe(e){return null!=xxe().platform.isTypedArray?xxe().platform.isTypedArray(e):HSe(e)}function fIe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||gxe(e)||null==e||pIe(e)&&n)t.push(e);else if(Array.isArray(e)||pIe(e))for(let r=0;r<e.length;++r)fIe(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)fIe(e[a],t,n)}return t}class mIe{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new yIe)}profileKernel(e,t,n){let r;const a=()=>{r=n()};let s;const i=uIe();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const e of r)e.dataSync();s=Promise.resolve({kernelMs:uIe()-i})}if(xxe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){const t=r[o];t.data().then((n=>{gIe(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}}function gIe(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class yIe{logKernelProfile(e,t,n,r,a,s){const i="number"===typeof r?qve(`${r}ms`,9):r.error,o=qve(e,25),l=t.rank,u=t.size,c=qve(t.shape.toString(),14);let d="";for(const h in a){const e=a[h];if(null!=e){const n=e.shape||t.shape,r=n.length;d+=`${h}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const bIe=20,vIe=3,xIe=7;function wIe(e,t,n,r){const a=oxe(t),s=function(e,t,n,r){const a=Uve(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l="complex64"===n?CIe(e):e;if(o>1)for(let u=0;u<a/s;u++){const e=u*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],kIe(l[e+t],0,n).length)}return i}(e,t,n,a),i=t.length,o=IIe(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function kIe(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(xIe))} + ${parseFloat(e[1].toFixed(xIe))}j`:nxe(e)?`'${e}'`:"bool"===n?SIe(e):parseFloat(e.toFixed(xIe)).toString(),qve(r,t)}function SIe(e){return 0===e?"false":"true"}function IIe(e,t,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[kIe(CIe(e)[0],0,n)]}return"bool"===n?[SIe(e[0])]:[e[0].toString()]}if(1===l){if(o>bIe){const t=vIe*i;let r=Array.from(e.slice(0,t)),s=Array.from(e.slice((o-vIe)*i,o*i));return"complex64"===n&&(r=CIe(r),s=CIe(s)),["["+r.map(((e,t)=>kIe(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>kIe(e,a[o-vIe+t],n))).join(", ")+"]"]}return["["+("complex64"===n?CIe(e):Array.from(e)).map(((e,t)=>kIe(e,a[t],n))).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>bIe){for(let t=0;t<vIe;t++){const r=t*d,s=r+d;h.push(...IIe(e.slice(r,s),u,n,c,a,!1))}h.push("...");for(let t=o-vIe;t<o;t++){const r=t*d,s=r+d;h.push(...IIe(e.slice(r,s),u,n,c,a,t===o-1))}}else for(let m=0;m<o;m++){const t=m*d,r=t+d;h.push(...IIe(e.slice(t,r),u,n,c,a,m===o-1))}const p=2===l?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(s?"":f),h}function CIe(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class NIe{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Uve(e),null!=n){const e=n.length;Bve(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Zve(t,this.size),this.strides=oxe(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),Bve(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));const a=this.locToIndex(n);this.values[a]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(const s of t){if(s<0||s>=this.shape[r]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let a=t[t.length-1];for(let s=0;s<t.length-1;++s)a+=this.strides[s]*t[s];return this.values[a]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return TIe().makeTensor(this.values,this.shape,this.dtype)}}let TIe=null,EIe=null,AIe=null;class _Ie{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Uve(e),this.strides=oxe(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return EIe.buffer(this.shape,this.dtype,e)}bufferSync(){return EIe.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return uxe(this.shape,e,"complex64"===this.dtype)}arraySync(){return uxe(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=TIe().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>hIe(e)))}catch(eL){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),TIe().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=TIe().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>hIe(e)))}catch(eL){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await TIe().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),TIe().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return EIe.print(this,e)}clone(){return this.throwIfDisposed(),EIe.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return wIe(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),EIe.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),TIe().makeVariable(this,e,t,n)}}function $Ie(){return Ixe("Tensor",(()=>_Ie))}Object.defineProperty(_Ie,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),$Ie();class RIe extends _Ie{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!jve(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);TIe().disposeTensor(this),this.dataId=e.dataId,TIe().incRef(this,null)}dispose(){TIe().disposeVariable(this),this.isDisposedInternal=!0}}var DIe,MIe,FIe,OIe,PIe;Object.defineProperty(RIe,Symbol.hasInstance,{value:e=>e instanceof _Ie&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(DIe||(DIe={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(MIe||(MIe={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(FIe||(FIe={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(OIe||(OIe={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(PIe||(PIe={}));const LIe={float32:OIe,int32:MIe,bool:FIe,complex64:PIe};function zIe(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return LIe[e][t]}function BIe(e){return zIe(e,"int32")}function WIe(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function VIe(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function UIe(e,t){if(e.dtype===t.dtype)return[e,t];const n=zIe(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function jIe(e,t){return t.some((t=>t.id===e.id))}function GIe(e){const t=[];return HIe(e,t,new Set),t}function HIe(e,t,n){if(null==e)return;if(e instanceof _Ie)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!==typeof r)return;var r;const a=e;for(const s in a){const e=a[s];n.has(e)||(n.add(e),HIe(e,t,n))}}function qIe(e){return null!=e.kernelName}class KIe{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class XIe{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new KIe}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(OSe(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new mIe(this.backendInstance),!0}setupRegisteredKernels(){VSe(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){VSe(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof Mve||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,OSe(`Initialization of backend ${e} failed`),OSe(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return OSe(`Initialization of backend ${e} failed`),OSe(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return XIe.nextTensorId++}nextVariableId(){return XIe.nextVariableId++}clone(e){const t=QIe.runKernel(Bwe,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return QIe.runKernel(Kxe,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=BSe(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=qIe(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(qIe(e)){const{kernelName:t,inputs:a,attrs:s}=e;null==this.backendName&&this.backend;const l=BSe(t,this.backendName);Bve(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();o=l.kernelFunc({inputs:a,attrs:s,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const u=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,a,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,a=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,a)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,d=qIe(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(l,u,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=i()})),r&&this.addTapeNode(l,u,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=WSe(e);if(null!=r){const e=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(Bve(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const i=n.filter(((e,t)=>a[t]));return s.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&nxe(e[0])&&(a=e.map((e=>dIe(e))));const s=r.write(a,t,n),i=new _Ie(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(s),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:a}=e,s=new _Ie(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const a=new RIe(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*txe(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof RIe||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*txe(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=WSe(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=dxe(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=GIe(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const e=this.state.activeScope.track[a];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Bve(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Bve(a instanceof _Ie,(()=>"The result y returned by f() must be a tensor."));const s=function(e,t,n){const r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const n=e[l],s=n.inputs;for(const e in s){const i=s[e];let o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[n.id]=!0;break}if(o)break}}const s={};s[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(const e in n)s[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const t=e[l];if(a[t.id]&&i[t.id]){const e={};for(const a in t.inputs){const n=t.inputs[a];r[n.id]&&(e[a]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[a.id]=null==n?function(e){const t=cxe(Uve(e),"float32");return QIe.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){const s=t[a],i=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(i);for(const t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);const i=s.inputs[t];if(!jve(a.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{const t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}(e,s,(e=>this.tidy(e)),JIe);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){var t=this;return Bve(sxe(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let s;Bve(r.every((e=>e instanceof _Ie)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(s=e(...r,n),Bve(s.value instanceof _Ie,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Bve(sxe(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(e,t)=>{const n=s.gradFunc(e,t),a=Array.isArray(n)?n:[n];Bve(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Bve(a.every((e=>e instanceof _Ie)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=uIe(),n=await this.backend.time(e);return n.wallMs=uIe()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new KIe;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function YIe(){const e=Sxe();if(null==e._tfengine){const t=new bxe(e);e._tfengine=new XIe(t)}var t;return t=e._tfengine.ENV,kxe=t,function(e){TIe=e}((()=>e._tfengine)),e._tfengine}XIe.nextTensorId=0,XIe.nextVariableId=0;const QIe=YIe();function JIe(e,t){const n={a:e,b:t};return QIe.runKernel(Exe,n)}let ZIe;function eCe(e){if(void 0!==ZIe)return ZIe;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function tCe(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const nCe=xxe();function rCe(e,t){let n=e;if(pIe(e))return"string"===t?[]:[e.length];if(WIe(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(VIe(e))return[e.buffer.size/(null==t?4:txe(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||pIe(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&xxe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&aCe(e,r,[]),r}function aCe(e,t,n){if(n=n||[],!Array.isArray(e)&&!pIe(e))return void Bve(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Bve(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Bve(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let a=0;a<e.length;++a)aCe(e[a],r,n.concat(a))}function sCe(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function iCe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof $Ie())return sCe(r,e.dtype,t,n),e;let a=axe(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),sCe(r,a,t,n),null==e||!pIe(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const s=rCe(e,a);pIe(e)||Array.isArray(e)||(e=[e]);const i="string"!==a?lIe(e,a):fIe(e,[],!0);return QIe.makeTensor(i,s,a)}function oCe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>iCe(e,`${t}[${a}]`,n,r)))}nCe.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),nCe.registerFlag("IS_BROWSER",(()=>tCe())),nCe.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),nCe.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),nCe.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),nCe.registerFlag("PROD",(()=>!1)),nCe.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>nCe.getBool("DEBUG"))),nCe.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),nCe.registerFlag("IS_TEST",(()=>!1)),nCe.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>nCe.getBool("DEBUG"))),nCe.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),nCe.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),nCe.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const lCe="__op";function uCe(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=lCe;const a=function(){QIe.startScope(n);try{const e=r(...arguments);return gxe(e)&&console.error("Cannot return a Promise inside of tidy."),QIe.endScope(e),e}catch(e){throw QIe.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const cCe=uCe({complex_:function(e,t){const n=iCe(e,"real","complex"),r=iCe(t,"imag","complex");Wve(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const a={real:n,imag:r};return QIe.runKernel(Qxe,a)}});function dCe(e,t,n,r){if(null==r)r=axe(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(VIe(e)||WIe(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return QIe.backend.createTensorFromGPUData(e,t||n,r)}if(!pIe(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){pxe(t);const e=Uve(t),r=Uve(n);Bve(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){const e=n[a],r=a!==n.length-1||e!==Uve(t.slice(a));Bve(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return pIe(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?lIe(e,r):fIe(e,[],!0),QIe.makeTensor(e,t,r)}function hCe(e,t,n){return dCe(e,t,rCe(e,n),n)}const pCe={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class fCe{static join(e){return new fCe(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>pIe(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),a=new Uint8Array(r);let s=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],r=e+s-n.start,o=s,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(a.set(u,o),s+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const a=Math.floor((r-n)/2)+n,s=t(e[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function mCe(){return QIe}function gCe(){return QIe.memory()}function yCe(e,t){return QIe.tidy(e,t)}function bCe(e){GIe(e).forEach((e=>e.dispose()))}function vCe(e){return QIe.keep(e)}function xCe(){return QIe.backendName}function wCe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return QIe.registerBackend(e,t,n)}function kCe(){return QIe.backend}!function(e){AIe=e}((function(e){xxe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}));const SCe=4;async function ICe(e,t){const n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<a.length;++s){const i=a[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+SCe*t.length,r=new Uint8Array(n);let a=0;for(let s=0;s<t.length;s++){const e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=SCe,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:$Ce(await Promise.all(r)),specs:n}}function CCe(e,t){const n=new fCe(e),r={};let a=0;for(const s of t){const e=NCe(s,((e,t)=>n.slice(a+e,a+t)));r[s.name]=ECe(s,n.slice(a,a+e)),a+=e}return r}function NCe(e,t){const n=Uve(e.shape);let r;if("quantization"in e){const t=e.quantization;r=pCe[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=SCe+new Uint32Array(t(e,e+SCe))[0];return e}r=pCe[e.dtype]}return n*r}async function TCe(e,t){const n=Uve(e.shape);let r;if("quantization"in e){const t=e.quantization;r=pCe[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=SCe+new Uint32Array(await t(e,e+SCe))[0];return e}r=pCe[e.dtype]}return n*r}function ECe(e,t){const n=e.name,r=e.dtype,a=e.shape,s=Uve(a);let i,o=0;if("quantization"in e){const a=e.quantization;if("uint8"===a.dtype||"uint16"===a.dtype){if(!("min"in a)||!("scale"in a))throw new Error(`Weight ${e.name} with quantization ${a.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==a.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${a.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${a.dtype} which only supports weights of type float32 not ${r}.`)}const l=pCe[a.dtype],u="uint8"===a.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===a.dtype||"uint16"===a.dtype){i=new Float32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=t*a.scale+a.min}}else{if("float16"!==a.dtype)throw new Error(`Unsupported quantization type ${a.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){const a=r[i],o=e[n[a>>10]+(1023&a)]+t[a>>10];s[i]=o}return new Float32Array(a)}}();i=e(u)}}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${n}': ${r}`);if("uint8"!==a.dtype&&"uint16"!==a.dtype)throw new Error(`Unsupported quantization type ${a.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=Math.round(t*a.scale+a.min)}}o+=s*l}else if("string"===r){const n=Uve(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+SCe))[0];o+=SCe;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=pCe[r];if("float32"===r)i=new Float32Array(t);else if("int32"===r)i=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const r=hCe(e,a,"float32"),s=hCe(n,a,"float32"),o=cCe(r,s);return r.dispose(),s.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${r}`)}i=new Uint8Array(t)}o+=s*e}return hCe(i,a,r)}async function ACe(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:a}=await e.read();if(t&&null==a){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const s=new Uint8Array(r.length+a.byteLength);s.set(r,0),s.set(new Uint8Array(a),r.length),r=s}return r.buffer}async function _Ce(e,t){const n={},r=e.getReader();let a=new ArrayBuffer(0);for(const s of t){const e=await TCe(s,(async(e,t)=>(a=await ACe(r,a,t),a.slice(e,t))));a=await ACe(r,a,e);const t=a.slice(0,e);a=a.slice(e);const i=ECe(s,t);if(n[s.name]=i,"webgpu"===xCe()){const e=kCe();"uploadToGPU"in e&&Uve(i.shape)>=xxe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function $Ce(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}const RCe="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function DCe(e){return RCe?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function MCe(e){return fCe.join(e)}function FCe(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function OCe(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function PCe(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function LCe(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),PCe(e,n,r)}function zCe(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:DCe(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:DCe(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new fCe(e.weightData).byteLength}}function BCe(e){const t=[];for(const n of e)t.push(...n.weights);return t}class WCe{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==WCe.instance&&(WCe.instance=new WCe),WCe.instance}static registerSaveRouter(e){WCe.getInstance().saveRouters.push(e)}static registerLoadRouter(e){WCe.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return WCe.getHandlers(e,"save")}static getLoadHandlers(e,t){return WCe.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?WCe.getInstance().loadRouters:WCe.getInstance().saveRouters).forEach((t=>{const a=t(e,n);null!==a&&r.push(a)})),r}}const VCe=e=>WCe.registerSaveRouter(e),UCe=e=>WCe.registerLoadRouter(e),jCe=e=>WCe.getSaveHandlers(e),GCe=(e,t)=>WCe.getLoadHandlers(e,t),HCe="tensorflowjs",qCe="models_store",KCe="model_info_store";function XCe(){if(!xxe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function YCe(e){const t=e.result;t.createObjectStore(qCe,{keyPath:"modelPath"}),t.createObjectStore(KCe,{keyPath:"modelPath"})}class QCe{constructor(e){if(this.indexedDB=XCe(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(HCe,1);r.onupgradeneeded=()=>YCe(r),r.onsuccess=()=>{const a=r.result;if(null==t){const t=a.transaction(qCe,"readonly"),r=t.objectStore(qCe).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=fCe.join(t.weightData);const r=zCe(t),i=a.transaction(KCe,"readwrite");let o,l,u=i.objectStore(KCe);try{o=u.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(s){return n(s)}o.onsuccess=()=>{l=a.transaction(qCe,"readwrite");const o=l.objectStore(qCe);let c;try{c=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(s){return n(s)}c.onsuccess=()=>e({modelArtifactsInfo:r}),c.onerror=e=>{u=i.objectStore(KCe);const t=u.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(c.error)),t.onerror=e=>(a.close(),n(c.error))}},o.onerror=e=>(a.close(),n(o.error)),i.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}}QCe.URL_SCHEME="indexeddb://";const JCe=e=>{return xxe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(QCe.URL_SCHEME)?(t=e.slice(QCe.URL_SCHEME.length),new QCe(t)):null;var t};WCe.registerSaveRouter(JCe),WCe.registerLoadRouter(JCe);class ZCe{constructor(){this.indexedDB=XCe()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(HCe,1);n.onupgradeneeded=()=>YCe(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(KCe,"readonly"),s=a.objectStore(KCe).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(QCe.URL_SCHEME)?t.slice(QCe.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(HCe,1);r.onupgradeneeded=()=>YCe(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(KCe,"readwrite"),i=s.objectStore(KCe),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),s=()=>{l=a.transaction(qCe,"readwrite");const r=l.objectStore(qCe).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=s,r.onerror=e=>(s(),a.close(),n(o.error))}},o.onerror=e=>(a.close(),n(o.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}},r.onerror=e=>n(r.error)}))}}const eNe="/",tNe="tensorflowjs_models",nNe="info",rNe="model_topology",aNe="weight_specs",sNe="weight_data",iNe="model_metadata";function oNe(e){return{info:[tNe,e,nNe].join(eNe),topology:[tNe,e,rNe].join(eNe),weightSpecs:[tNe,e,aNe].join(eNe),weightData:[tNe,e,sNe].join(eNe),modelMetadata:[tNe,e,iNe].join(eNe)}}function lNe(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function uNe(e){const t=e.split(eNe);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(eNe)}class cNe{constructor(e){if(!xxe().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=oNe(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=zCe(e),s=fCe.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(RCe)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(s));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw lNe(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(RCe){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(s),t}}cNe.URL_SCHEME="localstorage://";const dNe=e=>{return xxe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(cNe.URL_SCHEME)?(t=e.slice(cNe.URL_SCHEME.length),new cNe(t)):null;var t};WCe.registerSaveRouter(dNe),WCe.registerLoadRouter(dNe);class hNe{constructor(){Bve(xxe().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Bve("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=tNe+eNe,n=eNe+nNe;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){e[uNe(a)]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){var t;const n=oNe(e=(t=e).startsWith(cNe.URL_SCHEME)?t.slice(cNe.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return lNe(n),r}}const pNe="://";class fNe{constructor(){this.managers={}}static getInstance(){return null==fNe.instance&&(fNe.instance=new fNe),fNe.instance}static registerManager(e,t){Bve(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(pNe)&&(e=e.slice(0,e.indexOf(pNe))),Bve(e.length>0,(()=>"scheme must not be an empty string."));const n=fNe.getInstance();Bve(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=fNe.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(fNe.getInstance().managers)}}function mNe(e){if(-1===e.indexOf(pNe))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${fNe.getSchemes().join(",")}`);return{scheme:e.split(pNe)[0],path:e.split(pNe)[1]}}async function gNe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Bve(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=WCe.getLoadHandlers(e);Bve(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),Bve(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const a=r[0],s=WCe.getSaveHandlers(t);Bve(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),Bve(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const i=s[0],o=mNe(e).scheme,l=mNe(e).path,u=o===mNe(e).scheme,c=await a.load();n&&u&&await fNe.getManager(o).removeModel(l);const d=await i.save(c);return n&&!u&&await fNe.getManager(o).removeModel(l),d.modelArtifactsInfo}async function yNe(){const e=fNe.getSchemes(),t={};for(const n of e){const e=await fNe.getManager(n).listModels();for(const r in e){t[n+pNe+r]=e[r]}}return t}async function bNe(e){const t=mNe(e);return fNe.getManager(t.scheme).removeModel(t.path)}async function vNe(e,t){return gNe(e,t,!1)}async function xNe(e,t){return gNe(e,t,!0)}class wNe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&xxe().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return HSe(e)}}if(xxe().get("IS_BROWSER")){xxe().setPlatform("browser",new wNe);try{fNe.registerManager(cNe.URL_SCHEME,new hNe)}catch(Z8e){}try{fNe.registerManager(QCe.URL_SCHEME,new ZCe)}catch(Z8e){}}const kNe=()=>n(5817);let SNe;class INe{constructor(){this.util=n(8590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=xxe().global.fetch?xxe().global.fetch(e,t):(null==SNe&&(SNe=kNe()),SNe(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function CNe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",pxe(e),new NIe(e,t,n)}xxe().get("IS_NODE")&&!xxe().get("IS_BROWSER")&&xxe().setPlatform("node",new INe);const NNe=uCe({cast_:function(e,t){const n=iCe(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:t};return QIe.runKernel(Kxe,r,a)}});const TNe=uCe({clone_:function(e){const t={x:iCe(e,"x","clone","string_or_numeric")};return QIe.runKernel(Bwe,t)}});function ENe(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}YIe();EIe={buffer:CNe,cast:NNe,clone:TNe,print:ENe};const ANe=uCe({add_:function(e,t){let n=iCe(e,"a","add"),r=iCe(t,"b","add");[n,r]=UIe(n,r);const a={a:n,b:r};return QIe.runKernel(Exe,a)}});const _Ne=uCe({floorDiv_:function(e,t){let n=iCe(e,"a","floorDiv"),r=iCe(t,"b","floorDiv");[n,r]=UIe(n,r);const a={a:n,b:r};return QIe.runKernel(Mwe,a)}});const $Ne=uCe({div_:function(e,t){let n=iCe(e,"a","div"),r=iCe(t,"b","div");if([n,r]=UIe(n,r),"int32"===n.dtype&&"int32"===r.dtype)return _Ne(n,r);const a={a:n,b:r};return QIe.runKernel(wwe,a,{})}});const RNe=uCe({mul_:function(e,t){let n=iCe(e,"a","mul"),r=iCe(t,"b","mul");[n,r]=UIe(n,r);const a={a:n,b:r};return QIe.runKernel(gke,a)}});const DNe=uCe({sqrt_:function(e){const t={x:iCe(e,"x","sqrt","float32")};return QIe.runKernel(nSe,t)}});const MNe=uCe({square_:function(e){const t=iCe(e,"x","square");return QIe.runKernel("Square",{x:t},{})}});const FNe=uCe({zerosLike_:function(e){const t={x:iCe(e,"x","zerosLike")};return QIe.runKernel(ASe,t)}});function ONe(e){return QIe.customGrad(e)}function PNe(e,t){if((pIe(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&pIe(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return dCe(e,[],[],t)}const LNe=new Map,zNe=new Map;class BNe{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class WNe{constructor(){this.classNameMap={}}static getMap(){return null==WNe.instance&&(WNe.instance=new WNe),WNe.instance}static register(e){WNe.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function VNe(e,t,n){Bve(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Bve("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Bve(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const r=t+">"+n;return WNe.register(e),LNe.set(r,e),zNe.set(e,r),e}class UNe extends BNe{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return bCe(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Bve(sxe(e),(()=>"The f passed in variableGrads(f) must be a function")),Bve(null==t||Array.isArray(t)&&t.every((e=>e instanceof RIe)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in QIe.registeredVariables)t.push(QIe.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,a=t.length;t=t.filter((e=>e.trainable)),Bve(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));const{value:s,grads:i}=QIe.gradients(e,t,null,!0);Bve(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Bve(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:s,grads:o}}(e,t)}dispose(){null!=this.iterations_&&bCe(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:PNe(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(UNe,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class jNe extends UNe{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=QIe.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=QIe.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:yCe((()=>FNe(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:yCe((()=>FNe(r).variable(a)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;yCe((()=>{const e=ANe(RNe(i,this.rho),RNe(MNe(s),1-this.rho)),t=RNe($Ne(DNe(ANe(o,this.epsilon)),DNe(ANe(i,this.epsilon))),s),n=ANe(RNe(o,this.rho),RNe(MNe(t),1-this.rho));i.assign(e),o.assign(n);const a=ANe(RNe(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(bCe(this.accumulatedGrads.map((e=>e.variable))),bCe(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function GNe(e,t,n){pxe(e);const r={shape:e,value:t,dtype:n=n||axe(t)};return QIe.runKernel($we,{},r)}class HNe extends UNe{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=QIe.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:yCe((()=>GNe(r.shape,this.initialAccumulatorValue).variable(e)))}}const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const s=this.accumulatedGrads[n].variable;yCe((()=>{const e=ANe(s,MNe(a));s.assign(e);const t=ANe(RNe($Ne(a,DNe(ANe(e,QIe.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&bCe(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const qNe=uCe({pow_:function(e,t){let n=iCe(e,"base","pow"),r=iCe(t,"exp","pow");[n,r]=UIe(n,r);const a={a:n,b:r};return QIe.runKernel(Nke,a)}});const KNe=uCe({sub_:function(e,t){let n=iCe(e,"a","sub"),r=iCe(t,"b","sub");[n,r]=UIe(n,r);const a={a:n,b:r};return QIe.runKernel(vSe,a)}});class XNe extends UNe{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],yCe((()=>{this.accBeta1=PNe(t).variable(),this.accBeta2=PNe(n).variable()})),null==r&&(this.epsilon=QIe.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);yCe((()=>{const n=KNe(1,this.accBeta1),r=KNe(1,this.accBeta2);t.forEach(((t,a)=>{const s=QIe.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:yCe((()=>FNe(s).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:yCe((()=>FNe(s).variable(i)))});const o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,c=ANe(RNe(l,this.beta1),RNe(o,1-this.beta1)),d=ANe(RNe(u,this.beta2),RNe(MNe(o),1-this.beta2)),h=$Ne(c,n),p=$Ne(d,r);l.assign(c),u.assign(d);const f=ANe(RNe($Ne(h,ANe(DNe(p),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(RNe(this.accBeta1,this.beta1)),this.accBeta2.assign(RNe(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&bCe(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&bCe(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),yCe((()=>{this.accBeta1.assign(qNe(this.beta1,this.iterations_+1)),this.accBeta2.assign(qNe(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const YNe=uCe({abs_:function(e){const t=iCe(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return QIe.runKernel(Jxe,e)}{const e={x:t};return QIe.runKernel(Cxe,e)}}});function QNe(e,t){const n=e.length,r=[];for(let a=0;a<n;a++){const s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function JNe(e,t){const n=[];for(let r=0;r<t.length;r++){const a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function ZNe(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];null==s&&(s=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===s)r[n-a-1]=i;else if(1===i)r[n-a-1]=s;else{if(s!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-a-1]=s}}return r}const eTe=uCe({maximum_:function(e,t){let n=iCe(e,"a","maximum"),r=iCe(t,"b","maximum");[n,r]=UIe(n,r),"bool"===n.dtype&&(n=NNe(n,"int32"),r=NNe(r,"int32")),ZNe(n.shape,r.shape);const a={a:n,b:r};return QIe.runKernel(ake,a)}});class tTe extends UNe{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],yCe((()=>{this.iteration=PNe(0).variable(),this.accBeta1=PNe(t).variable()})),null==r&&(this.epsilon=QIe.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);yCe((()=>{const n=KNe(1,this.accBeta1),r=$Ne(-this.learningRate,ANe(RNe(this.iteration,this.decay),1));t.forEach(((t,a)=>{const s=QIe.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:FNe(s).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:FNe(s).variable(i)});const o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,c=ANe(RNe(l,this.beta1),RNe(o,1-this.beta1)),d=RNe(u,this.beta2),h=YNe(o),p=eTe(d,h);l.assign(c),u.assign(p);const f=ANe(RNe($Ne(r,n),$Ne(c,ANe(p,this.epsilon))),s);s.assign(f)})),this.iteration.assign(ANe(this.iteration,1)),this.accBeta1.assign(RNe(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&bCe(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&bCe(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class nTe extends UNe{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=QIe.registeredVariables[t];yCe((()=>{const e=ANe(RNe(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=vCe(PNe(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class rTe extends nTe{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=PNe(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=QIe.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:yCe((()=>FNe(r).variable(e)))}}const a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&yCe((()=>{let e;const t=ANe(RNe(this.m,a),s);e=this.useNesterov?ANe(RNe(this.c,ANe(s,RNe(t,this.m))),r):ANe(RNe(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&bCe(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class aTe extends UNe{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=QIe.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=QIe.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:yCe((()=>FNe(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:yCe((()=>FNe(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:yCe((()=>FNe(r).variable(a)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;yCe((()=>{const e=ANe(RNe(i,this.decay),RNe(MNe(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,a=ANe(RNe(t,this.decay),RNe(s,1-this.decay)),l=$Ne(RNe(s,this.learningRate),DNe(KNe(e,ANe(MNe(a),this.epsilon)))),u=ANe(RNe(o,this.momentum),l);i.assign(e),t.assign(a),o.assign(u);const c=KNe(r,u);r.assign(c)}else{const e=ANe(RNe(i,this.decay),RNe(MNe(s),1-this.decay)),t=ANe(RNe(o,this.momentum),$Ne(RNe(s,this.learningRate),DNe(ANe(e,this.epsilon))));i.assign(e),o.assign(t);const n=KNe(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&bCe(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&bCe(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&bCe(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const sTe=[jNe,HNe,XNe,tTe,rTe,aTe,nTe];function iTe(e){return new Promise((e=>setTimeout(e))).then(e)}class oTe{constructor(e){if(!xxe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(oTe.URL_SCHEME)&&(e=e.slice(oTe.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=fCe.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=OCe(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await iTe((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await iTe((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:zCe(e)}}}}oTe.URL_SCHEME="downloads://";class lTe{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});const s=LCe(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const s of e)t.push(...s.weights),n.push(...s.paths);const r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const a=new FileReader;a.onload=e=>{const t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>FCe(e.name))),r={};for(const a of e)a.paths.forEach((e=>{const a=FCe(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function uTe(e){return new lTe(e)}function cTe(e,t,n,r){!function(e){Bve(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Bve(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),Bve(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),Bve(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(e.map((s=>(s.then((s=>{const i=n+ ++a/e.length*(r-n);return t(i),s})),s))))}async function dTe(e,t){null==t&&(t={});const n=null==t.fetchFunc?xxe().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await cTe(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await cTe(a,t.onProgress,.5,1)}async function hTe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return pTe((e=>dTe(e,{requestInit:r})))(e,t,n)}function pTe(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0;const a=t.map((()=>!1)),s={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,u=pCe[l]*Uve(e.shape),c=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){const e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));const c=await e(u),d={};let h=0;return l.forEach((e=>{const n=t[e].paths.length,r=new fCe(c.slice(h,h+n));s[e].forEach((e=>{const t=CCe(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)d[n]=t[n]})),h+=n})),d}}WCe.registerSaveRouter((e=>xxe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(oTe.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new oTe(e)}(e.slice(oTe.URL_SCHEME.length)):null));class fTe{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Bve("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=xxe().platform.fetch,Bve(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Bve(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=OCe(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=fCe.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:zCe(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(mD){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return LCe(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=BCe(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?xxe().platform.fetch:t.fetchFunc;let a,s=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;s<e.length;){if(!a){const n=(await r(e[s],t.requestInit,{isBinary:!0})).body;a=n.getReader()}const{done:o,value:l}=await a.read();if(!o)return void n.enqueue(l);s++,a=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,s/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,s=[],i=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):s.push(a+e+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){const t=await this.getWeightUrls(e);return[BCe(e),await dTe(t,this.loadOptions)]}}function mTe(e){return null!=e.match(fTe.URL_SCHEME_REGEX)}fTe.URL_SCHEME_REGEX=/^https?:\/\//;const gTe=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>mTe(e))):mTe(e),n)return yTe(e,t)}return null};function yTe(e,t){return new fTe(e,t)}function bTe(e,t){return yTe(e,t)}WCe.registerSaveRouter(gTe),WCe.registerLoadRouter(gTe);class vTe{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class xTe{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class wTe{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function kTe(e,t,n,r){return new wTe(STe(...arguments))}function STe(e,t,n,r){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new vTe(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new vTe({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new vTe({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function ITe(e){return new xTe(e)}function CTe(e){return new xTe(e)}function NTe(e,t,n){if(Vve(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=rCe(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return dCe(e,t,r,n)}let TTe;function ETe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=BSe($Se,QIe.backendName)){const n={pixels:e},r={numChannels:t};return QIe.runKernel($Se,n,r)}const[l,u]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,d;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(s||a||o){if(null==TTe)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");TTe=new OffscreenCanvas(1,1).getContext("2d")}else TTe=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});TTe.canvas.width=l,TTe.canvas.height=u,TTe.drawImage(e,0,0,l,u),c=TTe.getImageData(0,0,l,u).data}if(4===t)d=new Int32Array(c);else{const e=l*u;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=c[4*n+e]}return NTe(d,[u,l,t],"int32")}const ATe=uCe({fromPixels_:ETe}),_Te=-2,$Te=-1;function RTe(e,t,n){const r=e.shape.length;Bve(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),Bve(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)Bve(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function DTe(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function MTe(e,t,n){const r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function FTe(e,t,n,r){const a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[t]=1:(a.splice(t,0,1),a.pop());return a}function OTe(e,t,n){return n<=e?n:n-(t-1)}function PTe(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function LTe(e,t,n,r,a,s,i,o,l){const u=e.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=zTe(i,l,u,r,e),d=BTe(o,l,u,a,e),h=FTe(s,l,u,e)}else for(let p=0;p<u;p++)c[p]=VTe(i,r,s,e,p,l),d[p]=UTe(o,a,s,e,p,l),h[p]=WTe(s,p,l);return{begin:c,end:d,strides:h}}function zTe(e,t,n,r,a){const s=[...a],i=PTe(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{const a=OTe(t,n,o);let i=r[a];e&1<<a&&(i=0),s[o]=i}return s}function BTe(e,t,n,r,a){const s=[...a],i=PTe(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{const a=OTe(t,n,o);let i=r[a];e&1<<a&&(i=Number.MAX_SAFE_INTEGER),s[o]=i}for(let o=0;o<s.length;o++){const e=a[o];s[o]<0&&(s[o]+=e),s[o]=Pve(0,s[o],a[o])}return s}function WTe(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function VTe(e,t,n,r,a,s){let i=t[a];const o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[a];return i<0&&(i+=l),i=Pve(0,i,l-1),i}function UTe(e,t,n,r,a,s){let i=t[a];const o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[a];return i<0&&(i+=l),i=o>0?Pve(0,i,l):Pve(-1,i,l-1),i}function jTe(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function GTe(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function HTe(e,t,n){let r;const a=e.shape.length;let s;return r="number"===typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),r.forEach((e=>{Bve(-1!==e,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((t,n)=>t>=0?t:(Bve(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,s]}function qTe(e,t,n,r,a,s,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&0!==(1<<b&o)&&d.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(_Te),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push($Te),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],y=[];for(let b=0;b<e.length;++b){if(0===h.strides[b])throw Error(`strides[${b}] must be non-zero`);const t=!!(h.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}const r=[h.beginMask&1<<b,h.endMask&1<<b],a=[h.strides[b]>0?0:-1,h.strides[b]>0?n:n-1];if(t&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[b];const s=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(t){const e=h.begin[b]<0?n+h.begin[b]:h.begin[b];if(h.begin[b]=e,h.end[b]=h.begin[b]+1,e<0||e>=n)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=KTe(h.begin[b],0,h.strides[b],n,r,a),h.end[b]=KTe(h.end[b],1,h.strides[b],n,r,a);const e=1===h.strides[b]&&0===h.begin[b]&&h.end[b]===n;p=p&&e,f=f&&(0===b&&1===h.strides[b]||e)}else p=p&&1===h.strides[b]&&s,f=f&&(0===b&&1===h.strides[b]||s);let i,o=!1;if(h.beginValid&&h.endValid?(i=h.end[b]-h.begin[b],o=!0):t?(i=1,o=!0):s&&n>=0&&(i=h.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!==h.strides[b]<0?0:Math.trunc(i/h.strides[b])+(i%h.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){const e=h.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===_Te&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>h.finalShapeGatherIndices[t]!==_Te)),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function KTe(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{const t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}const XTe=uCe({acos_:function(e){const t={x:iCe(e,"x","acos")};return QIe.runKernel(Nxe,t)}});const YTe=uCe({acosh_:function(e){const t={x:iCe(e,"x","acosh")};return QIe.runKernel(Txe,t)}});const QTe=uCe({addN_:function(e){Bve(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),Bve(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>iCe(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!jve(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return QIe.runKernel(Axe,r)}});const JTe=uCe({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:iCe(e,"x","all","bool")},a={axis:t,keepDims:n};return QIe.runKernel(_xe,r,a)}});const ZTe=uCe({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:iCe(e,"x","any","bool")},a={axis:t,keepDims:n};return QIe.runKernel($xe,r,a)}});const eEe=uCe({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:iCe(e,"x","argMax")},r={axis:t};return QIe.runKernel(Rxe,n,r)}});const tEe=uCe({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:iCe(e,"x","argMin")},r={axis:t};return QIe.runKernel(Dxe,n,r)}});const nEe=uCe({asin_:function(e){const t={x:iCe(e,"x","asin")};return QIe.runKernel(Mxe,t)}});const rEe=uCe({asinh_:function(e){const t={x:iCe(e,"x","asinh")};return QIe.runKernel(Fxe,t)}});const aEe=uCe({atan_:function(e){const t={x:iCe(e,"x","atan")};return QIe.runKernel(Oxe,t)}});const sEe=uCe({atan2_:function(e,t){let n=iCe(e,"a","atan2"),r=iCe(t,"b","atan2");[n,r]=UIe(n,r);const a={a:n,b:r};return QIe.runKernel(Lxe,a)}});const iEe=uCe({atanh_:function(e){const t={x:iCe(e,"x","atanh")};return QIe.runKernel(Pxe,t)}});function oEe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return cEe(e,[...t,e[3]],n,s,r,null,null,xEe(a))}function lEe(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[o,l]=pEe(t);let u;if("channelsLast"===i)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[o,l,e[1],e[1]]}return cEe(e,u,n,r,a,s,!1,i)}function uEe(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,l,u]=fEe(t);let c,d;if("NDHWC"===i)d="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[o,l,u,e[1],e[1]]}return dEe(e,c,n,r,a,!1,d,s)}function cEe(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,c]=e}const[h,p,,f]=t,[m,g]=pEe(n),[y,b]=pEe(r),v=mEe(h,y),x=mEe(p,b),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,r,a,s,i,o,l){let u,c,d;if("number"===typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,r,a){null==r&&(r=hEe(e,t,n));const s=e[0],i=e[1],o=gEe((s-t+2*r)/n+1,a),l=gEe((i-t+2*r)/n+1,a);return[o,l]}([t,n],s,r,e,o);c=a[0],d=a[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/a);const e=Math.max(0,(c-1)*r+s-t),o=Math.max(0,(d-1)*a+i-n),l=Math.floor(e/2),h=e-l,p=Math.floor(o/2);u={top:l,bottom:h,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/r),d=Math.ceil((n-i+1)/a);else{if("object"!==typeof e)throw Error(`Unknown padding parameter: ${e}`);{const h="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=gEe((t-s+h+p)/r+1,o),d=gEe((n-i+f+m)/a+1,o)}}return{padInfo:u,outHeight:c,outWidth:d}}(a,u,c,m,g,v,x,s,o),I=i?f*d:f;let C;return"channelsFirst"===o?C=[l,I,k,S]:"channelsLast"===o&&(C=[l,k,S,I]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:e,outShape:C,filterShape:t}}function dEe(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=e}const[p,f,m,,g]=t,[y,b,v]=fEe(n),[x,w,k]=fEe(r),S=mEe(p,x),I=mEe(f,w),C=mEe(m,k),{padInfo:N,outDepth:T,outHeight:E,outWidth:A}=function(e,t,n,r,a,s,i,o,l,u,c){let d,h,p,f;"valid"===e&&(e=0);if("number"===typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,a,s){null==a&&(a=hEe(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=gEe((e[o]-t[o]+2*a)/r[o]+1,s));return i}([t,n,r,1],[o,l,u],1,[a,s,i],e,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(t/a),p=Math.ceil(n/s),f=Math.ceil(r/i);const e=(h-1)*a+o-t,c=(p-1)*s+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),v=c-b,x=Math.floor(m/2);d={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(a,u,c,d,y,b,v,S,I,C,o),_=s?g*h:g;let $;return"channelsFirst"===i?$=[l,_,T,E,A]:"channelsLast"===i&&($=[l,T,E,A,_]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:T,outHeight:E,outWidth:A,outChannels:_,padInfo:N,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:C,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:$,filterShape:t}}function hEe(e,t,n){const r=mEe(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function pEe(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function fEe(e){return"number"===typeof e?[e,e,e]:e}function mEe(e,t){return t<=1?e:e+(e-1)*(t-1)}function gEe(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function yEe(e){const[t,n,r]=pEe(e);return 1===t&&1===n&&1===r}function bEe(e,t){return yEe(e)||yEe(t)}function vEe(e){return pEe(e).every((e=>e>0))}function xEe(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function wEe(e,t,n){if(null!=n){if("string"===typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"===typeof t)Bve(Gve(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!==typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{Bve(Gve(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const kEe=uCe({reshape_:function(e,t){const n={x:iCe(e,"x","reshape","string_or_numeric")},r={shape:t};return QIe.runKernel(Oke,n,r)}});const SEe=uCe({avgPool_:function(e,t,n,r,a){const s=iCe(e,"x","avgPool","float32");Bve(bEe(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=s,o=!1;3===s.rank&&(o=!0,i=kEe(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Bve(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),wEe("avgPool",r,a);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a};let c=QIe.runKernel(zxe,l,u);return c=NNe(c,s.dtype),o?kEe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const IEe=uCe({avgPool3d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=iCe(e,"x","avgPool3d","float32");let o=i,l=!1;4===i.rank&&(l=!0,o=kEe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Bve(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),Bve("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Bve("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),wEe("avgPool3d",r,a);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let d=QIe.runKernel(Wxe,u,c);return d=NNe(d,o.dtype),l?kEe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const CEe=uCe({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Bve(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=oCe(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return TNe(n[0]);const r=n,a={axis:t};return QIe.runKernel(Zxe,r,a)}});const NEe=uCe({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=iCe(e,"a","matMul"),s=iCe(t,"b","matMul");[a,s]=UIe(a,s);const i={a:a,b:s},o={transposeA:n,transposeB:r};return QIe.runKernel(Uxe,i,o)}});const TEe=uCe({sigmoid_:function(e){const t={x:iCe(e,"x","sigmoid","float32")};return QIe.runKernel(eSe,t)}});const EEe=uCe({slice_:function(e,t,n){const r=iCe(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:t,size:n};return QIe.runKernel(Yke,a,s)}});const AEe=uCe({tanh_:function(e){const t={x:iCe(e,"x","tanh","float32")};return QIe.runKernel(wSe,t)}});const _Ee=uCe({basicLSTMCell_:function(e,t,n,r,a,s){const i=iCe(e,"forgetBias","basicLSTMCell"),o=iCe(t,"lstmKernel","basicLSTMCell"),l=iCe(n,"lstmBias","basicLSTMCell"),u=iCe(r,"data","basicLSTMCell"),c=iCe(a,"c","basicLSTMCell"),d=iCe(s,"h","basicLSTMCell"),h=CEe([u,d],1),p=NEe(h,o),f=ANe(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=EEe(f,[0,0],y),v=EEe(f,[0,g],y),x=EEe(f,[0,2*g],y),w=EEe(f,[0,3*g],y),k=ANe(RNe(TEe(b),AEe(v)),RNe(c,TEe(ANe(i,x))));return[k,RNe(AEe(k),TEe(w))]}});const $Ee=uCe({batchToSpaceND_:function(e,t,n){const r=iCe(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));Bve(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),Bve(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),Bve(r.shape[0]%a===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));const s={x:r},i={blockShape:t,crops:n};return QIe.runKernel(jxe,s,i)}});const REe=uCe({batchNorm_:function(e,t,n,r,a,s){null==s&&(s=.001);const i=iCe(e,"x","batchNorm"),o=iCe(t,"mean","batchNorm"),l=iCe(n,"variance","batchNorm");let u,c;null!=a&&(u=iCe(a,"scale","batchNorm")),null!=r&&(c=iCe(r,"offset","batchNorm")),Bve(o.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Bve(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Bve(null==u||o.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d=function(e){let t;return t=0===e.rank||1===e.rank?kEe(e,[1,1,1,e.size]):2===e.rank?kEe(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?kEe(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),h={x:d,scale:u,offset:c,mean:o,variance:l},p={varianceEpsilon:s},f=QIe.runKernel(Fwe,h,p);return kEe(f,i.shape)}});const DEe=uCe({batchNorm2d_:function(e,t,n,r,a,s){const i=iCe(e,"x","batchNorm"),o=iCe(t,"mean","batchNorm"),l=iCe(n,"variance","batchNorm");let u,c;return null!=a&&(u=iCe(a,"scale","batchNorm")),null!=r&&(c=iCe(r,"offset","batchNorm")),Bve(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),Bve(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),Bve(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&Bve(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&Bve(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),REe(i,o,l,c,u,s)}});const MEe=uCe({batchNorm3d_:function(e,t,n,r,a,s){const i=iCe(e,"x","batchNorm"),o=iCe(t,"mean","batchNorm"),l=iCe(n,"variance","batchNorm");let u,c;return null!=a&&(u=iCe(a,"scale","batchNorm")),null!=r&&(c=iCe(r,"offset","batchNorm")),Bve(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),Bve(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),Bve(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&Bve(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&Bve(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),REe(i,o,l,c,u,s)}});const FEe=uCe({batchNorm4d_:function(e,t,n,r,a,s){const i=iCe(e,"x","batchNorm"),o=iCe(t,"mean","batchNorm"),l=iCe(n,"variance","batchNorm");let u,c;return null!=a&&(u=iCe(a,"scale","batchNorm")),null!=r&&(c=iCe(r,"offset","batchNorm")),Bve(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),Bve(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),Bve(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&Bve(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&Bve(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),REe(i,o,l,c,u,s)}});const OEe=uCe({bincount_:function(e,t,n){const r=iCe(e,"x","bincount"),a=iCe(t,"weights","bincount");Bve("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Bve(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Bve(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));const s={x:r,weights:a},i={size:n};return QIe.runKernel(Gxe,s,i)}});const PEe=uCe({bitwiseAnd_:function(e,t){const n=iCe(e,"x","bitwiseAnd"),r=iCe(t,"y","bitwiseAnd");if(!jve(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const a={a:n,b:r};return QIe.runKernel(Hxe,a)}});const LEe=uCe({broadcastArgs_:function(e,t){const n=iCe(e,"s0","broadcastArgs","int32"),r=iCe(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const a={s0:n,s1:r};return QIe.runKernel(qxe,a)}});const zEe=uCe({broadcastTo_:function(e,t){let n=iCe(e,"broadcastTo","x");const r=n.shape;if(pxe(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=kEe(n,e)}const a=n.shape,s=Array.from(t);for(let u=t.length-1;u>=0;u--)if(a[u]===t[u])s[u]=1;else if(1!==n.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);const i=s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(0===i.length)return TNe(n);const o={x:n},l={reps:s};return QIe.runKernel(kSe,o,l)}});const BEe=uCe({ceil_:function(e){const t={x:iCe(e,"x","ceil","float32")};return QIe.runKernel(Xxe,t)}});const WEe=uCe({clipByValue_:function(e,t,n){const r=iCe(e,"x","clipByValue");if(Bve(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return GNe(r.shape,t,r.dtype);const a={x:r},s={clipValueMin:t,clipValueMax:n};return QIe.runKernel(Yxe,a,s)}});const VEe=uCe({concat1d_:function(e){return CEe(e,0)}});const UEe=uCe({concat2d_:function(e,t){return CEe(e,t)}});const jEe=uCe({concat3d_:function(e,t){return CEe(e,t)}});const GEe=uCe({concat4d_:function(e,t){return CEe(e,t)}});const HEe=uCe({conv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=iCe(e,"x","conv2d","float32"),l=iCe(t,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=kEe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Bve(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),Bve(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),wEe("conv2d",r,i);const d="NHWC"===a?u.shape[3]:u.shape[1];Bve(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),Bve(bEe(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Bve(vEe(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Bve(vEe(n),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=QIe.runKernel(ewe,h,p);return c?kEe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const qEe=uCe({conv1d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0;const o=iCe(e,"x","conv1d"),l=iCe(t,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=kEe(o,[1,o.shape[0],o.shape[1]])),Bve(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),Bve(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),wEe("conv1d",r,i),Bve(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),Bve(bEe(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),Bve(vEe(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Bve(vEe(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Bve("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));const d=kEe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=kEe(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=HEe(h,d,[1,n],r,"NHWC",[1,s],i);return kEe(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const KEe=uCe({conv2DBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;Bve(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=kEe(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Bve(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),Bve(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),Bve(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===s?o[3]:o[1],d="NHWC"===s?l.shape[3]:l.shape[1];Bve(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),Bve(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),wEe("conv2dDerInput",a,i);const h={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=QIe.runKernel(nwe,h,p);return u?kEe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const XEe=uCe({conv2dTranspose_:function(e,t,n,r,a,s){const i=iCe(e,"x","conv2dTranspose"),o=iCe(t,"filter","conv2dTranspose");return KEe(n,i,o,r,a,"NHWC",s)}});const YEe=uCe({conv3d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=iCe(e,"x","conv3d"),o=iCe(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=kEe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Bve(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),Bve(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),Bve(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),Bve(bEe(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Bve("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),Bve(vEe(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Bve(vEe(n),(()=>"Error in conv3D: Strides should be larger than 0."));const c={x:l,filter:o},d={strides:n,pad:r,dataFormat:a,dilations:s},h=QIe.runKernel(rwe,c,d);return u?kEe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const QEe=uCe({conv3DBackpropInput_:function(e,t,n,r,a){Bve(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=kEe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);const l=s[4],u=i.shape[4];Bve(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),Bve(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),Bve(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Bve(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),Bve(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:i,filter:n},d={pad:a,strides:r,inputShape:s},h=QIe.runKernel(swe,c,d);return o?kEe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const JEe=uCe({conv3dTranspose_:function(e,t,n,r,a){const s=iCe(e,"x","conv3dTranspose"),i=iCe(t,"filter","conv3dTranspose");return QEe(n,s,i,r,a)}});const ZEe=uCe({cos_:function(e){const t={x:iCe(e,"x","cos","float32")};return QIe.runKernel(iwe,t)}});const eAe=uCe({cosh_:function(e){const t={x:iCe(e,"x","cosh","float32")};return QIe.runKernel(owe,t)}});const tAe=uCe({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:iCe(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return QIe.runKernel(lwe,a,s)}});const nAe=uCe({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:iCe(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return QIe.runKernel(uwe,a,s)}});const rAe=uCe({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=iCe(e,"x","denseBincount"),s=iCe(t,"weights","denseBincount");Bve("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),Bve(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),Bve(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Bve(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));const i={x:a,weights:s},o={size:n,binaryOutput:r};return QIe.runKernel(dwe,i,o)}});const aAe=uCe({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=iCe(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Bve(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),Bve(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),Bve(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),Bve(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const o={x:r},l={blockSize:t,dataFormat:n};return QIe.runKernel(hwe,o,l)}});const sAe=uCe({depthwiseConv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=iCe(e,"x","depthwiseConv2d","float32"),l=iCe(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=kEe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Bve(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),Bve(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const d="NHWC"===a?u.shape[3]:u.shape[1];Bve(d===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`)),wEe("depthwiseConv2d",r,i);const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=QIe.runKernel(pwe,h,p);return c?kEe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const iAe=uCe({diag_:function(e){const t={x:iCe(e,"x","diag")};return QIe.runKernel(gwe,t)}});const oAe=uCe({dilation2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const i=iCe(e,"x","dilation2d"),o=iCe(t,"filter","dilation2d");Bve(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),Bve(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),Bve("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=i,u=!1;3===i.rank&&(l=kEe(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Bve(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));const c={x:l,filter:o},d={strides:n,pad:r,dilations:a},h=QIe.runKernel(ywe,c,d);return u?kEe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const lAe=uCe({equal_:function(e,t){let n=iCe(e,"a","equal","string_or_numeric"),r=iCe(t,"b","equal","string_or_numeric");[n,r]=UIe(n,r),ZNe(n.shape,r.shape);const a={a:n,b:r};return QIe.runKernel(Nwe,a)}});const uAe=uCe({where_:function(e,t,n){const r=iCe(t,"a","where"),a=iCe(n,"b","where"),s=iCe(e,"condition","where","bool"),i=ZNe(ZNe(s.shape,r.shape),a.shape),o={condition:zEe(s,i),t:zEe(r,i),e:zEe(a,i)};return QIe.runKernel(Kke,o)}});const cAe=uCe({divNoNan_:function(e,t){let n=iCe(e,"a","div"),r=iCe(t,"b","div");[n,r]=UIe(n,r);const a=$Ne(n,r),s=FNe(a),i=lAe(r,s);return uAe(i,s,a)}});const dAe=uCe({dot_:function(e,t){const n=iCe(e,"t1","dot"),r=iCe(t,"t2","dot");Bve((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(Bve(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){const e=kEe(n,[1,-1]),t=kEe(r,[-1,1]),a=NEe(e,t);return kEe(a,[])}if(1===n.rank&&2===r.rank){const e=kEe(n,[1,-1]),t=kEe(r,[r.shape[0],r.shape[1]]),a=NEe(e,t);return kEe(a,[a.size])}if(2===n.rank&&1===r.rank){const e=kEe(r,[-1,1]),t=NEe(n,e);return kEe(t,[t.size])}{const e=kEe(r,[r.shape[0],r.shape[1]]);return NEe(n,e)}}});const hAe=uCe({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(((e,t)=>iCe(e,`tensors${t}`,"einsum"))),s={equation:e};return QIe.runKernel(kwe,a,s)}});const pAe=uCe({elu_:function(e){const t={x:iCe(e,"x","elu","float32")};return QIe.runKernel(Swe,t)}});const fAe=uCe({ensureShape_:function(e,t){const n=iCe(e,"x","ensureShape","string_or_numeric");if(!function(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});const mAe=uCe({erf_:function(e){let t=iCe(e,"x","erf");Bve("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=NNe(t,"float32"));const n={x:t};return QIe.runKernel(Cwe,n)}});function gAe(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function yAe(e,t,n){const r=e.length+t.length,a=[];let s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function bAe(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function vAe(e,t){return yAe(e,t.map((e=>1)),t)}function xAe(e,t,n){Bve(gAe(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function wAe(e,t){if(gAe(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function kAe(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function SAe(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const IAe=uCe({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:iCe(e,"x","max")},a={reductionIndices:t,keepDims:n};return QIe.runKernel(rke,r,a)}});const CAe=uCe({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:iCe(e,"x","min")},a={axis:t,keepDims:n};return QIe.runKernel(dke,r,a)}});const NAe=uCe({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=iCe(e,"x","sum");"bool"===r.dtype&&(r=NNe(r,"int32"));const a={x:r},s={axis:t,keepDims:n};return QIe.runKernel(rSe,a,s)}});function TAe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return YNe(e);if(1!==e.rank&&null===n)return TAe(kEe(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return NAe(YNe(e),n);if(t===1/0)return IAe(YNe(e),n);if(t===-1/0)return CAe(YNe(e),n);if("euclidean"===t||2===t)return DNe(NAe(qNe(YNe(e),PNe(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return IAe(NAe(YNe(e),n[0]),n[1]-1);if(t===1/0)return IAe(NAe(YNe(e),n[1]),n[0]);if(t===-1/0)return CAe(NAe(YNe(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return DNe(NAe(MNe(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const EAe=uCe({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=TAe(e=iCe(e,"x","norm"),t,n);let s=a.shape;if(r){const t=Yve(n,e.shape);s=vAe(a.shape,t)}return kEe(a,s)}});const AAe=uCe({euclideanNorm_:function(e){return EAe(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const _Ae=uCe({exp_:function(e){const t={x:iCe(e,"x","exp")};return QIe.runKernel(Twe,t)}});const $Ae=uCe({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=iCe(e,"x","expandDims","string_or_numeric");Bve(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:t};return QIe.runKernel(Ewe,r,a)}});const RAe=uCe({expm1_:function(e){const t={x:iCe(e,"x","expm1")};return QIe.runKernel(Awe,t)}});const DAe=uCe({tile_:function(e,t){const n=iCe(e,"x","tile","string_or_numeric");Bve(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},a={reps:t};return QIe.runKernel(kSe,r,a)}});const MAe=uCe({eye_:function(e,t,n){null==t&&(t=e);const r=CNe([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=e<=t?e:t;for(let i=0;i<a;++i)r.set(1,i,i);const s=kEe(r.toTensor(),[e,t]);if(null==n)return s;if(1===n.length)return DAe($Ae(s,0),[n[0],1,1]);if(2===n.length)return DAe($Ae($Ae(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return DAe($Ae($Ae($Ae(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const FAe=uCe({floor_:function(e){const t={x:iCe(e,"x","floor","float32")};return QIe.runKernel(Dwe,t)}});const OAe=uCe({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a={x:iCe(e,"x","gather"),indices:iCe(t,"indices","gather","int32")},s={axis:n,batchDims:r};return QIe.runKernel(Owe,a,s)}});const PAe=uCe({greater_:function(e,t){let n=iCe(e,"a","greater","string_or_numeric"),r=iCe(t,"b","greater","string_or_numeric");[n,r]=UIe(n,r),ZNe(n.shape,r.shape);const a={a:n,b:r};return QIe.runKernel(Lwe,a)}});const LAe=uCe({greaterEqual_:function(e,t){let n=iCe(e,"a","greaterEqual","string_or_numeric"),r=iCe(t,"b","greaterEqual","string_or_numeric");[n,r]=UIe(n,r),ZNe(n.shape,r.shape);const a={a:n,b:r};return QIe.runKernel(zwe,a)}});const zAe=uCe({imag_:function(e){const t={input:iCe(e,"input","imag")};return QIe.runKernel(Vwe,t)}});const BAe=uCe({isFinite_:function(e){const t={x:iCe(e,"x","isFinite")};return QIe.runKernel(Uwe,t)}});const WAe=uCe({isInf_:function(e){const t={x:iCe(e,"x","isInf")};return QIe.runKernel(jwe,t)}});const VAe=uCe({isNaN_:function(e){const t={x:iCe(e,"x","isNaN")};return QIe.runKernel(Gwe,t)}});const UAe=uCe({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:iCe(e,"x","leakyRelu")},r={alpha:t};return QIe.runKernel(Hwe,n,r)}});const jAe=uCe({less_:function(e,t){let n=iCe(e,"a","less","string_or_numeric"),r=iCe(t,"b","less","string_or_numeric");[n,r]=UIe(n,r),ZNe(n.shape,r.shape);const a={a:n,b:r};return QIe.runKernel(qwe,a)}});const GAe=uCe({lessEqual_:function(e,t){let n=iCe(e,"a","lessEqual","string_or_numeric"),r=iCe(t,"b","lessEqual","string_or_numeric");[n,r]=UIe(n,r),ZNe(n.shape,r.shape);const a={a:n,b:r};return QIe.runKernel(Kwe,a)}});function HAe(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return QIe.runKernel(Xwe,{},r)}const qAe=uCe({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const s=iCe(e,"x","localResponseNormalization");Bve(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),Bve(Gve(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=s,o=!1;3===s.rank&&(o=!0,i=kEe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:a},c=QIe.runKernel(tke,l,u);return o?kEe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const KAe=uCe({log_:function(e){const t={x:iCe(e,"x","log","float32")};return QIe.runKernel(Ywe,t)}});const XAe=uCe({log1p_:function(e){const t={x:iCe(e,"x","log1p")};return QIe.runKernel(Qwe,t)}});const YAe=uCe({neg_:function(e){const t={x:iCe(e,"x","neg")};return QIe.runKernel(yke,t)}});const QAe=uCe({softplus_:function(e){const t={x:iCe(e,"x","softplus")};return QIe.runKernel(tSe,t)}});const JAe=uCe({logSigmoid_:function(e){const t=iCe(e,"x","logSigmoid"),n=ONe((e=>({value:YAe(QAe(YAe(e))),gradFunc:t=>RNe(t,TEe(YAe(e)))})));return n(t)}});const ZAe=uCe({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=iCe(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=ONe(((e,n)=>{const r=IAe(e,t,!0),a=KNe(e,r),s=KNe(NNe(a,"float32"),KAe(NAe(_Ae(a),t,!0)));n([s]);return{value:s,gradFunc:(e,n)=>{const[r]=n,a=_Ae(r);return KNe(e,RNe(NAe(e,t,!0),a))}}}));return r(n)}});const e_e=uCe({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=iCe(e,"x","logSumExp"),a=Yve(t,r.shape),s=IAe(r,a,!0),i=KNe(r,s),o=_Ae(i),l=NAe(o,a),u=KAe(l),c=ANe(kEe(s,u.shape),u);if(n){const e=vAe(c.shape,a);return kEe(c,e)}return c}});const t_e=uCe({logicalAnd_:function(e,t){const n=iCe(e,"a","logicalAnd","bool"),r=iCe(t,"b","logicalAnd","bool");ZNe(n.shape,r.shape);const a={a:n,b:r};return QIe.runKernel(Jwe,a)}});const n_e=uCe({logicalNot_:function(e){const t={x:iCe(e,"x","logicalNot","bool")};return QIe.runKernel(Zwe,t)}});const r_e=uCe({logicalOr_:function(e,t){const n=iCe(e,"a","logicalOr","bool"),r=iCe(t,"b","logicalOr","bool");ZNe(n.shape,r.shape);const a={a:n,b:r};return QIe.runKernel(eke,a)}});const a_e=uCe({logicalXor_:function(e,t){const n=iCe(e,"a","logicalXor","bool"),r=iCe(t,"b","logicalXor","bool");return ZNe(n.shape,r.shape),t_e(r_e(e,t),n_e(t_e(e,t)))}}),s_e=2147483648;const i_e=uCe({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const r=iCe(e,"sortedSequence","searchSorted"),a=iCe(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=kEe(r,[-1,s]),l=kEe(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Uve(l.shape)>=s_e)throw new Error("values tensor size must less than 2147483648");if(o.shape[1]>=s_e)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);const u={sortedSequence:o,values:l},c={side:n};return QIe.runKernel(qke,u,c)}});function o_e(e,t){return i_e(e,t,"left")}const l_e=uCe({maxPool_:function(e,t,n,r,a){const s=iCe(e,"x","maxPool");let i=s,o=!1;3===s.rank&&(o=!0,i=kEe(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Bve(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),Bve(bEe(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),wEe("maxPool",r,a);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=QIe.runKernel(ske,l,u);return o?kEe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const u_e=uCe({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=iCe(e,"x","maxPool3d");let o=i,l=!1;4===i.rank&&(l=!0,o=kEe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Bve(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),Bve("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),wEe("maxPool3d",r,a);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=QIe.runKernel(oke,u,c);return l?kEe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const c_e=uCe({maxPoolWithArgmax_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const s={x:iCe(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=QIe.runKernel(uke,s,i);return{result:o[0],indexes:o[1]}}});const d_e=uCe({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:iCe(e,"x","mean")},a={axis:t,keepDims:n};return QIe.runKernel(cke,r,a)}});function h_e(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(pxe(e),"complex64"===t){const t=h_e(e,"float32"),n=h_e(e,"float32");return cCe(t,n)}const n=dxe(Uve(e),t);return QIe.makeTensor(n,e,t)}function p_e(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(pxe(e),"complex64"===t){const t=p_e(e,"float32"),n=h_e(e,"float32");return cCe(t,n)}const n=cxe(Uve(e),t);return QIe.makeTensor(n,e,t)}function f_e(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=iCe(e,"x","meshgrid",e instanceof _Ie?e.dtype:"float32");if(void 0===t)return[r];let a=iCe(t,"y","meshgrid",t instanceof _Ie?t.dtype:"float32");const s=Uve(r.shape),i=Uve(a.shape);return"xy"===n?(r=kEe(r,[1,-1]),a=kEe(a,[-1,1]),[NEe(p_e([i,1],r.dtype),r),NEe(a,p_e([1,s],a.dtype))]):(r=kEe(r,[-1,1]),a=kEe(a,[1,-1]),[NEe(r,p_e([1,i],r.dtype)),NEe(p_e([s,1],a.dtype),a)])}const m_e=uCe({minimum_:function(e,t){let n=iCe(e,"a","minimum"),r=iCe(t,"b","minimum");[n,r]=UIe(n,r),"bool"===n.dtype&&(n=NNe(n,"int32"),r=NNe(r,"int32")),ZNe(n.shape,r.shape);const a={a:n,b:r};return QIe.runKernel(hke,a)}});const g_e=uCe({mirrorPad_:function(e,t,n){Bve("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=iCe(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Bve(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const a="reflect"===n?1:0;for(let o=0;o<r.rank;o++)Bve(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Bve(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`));const s={paddings:t,mode:n},i={x:r};return QIe.runKernel(pke,i,s)}});const y_e=uCe({mod_:function(e,t){let n=iCe(e,"a","mod"),r=iCe(t,"b","mod");[n,r]=UIe(n,r);const a={a:n,b:r};return QIe.runKernel(fke,a)}});const b_e=uCe({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Yve(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=iCe(e,"x","moments")).shape),r=d_e(e,n,t);let a=r.shape;t||(a=vAe(r.shape,n));const s=MNe(KNe(NNe(e,"float32"),kEe(r,a)));return{mean:r,variance:d_e(s,n,t)}}});const v_e=uCe({multiRNNCell_:function(e,t,n,r){const a=iCe(t,"data","multiRNNCell"),s=oCe(n,"c","multiRNNCell"),i=oCe(r,"h","multiRNNCell");let o=a;const l=[];for(let d=0;d<e.length;d++){const t=e[d](o,s[d],i[d]);l.push(t[0]),l.push(t[1]),o=t[1]}const u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}});const x_e=uCe({multinomial_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=iCe(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?kEe(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=QIe.runKernel(mke,o,l);return 1===i?kEe(u,[u.size]):u}});const w_e=uCe({notEqual_:function(e,t){let n=iCe(e,"a","notEqual","string_or_numeric"),r=iCe(t,"b","notEqual","string_or_numeric");[n,r]=UIe(n,r),ZNe(n.shape,r.shape);const a={a:n,b:r};return QIe.runKernel(bke,a)}});const k_e=uCe({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const s={indices:iCe(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return QIe.runKernel(Ske,s,i)}});const S_e=uCe({onesLike_:function(e){const t={x:iCe(e,"x","onesLike")};return QIe.runKernel(kke,t)}});const I_e=uCe({outerProduct_:function(e,t){const n=iCe(e,"v1","outerProduct"),r=iCe(t,"v2","outerProduct");Bve(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const a=kEe(n,[-1,1]),s=kEe(r,[1,-1]);return NEe(a,s)}});const C_e=uCe({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=iCe(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:t,constantValue:n},s={x:r};return QIe.runKernel(Cke,s,a)}});const N_e=uCe({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Bve(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),C_e(e,[t],n)}});const T_e=uCe({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Bve(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),C_e(e,t,n)}});const E_e=uCe({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Bve(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),C_e(e,t,n)}});const A_e=uCe({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Bve(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),C_e(e,t,n)}});const __e=uCe({spaceToBatchND_:function(e,t,n){const r=iCe(e,"x","spaceToBatchND");Bve(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),Bve(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),Bve(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const a={x:r},s={blockShape:t,paddings:n};return QIe.runKernel(aSe,a,s)}});const $_e=uCe({pool_:function(e,t,n,r,a,s,i){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");const o=iCe(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=kEe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Bve(bEe(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));const c=lEe(l.shape,t,s,a,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),a=r.map((e=>Math.floor(e/2))),s=r.map(((e,t)=>e-a[t]));return r.map(((e,t)=>[a[t],s[t]]))}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),i=t.map(((e,t)=>(e-s[t]%e)%e)),o=a.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([c.inHeight,c.inWidth],d,h),g=p?r:"valid",y=p?l:__e(l,d,f),b=("avg"===n?()=>SEe(y,t,s,g,i):()=>l_e(y,t,s,g,i))(),v=p?b:$Ee(b,d,m);return u?kEe(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});const R_e=uCe({prelu_:function(e,t){const n={x:iCe(e,"x","prelu"),alpha:iCe(t,"alpha","prelu")};return QIe.runKernel(Tke,n)}});const D_e=uCe({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=iCe(e,"x","prod");"bool"===r.dtype&&(r=NNe(r,"int32"));const a={x:r},s={axis:t,keepDims:n};return QIe.runKernel(Eke,a,s)}});const M_e=uCe({raggedGather_:function(e,t,n,r){const a={paramsNestedSplits:e.map(((e,t)=>iCe(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:iCe(t,"paramsDenseValues","raggedGather"),indices:iCe(n,"indices","raggedGather","int32")},s={outputRaggedRank:r},i=QIe.runKernel(Ake,a,s);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const F_e=uCe({raggedRange_:function(e,t,n){const r=iCe(e,"starts","raggedRange"),a={starts:r,limits:iCe(t,"limits","raggedRange",r.dtype),deltas:iCe(n,"deltas","raggedRange",r.dtype)},s=QIe.runKernel(_ke,a);return{rtNestedSplits:s[0],rtDenseValues:s[1]}}});const O_e=uCe({raggedTensorToTensor_:function(e,t,n,r,a){const s=iCe(e,"shape","raggedTensorToTensor","int32"),i=iCe(t,"values","raggedTensorToTensor"),o={shape:s,values:i,defaultValue:iCe(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>iCe(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:a};return QIe.runKernel($ke,o,l)}});const P_e=uCe({rand_:function(e,t,n){pxe(e);const r=Uve(e);let a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let s=0;s<r;s++)a[s]=t();return QIe.makeTensor(a,e,n)}});var L_e=n(4334);class z_e{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=L_e.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class B_e{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const a=r||Math.random();this.randu=L_e.alea(a.toString()),this.randn=new z_e(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class W_e{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=L_e.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const V_e=uCe({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;if(pxe(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const s=new B_e(t,n,r,a),i=CNe(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const U_e=uCe({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(pxe(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const s=new z_e(t,n,r,!1,a),i=CNe(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const j_e=uCe({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return U_e(e,0,1,t,n)}});const G_e=uCe({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;pxe(e);const s=CNe(e,r),i=new W_e(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});const H_e=uCe({randomUniformInt_:function(e,t,n,r){return G_e(e,t,n,"int32",r)}});function q_e(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:e,stop:t,step:n,dtype:r};return QIe.runKernel(Rke,{},a)}const K_e=uCe({real_:function(e){const t={input:iCe(e,"input","real")};return QIe.runKernel(Dke,t)}});const X_e=uCe({reciprocal_:function(e){const t={x:iCe(e,"x","reciprocal")};return QIe.runKernel(Mke,t)}});const Y_e=uCe({relu_:function(e){const t={x:iCe(e,"x","relu")};return QIe.runKernel(Fke,t)}});const Q_e=uCe({relu6_:function(e){const t={x:iCe(e,"x","relu6")};return QIe.runKernel(Wke,t)}});const J_e=uCe({reverse_:function(e,t){const n={x:iCe(e,"x","reverse")},r={dims:t};return QIe.runKernel(Vke,n,r)}});const Z_e=uCe({reverse1d_:function(e){const t=iCe(e,"x","reverse");return Bve(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),J_e(t,0)}});const e$e=uCe({reverse2d_:function(e,t){const n=iCe(e,"x","reverse");return Bve(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),J_e(n,t)}});const t$e=uCe({reverse3d_:function(e,t){const n=iCe(e,"x","reverse");return Bve(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),J_e(n,t)}});const n$e=uCe({reverse4d_:function(e,t){const n=iCe(e,"x","reverse");return Bve(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),J_e(n,t)}});const r$e=uCe({round_:function(e){const t={x:iCe(e,"x","round")};return QIe.runKernel(Uke,t)}});const a$e=uCe({rsqrt_:function(e){const t={x:iCe(e,"x","rsqrt","float32")};return QIe.runKernel(jke,t)}});const s$e=uCe({selu_:function(e){const t={x:iCe(e,"x","selu")};return QIe.runKernel(Xke,t)}});const i$e=uCe({separableConv2d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const o=iCe(e,"x","separableConv2d"),l=iCe(t,"depthwiseFilter","separableConv2d"),u=iCe(n,"pointwiseFilter","separableConv2d");let c=o,d=!1;if(3===o.rank&&(d=!0,c=kEe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Bve(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),Bve(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),Bve(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),Bve(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),Bve(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const h=l.shape[2],p=l.shape[3];Bve(u.shape[2]===h*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`));const f=sAe(c,l,r,a,i,s),m=HEe(f,u,1,"valid",i);return d?kEe(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const o$e=async function(e,t){const n=iCe(e,"x","setdiff1d"),r=iCe(t,"y","setdiff1d");Bve(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),Bve(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),Bve(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const a=await n.data(),s=await r.data(),i=new Set(s);let o=0;for(let c=0;c<a.length;c++)i.has(a[c])||o++;const l=new NIe([o],n.dtype),u=new NIe([o],"int32");for(let c=0,d=0;c<a.length;c++)i.has(a[c])||(l.values[d]=a[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]};const l$e=uCe({sign_:function(e){const t={x:iCe(e,"x","sign")};return QIe.runKernel(Zke,t)}});const u$e=uCe({sin_:function(e){const t={x:iCe(e,"x","sin","float32")};return QIe.runKernel(Qke,t)}});const c$e=uCe({sinh_:function(e){const t={x:iCe(e,"x","sinh")};return QIe.runKernel(Jke,t)}});const d$e=uCe({slice1d_:function(e,t,n){const r=iCe(e,"x","slice1d");return Bve(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),EEe(r,[t],[n])}});const h$e=uCe({slice2d_:function(e,t,n){const r=iCe(e,"x","slice2d");return Bve(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),EEe(r,t,n)}});const p$e=uCe({slice3d_:function(e,t,n){const r=iCe(e,"x","slice3d");return Bve(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),EEe(r,t,n)}});const f$e=uCe({slice4d_:function(e,t,n){const r=iCe(e,"x","slice4d");return Bve(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),EEe(r,t,n)}});const m$e=uCe({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=iCe(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},a={dim:t};return QIe.runKernel(iSe,r,a)}});const g$e=uCe({fft_:function(e){Bve("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return QIe.runKernel(_we,t)}});const y$e=uCe({ifft_:function(e){Bve("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return QIe.runKernel(Wwe,t)}});const b$e=uCe({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const a=kEe(e,[n,t]);r=y$e(a)}else{const a=[n,2*(t-1)],s=kEe(K_e(e),[n,t]),i=kEe(zAe(e),[n,t]),o=J_e(EEe(s,[0,1],[n,t-2]),1),l=RNe(J_e(EEe(i,[0,1],[n,t-2]),1),PNe(-1)),u=CEe([s,o],1),c=CEe([i,l],1),d=kEe(cCe(u,c),[a[0],a[1]]);r=y$e(d)}if(r=K_e(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=kEe(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const v$e=uCe({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:iCe(e,"x","split")},a={numOrSizeSplits:t,axis:n};return QIe.runKernel(sSe,r,a)}});const x$e=uCe({rfft_:function(e,t){Bve("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let a;if(null!=t&&t<n){const r=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,a=EEe(e,r,s),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,a=CEe([e,h_e(r)],e.shape.length-1),n=t}else a=e;const s=FNe(a),i=kEe(cCe(a,s),[r,n]),o=g$e(i),l=Math.floor(n/2)+1,u=K_e(o),c=zAe(o),d=v$e(u,[l,n-l],u.shape.length-1),h=v$e(c,[l,n-l],c.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,kEe(cCe(d[0],h[0]),p)}});const w$e=uCe({squaredDifference_:function(e,t){let n=iCe(e,"a","squaredDifference"),r=iCe(t,"b","squaredDifference");[n,r]=UIe(n,r),ZNe(n.shape,r.shape);const a={a:n,b:r};return QIe.runKernel(hSe,a,{})}});const k$e=uCe({squeeze_:function(e,t){const n=iCe(e,"x","squeeze","string_or_numeric");return kEe(n,Qve(n.shape,t).newShape)}});const S$e=uCe({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=oCe(e,"tensors","stack","string_or_numeric");Bve(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Bve(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:t};return QIe.runKernel(Ike,r,a)}});const I$e=uCe({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:iCe(e,"x","step")},r={alpha:t};return QIe.runKernel(_Se,n,r)}});const C$e=uCe({stridedSlice_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const u={x:iCe(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return QIe.runKernel(mSe,u,c)}});const N$e=uCe({tan_:function(e){const t={x:iCe(e,"x","tan","float32")};return QIe.runKernel(xSe,t)}});function T$e(e,t){Vve(e);const n=rCe(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return dCe(e,null,n,t)}function E$e(e,t,n){if(Vve(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=rCe(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return dCe(e,t,r,n)}function A$e(e,t,n){if(Vve(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=rCe(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return dCe(e,t,r,n)}function _$e(e,t,n){if(Vve(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=rCe(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return dCe(e,t,r,n)}function $$e(e,t,n){if(Vve(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=rCe(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return dCe(e,t=t||r,r,n)}function R$e(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function D$e(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}R$e(n,t,e)}function M$e(e,t,n){const r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length;let i=1;for(let l=a;l<s;++l)i*=n[l];const o=a<1?1:a;return{sliceRank:a,numUpdates:Uve(t.shape)/o,sliceSize:i,strides:[...oxe(n.slice(0,a)),1],outputSize:Uve(n)}}const F$e=uCe({tensorScatterUpdate_:function(e,t,n){const r=iCe(e,"tensor","tensorScatterupdate"),a=iCe(t,"indices","tensorScatterupdate","int32"),s=iCe(n,"updates","tensorScatterupdate");if(D$e(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);const i={tensor:r,indices:a,updates:s};return QIe.runKernel(Hke,i,{})}});const O$e=uCe({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=iCe(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);const s={x:r},i={k:t,sorted:n},[o,l]=QIe.runKernel(SSe,s,i);return{values:o,indices:l}}});const P$e=uCe({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(pxe(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new z_e(t,n,r,!0,a),i=CNe(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const L$e=uCe({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=iCe(e,"x","unique","string_or_numeric");Bve(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},a={axis:t},[s,i]=QIe.runKernel(NSe,r,a);return{values:s,indices:i}}});const z$e=uCe({unsortedSegmentSum_:function(e,t,n){const r=iCe(e,"x","unsortedSegmentSum"),a=iCe(t,"segmentIds","unsortedSegmentSum","int32");Bve(Gve(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:a},i={numSegments:n};return QIe.runKernel(ESe,s,i)}});const B$e=uCe({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=iCe(e,"x","unstack","string_or_numeric");Bve(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},a={axis:t};return QIe.runKernel(TSe,r,a)}});function W$e(e,t){return i_e(e,t,"right")}function V$e(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return QIe.makeVariable(e,t,n,r)}function U$e(e,t){const n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);const r=CNe(e,"int32"),a=CNe([n.length,e.length],"int32");for(let s=0;s<n.length;s++){const t=r.indexToLoc(n[s]),i=s*e.length;a.values.set(t,i)}return a.toTensor()}const j$e=async function(e){const t=iCe(e,"condition","whereAsync","bool"),n=await t.data(),r=U$e(t.shape,n);return e!==t&&t.dispose(),r};const G$e=async function(e,t,n){const r=iCe(e,"tensor","boolMask"),a=iCe(t,"mask","boolMask","bool"),s=null==n?0:n,i=a.rank,o=r.shape;Bve(i>0,(()=>"mask cannot be scalar")),Wve(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];const u=o.slice(0,s).concat([l],o.slice(s+i)),c=kEe(r,u),d=kEe(a,[-1]),h=await j$e(d),p=k$e(h,[1]),f=OAe(c,p,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f};const H$e=uCe({transpose_:function(e,t,n){const r=iCe(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Bve(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{Bve(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const a={x:r},s={perm:t};return"complex64"===r.dtype?yCe((()=>{let e=K_e(r),t=zAe(r);return e=QIe.runKernel(CSe,{x:e},s),t=QIe.runKernel(CSe,{x:t},s),n&&(t=YAe(t)),cCe(e,t)})):QIe.runKernel(CSe,a,s)}});const q$e=uCe({movingAverage_:function(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const s=iCe(e,"v","movingAverage"),i=iCe(t,"x","movingAverage"),o=iCe(n,"decay","movingAverage");!function(e,t){Bve(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}(s,i),Bve(jve(s.shape,i.shape),(()=>"Shape mismatch in v and x"));const l=PNe(1),u=KNe(l,o);let c=RNe(KNe(i,s),u);if(a){Bve(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=iCe(r,"step","movingAverage");c=$Ne(c,KNe(l,qNe(o,e)))}return ANe(s,c)}});const K$e=uCe({scatterND_:function(e,t,n){pxe(n);const r=iCe(e,"indices","scatterND","int32"),a=iCe(t,"updates","scatterND");D$e(a,r,n);const s={indices:r,updates:a},i={shape:n};return QIe.runKernel(Gke,s,i)}});const X$e=uCe({sparseToDense_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;pxe(n);const a=iCe(e,"sparseIndices","sparseToDense","int32"),s=iCe(t,"sparseValues","sparseToDense","string_or_numeric"),i=iCe(r,"defaultValue","sparseToDense",s.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,s,n,i);const o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return QIe.runKernel(dSe,o,l)}});const Y$e=uCe({gatherND_:function(e,t){const n=iCe(t,"indices","gatherND","int32"),r={params:iCe(e,"x","gatherND","string_or_numeric"),indices:n};return QIe.runKernel(Pwe,r)}});const Q$e=uCe({dropout_:function(e,t,n,r){const a=iCe(e,"x","dropout");if(Bve("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),Bve(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof _Ie?a.clone():a;const s=function(e,t){if(null==t)return e.shape.slice();if(jve(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),i=1-t,o=$Ne(FAe(ANe(G_e(s,0,1,"float32",r),i)),i);return RNe(a,o)}});function J$e(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Z$e(e,t,n){const r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){const i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return T$e(a,"float32")}const eRe=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const r=iCe(e,"predictions","inTopK"),a=iCe(t,"targets","inTopK");Bve(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),Bve(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),Wve(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];Bve(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));const i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],c=Jve("bool",l);for(let d=0;d<l;d++){const e=d*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),c[d]=0;for(let a=0;a<n;a++)if(r[a].index===o[d]){c[d]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),hCe(c,a.shape,"bool")};const tRe=uCe({conv2DBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=kEe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=kEe(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Bve(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),Bve(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),Bve(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===s?o.shape[3]:o.shape[1],c="NHWC"===s?l.shape[3]:l.shape[1];Bve(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),Bve(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),wEe("conv2dDerFilter",a,i);const d={x:o,dy:l},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return QIe.runKernel(twe,d,h)}});function nRe(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return RNe(e,I$e(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function rRe(e,t){let n=t;const r=JNe(e.shape,t.shape);return r.length>0&&(n=NAe(n,r)),kEe(n,e.shape)}function aRe(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Y_e(e);if("elu"===t)return pAe(e);if("relu6"===t)return Q_e(e);if("prelu"===t)return R_e(e,n);if("leakyrelu"===t)return UAe(e,r);if("sigmoid"===t)return TEe(e);throw new Error(`Unknown fused activation ${t}.`)}const sRe=(e,t)=>!(e>0)||"linear"===t;const iRe=uCe({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(u=u||"linear",!1===sRe(QIe.state.gradientDepth,u)){Bve("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=HEe(t,n,r,a,s,i,o);return null!=l&&(e=ANe(e,l)),aRe(e,u,c,d)}const h=iCe(t,"x","conv2d","float32"),p=iCe(n,"filter","conv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=kEe(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Bve(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),Bve(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),wEe("fused conv2d",a,o);const g="NHWC"===s?f.shape[3]:f.shape[1];Bve(p.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`)),Bve(bEe(r,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`));const y=cEe(f.shape,p.shape,r,i,a,o);let b,v;if(null!=l&&(b=iCe(l,"bias","fused conv2d"),[b]=UIe(b,h),"NHWC"===s?ZNe(y.outShape,b.shape):(Bve(b.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`)),Bve(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)))),null!=c){const e=c.shape;if(Bve(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)Bve(1===e[0]||e[0]===y.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${y.outChannels}).`));else if(3===e.length)try{ZNe(e,y.outShape)}catch(mD){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(n)}v=iCe(c,"prelu weights","fused conv2d")}const x=(e,t)=>{Bve("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));const[n,o,l,c]=t,d=nRe(e,l,u);Bve(yEe(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));const h=[KEe(o.shape,d,n,r,a),tRe(o,d,n.shape,r,a)];if(null!=c){const e=rRe(c,d);h.push(e)}return h},w={x:f,filter:p,bias:b,preluActivationWeights:v},k={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};if(null==l){const e=ONe(((e,t,n)=>{let r=QIe.runKernel(MSe,w,k);return n([t,e,r]),m&&(r=kEe(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p)}{const e=ONe(((e,t,n,r)=>{let a=QIe.runKernel(MSe,w,k);return r([t,e,a,n]),m&&(a=kEe(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}));return e(f,p,b)}}});const oRe=uCe({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=kEe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=kEe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return QIe.runKernel(fwe,u,c)}});const lRe=uCe({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,l=!1;3===t.rank&&(l=!0,o=kEe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},d=QIe.runKernel(mwe,u,c);return l?kEe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const uRe=uCe({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(!1===sRe(QIe.state.gradientDepth,u)){let e=sAe(t,n,r,a,s,i,o);return null!=l&&(e=ANe(e,l)),aRe(e,u,c,d)}const h=iCe(t,"x","depthwiseConv2d","float32"),p=iCe(n,"filter","depthwiseConv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=kEe(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Bve(4===f.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`)),Bve(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),Bve(f.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==i&&(i=[1,1]),Bve(bEe(r,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`)),wEe("fused depthwiseConv2d",a,o);const g=cEe(f.shape,p.shape,r,i,a,o,!0);let y,b;null!=l&&(y=iCe(l,"bias","fused conv2d"),[y]=UIe(y,h),ZNe(g.outShape,y.shape)),null!=c&&(b=iCe(c,"prelu weights","fused depthwiseConv2d"));const v=(e,t)=>{Bve(yEe(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[n,s,l,c]=t,d=nRe(e,l,u),h=lRe(s.shape,d,n,r,a,i,o),p=oRe(s,d,n.shape,r,a,i,o);if(null!=c){return[h,p,rRe(y,d)]}return[h,p]},x={x:f,filter:p,bias:y,preluActivationWeights:b},w={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};if(null==l){const e=ONe(((e,t,n)=>{let r=QIe.runKernel(FSe,x,w);return n([t,e,r]),m&&(r=kEe(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p)}{const e=ONe(((e,t,n,r)=>{let a=QIe.runKernel(FSe,x,w);return r([t,e,a,n]),m&&(a=kEe(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return e(f,p,y)}}});const cRe=uCe({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}=e;if(!1===sRe(QIe.state.gradientDepth,i)){let e=NEe(t,n,r,a);return null!=s&&(e=ANe(e,s)),aRe(e,i,o,l)}let u=iCe(t,"a","fused matMul"),c=iCe(n,"b","fused matMul");[u,c]=UIe(u,c);const d=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=a?c.shape[c.rank-1]:c.shape[c.rank-2],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=a?c.shape[c.rank-2]:c.shape[c.rank-1],m=u.shape.slice(0,-2),g=c.shape.slice(0,-2),y=Uve(m),b=Uve(g);Bve(d===h,(()=>`Error in fused matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${r} and transposeB=${a} must match.`));const v=ZNe(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),x=kEe(u,r?[y,d,p]:[y,p,d]),w=kEe(c,a?[b,f,h]:[b,h,f]);let k,S;null!=s&&(k=iCe(s,"bias","fused matMul"),[k]=UIe(k,u),ZNe(v,k.shape)),null!=o&&(S=iCe(o,"prelu weights","fused matMul"));const I=(e,t)=>{const[n,o,l,u]=t,c=nRe(kEe(e,l.shape),l,i);let d,h;if(r||a?!r&&a?(d=NEe(c,o,!1,!1),h=NEe(c,n,!0,!1)):r&&!a?(d=NEe(o,c,!1,!0),h=NEe(n,c,!1,!1)):(d=NEe(o,c,!0,!0),h=NEe(c,n,!0,!0)):(d=NEe(c,o,!1,!0),h=NEe(n,c,!0,!1)),null!=s){return[d,h,rRe(u,c)]}return[d,h]},C={a:x,b:w,bias:k,preluActivationWeights:S},N={transposeA:r,transposeB:a,activation:i,leakyreluAlpha:l};if(null==s){const e=ONe(((e,t,n)=>{const r=QIe.runKernel(DSe,C,N);return n([e,t,r]),{value:kEe(r,v),gradFunc:I}}));return e(x,w)}{const e=ONe(((e,t,n,r)=>{const a=QIe.runKernel(DSe,C,N);return r([e,t,a,n]),{value:kEe(a,v),gradFunc:I}}));return e(x,w,k)}}});const dRe=uCe({hammingWindow_:function(e){return Z$e(e,.54,.46)}});const hRe=uCe({hannWindow_:function(e){return Z$e(e,.5,.5)}});const pRe=uCe({frame_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0;const i=[];for(;s+t<=e.size;)i.push(EEe(e,s,t)),s+=n;if(r)for(;s<e.size;){const r=s+t-e.size,o=CEe([EEe(e,s,t-r),GNe([r],a)]);i.push(o),s+=n}return 0===i.length?E$e([],[0,t]):kEe(CEe(i),[i.length,t])}});const fRe=uCe({stft_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:hRe;null==r&&(r=J$e(t));const s=pRe(e,t,n),i=RNe(s,a(t));return x$e(i,r)}});const mRe=uCe({cropAndResize_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=iCe(e,"image","cropAndResize"),o=iCe(t,"boxes","cropAndResize","float32"),l=iCe(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Bve(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),Bve(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),Bve(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),Bve(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Bve(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Bve("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));const c={image:i,boxes:o,boxInd:l},d={method:a,extrapolationValue:s,cropSize:r};return QIe.runKernel(cwe,c,d)}});const gRe=uCe({flipLeftRight_:function(e){const t=iCe(e,"image","flipLeftRight","float32");Bve(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return QIe.runKernel(Rwe,n,{})}});const yRe=uCe({grayscaleToRGB_:function(e){const t=iCe(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Bve(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),Bve(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,DAe(t,a)}});const bRe=uCe({rgbToGrayscale_:function(e){const t=iCe(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Bve(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),Bve(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const a=t.dtype,s=NNe(t,"float32"),i=T$e([.2989,.587,.114]);let o;switch(t.rank){case 2:o=hAe("ij,j->i",s,i);break;case 3:o=hAe("ijk,k->ij",s,i);break;case 4:o=hAe("ijkl,l->ijk",s,i);break;case 5:o=hAe("ijklm,m->ijkl",s,i);break;case 6:o=hAe("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=$Ae(o,-1),NNe(o,a)}});const vRe=uCe({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=iCe(e,"image","rotateWithOffset","float32");Bve(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));const s={image:a},i={radians:t,fillValue:n,center:r};return QIe.runKernel(RSe,s,i)}});function xRe(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const i=e.shape[0];return n=Math.min(n,i),Bve(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Bve(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),Bve(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),Bve(1===t.rank,(()=>"scores must be a 1D tensor")),Bve(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),Bve(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}const wRe=uCe({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=iCe(e,"boxes","nonMaxSuppression","float32"),i=iCe(t,"scores","nonMaxSuppression","float32"),o=xRe(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return QIe.runKernel(vke,{boxes:s,scores:i},l)}});function kRe(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);const o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}(e,t,n||SRe)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function SRe(e,t){return e>t?1:e<t?-1:0}function IRe(e,t,n,r,a){return TRe(e,t,n,r,a,0)}function CRe(e,t,n,r,a,s){return TRe(e,t,n,r,a,0,!1,s,!0)}function NRe(e,t,n,r,a,s){return TRe(e,t,n,r,a,s,!0)}function TRe(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(_Re);const c=s>0?-.5/s:0,d=[],h=[];for(;d.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<a)break;let o=!1;for(let l=d.length-1;l>=i;--l){const n=ERe(e,s,d[l]);if(n>=r){o=!0;break}if(t.score=t.score*ARe(r,c,n),t.score<=a)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(s),h.push(t.score)):t.score>a&&kRe(u,t,_Re))}const p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function ERe(e,t,n){const r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),h=Math.max(a[1],a[3]),p=(o-s)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(s,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function ARe(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function _Re(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const $Re=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=iCe(e,"boxes","nonMaxSuppressionAsync"),i=iCe(t,"scores","nonMaxSuppressionAsync"),o=xRe(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;const l=await Promise.all([s.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=IRe(u,c,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),T$e(d,"int32")};const RRe=uCe({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=iCe(e,"boxes","nonMaxSuppression"),o=iCe(t,"scores","nonMaxSuppression"),l=xRe(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},d=QIe.runKernel(wke,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}});const DRe=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=iCe(e,"boxes","nonMaxSuppressionAsync"),o=iCe(t,"scores","nonMaxSuppressionAsync"),l=xRe(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=NRe(c,d,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:T$e(h,"int32"),selectedScores:T$e(p)}};const MRe=uCe({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=iCe(e,"boxes","nonMaxSuppression"),o=iCe(t,"scores","nonMaxSuppression"),l=xRe(i,o,n,r,a,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},d=QIe.runKernel(xke,u,c);return{selectedIndices:d[0],validOutputs:d[1]}}});const FRe=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=iCe(e,"boxes","nonMaxSuppressionAsync"),o=iCe(t,"scores","nonMaxSuppressionAsync"),l=xRe(i,o,n,r,a,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=CRe(h,p,u,c,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:T$e(f,"int32"),validOutputs:PNe(m,"int32")}};const ORe=uCe({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=iCe(e,"images","resizeBilinear");Bve(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),Bve(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),Bve(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=kEe(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=QIe.runKernel(zke,o,l);return i?kEe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const PRe=uCe({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=iCe(e,"images","resizeNearestNeighbor");Bve(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),Bve(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),Bve("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Bve(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=kEe(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=QIe.runKernel(Pke,o,l);return i?kEe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const LRe=uCe({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=iCe(e,"image","threshold"),s=a.shape[0]*a.shape[1];let i,o,l,u,c=RNe(T$e([r]),255);if(Bve(3===a.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`)),Bve(3===a.shape[2]||1===a.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`)),Bve("int32"===a.dtype||"float32"===a.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`)),Bve("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===a.shape[2]){[i,o,l]=v$e(a,[1,1,1],-1);const e=RNe(i,.2989),t=RNe(o,.587),n=RNe(l,.114);u=ANe(ANe(e,t),n)}else u=e;if("otsu"===t){c=function(e,t){let n,r,a,s,i,o,l=T$e([-1]),u=T$e([0]),c=T$e([0]);for(let d=0;d<e.size-1;d++){n=EEe(e,0,d+1),r=EEe(e,d+1),i=$Ne(NAe(n),t),o=$Ne(NAe(r),t);const h=NAe(RNe(n,q_e(0,n.size)));a=$Ne(h,NAe(n));const p=GNe(r.shape,n.size),f=ANe(q_e(0,r.size),p),m=RNe(r,f);s=$Ne(NAe(m),NAe(r));const g=KNe(a,s),y=KNe(a,s),b=RNe(i,o);c=RNe(RNe(b,g),y);const v=PAe(c,u);u=uAe(v,c,u),l=uAe(v,T$e([d]),l)}return l}(OEe(NNe(r$e(u),"int32"),hCe([]),256),s)}const d=n?GAe(u,c):PAe(u,c);return NNe(RNe(d,255),"int32")}});const zRe=uCe({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const i=iCe(e,"image","transform","float32"),o=iCe(t,"transforms","transform","float32");Bve(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),Bve(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Bve(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return QIe.runKernel(ISe,l,u)}});const BRe=uCe({bandPart_:function(e,t,n){const r=iCe(e,"a","bandPart");Bve(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const a=r.shape,[s,i]=r.shape.slice(-2);let o,l;"number"===typeof t?(Bve(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Bve(t<=s,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`)),o=iCe(t<0?s:t,"numLower","bandPart")):(Bve("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=uAe(jAe(t,0),s,m_e(t,s))),"number"===typeof n?(Bve(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),Bve(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),l=iCe(n<0?i:n,"numUpper","bandPart")):(Bve("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=uAe(jAe(n,0),i,m_e(n,i)));const u=kEe(q_e(0,s,1,"int32"),[-1,1]),c=q_e(0,i,1,"int32"),d=KNe(u,c),h=t_e(GAe(d,o),LAe(d,YAe(l))),p=h_e([s,i],r.dtype);return kEe(S$e(B$e(kEe(r,[-1,s,i])).map((e=>uAe(h,e,p)))),a)}});const WRe=uCe({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Bve(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Bve(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=v$e(e,e.shape[0],0).map((e=>k$e(e,[0])));Bve(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let a=0;a<e.length;++a)n.push(QIe.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){const r=RNe(NAe(RNe(n[t],e)),n[t]);e=KNe(e,r)}return $Ne(e,EAe(e,"euclidean"))})));return t?S$e(n,0):n}});function VRe(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return QIe.tidy((()=>{Bve(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let a=MAe(n),s=TNe(e);const i=E$e([[1]],[1,1]);let o=TNe(i);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=s,l=o,u=a;[o,s,a]=QIe.tidy((()=>{const t=EEe(s,[e,e],[n-e,1]),l=EAe(t),u=EEe(s,[e,e],[1,1]),c=uAe(PAe(u,0),E$e([[-1]]),E$e([[1]])),d=KNe(u,RNe(c,l)),h=$Ne(t,d);o=1===h.shape[0]?TNe(i):CEe([i,EEe(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=YAe($Ne(NEe(c,d),l)),f=EEe(s,[e,0],[n-e,r]),m=RNe(p,o),g=H$e(o);if(0===e)s=KNe(f,NEe(m,NEe(g,f)));else{const t=KNe(f,NEe(m,NEe(g,f)));s=CEe([EEe(s,[0,0],[e,r]),t],0)}const y=H$e(m),b=EEe(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=KNe(b,NEe(NEe(b,o),y));else{const t=KNe(b,NEe(NEe(b,o),y));a=CEe([EEe(a,[0,0],[n,e]),t],1)}return[o,s,a]})),bCe([t,l,u])}return!t&&n>r&&(a=EEe(a,[0,0],[n,r]),s=EEe(s,[0,0],[r,r])),[a,s]}))}const URe=uCe({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Bve(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return VRe(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=B$e(kEe(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach((e=>{const[n,r]=VRe(e,t);a.push(n),s.push(r)}));return[kEe(S$e(a,0),e.shape),kEe(S$e(s,0),e.shape)]}}});var jRe;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(jRe||(jRe={}));const GRe=uCe({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:jRe.SUM_BY_NONZERO_WEIGHTS;const r=iCe(e,"losses","computeWeightedLoss");let a=null;null!=t&&(a=iCe(t,"weights","computeWeightedLoss"));const s=null==a?r:RNe(r,a);if(n===jRe.NONE)return s;if(n===jRe.SUM)return NAe(s);if(n===jRe.MEAN){if(null==a)return d_e(s);{const e=r.size/a.size,t=$Ne(NAe(s),NAe(a));return e>1?$Ne(t,PNe(e)):t}}if(n===jRe.SUM_BY_NONZERO_WEIGHTS){if(null==a)return $Ne(NAe(s),PNe(r.size));{const e=RNe(a,p_e(r.shape)),t=NNe(NAe(w_e(e,PNe(0))),"float32");return $Ne(NAe(s),t)}}throw Error(`Unknown reduction: ${n}`)}});const HRe=uCe({absoluteDifference_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:jRe.SUM_BY_NONZERO_WEIGHTS;const a=iCe(e,"labels","absoluteDifference"),s=iCe(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=iCe(n,"weights","absoluteDifference")),Wve(a.shape,s.shape,"Error in absoluteDifference: ");const o=YNe(KNe(a,s));return GRe(o,i,r)}});const qRe=uCe({cosineDistance_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:jRe.SUM_BY_NONZERO_WEIGHTS;const s=iCe(e,"labels","cosineDistance"),i=iCe(t,"predictions","cosineDistance");let o=null;null!=r&&(o=iCe(r,"weights","cosineDistance")),Wve(s.shape,i.shape,"Error in cosineDistance: ");const l=PNe(1),u=KNe(l,NAe(RNe(s,i),n,!0));return GRe(u,o,a)}});const KRe=uCe({hingeLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:jRe.SUM_BY_NONZERO_WEIGHTS,a=iCe(e,"labels","hingeLoss");const s=iCe(t,"predictions","hingeLoss");let i=null;null!=n&&(i=iCe(n,"weights","hingeLoss")),Wve(a.shape,s.shape,"Error in hingeLoss: ");const o=PNe(1);a=KNe(RNe(PNe(2),a),o);const l=Y_e(KNe(o,RNe(a,s)));return GRe(l,i,r)}});const XRe=uCe({huberLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:jRe.SUM_BY_NONZERO_WEIGHTS;const s=iCe(e,"labels","huberLoss"),i=iCe(t,"predictions","huberLoss");let o=null;null!=n&&(o=iCe(n,"weights","huberLoss")),Wve(s.shape,i.shape,"Error in huberLoss: ");const l=PNe(r),u=YNe(KNe(i,s)),c=m_e(u,l),d=KNe(u,c),h=ANe(RNe(PNe(.5),MNe(c)),RNe(l,d));return GRe(h,o,a)}});const YRe=uCe({logLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:jRe.SUM_BY_NONZERO_WEIGHTS;const s=iCe(e,"labels","logLoss"),i=iCe(t,"predictions","logLoss");let o=null;null!=n&&(o=iCe(n,"weights","logLoss")),Wve(s.shape,i.shape,"Error in logLoss: ");const l=PNe(1),u=PNe(r),c=YAe(RNe(s,KAe(ANe(i,u)))),d=RNe(KNe(l,s),KAe(ANe(KNe(l,i),u))),h=KNe(c,d);return GRe(h,o,a)}});const QRe=uCe({meanSquaredError_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:jRe.SUM_BY_NONZERO_WEIGHTS;const a=iCe(e,"labels","meanSquaredError"),s=iCe(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=iCe(n,"weights","meanSquaredError")),Wve(a.shape,s.shape,"Error in meanSquaredError: ");const o=w$e(a,s);return GRe(o,i,r)}});const JRe=uCe({sigmoidCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:jRe.SUM_BY_NONZERO_WEIGHTS,s=iCe(e,"multiClassLabels","sigmoidCrossEntropy");const i=iCe(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=iCe(n,"weights","sigmoidCrossEntropy")),Wve(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=PNe(r),t=PNe(1),n=PNe(.5);s=ANe(RNe(s,KNe(t,e)),RNe(n,e))}const l=function(e,t){const n=iCe(e,"labels","sigmoidCrossEntropyWithLogits"),r=iCe(t,"logits","sigmoidCrossEntropyWithLogits");Wve(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const a=Y_e(r),s=RNe(r,n),i=XAe(_Ae(YAe(YNe(r))));return ANe(KNe(a,s),i)}(s,i);return GRe(l,o,a)}});const ZRe=uCe({softmaxCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:jRe.SUM_BY_NONZERO_WEIGHTS,s=iCe(e,"onehotLabels","softmaxCrossEntropy");const i=iCe(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=iCe(n,"weights","softmaxCrossEntropy")),Wve(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=PNe(r),t=PNe(1),n=PNe(s.shape[1]);s=ANe(RNe(s,KNe(t,e)),$Ne(e,n))}const l=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=ONe(((e,t,r)=>{const a=e_e(t,[n],!0),s=KNe(NNe(t,"float32"),a);r([e,s]);const i=YAe(RNe(s,e));return{value:NAe(i,[n]),gradFunc:(e,t)=>{const[r,a]=t,s=vAe(e.shape,[n]);return[RNe(kEe(e,s),KNe(NNe(r,"float32"),_Ae(a))),RNe(kEe(e,s),KNe(_Ae(a),NNe(r,"float32")))]}}}));return r(e,t)}(s,i);return GRe(l,o,a)}});const eDe=uCe({sparseFillEmptyRows_:function(e,t,n,r){const a=iCe(e,"indices","sparseFillEmptyRows","int32"),s=iCe(t,"values","sparseFillEmptyRows"),i=iCe(n,"denseShape","sparseFillEmptyRows","int32"),o=iCe(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:a,values:s,denseShape:i,defaultValue:o},u=QIe.runKernel(oSe,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});const tDe=uCe({sparseReshape_:function(e,t,n){const r=iCe(e,"inputIndices","sparseReshape","int32"),a=iCe(t,"inputShape","sparseReshape","int32"),s=iCe(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const i={inputIndices:r,inputShape:a,newShape:s},o=QIe.runKernel(lSe,i);return{outputIndices:o[0],outputShape:o[1]}}});const nDe=uCe({sparseSegmentMean_:function(e,t,n){const r=iCe(e,"data","sparseSegmentMean"),a=iCe(t,"indices","sparseSegmentMean","int32"),s=iCe(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);const i={data:r,indices:a,segmentIds:s};return QIe.runKernel(uSe,i)}});const rDe=uCe({sparseSegmentSum_:function(e,t,n){const r=iCe(e,"data","sparseSegmentSum"),a=iCe(t,"indices","sparseSegmentSum","int32"),s=iCe(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);const i={data:r,indices:a,segmentIds:s};return QIe.runKernel(cSe,i)}});const aDe=uCe({stringNGrams_:function(e,t,n,r,a,s,i,o){const l=iCe(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=iCe(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=QIe.runKernel(gSe,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}});const sDe=uCe({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=iCe(e,"input","stringSplit","string"),a=iCe(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);const s={skipEmpty:n},i={input:r,delimiter:a},o=QIe.runKernel(ySe,i,s);return{indices:o[0],values:o[1],shape:o[2]}}});const iDe=uCe({stringToHashBucketFast_:function(e,t){const n=iCe(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return QIe.runKernel(bSe,a,r)}});const oDe=uCe({staticRegexReplace_:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=iCe(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return QIe.runKernel(fSe,{x:a},s)}}),lDe={fft:g$e,ifft:y$e,rfft:x$e,irfft:b$e},uDe={hammingWindow:dRe,hannWindow:hRe,frame:pRe,stft:fRe},cDe={flipLeftRight:gRe,grayscaleToRGB:yRe,resizeNearestNeighbor:PRe,resizeBilinear:ORe,rgbToGrayscale:bRe,rotateWithOffset:vRe,cropAndResize:mRe,nonMaxSuppression:wRe,nonMaxSuppressionAsync:$Re,nonMaxSuppressionWithScore:RRe,nonMaxSuppressionWithScoreAsync:DRe,nonMaxSuppressionPadded:MRe,nonMaxSuppressionPaddedAsync:FRe,threshold:LRe,transform:zRe},dDe={bandPart:BRe,gramSchmidt:WRe,qr:URe},hDe={absoluteDifference:HRe,computeWeightedLoss:GRe,cosineDistance:qRe,hingeLoss:KRe,huberLoss:XRe,logLoss:YRe,meanSquaredError:QRe,sigmoidCrossEntropy:JRe,softmaxCrossEntropy:ZRe},pDe={sparseFillEmptyRows:eDe,sparseReshape:tDe,sparseSegmentMean:nDe,sparseSegmentSum:rDe},fDe={stringNGrams:aDe,stringSplit:sDe,stringToHashBucketFast:iDe,staticRegexReplace:oDe};const mDe=class{static sgd(e){return new nTe(e)}static momentum(e,t){return new rTe(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new aTe(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new XNe(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new jNe(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new tTe(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new HNe(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},gDe="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function yDe(){return new Promise((e=>gDe((()=>e()))))}function bDe(e,t){const n=e[0].length;e.forEach(((e,t)=>{Bve(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),Bve(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)Bve(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function vDe(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var xDe;function wDe(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){const s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function kDe(e){const t={FIRST_DIM_SIZE:xDe.FIRST_DIM_SIZE,VALUE_ROWIDS:xDe.VALUE_ROWIDS,ROW_LENGTHS:xDe.ROW_LENGTHS,ROW_SPLITS:xDe.ROW_SPLITS,ROW_LIMITS:xDe.ROW_LIMITS,ROW_STARTS:xDe.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function SDe(e){return 0===e.length?0:e[0]===xDe.FIRST_DIM_SIZE?e.length-1:e.length}function IDe(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){const n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(xDe||(xDe={}));const CDe=30;function NDe(e){return e<=CDe?e:ixe(e,Math.floor(Math.sqrt(e)))}function TDe(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function EDe(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function ADe(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{const r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function _De(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function $De(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function RDe(e,t,n){const r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}function DDe(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Uve(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const a=t.shape,s=a[a.length-1];let i=1;for(let d=0;d<a.length-1;++d)i*=a[d];const o=e.shape,l=a.slice();l.pop();let u=1;for(let d=s;d<n;++d)u*=o[d],l.push(o[d]);const c=[...oxe(e.shape).map((e=>e/u)),1].slice(0,s);return[l,i,u,c]}const MDe=1.7580993408473768,FDe=1.0507009873554805,ODe=.3275911,PDe=.254829592,LDe=-.284496736,zDe=1.421413741,BDe=-1.453152027,WDe=1.061405429;function VDe(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function UDe(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function jDe(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function GDe(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function HDe(e,t){return{real:e[2*t],imag:e[2*t+1]}}function qDe(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function KDe(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){const s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function XDe(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const YDe="->",QDe=/->/g,JDe=",",ZDe="...";function eMe(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(QDe,"").length)/YDe.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${YDe}").`);const[r,a]=e.split(YDe);Bve(-1===r.indexOf(ZDe),(()=>`The ellipsis notation ("${ZDe}") is not supported yet.`));const s=r.split(JDe),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let d=0;d<a.length;++d){const e=a[d];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<r.length;++d){const e=r[d];-1===o.indexOf(e)&&e!==JDe&&o.push(e)}const l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let e=0;e<s[d].length;++e)l[d].push(o.indexOf(s[d][e]))}const u=o.length,c=[];for(let d=a.length;d<u;++d)c.push(d);return{allDims:o,summedDims:c,idDims:l}}function tMe(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;const r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function nMe(e,t,n){const r=new Array(e);for(let a=0;a<n.length;++a){const e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:Bve(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function rMe(e,t){const n=e,r=[];let a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);const s=[];for(let i=0;i<n.length;++i){const e=sMe(t,n[i]);for(const t of e)-1===s.indexOf(t)&&(r[i].push(t),s.push(t))}return{path:n,steps:r}}function aMe(e){return e.every(((e,t)=>e===t))}function sMe(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function iMe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof t)Bve(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Bve(a<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}Bve(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function oMe(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function lMe(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function uMe(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function cMe(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function dMe(e,t){return`size ${e} must be non-negative, not ${t}`}function hMe(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function pMe(e,t){return`Input to reshape is a SparseTensor with ${Uve(e)}\n  dense values, but the requested shape requires a multiple of ${Uve(t)}. inputShape=${e} outputShape= ${t}`}function fMe(e,t){return`Input to reshape is a tensor with ${Uve(e)} dense values, but the requested shape has ${Uve(t)}. inputShape=${e} outputShape=${t}`}function mMe(){return"segment ids must be >= 0"}function gMe(){return"segment ids are not increasing"}function yMe(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function bMe(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function vMe(e,t){let n,r=!1;for(e<=CDe?(n=e,r=!0):n=ixe(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=ixe(e,n+1);return n}function xMe(e,t,n){const r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function wMe(e,t,n,r){const a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<a;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function kMe(e){try{return e.map((e=>hIe(e)))}catch(Z8e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${Z8e}`)}}function SMe(e){return e.map((e=>dIe(e)))}!function(){for(const e of sTe)VNe(e)}();const IMe={kernelName:Cxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(e,I$e(NNe(n,"float32"),-1))}}},CMe={kernelName:Nxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=MNe(NNe(n,"float32")),r=DNe(KNe(PNe(1),t));return YAe($Ne(e,r))}}}},NMe={kernelName:Txe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=DNe(KNe(MNe(NNe(n,"float32")),1));return $Ne(e,t)}}}},TMe={kernelName:Exe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=ZNe(n.shape,r.shape);return{a:()=>{let t=e;const r=JNe(n.shape,a);return r.length>0&&(t=NAe(t,r)),kEe(t,n.shape)},b:()=>{let t=e;const n=JNe(r.shape,a);return n.length>0&&(t=NAe(t,n)),kEe(t,r.shape)}}}},EMe={kernelName:Axe,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},AMe={kernelName:Rxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>FNe(n)}}},_Me={kernelName:Dxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>FNe(n)}}},$Me={kernelName:Mxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>$Ne(e,DNe(KNe(PNe(1),MNe(NNe(n,"float32")))))}}},RMe={kernelName:Fxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=DNe(ANe(PNe(1),MNe(NNe(n,"float32"))));return $Ne(e,t)}}}},DMe={kernelName:Lxe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=ZNe(n.shape,r.shape);return{a:()=>{const t=ANe(MNe(n),MNe(r));let s=RNe(e,$Ne(r,t));const i=JNe(n.shape,a);return i.length>0&&(s=NAe(s,i)),kEe(s,n.shape)},b:()=>{const t=ANe(MNe(n),MNe(r));let s=YAe(RNe(e,$Ne(n,t)));const i=JNe(r.shape,a);return i.length>0&&(s=NAe(s,i)),kEe(s,r.shape)}}}},MMe={kernelName:Oxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>$Ne(e,ANe(MNe(NNe(n,"float32")),1))}}},FMe={kernelName:Pxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>$Ne(e,KNe(PNe(1),MNe(NNe(n,"float32"))))}}};const OMe=uCe({avgPool3dGrad_:function(e,t,n,r,a,s){const i=iCe(e,"dy","avgPool3dGrad"),o=iCe(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=kEe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=kEe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Bve(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),Bve(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),wEe("avgPool3dGrad",a,s);const d={dy:l,input:u},h={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=QIe.runKernel(Vxe,d,h);return c?kEe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),PMe={kernelName:Wxe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>OMe(e,r,a,s,i,o)}}};const LMe=uCe({avgPoolGrad_:function(e,t,n,r,a){const s=iCe(e,"dy","avgPoolGrad"),i=iCe(t,"input","avgPoolGrad");Bve(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=kEe(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=kEe(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Bve(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),Bve(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},d={filterSize:n,strides:r,pad:a},h=QIe.runKernel(Bxe,c,d);return u?kEe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),zMe={kernelName:zxe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>LMe(e,r,a,s,i)}}},BMe={kernelName:Uxe,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>NEe(e,a,!1,!1),b:()=>NEe(e,r,!0,!1)}:s&&!i?{a:()=>NEe(a,e,!1,!0),b:()=>NEe(r,e,!1,!1)}:{a:()=>NEe(a,e,!0,!0),b:()=>NEe(e,r,!0,!0)}:{a:()=>NEe(e,a,!1,!0),b:()=>NEe(r,e,!0,!1)}}},WMe={kernelName:jxe,gradFunc:(e,t,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>__e(e,r,a)}}},VMe={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>NAe(e,o,!0)}}},UMe={kernelName:Kxe,gradFunc:e=>({x:()=>e.clone()})},jMe={kernelName:Xxe,gradFunc:e=>({x:()=>FNe(e)})},GMe={kernelName:Yxe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>uAe(t_e(LAe(r,a),GAe(r,s)),e,FNe(e))}}},HMe={kernelName:Jxe,inputsToSave:["x"],gradFunc:IMe.gradFunc},qMe={kernelName:Zxe,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:a}=n,s=Yve(a,t[0].shape)[0],i=r.map((e=>e[s]));return v$e(e,i,s).map((e=>()=>e))}},KMe={kernelName:ewe,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return Bve(yEe(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>KEe(r.shape,e,a,i,o,l),filter:()=>tRe(r,e,a.shape,i,o,l)}}},XMe={kernelName:nwe,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>HEe(e,a,s,i,o,1,l),filter:()=>tRe(e,r,a.shape,s,i,o,l)}}};const YMe=uCe({conv3DBackpropFilter_:function(e,t,n,r,a){let s=e;4===e.rank&&(s=kEe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=kEe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Bve(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),Bve(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),Bve(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Bve(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),Bve(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return QIe.runKernel(awe,o,l)}}),QMe={kernelName:rwe,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:s}=n;Bve(yEe(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>QEe(i.shape,e,o,a,s),filter:()=>YMe(i,e,o.shape,a,s)}}},JMe={kernelName:iwe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(YAe(u$e(NNe(n,"float32"))),e)}}},ZMe={kernelName:owe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(c$e(NNe(n,"float32")),e)}}},eFe={kernelName:uwe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{const t=wAe([a],r.rank);let n=nAe(e,a,s,!i);return null!=t&&(n=H$e(n,t)),n}}}},tFe={kernelName:pwe,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Bve(yEe(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=t;return Bve(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),Bve(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),Bve(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Bve(bEe(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),wEe("depthwiseConv2d",s,i),{x:()=>lRe(l.shape,e,u,a,s,o,i),filter:()=>oRe(l,e,u.shape,a,s,o,i)}}},nFe={kernelName:ywe,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>QIe.runKernel(bwe,s,n),filter:()=>QIe.runKernel(vwe,i,n)}}},rFe={kernelName:Swe,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>QIe.runKernel(Iwe,r)}}},aFe={kernelName:Cwe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=RNe(_Ae(YAe(MNe(n))),2/Math.sqrt(Math.PI));return{x:()=>RNe(e,r)}}},sFe={kernelName:Twe,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(e,n)}}},iFe={kernelName:Ewe,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>kEe(e,n.shape)}}},oFe={kernelName:Awe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(e,_Ae(n))}}},lFe={kernelName:Dwe,gradFunc:e=>({x:()=>FNe(e)})},uFe={kernelName:Mwe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=ZNe(n.shape,r.shape);return{a:()=>{const t=$Ne(e,NNe(r,"float32")),s=JNe(n.shape,a);return s.length>0?kEe(NAe(t,s),n.shape):t},b:()=>{let t=RNe(e,NNe(n,"float32"));const s=JNe(r.shape,a);s.length>0&&(t=kEe(NAe(t,s),r.shape));const i=MNe(r);return YAe($Ne(t,NNe(i,"float32")))}}}},cFe={kernelName:Fwe,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?PNe(1):o,u=JNe(s.shape,a.shape),c=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)c.push(a.shape[e]);c.push(1)}const d=KNe(a,s),h=RNe(e,l),p=a$e(ANe(i,PNe(r))),f=RNe(RNe(RNe(p,p),p),PNe(-.5));return{x:()=>1===s.rank?kEe(RNe(RNe(e,DAe(kEe(p,[1,1,1,s.shape[0]]),c)),l),a.shape):kEe(RNe(RNe(e,p),l),a.shape),mean:()=>{let e=RNe(RNe(p,PNe(-1)),h);return 1===s.rank&&(e=NAe(e,u)),kEe(e,s.shape)},variance:()=>{let e=RNe(RNe(f,d),h);return 1===s.rank&&(e=NAe(e,u)),kEe(e,s.shape)},scale:()=>{const t=RNe(d,p);let n=RNe(e,t);return 1===s.rank&&(n=NAe(n,u)),kEe(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=NAe(t,u)),kEe(t,s.shape)}}}},dFe={kernelName:Owe,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,a]=t,{axis:s,batchDims:i}=n,o=Yve(s,r.shape)[0],l=(e,t,n)=>()=>{const r=e.shape,a=t.size,i=r.slice(0,o),l=i.length,u=r.slice(s,r.length).slice(1),c=u.length,d=hFe(0,l),h=hFe(l+1,l+1+c),p=pFe([i,[a],u]),f=kEe(n,p),m=kEe(t,[a]),g=pFe([[l],d,h]),y=H$e(f,g);let b=z$e(y,m,e.shape[o]);const v=kAe(g);return b=H$e(b,v),b};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>{const t=S$e(n.map(((t,n)=>l(t,a.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)},indices:()=>a}}return{x:l(r,a,e),indices:()=>a}}};function hFe(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function pFe(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const fFe={kernelName:zwe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>FNe(n),b:()=>FNe(r)}}},mFe={kernelName:Bwe,gradFunc:e=>({x:()=>NNe(e,"float32")})},gFe={kernelName:Uwe,gradFunc:e=>({x:()=>FNe(e)})},yFe={kernelName:jwe,gradFunc:e=>({x:()=>FNe(e)})},bFe={kernelName:Gwe,gradFunc:e=>({x:()=>FNe(e)})},vFe={kernelName:Hwe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:a}=n,s=PAe(r,0);return{x:()=>uAe(s,e,RNe(e,a))}}},xFe={kernelName:Qwe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>$Ne(e,ANe(n,1))}}},wFe={kernelName:Ywe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>$Ne(e,NNe(n,"float32"))}}},kFe={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;return{logits:()=>{const t=_Ae(r);return KNe(e,RNe(NAe(e,a,!0),t))}}}};const SFe=uCe({localResponseNormalizationBackprop_:function(e,t,n){const r={x:e,y:t,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return QIe.runKernel(nke,r,a)}}),IFe={kernelName:tke,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>SFe(r,a,e,s,i,o,l)}}};function CFe(e,t,n,r){return t.rank<n.rank&&(t=kEe(t,vAe(t.shape,r))),e.rank<n.rank&&(e=kEe(e,vAe(e.shape,r))),{x:()=>RNe(e,NNe(lAe(n,t),e.dtype))}}const NFe={kernelName:rke,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:a}=r,s=t[0],i=CFe(e,t[1],s,Yve(a,s.shape));return{x:()=>i.x()}}},TFe={kernelName:ake,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>RNe(e,NNe(LAe(n,r),"float32")),b:()=>RNe(e,NNe(jAe(n,r),"float32"))}}};const EFe=uCe({maxPool3dGrad_:function(e,t,n,r,a,s,i){const o=iCe(e,"dy","maxPool3dGrad"),l=iCe(t,"input","maxPool3dGrad"),u=iCe(n,"output","maxPool3dGrad");let c=o,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=kEe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=kEe(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=kEe(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Bve(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),Bve(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),Bve(5===h.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),wEe("maxPool3dGrad",s,i);const f={dy:c,input:d,output:h},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=QIe.runKernel(lke,f,m);return p?kEe(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),AFe={kernelName:oke,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>EFe(e,r,a,s,i,o,l)}}};const _Fe=uCe({maxPoolGrad_:function(e,t,n,r,a,s,i){const o=iCe(e,"dy","maxPoolGrad"),l=iCe(t,"input","maxPoolGrad"),u=iCe(n,"output","maxPoolGrad");Bve(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),Bve(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Bve(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),wEe("maxPoolGrad",s,i);const c={dy:o,input:l,output:u},d={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return QIe.runKernel(ike,c,d)}}),$Fe={kernelName:ske,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>_Fe(e,r,a,s,i,o)}}},RFe={kernelName:cke,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n,s=Yve(a,r.shape),i=Uve(bAe(r.shape,s)[1]);return{x:()=>{const t=r.shape.slice();s.forEach((e=>{t[e]=1}));const n=kEe(e,t);return $Ne(RNe(n,p_e(r.shape,"float32")),i)}}}},DFe={kernelName:dke,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:a}=r,[s,i]=t,o=CFe(e,i,s,Yve(a,s.shape));return{x:()=>o.x()}}},MFe={kernelName:hke,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>RNe(e,NNe(GAe(n,r),"float32")),b:()=>RNe(e,NNe(PAe(n,r),"float32"))}}},FFe={kernelName:pke,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>EEe(e,s,r.shape)}}},OFe={kernelName:fke,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=ZNe(n.shape,r.shape);return{a:()=>{const t=JNe(n.shape,a);return t.length>0?kEe(NAe(e,t),n.shape):e},b:()=>{const t=RNe(e,YAe(FAe($Ne(n,r)))),s=JNe(r.shape,a);return s.length>0?kEe(NAe(t,s),r.shape):t}}}},PFe={kernelName:gke,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=ZNe(n.shape,r.shape);return{a:()=>{const t=RNe(e,NNe(r,"float32")),s=JNe(n.shape,a);return s.length>0?kEe(NAe(t,s),n.shape):t},b:()=>{const t=RNe(e,NNe(n,"float32")),s=JNe(r.shape,a);return s.length>0?kEe(NAe(t,s),r.shape):t}}}},LFe={kernelName:Cke,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>EEe(e,s,r.shape)}}},zFe={kernelName:Nke,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,a]=t,s=n,i=r,o=ZNe(s.shape,i.shape);return{a:()=>{const t=NNe(i,"float32");let n=RNe(e,RNe(t,qNe(s,KNe(t,PNe(1)))));const r=JNe(s.shape,o);return r.length>0&&(n=NAe(n,r)),kEe(n,s.shape)},b:()=>{const t=PAe(s,0),n=uAe(t,KAe(s),FNe(s));let r=RNe(e,RNe(a,n));const l=JNe(i.shape,o);return l.length>0&&(r=NAe(r,l)),kEe(r,i.shape)}}}},BFe={kernelName:Tke,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,a=PAe(n,0);return{x:()=>uAe(a,e,RNe(e,r)),alpha:()=>{let t=uAe(a,FNe(e),RNe(e,n));const s=JNe(r.shape,e.shape);return s.length>0&&(t=NAe(t,s)),kEe(t,r.shape)}}}};function WFe(e,t,n){const r=e.shape.length,a=r-n.length,s=wAe(n,r);let i=e;null!=s&&(i=H$e(e,s));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const a=kEe(t,r),s=tAe(e,n,!0,!1),i=tAe(e,n,!0,!0),o=RNe(s,i);return RNe(a,o)}(i.reshape(o),t,a);if(u=u.reshape(i.shape),null!=s){const e=kAe(s);u=H$e(u,e)}return u}const VFe={kernelName:Eke,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;let s=[];return s=void 0===a||null===a?r.shape.map(((e,t)=>t)):"number"===typeof a?[a]:a,{x:()=>WFe(r,e,s)}}},UFe={kernelName:wwe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=ZNe(n.shape,r.shape);return{a:()=>{const t=$Ne(e,NNe(r,"float32")),s=JNe(n.shape,a);return s.length>0?kEe(NAe(t,s),n.shape):t},b:()=>{let t=RNe(e,NNe(n,"float32"));const s=JNe(r.shape,a);s.length>0&&(t=kEe(NAe(t,s),r.shape));const i=MNe(r);return YAe($Ne(t,NNe(i,"float32")))}}}},jFe={kernelName:Mke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>$Ne(e,YAe(MNe(n)))}}},GFe={kernelName:Wke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=RNe(GAe(n,6),I$e(n));return{x:()=>RNe(e,NNe(r,"float32"))}}},HFe={kernelName:Fke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(e,NNe(I$e(n),"float32"))}}},qFe={kernelName:Oke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>kEe(e,n.shape)}}},KFe={kernelName:jke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>YAe($Ne(e,RNe(qNe(n,1.5),2)))}}},XFe={kernelName:Xke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=PAe(n,PNe(0)),r=PNe(MDe),a=PNe(FDe),s=RNe(e,a),i=RNe(RNe(e,r),_Ae(NNe(n,"float32")));return uAe(t,s,i)}}}},YFe={kernelName:Qke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(ZEe(NNe(n,"float32")),e)}}},QFe={kernelName:Jke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(eAe(NNe(n,"float32")),e)}}},JFe={kernelName:Yke,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=HTe(r,a,s),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>C_e(e,u)}}},ZFe={kernelName:tSe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(e,TEe(n))}}},eOe={kernelName:aSe,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>$Ee(e,r,a)}}},tOe={kernelName:sSe,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>CEe(e,r)}}},nOe={kernelName:nSe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>$Ne(e,RNe(DNe(NNe(n,"float32")),2))}}},rOe={kernelName:pSe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(e,RNe(NNe(n,"float32"),2))}}},aOe={kernelName:hSe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=PNe(2);return{a:()=>RNe(e,RNe(a,KNe(n,r))),b:()=>RNe(e,RNe(a,KNe(r,n)))}}},sOe={kernelName:vSe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=ZNe(n.shape,r.shape);return{a:()=>{let t=e;const r=JNe(n.shape,a);return r.length>0&&(t=NAe(t,r)),kEe(t,n.shape)},b:()=>{let t=e;const n=JNe(r.shape,a);return n.length>0&&(t=NAe(t,n)),kEe(YAe(t),r.shape)}}}},iOe={kernelName:rSe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,a=r.shape.slice(),{axis:s}=n;Yve(s,r.shape).forEach((e=>{a[e]=1}));const i=kEe(e,a),o=RNe(i,p_e(r.shape,"float32"));return{x:()=>o}}},oOe={kernelName:xSe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>$Ne(e,MNe(ZEe(n)))}}},lOe={kernelName:kSe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:a}=n;return{x:()=>{let t=FNe(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=ANe(t,EEe(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=ANe(t,EEe(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=ANe(t,EEe(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=ANe(t,EEe(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},uOe={kernelName:ESe,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=eTe(t,FNe(t)),r=OAe(e,n);let a=LAe(t,PNe(0,"int32"));const s=r.rank-a.rank;for(let o=0;o<s;++o)a=$Ae(a,o+1);a=t_e(a,p_e(r.shape,"bool"));const i=FNe(r);return uAe(a,r,i)}(e,n)}}};const cOe=[IMe,CMe,NMe,TMe,EMe,AMe,_Me,$Me,RMe,DMe,MMe,FMe,PMe,zMe,BMe,WMe,VMe,UMe,jMe,GMe,HMe,qMe,XMe,KMe,QMe,JMe,ZMe,eFe,tFe,nFe,UFe,rFe,aFe,sFe,iFe,oFe,uFe,lFe,cFe,dFe,fFe,mFe,gFe,yFe,bFe,vFe,xFe,wFe,kFe,IFe,NFe,NFe,TFe,AFe,$Fe,RFe,DFe,MFe,FFe,OFe,PFe,{kernelName:yke,gradFunc:e=>({x:()=>YAe(e)})},{kernelName:Ske,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>h_e(n.shape,"float32")}}},{kernelName:kke,gradFunc:e=>({x:()=>FNe(e)})},{kernelName:Ike,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return B$e(e,r).map((e=>()=>e))}},LFe,LFe,zFe,BFe,VFe,jFe,GFe,HFe,qFe,{kernelName:zke,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>QIe.runKernel(Bke,a,n)}}},{kernelName:Pke,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>QIe.runKernel(Lke,a,n)}}},{kernelName:Vke,gradFunc:(e,t,n)=>{const{dims:r}=n,a=Yve(r,e.shape);return{x:()=>J_e(e,a)}}},{kernelName:Uke,gradFunc:e=>({x:()=>FNe(e)})},KFe,{kernelName:Kke,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>NNe(FNe(n),"float32"),t:()=>RNe(e,NNe(n,e.dtype)),e:()=>RNe(e,NNe(n_e(n),e.dtype))}}},XFe,{kernelName:eSe,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(e,RNe(n,KNe(PNe(1),n)))}}},{kernelName:Zke,gradFunc:e=>({x:()=>FNe(e)})},YFe,QFe,JFe,{kernelName:iSe,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:a}=n,s=RNe(e,r);return{logits:()=>KNe(s,RNe(NAe(s,[a],true),r))}}},ZFe,eOe,eOe,tOe,tOe,nOe,aOe,rOe,{kernelName:_Se,gradFunc:e=>({x:()=>FNe(e)})},sOe,iOe,oOe,{kernelName:wSe,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>RNe(KNe(PNe(1),MNe(n)),e)}}},lOe,{kernelName:CSe,gradFunc:(e,t,n)=>{const r=n,{perm:a}=r,s=kAe(a);return{x:()=>H$e(e,s)}}},{kernelName:TSe,gradFunc:(e,t,n)=>{const r=n,{axis:a}=r;return{value:()=>S$e(e,a)}}},uOe,{kernelName:ASe,gradFunc:e=>({x:()=>FNe(e)})}];for(const n of cOe)jSe(n);$Ie().prototype.abs=function(){return this.throwIfDisposed(),YNe(this)},$Ie().prototype.acos=function(){return this.throwIfDisposed(),XTe(this)},$Ie().prototype.acosh=function(){return this.throwIfDisposed(),YTe(this)},$Ie().prototype.add=function(e){return this.throwIfDisposed(),ANe(this,e)},$Ie().prototype.all=function(e,t){return this.throwIfDisposed(),JTe(this,e,t)},$Ie().prototype.any=function(e,t){return this.throwIfDisposed(),ZTe(this,e,t)},$Ie().prototype.argMax=function(e){return this.throwIfDisposed(),eEe(this,e)},$Ie().prototype.argMin=function(e){return this.throwIfDisposed(),tEe(this,e)},$Ie().prototype.asScalar=function(){return this.throwIfDisposed(),Bve(1===this.size,(()=>"The array must have only 1 element.")),kEe(this,[])},$Ie().prototype.asType=function(e){return this.throwIfDisposed(),NNe(this,e)},$Ie().prototype.as1D=function(){return this.throwIfDisposed(),kEe(this,[this.size])},$Ie().prototype.as2D=function(e,t){return this.throwIfDisposed(),kEe(this,[e,t])},$Ie().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),kEe(this,[e,t,n])},$Ie().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),kEe(this,[e,t,n,r])},$Ie().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),kEe(this,[e,t,n,r,a])},$Ie().prototype.asin=function(){return this.throwIfDisposed(),nEe(this)},$Ie().prototype.asinh=function(){return this.throwIfDisposed(),rEe(this)},$Ie().prototype.atan=function(){return this.throwIfDisposed(),aEe(this)},$Ie().prototype.atan2=function(e){return this.throwIfDisposed(),sEe(this,e)},$Ie().prototype.atanh=function(){return this.throwIfDisposed(),iEe(this)},$Ie().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),SEe(this,e,t,n,r)},$Ie().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),$Ee(this,e,t)},$Ie().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),REe(this,e,t,n,r,a)},$Ie().prototype.broadcastTo=function(e){return this.throwIfDisposed(),zEe(this,e)},$Ie().prototype.cast=function(e){return this.throwIfDisposed(),NNe(this,e)},$Ie().prototype.ceil=function(){return this.throwIfDisposed(),BEe(this)},$Ie().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),WEe(this,e,t)},$Ie().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof _Ie&&(e=[e]),CEe([this,...e],t)},$Ie().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),qEe(this,e,t,n,r,a,s)},$Ie().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),XEe(this,e,t,n,r,a)},$Ie().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),HEe(this,e,t,n,r,a,s)},$Ie().prototype.cos=function(){return this.throwIfDisposed(),ZEe(this)},$Ie().prototype.cosh=function(){return this.throwIfDisposed(),eAe(this)},$Ie().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),tAe(this,e,t,n)},$Ie().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),nAe(this,e,t,n)},$Ie().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),aAe(this,e,t)},$Ie().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),sAe(this,e,t,n,r,a,s)},$Ie().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),oAe(this,e,t,n,r,a)},$Ie().prototype.divNoNan=function(e){return this.throwIfDisposed(),cAe(this,e)},$Ie().prototype.div=function(e){return this.throwIfDisposed(),$Ne(this,e)},$Ie().prototype.dot=function(e){return this.throwIfDisposed(),dAe(this,e)},$Ie().prototype.elu=function(){return this.throwIfDisposed(),pAe(this)},$Ie().prototype.equal=function(e){return this.throwIfDisposed(),lAe(this,e)},$Ie().prototype.erf=function(){return this.throwIfDisposed(),mAe(this)},$Ie().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),AAe(this,e,t)},$Ie().prototype.exp=function(){return this.throwIfDisposed(),_Ae(this)},$Ie().prototype.expandDims=function(e){return this.throwIfDisposed(),$Ae(this,e)},$Ie().prototype.expm1=function(){return this.throwIfDisposed(),RAe(this)},$Ie().prototype.fft=function(){return this.throwIfDisposed(),g$e(this)},$Ie().prototype.flatten=function(){return this.throwIfDisposed(),kEe(this,[this.size])},$Ie().prototype.floor=function(){return this.throwIfDisposed(),FAe(this)},$Ie().prototype.floorDiv=function(e){return this.throwIfDisposed(),_Ne(this,e)},$Ie().prototype.gather=function(e,t,n){return this.throwIfDisposed(),OAe(this,e,t,n)},$Ie().prototype.greaterEqual=function(e){return this.throwIfDisposed(),LAe(this,e)},$Ie().prototype.greater=function(e){return this.throwIfDisposed(),PAe(this,e)},$Ie().prototype.ifft=function(){return this.throwIfDisposed(),y$e(this)},$Ie().prototype.irfft=function(){return this.throwIfDisposed(),b$e(this)},$Ie().prototype.isFinite=function(){return this.throwIfDisposed(),BAe(this)},$Ie().prototype.isInf=function(){return this.throwIfDisposed(),WAe(this)},$Ie().prototype.isNaN=function(){return this.throwIfDisposed(),VAe(this)},$Ie().prototype.leakyRelu=function(e){return this.throwIfDisposed(),UAe(this,e)},$Ie().prototype.lessEqual=function(e){return this.throwIfDisposed(),GAe(this,e)},$Ie().prototype.less=function(e){return this.throwIfDisposed(),jAe(this,e)},$Ie().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),qAe(this,e,t,n,r)},$Ie().prototype.logSigmoid=function(){return this.throwIfDisposed(),JAe(this)},$Ie().prototype.logSoftmax=function(e){return this.throwIfDisposed(),ZAe(this,e)},$Ie().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),e_e(this,e,t)},$Ie().prototype.log=function(){return this.throwIfDisposed(),KAe(this)},$Ie().prototype.log1p=function(){return this.throwIfDisposed(),XAe(this)},$Ie().prototype.logicalAnd=function(e){return this.throwIfDisposed(),t_e(this,e)},$Ie().prototype.logicalNot=function(){return this.throwIfDisposed(),n_e(this)},$Ie().prototype.logicalOr=function(e){return this.throwIfDisposed(),r_e(this,e)},$Ie().prototype.logicalXor=function(e){return this.throwIfDisposed(),a_e(this,e)},$Ie().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),NEe(this,e,t,n)},$Ie().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),l_e(this,e,t,n,r)},$Ie().prototype.max=function(e,t){return this.throwIfDisposed(),IAe(this,e,t)},$Ie().prototype.maximum=function(e){return this.throwIfDisposed(),eTe(this,e)},$Ie().prototype.mean=function(e,t){return this.throwIfDisposed(),d_e(this,e,t)},$Ie().prototype.min=function(e,t){return this.throwIfDisposed(),CAe(this,e,t)},$Ie().prototype.minimum=function(e){return this.throwIfDisposed(),m_e(this,e)},$Ie().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),g_e(this,e,t)},$Ie().prototype.mod=function(e){return this.throwIfDisposed(),y_e(this,e)},$Ie().prototype.mul=function(e){return this.throwIfDisposed(),RNe(this,e)},$Ie().prototype.neg=function(){return this.throwIfDisposed(),YAe(this)},$Ie().prototype.norm=function(e,t,n){return this.throwIfDisposed(),EAe(this,e,t,n)},$Ie().prototype.notEqual=function(e){return this.throwIfDisposed(),w_e(this,e)},$Ie().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),k_e(this,e,t,n)},$Ie().prototype.onesLike=function(){return this.throwIfDisposed(),S_e(this)},$Ie().prototype.pad=function(e,t){return this.throwIfDisposed(),C_e(this,e,t)},$Ie().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),$_e(this,e,t,n,r,a,s)},$Ie().prototype.pow=function(e){return this.throwIfDisposed(),qNe(this,e)},$Ie().prototype.prelu=function(e){return this.throwIfDisposed(),R_e(this,e)},$Ie().prototype.prod=function(e,t){return this.throwIfDisposed(),D_e(this,e,t)},$Ie().prototype.reciprocal=function(){return this.throwIfDisposed(),X_e(this)},$Ie().prototype.relu=function(){return this.throwIfDisposed(),Y_e(this)},$Ie().prototype.relu6=function(){return this.throwIfDisposed(),Q_e(this)},$Ie().prototype.reshapeAs=function(e){return this.throwIfDisposed(),kEe(this,e.shape)},$Ie().prototype.reshape=function(e){return this.throwIfDisposed(),kEe(this,e)},$Ie().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),ORe(this,e,t,n)},$Ie().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),PRe(this,e,t,n)},$Ie().prototype.reverse=function(e){return this.throwIfDisposed(),J_e(this,e)},$Ie().prototype.rfft=function(){return this.throwIfDisposed(),x$e(this)},$Ie().prototype.round=function(){return this.throwIfDisposed(),r$e(this)},$Ie().prototype.rsqrt=function(){return this.throwIfDisposed(),a$e(this)},$Ie().prototype.selu=function(){return this.throwIfDisposed(),s$e(this)},$Ie().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),i$e(this,e,t,n,r,a,s)},$Ie().prototype.sigmoid=function(){return this.throwIfDisposed(),TEe(this)},$Ie().prototype.sign=function(){return this.throwIfDisposed(),l$e(this)},$Ie().prototype.sin=function(){return this.throwIfDisposed(),u$e(this)},$Ie().prototype.sinh=function(){return this.throwIfDisposed(),c$e(this)},$Ie().prototype.slice=function(e,t){return this.throwIfDisposed(),EEe(this,e,t)},$Ie().prototype.softmax=function(e){return this.throwIfDisposed(),m$e(this,e)},$Ie().prototype.softplus=function(){return this.throwIfDisposed(),QAe(this)},$Ie().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),__e(this,e,t)},$Ie().prototype.split=function(e,t){return this.throwIfDisposed(),v$e(this,e,t)},$Ie().prototype.sqrt=function(){return this.throwIfDisposed(),DNe(this)},$Ie().prototype.square=function(){return this.throwIfDisposed(),MNe(this)},$Ie().prototype.squaredDifference=function(e){return this.throwIfDisposed(),w$e(this,e)},$Ie().prototype.squeeze=function(e){return this.throwIfDisposed(),k$e(this,e)},$Ie().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof _Ie?[this,e]:[this,...e];return S$e(n,t)},$Ie().prototype.step=function(e){return this.throwIfDisposed(),I$e(this,e)},$Ie().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),C$e(this,e,t,n,r,a,s,i,o)},$Ie().prototype.sub=function(e){return this.throwIfDisposed(),KNe(this,e)},$Ie().prototype.sum=function(e,t){return this.throwIfDisposed(),NAe(this,e,t)},$Ie().prototype.tan=function(){return this.throwIfDisposed(),N$e(this)},$Ie().prototype.tanh=function(){return this.throwIfDisposed(),AEe(this)},$Ie().prototype.tile=function(e){return this.throwIfDisposed(),DAe(this,e)},$Ie().prototype.toBool=function(){return this.throwIfDisposed(),NNe(this,"bool")},$Ie().prototype.toFloat=function(){return this.throwIfDisposed(),NNe(this,"float32")},$Ie().prototype.toInt=function(){return this.throwIfDisposed(),NNe(this,"int32")},$Ie().prototype.topk=function(e,t){return this.throwIfDisposed(),O$e(this,e,t)},$Ie().prototype.transpose=function(e){return this.throwIfDisposed(),H$e(this,e)},$Ie().prototype.unique=function(e){return this.throwIfDisposed(),L$e(this,e)},$Ie().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),z$e(this,e,t)},$Ie().prototype.unstack=function(e){return this.throwIfDisposed(),B$e(this,e)},$Ie().prototype.where=function(e,t){return this.throwIfDisposed(),uAe(e,this,t)},$Ie().prototype.zerosLike=function(){return this.throwIfDisposed(),FNe(this)};class dOe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,dOe.prototype)}}class hOe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hOe.prototype)}}class pOe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,pOe.prototype)}}class fOe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,fOe.prototype)}}class mOe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,mOe.prototype)}}Error;class gOe{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function yOe(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function bOe(e,t){if(!e)throw new mOe(t)}function vOe(e,t){let n=0;for(const r of e)r===t&&n++;return n}function xOe(e){return 1===e.length?e[0]:e}function wOe(e){return Array.isArray(e)?e:[e]}function kOe(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function SOe(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let IOe={};function COe(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function NOe(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>NOe(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?NOe(t):e[n]=t.value)}}}function TOe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const a=e;let s;if(a in n)s=n[a];else if(a in IOe)s=IOe[a];else if(s=t[a],null==s)throw new pOe(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const s=e;if(null==s.className||null==s.config)throw new pOe(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const i=s.className;let o,l;if(i in n?[o,l]=n[i]:i in IOe?[o,l]=IOe.className:i in t&&([o,l]=t[i]),null==o)throw new pOe(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const n of Object.keys(IOe))e[n]=IOe[n];for(const a of Object.keys(n))e[a]=n[a];s.config.customObjects=e;const t=Object.assign({},IOe);for(const a of Object.keys(n))IOe[a]=n[a];NOe(s.config);const r=l(o,s.config,n,a);return IOe=Object.assign({},t),r}{const e=Object.assign({},IOe);for(const r of Object.keys(n))IOe[r]=n[r];const t=new o(s.config);return IOe=Object.assign({},e),t}}}function EOe(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function AOe(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function _Oe(e){if(null==e)throw new pOe(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function $Oe(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new pOe(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function ROe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return bOe(n>=0),bOe(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function DOe(e,t){Array.isArray(e)?(Bve(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>DOe(e,`element ${n+1} of ${t}`)))):Bve(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${MOe(e)}.`))}function MOe(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>MOe(e))).join(",")+"]":"string"===typeof e?`"${e}"`:`${e}`}function FOe(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let OOe=0;function POe(){return OOe++}const LOe={};function zOe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in LOe||(LOe[e]=0),LOe[e]+=1,e+LOe[e].toString()}const BOe=["channelsFirst","channelsLast"],WOe=["nearest","bilinear"],VOe=["valid","same","causal"],UOe=["max","avg"],jOe=["sum","mul","concat","ave"],GOe=new Map;function HOe(e){$Oe(BOe,"DataFormat",e)}function qOe(e){$Oe(VOe,"PaddingMode",e)}function KOe(e){$Oe(UOe,"PoolMode",e)}const XOe=[],YOe="/";function QOe(e,t){XOe.push(e);try{const e=t();return XOe.pop(),e}catch(mD){throw XOe.pop(),mD}}function JOe(e){if(!tPe(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===XOe.length?"":XOe.join(YOe)+YOe)+e}function ZOe(e){if(!tPe(e))throw new Error("Not a valid tensor name: '"+e+"'");GOe.has(e)||GOe.set(e,0);const t=GOe.get(e);if(GOe.set(e,GOe.get(e)+1),t>0){const n=`${e}_${t}`;return GOe.set(n,1),n}return e}const ePe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function tPe(e){return!!e.match(ePe)}function nPe(e){return e===parseInt(e.toString(),10)}function rPe(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function aPe(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function sPe(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function iPe(e,t){if(t<e)throw new pOe(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let oPe;function lPe(){return null==oPe&&(oPe=kCe().epsilon()),oPe}function uPe(e,t){return NNe(e,t)}function cPe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),kEe(e,n)}function dPe(e,t,n){return yCe((()=>{switch(e.rank){case 1:return d$e(e,t,n);case 2:return h$e(e,[t,0],[n,e.shape[1]]);case 3:return p$e(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return f$e(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return EEe(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return EEe(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new pOe(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function hPe(e,t,n){return yCe((()=>{switch(e.rank){case 1:return d$e(e,t,n);case 2:return h$e(e,[0,t],[e.shape[0],n]);case 3:return p$e(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return f$e(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new pOe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function pPe(e,t,n,r){return yCe((()=>{switch(e.rank){case 1:return d$e(e,t,n);case 2:switch(r){case 1:return dPe(e,t,n);case 2:return hPe(e,t,n);default:throw new pOe(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return dPe(e,t,n);case 2:return p$e(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return hPe(e,t,n);default:throw new pOe(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return dPe(e,t,n);case 2:return f$e(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return f$e(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return hPe(e,t,n);default:throw new pOe(`The axis is not within the rank of the tensor ${r}`)}default:throw new pOe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function fPe(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),CEe(e,n)}function mPe(e,t){switch(e.rank){case 1:return VEe([e,t]);case 2:return UEe([e,t],0);case 3:return jEe([e,t],0);case 4:return GEe([e,t],0);default:throw new pOe(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function gPe(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new pOe(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return DAe(e,t)}function yPe(e){return U_e(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function bPe(e,t,n,r){if(e.rank<2||t.rank<2)throw new fOe(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new fOe(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){return cRe({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?wPe(e.rank,r,"channelsLast"):null,activation:n})}{const a=e.shape.slice(),s=a.pop();e=kEe(e,[-1,s]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=kEe(H$e(t,c),[l,-1]);const d=[...a,...u];return kEe(cRe({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?wPe(e.rank,r,"channelsLast"):null,activation:n}),d)}}function vPe(e,t,n){return yCe((()=>(t=Array.isArray(t)?T$e(t,"int32"):NNe(t,"int32"),OAe(e,t,n))))}function xPe(e){return RNe(e,e)}function wPe(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new pOe(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?kEe(t,[1,r[0],1,1,1]):kEe(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?kEe(t,[1,1,1,1,r[0]]):kEe(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?kEe(t,[1,r[0],1,1]):kEe(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?kEe(t,[1,1,1,r[0]]):kEe(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?kEe(t,[1,r[0],1]):kEe(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?kEe(t,[1,1,r[0]]):kEe(t,[1].concat(r))}else if(e<3)return t;throw new pOe(`Unsupported input rank by biasAdd: ${t.rank}`)}function kPe(e,t,n){return yCe((()=>(null==n&&(n="channelsLast"),HOe(n),ANe(e,wPe(e.rank,t,n)))))}function SPe(e,t,n,r){return yCe((()=>Q$e(e,t,n,r)))}function IPe(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const CPe=["fanIn","fanOut","fanAvg"],NPe=["normal","uniform","truncatedNormal"];class TPe extends BNe{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class EPe extends TPe{apply(e,t){return h_e(e,t)}}EPe.className="Zeros",VNe(EPe);class APe extends TPe{apply(e,t){return p_e(e,t)}}APe.className="Ones",VNe(APe);class _Pe extends TPe{constructor(e){if(super(),"object"!==typeof e)throw new pOe(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new pOe(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return yCe((()=>RNe(PNe(this.value),p_e(e,t))))}getConfig(){return{value:this.value}}}_Pe.className="Constant",VNe(_Pe);class $Pe extends TPe{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return G_e(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}$Pe.className="RandomUniform",VNe($Pe);class RPe extends TPe{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new fOe(`randomNormal does not support dType ${t}.`);return yPe(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}RPe.className="RandomNormal",VNe(RPe);class DPe extends TPe{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new fOe(`truncatedNormal does not support dType ${t}.`);return P$e(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}DPe.className="TruncatedNormal",VNe(DPe);class MPe extends TPe{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return yCe((()=>{if(2!==e.length||e[0]!==e[1])throw new pOe("Identity matrix initializer can only be used for 2D square matrices.");return RNe(this.gain,MAe(e[0]))}))}getConfig(){return{gain:this.gain}}}MPe.className="Identity",VNe(MPe);class FPe extends TPe{constructor(e){if(super(),e.scale<0)throw new pOe(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,$Oe(CPe,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){$Oe(NPe,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(HOe(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){const r=rPe(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){const r=rPe(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{const r=rPe(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],a=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new fOe(`${this.getClassName()} does not support dType ${t}.`);return P$e(e,0,n,t,this.seed)}{const n=Math.sqrt(3*s);return G_e(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}FPe.className="VarianceScaling",VNe(FPe);class OPe extends FPe{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return FPe.className}}OPe.className="GlorotUniform",VNe(OPe);class PPe extends FPe{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return FPe.className}}PPe.className="GlorotNormal",VNe(PPe);class LPe extends FPe{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return FPe.className}}LPe.className="HeNormal",VNe(LPe);class zPe extends FPe{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return FPe.className}}zPe.className="HeUniform",VNe(zPe);class BPe extends FPe{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return FPe.className}}BPe.className="LeCunNormal",VNe(BPe);class WPe extends FPe{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return FPe.className}}WPe.className="LeCunUniform",VNe(WPe);class VPe extends TPe{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return yCe((()=>{if(e.length<2)throw new fOe("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=Uve(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const s=yPe([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=dDe.qr(s,!1);let o=i[0];const l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=RNe(o,l.sign()),n<r&&(o=o.transpose()),RNe(PNe(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}VPe.className="Orthogonal",VNe(VPe);const UPe={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function jPe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return TOe(e,WNe.getMap().classNameMap,t,"initializer")}function GPe(e){return COe(e)}function HPe(e){if("string"===typeof e){const t=e in UPe?UPe[e]:e;if("GlorotNormal"===t)return new PPe;if("GlorotUniform"===t)return new OPe;if("HeNormal"===t)return new LPe;if("HeUniform"===t)return new zPe;if("LeCunNormal"===t)return new BPe;if("LeCunUniform"===t)return new WPe;{const e={};return e.className=t,e.config={},jPe(e)}}return e instanceof TPe?e:jPe(e)}function qPe(e){return Array.isArray(e)&&Array.isArray(e[0])}function KPe(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function XPe(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new pOe(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function YPe(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new pOe(`Expected exactly 1 Shape; got ${e.length}`)}return e}function QPe(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const JPe="Variable";class ZPe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:JPe,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=POe(),n=null==n?JPe:n,this.originalName=JOe(n),this.name=ZOe(this.originalName),this.trainable_=r,this.constraint=a,this.val=V$e(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function eLe(e){return e.map((e=>e.read()))}function tLe(e){e.forEach((e=>{e[0].write(e[1])}))}class nLe{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class rLe{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=POe(),null!=s&&(this.originalName=JOe(s),this.name=ZOe(this.originalName)),this.rank=t.length}}let aLe=0;class sLe{constructor(e,t){this.callArgs=t,this.id=aLe++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let iLe=0;class oLe extends BNe{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=iLe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=kOe(e)+"_"+zOe(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new hOe(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new pOe(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return xOe(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return xOe(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new dOe(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new dOe(`Layer ${this.name} is not connected, no input to return.`);return xOe(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new dOe(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new dOe(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return xOe(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=wOe(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=wOe(this.inputSpec);if(t.length!==n.length)throw new pOe(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const e=t[r],a=n[r];if(null==a)continue;const s=e.rank;if(null!=a.ndim&&s!==a.ndim)throw new pOe(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new pOe(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new pOe(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&e.dtype!==a.dtype)throw new pOe(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${e.dtype}.`);if(a.axes){const t=e.shape;for(const e in a.axes){const n=Number(e),s=a.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=s&&-1===[s,null].indexOf(i))throw new pOe(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){const n=a.shape[t],s=e.shape[t];if(null!=n&&null!=s&&n!==s)throw new pOe(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=wOe(e),r=function(e){let t=!0;for(const n of wOe(e))if(!(n instanceof rLe)){t=!1;break}return t}(e),a=function(e){let t=!0;for(const n of wOe(e))if(n instanceof rLe){t=!1;break}return t}(e);if(r===a)throw new pOe("Arguments to apply() must be all SymbolicTensors or all Tensors");return QOe(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of wOe(e))t.push(n.shape);this.build(xOe(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const a=wOe(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=xOe(s),null!=this.activityRegularizer)throw new fOe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=wOe(e);const t=[];for(const n of e)t.push(n.shape);return xOe(t)}(e),r=this.computeOutputShape(n);let a;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new rLe(s,n,this,wOe(e),t,this.name,r))):new rLe(s,r,this,wOe(e),t,this.name),this.addInboundNode(e,a,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new fOe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new dOe(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new dOe(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new hOe(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return QPe(this.weights)}build(e){this.built=!0}getWeights(){return eLe(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){yCe((()=>{const t=this.weights;if(t.length!==e.length)throw new pOe(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=eLe(t);for(let a=0;a<r.length;++a){const s=r[a],i=t[a],o=e[a];if(!jve(s.shape,o.shape))throw new pOe(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}tLe(n)}))}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new pOe(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():HPe("zeros"));const l=r.apply(t,n),u=new ZPe(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=wOe(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),a=wOe(t),s=wOe(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=s[i]}addInboundNode(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const o=wOe(e);t=wOe(t),n=wOe(n),r=wOe(r),a=KPe(a),s=KPe(s);const l=[],u=[],c=[];for(const d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new sLe({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function lLe(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=lLe(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class uLe extends oLe{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:zOe("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new pOe("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new pOe("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new pOe("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new rLe(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new sLe({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new pOe(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}uLe.className="InputLayer",VNe(uLe);class cLe{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof cLe)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new pOe(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return NNe(t,e.dtype)}catch(Z8e){throw new pOe(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof rLe){if(null==this.id2Value[e.id])throw new pOe(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new pOe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof rLe){if(null==this.id2Value[e.id])throw new pOe(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new pOe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&bCe(this.id2Mask)}}const dLe=new gOe,hLe=new gOe;function pLe(e,t,n,r){const a=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(const f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let d,h=dLe.get(c);if(null==h){const e=function(e,t){Bve(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const a=mLe(e[0],t);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of e){const{sorted:e,recipientMap:i}=mLe(s,t);for(const t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:fLe(r)}}(i,t);h=e.sorted,d=e.recipientCounts,dLe.put(c,h),hLe.put(c,d)}d={},a||Object.assign(d,hLe.get(c));const p=new cLe(t);for(let f=0;f<h.length;++f){if(null!=r){const e=gCe().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=h[f],s=e.sourceLayer;if(s instanceof uLe)continue;const i=[],u=[],c=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),a||(d[n.name]--,0!==d[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&((n=n||{}).mask=u[0]);const g=wOe(s.apply(i,n));let y=null;s.supportsMasking&&(y=s.computeMask(i,u));const b=gLe(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);const e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}a||bCe(c)}return p.disposeMasks(),s?l:l[0]}function fLe(e){const t={};for(const n in e)t[n]=e[n].size;return t}function mLe(e,t){const n=new Set,r=[],a={};for(const o of t.names())n.add(o);const s=[],i=[];for(s.push(e);s.length>0;){const e=s[s.length-1];if(n.has(e.name)){s.pop();continue}const t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(const t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),n.has(t.name)||s.push(t)}}return{sorted:r,recipientMap:a}}function gLe(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function yLe(e,t){return yCe((()=>DNe(NAe(RNe(e,e),t,!0))))}xxe().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=dLe&&dLe.setMaxEntries(e),null!=hLe&&hLe.setMaxEntries(e)}));class bLe extends BNe{getConfig(){return{}}}class vLe extends bLe{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return yCe((()=>{const t=yLe(e,this.axis),n=WEe(t,0,this.maxValue);return RNe(e,$Ne(n,ANe(lPe(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}vLe.className="MaxNorm",VNe(vLe);class xLe extends bLe{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return yCe((()=>$Ne(e,ANe(lPe(),yLe(e,this.axis)))))}getConfig(){return{axis:this.axis}}}xLe.className="UnitNorm",VNe(xLe);class wLe extends bLe{apply(e){return Y_e(e)}}wLe.className="NonNeg",VNe(wLe);class kLe extends bLe{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return yCe((()=>{const t=yLe(e,this.axis),n=ANe(RNe(this.rate,WEe(t,this.minValue,this.maxValue)),RNe(1-this.rate,t));return RNe(e,$Ne(n,ANe(lPe(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}kLe.className="MinMaxNorm",VNe(kLe);const SLe={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ILe(e){return COe(e)}function CLe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return TOe(e,WNe.getMap().classNameMap,t,"constraint")}function NLe(e){if(null==e)return null;if("string"===typeof e){return CLe({className:e in SLe?SLe[e]:e,config:{}})}return e instanceof bLe?e:CLe(e)}async function TLe(e){if(null==e)return;const t=[],n=[],r=[];for(const a in e){const s=e[a];if("number"!==typeof s){const e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){const a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];bCe(r)}}function ELe(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var ALe;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(ALe||(ALe={}));class _Le{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class $Le{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class RLe extends _Le{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const r in t){const e=t[r];if("number"===typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;const a=yCe((()=>ANe(this.totals[r],RNe(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:yCe((()=>{const e=RNe($Ne(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),vCe(t[n])})))}}class DLe extends _Le{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const a in this.history){const r=this.history[a];for(let s=0;s<r.length;++s)if("number"!==typeof r[s]){const i=r[s];e.push(i.data()),t.push(a),n.push(s)}}const r=await Promise.all(e);for(let a=0;a<r.length;++a){this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}}}class MLe extends _Le{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||yDe,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");rxe(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():uIe();return function(){const s=null!=n?n():uIe();return s-a<t||(a=s,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await TLe(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await TLe(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await TLe(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await TLe(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await TLe(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):rxe(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await TLe(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await TLe(e),await this.trainEnd(e))}}function FLe(e,t){if(null==e&&(e={}),e instanceof _Le)return[e];if(Array.isArray(e)&&e[0]instanceof _Le)return e;return wOe(e).map((e=>new MLe(e,t)))}class OLe{constructor(){}static registerCallbackConstructor(e,t){Bve(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),OLe.checkForDuplicate(t),null==OLe.constructors[e]&&(OLe.constructors[e]=[]),OLe.constructors[e].push(t)}static checkForDuplicate(e){for(const t in OLe.constructors){OLe.constructors[+t].forEach((t=>{if(t===e)throw new pOe("Duplicate callback constructor.")}))}}static clear(){OLe.constructors={}}static createCallbacks(e){const t=[];for(const n in OLe.constructors){const r=+n;e>=r&&t.push(...OLe.constructors[r])}return t.map((e=>new e))}}function PLe(e,t,n,r,a,s,i,o,l){const u=new DLe,c=[new RLe,...OLe.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const d=new $Le(c);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function LLe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return TOe(e,WNe.getMap().classNameMap,t,"layer",n)}function zLe(e,t){return yCe((()=>{"float32"!==e.dtype&&(e=NNe(e,"float32"));const n=NAe(xPe(e),t,!0),r=GNe(n.shape,lPe()),a=DNe(eTe(n,r));return $Ne(e,a)}))}function BLe(e,t){return yCe((()=>d_e(xPe(KNe(t,e)),-1)))}function WLe(e,t){return yCe((()=>d_e(YNe(KNe(t,e)),-1)))}function VLe(e,t){return yCe((()=>{const n=KNe(e,t),r=WEe(YNe(e),lPe(),Number.MAX_VALUE),a=YNe($Ne(n,r));return RNe(100,d_e(a,-1))}))}function ULe(e,t){return yCe((()=>{const n=WEe(t,lPe(),Number.MAX_VALUE),r=KAe(ANe(1,n)),a=WEe(e,lPe(),Number.MAX_VALUE),s=KAe(ANe(1,a));return d_e(xPe(KNe(r,s)),-1)}))}function jLe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return yCe((()=>{if(n)t=m$e(t);else{const e=NAe(t,t.shape.length-1,!0);t=$Ne(t,e)}return t=WEe(t,lPe(),1-lPe()),YAe(NAe(RNe(NNe(e,"float32"),KAe(t)),t.shape.length-1))}))}function GLe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return yCe((()=>{const r=NNe(FAe(function(e){const t=[rPe(e.shape)];return kEe(e,t)}(e)),"int32"),a=(t=WEe(t,lPe(),1-lPe())).shape;return jLe(kEe(k_e(r,a[a.length-1]),a),t,n)}))}function HLe(e,t){return yCe((()=>{let n;return n=WEe(t,lPe(),1-lPe()),n=KAe($Ne(n,KNe(1,n))),d_e(function(e,t){if(!jve(e.shape,t.shape))throw new pOe(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return yCe((()=>{const n=Y_e(t),r=YAe(YNe(t));return ANe(KNe(n,RNe(t,e)),XAe(_Ae(r)))}))}(e,n),-1)}))}function qLe(e,t){return yCe((()=>{const n=WEe(e,lPe(),1),r=WEe(t,lPe(),1);return NAe(RNe(e,KAe($Ne(n,r))),-1)}))}function KLe(e,t){return yCe((()=>{const n=zLe(e,-1),r=zLe(t,-1),a=RNe(n,r);return YAe(NAe(a,-1))}))}OLe.constructors={};const XLe={meanSquaredError:BLe,meanAbsoluteError:WLe,meanAbsolutePercentageError:VLe,meanSquaredLogarithmicError:ULe,squaredHinge:function(e,t){return yCe((()=>{const n=eTe(0,KNe(1,RNe(e,t)));return d_e(xPe(n),-1)}))},hinge:function(e,t){return yCe((()=>{const n=eTe(0,KNe(1,RNe(e,t)));return d_e(n,-1)}))},categoricalHinge:function(e,t){return yCe((()=>{const n=NAe(RNe(e,t),-1),r=IAe(RNe(KNe(1,e),t),-1);return eTe(0,ANe(1,KNe(r,n)))}))},logcosh:function(e,t){return yCe((()=>{const n=Math.log(2),r=KNe(t,e),a=KNe(ANe(r,QAe(RNe(-2,r))),n);return d_e(a,-1)}))},categoricalCrossentropy:jLe,sparseCategoricalCrossentropy:GLe,binaryCrossentropy:HLe,kullbackLeiblerDivergence:qLe,poisson:function(e,t){return yCe((()=>{const n=KAe(ANe(lPe(),t));return d_e(KNe(t,RNe(e,n)),-1)}))},cosineProximity:KLe};function YLe(e){if("string"===typeof e){if(e in XLe)return XLe[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new pOe(t)}return e}function QLe(e,t){return yCe((()=>{const n=RNe(.5,S_e(t)),r=uPe(PAe(t,n),e.dtype);return d_e(lAe(e,r),-1)}))}function JLe(e,t){return yCe((()=>uPe(lAe(eEe(e,-1),eEe(t,-1)),"float32")))}function ZLe(e,t){return yCe((()=>NNe(NAe(t_e(lAe(e,1),lAe(t,1))),"float32")))}function eze(e,t){return HLe(e,t)}function tze(e,t){return e.rank===t.rank&&(e=k$e(e,[e.rank-1])),(t=eEe(t,-1)).dtype!==e.dtype&&(t=NNe(t,e.dtype)),NNe(lAe(e,t),"float32")}const nze=jLe,rze=GLe,aze={binaryAccuracy:QLe,categoricalAccuracy:JLe,precision:function(e,t){return yCe((()=>{const n=ZLe(e,t),r=function(e,t){return yCe((()=>NNe(NAe(t_e(lAe(e,0),lAe(t,1))),"float32")))}(e,t),a=ANe(n,r);return NNe(uAe(PAe(a,0),$Ne(n,a),0),"float32")}))},categoricalCrossentropy:nze,sparseCategoricalCrossentropy:rze,mse:BLe,MSE:BLe,mae:WLe,MAE:WLe,mape:VLe,MAPE:VLe,cosine:KLe};function sze(e){if("string"===typeof e&&e in aze)return aze[e];if("string"!==typeof e&&null!=e)return e;throw new pOe(`Unknown metric ${e}`)}function ize(e){if(bOe(null!==e,`Unknown LossOrMetricFn ${e}`),"string"===typeof e)return e;{let t;for(const n of Object.keys(XLe))if(XLe[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(aze))if(aze[n]===e){t=n;break}return void 0!==t?t:e.name}}const oze=1048576;function lze(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!uze(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>oze&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function uze(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!uze(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!uze(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function cze(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(e){let t=!0;const n=[],r=[];for(const a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(const a of e.layers){let e=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),s=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!a){s.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),dze(s,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)a?hze(o[c],n,r):pze(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;t=null!=e.collectedTrainableWeights?QPe(e.collectedTrainableWeights):QPe(e.trainableWeights);return t}(e),u=QPe(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function dze(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function hze(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(Z8e){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(Z8e){r="multiple"}dze([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function pze(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(Z8e){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(Z8e){a="multiple"}const i=[];for(const c of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let e=0;e<c.inboundLayers.length;++e){const t=c.inboundLayers[e].name,n=c.nodeIndices[e],r=c.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}const o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];dze([`${o} (${l})`,s,a,e.countParams().toString(),u],t,r);for(let c=1;c<i.length;++c)dze(["","","","",i[c]],t,r)}function fze(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function mze(e,t){if(null===e)return null;if("string"===typeof e)return SOe(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];fze(t,a,r)?n.push(r):n.push(mze(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"===typeof r)t[n]=r;else{const e=SOe(n);t[e]=mze(r,e)}}return t}}function gze(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return kOe(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];fze(t,a,r)?n.push(r):n.push(gze(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],a=kOe(n);t[a]="name"!==n&&"className"!==n||"string"!==typeof r?gze(r,n):r}return t}}const yze="4.20.0";class bze extends oLe{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=zOe(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],AOe(this.inputs).length!==this.inputs.length)throw new pOe(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);AOe(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;bOe(0===t,"input layer has >1 nodes"),bOe(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof uLe))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},a={},s={},i=[],o=(e,t,n,r,a,l)=>{null!=r&&null!=a&&null!=l||(r=e.sourceLayer,a=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[a];if(-1!==n.indexOf(u))throw new hOe(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(bze.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let s=0;s<c;s++){const e=u.inputTensors[s],r=u.inboundLayers[s],a=u.nodeIndices[s],i=u.tensorIndices[s];o(e,t,n,r,a,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const y of this.outputs)o(y,l,u);const c=i.slice().reverse();for(const y of c){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const s=null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id];e=Math.max(e,s),r[y.outboundLayer.id]=e,a[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){const a=y.inboundLayers[r],s=y.nodeIndices[r],i=a.inboundNodes[s],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const d={};for(const y in t){const e=t[y];e in d||(d[e]=[]),d[e].push(n[y])}const h={};for(const y in r){const e=r[y];e in h||(h[e]=[]),h[e].push(a[y])}let p=Object.keys(h).map((e=>parseInt(e,10))).sort(EOe);this.layers=[];for(const y of p){const e=h[y];e.sort(((e,t)=>{const n=s[e.id],r=s[t.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof bze&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=h,p=Object.keys(d).map((e=>parseInt(e,10))).sort(EOe);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of d[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new hOe(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=d;const g=this.layers.map((e=>e.name));for(const y of g){const e=g.filter((e=>e===y)).length;if(1!==e)throw new hOe(`The name "${y}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new sLe({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new pOe("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const a=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);a&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const s=a?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[s])throw new pOe(`Duplicate weight name: ${s}`);n[s]=t,r++}const s=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])s.push([n[r],e[i]]);else if(t)throw new pOe(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new pOe(`${e.length} of ${r} weights are not set: ${e}`)}tLe(s)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${yze}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=gze(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return yCe((()=>{e=wOe(e);const n=new cLe;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return pLe(this.outputs,n,t)}))}computeMask(e,t){return yCe((()=>{let n;return e=wOe(e),n=null==t?yOe(null,e.length):wOe(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=KPe(e);if(t.length!==this.inputLayers.length)throw new pOe(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(EOe);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const r=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],a=t.nodeIndices[i],s=t.tensorIndices[i],o=n[`${e.name}_${a}_${s}`];r.push(o)}const a=KPe(e.computeOutputShape(xOe(r))),s=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++){n[`${e.name}_${s}_${t}`]=a[t]}}}const a=[],s=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;s.push(r)}for(let i=0;i<s.length;i++){const e=s[i];bOe(e in n),a.push(n[e])}return xOe(a)}runInternalGraph(e,t){null==t&&(t=yOe(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const r=this.inputs[o],a=e[o],s=t[o];n[r.id]=[a,s]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(EOe);for(const o of r){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,s=new Array;for(const t of r)t.id in n&&s.push(n[t.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){const[t,n]=s[0];null==u.mask&&(u.mask=n),o=wOe(e.call(t,u)),l=wOe(e.computeMask(t,n)),r=[t],i=[n]}else r=s.map((e=>e[0])),i=s.map((e=>e[1])),null==u.mask&&(u.mask=i),o=wOe(e.call(r,u)),l=wOe(e.computeMask(r,i));if(e.activityRegularizer)throw new fOe("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){const t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}const a=[],s=[],i=[];for(const o of this.outputs){bOe(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];i.push(e.shape),a.push(e),s.push(t)}return[a,s,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof bze?1:0;for(let e=0;e<r.inboundNodes.length;e++){const a=bze.nodeKey(r,e);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new pOe("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new pOe(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new pOe(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return yCe((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=bze.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const e=s.getClassName(),r=s.getConfig(),a=[];for(let n=0;n<s.inboundNodes.length;n++){const e=s.inboundNodes[n],r=bze.nodeKey(s,n);let i={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(Z8e){console.warn(`Layer ${s.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const a=e.inboundLayers[r],s=e.nodeIndices[r],o=e.tensorIndices[r];let l=t[bze.nodeKey(a,s)];null==l&&(l=0),n.push([a.name,l,o,i])}a.push(n)}}}const i={};i.name=s.name,i.className=e,i.config=r,i.inboundNodes=a,n.push(i)}e.layers=n;const r=[];for(let s=0;s<this.inputLayers.length;s++){const e=this.inputLayers[s],n=this.inputLayersNodeIndices[s],a=bze.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let i=t[a];null!==i&&void 0!==i||(i=0);const o=this.inputLayersTensorIndices[s];r.push([e.name,i,o])}e.inputLayers=r;const a=[];for(let s=0;s<this.outputLayers.length;s++){const e=this.outputLayers[s],n=this.outputLayersNodeIndices[s],r=bze.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let i=t[r];null!==i&&void 0!==i||(i=0);const o=this.outputLayersTensorIndices[s];a.push([e.name,i,o])}return e.outputLayers=a,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function s(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function i(e,t){const n=[];let a;for(const i of t){const o=i[0],l=i[1],u=i[2];if(a=null==i[3]?{}:i[3],!(o in r))return void s(e,t);const c=r[o];if(c.inboundNodes.length<=l)return void s(e,t);const d=c.inboundNodes[l];n.push(d.outputTensors[u])}n.length>0&&e.apply(xOe(n),a)}function o(e){const a=e.name,i=LLe(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[a]=i;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new pOe(`Corrupted configuration, expected array for nodeData: ${e}`);s(i,e)}))}const l=t.name,u=t.layers;for(const f of u)o(f);for(;!_Oe(a);)for(const e of u){const t=r[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)i(t,n)}}const c=[],d=[],h=t.inputLayers;for(const f of h){const e=f[0],t=f[1],n=f[2];bOe(e in r);const a=r[e].inboundNodes[t].outputTensors;c.push(a[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];bOe(e in r);const a=r[e].inboundNodes[t].outputTensors;d.push(a[n])}return new e({inputs:c,outputs:d,name:l})}get stateful(){if(this._stateful)throw new pOe("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){yCe((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function vze(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function xze(e,t){return vze(e,t,"classWeight")}async function wze(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=yCe((()=>{if(1===e.shape.length)return TNe(e);if(2===e.shape.length){if(e.shape[1]>1){return eEe(e,1)}if(1===e.shape[1])return kEe(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());bCe(t);const a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),T$e(a,"float32")}return null}function kze(e,t){return RNe(e,t)}function Sze(e,t){let n,r;const a=t;n=a.xs,r=a.ys,Bve(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const s=Ize("input",e.inputNames,n),i=Ize("output",e.outputNames,r),o=s[0].shape[0];Bve(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),Bve(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<s.length;l++)Bve(s[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)Bve(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:i}}function Ize(e,t,n){if(n instanceof _Ie)return[n];if(Array.isArray(n))return Bve(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const a of t){if(null==n[a])throw new pOe(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function Cze(e,t,n){const r=null!=n.batchesPerEpoch;if(Bve(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Bve(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Bve(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Bve(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Bve(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const a=null!=n.validationData;let s,i;if(a)if(Nze(n.validationData))Bve(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new fOe("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);s=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=a?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=FLe(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=PLe(c,d,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,a,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const u={};await h.onEpochBegin(f);let c=0,d=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:a}=Sze(e,t.value),s={};s.batch=d,s.size=r[0].shape[0],await h.onBatchBegin(d,s);const i=[];if(null!=n.classWeight){const t=xze(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await wze(a[e],null,t[e]))}const u=r.concat(a).concat(i),p=o(u);bCe(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];s[t]=n,vCe(n)}await h.onBatchEnd(d,s),ELe(s),d++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(a){let t;t=Nze(n.validationData)?wOe(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):wOe(e.evaluate(s,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,u),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Nze(e){return"function"===typeof e.iterator}function Tze(e){Bve(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function Eze(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>dPe(e,t,n-t))):dPe(e,t,n-t)}function Aze(e,t){return yCe((()=>null==e?null:Array.isArray(e)?e.map((e=>Aze(e,t))):vPe(e,"int32"===t.dtype?t:NNe(t,"int32"))))}function _ze(e,t){const n=[];let r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function $ze(e){const t=[];e instanceof _Ie&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(cPe(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Rze(e,t){if(null==e)return;const n=[];if(t instanceof _Ie)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const a in t){const e=t[a];n.push(e.id)}const r=[];if(e instanceof _Ie)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const a in e){const t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function Dze(e){return Array.isArray(e)}function Mze(e){return!function(e){return e instanceof _Ie}(e)&&!Dze(e)}function Fze(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(Dze(e)&&e.length>0)t=!0;else if(Mze(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new pOe(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(Mze(e)){r=[];for(const n of t){if(null==e[n])throw new pOe(`No data provided for "${n}". Need data for each key in: ${t}`);r.push(e[n])}}else if(Dze(e)){if(e.length!==t.length)throw new pOe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);r=e}else{if(t.length>1)throw new pOe(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);r=[e]}if(r=$ze(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new pOe(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!a)continue;const r=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&r!==o)throw new pOe(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return r}function Oze(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new pOe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);r=e}else{if(t.length>1)throw new pOe(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new pOe(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let r=0;r<n[i].length;++r){if(0===r&&!a)continue;const o=e.shape[r],l=n[i][r];if(null!=l&&l!==o)throw new pOe(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class Pze extends bze{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new pOe("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");cze(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>mDe.adagrad(.01),Adadelta:()=>mDe.adadelta(1,.95,lPe()),Adam:()=>mDe.adam(.001,.9,.999,lPe()),Adamax:()=>mDe.adamax(.002,.9,.999,lPe(),0),RMSProp:()=>mDe.rmsprop(.001,.9,0,lPe()),SGD:()=>mDe.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new pOe(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof UNe))throw new pOe("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new pOe(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>YLe(e)))}else{const n=YLe(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new pOe(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(YLe(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],QOe("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};QOe("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,s;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let a;1===t[t.length-1]||this.lossFunctions[e]===HLe?-1!==["accuracy","acc"].indexOf(i)?r=QLe:-1!==["crossentropy","ce"].indexOf(i)&&(r=eze):this.lossFunctions[e]===GLe?-1!==["accuracy","acc"].indexOf(i)?r=tze:-1!==["crossentropy","ce"].indexOf(i)&&(r=rze):-1!==["accuracy","acc"].indexOf(i)?r=JLe:-1!==["crossentropy","ce"].indexOf(i)&&(r=nze),-1!==["accuracy","acc"].indexOf(i)?a="acc":-1!==["crossentropy","ce"].indexOf(i)&&(a="ce"),s=r,n=""+a}else{const e=sze(i);s=e,n=""+ize(i)}let t;QOe(n,(()=>{t=s})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;Tze(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const e=a[0].concat(a[1]);this.makeTestFunction();const t=this.testFunction;return xOe(this.testLoop(t,e,r,n.verbose,n.steps))}finally{Rze(a[0],e),Rze(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,a=e.testFunction;let s=[];if(n.verbose>0)throw new fOe("Verbose mode is not implemented yet.");Bve(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i="function"===typeof t.next?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await i.next();if(s=yCe((()=>{if(t.value){const{xs:n,ys:r}=Sze(e,t.value),i=n.concat(r),u=yCe((()=>a(i)));if(bCe(i),0===l)for(let e=0;e<u.length;++e)s.push(PNe(0));const c=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=s[e];s[e]=yCe((()=>ANe(s[e],RNe(c,t)))),l>0&&bCe(n)}bCe(u),o+=c,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){const e=s[u];s[u]=$Ne(s[u],o),bCe(e)}return xOe(s)}(this,e,t)}checkNumSamples(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new pOe(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new pOe(`Either the input data should have a defined shape, or ${a} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new pOe("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new cLe;if(e instanceof _Ie&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new pOe(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new pOe(`No value is provided for the model's input ${o.name}`);s.add(o,t)}const i=pLe(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){const t=yOe(null,e.length);let n=e.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){const i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new pOe(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return yCe((()=>{const r=this.checkNumSamples(e);if(n)throw new fOe("Verbose predictLoop() is not implemented yet.");const a=_ze(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t){yCe((()=>{const n=a[t][0],r=a[t][1],s=Eze(e,n,r),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});const o=new cLe(i);return pLe(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)))}return xOe(s.map((e=>CEe(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=$ze(e);Oze(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return Tze(e),this.predictLoop(n,e)}finally{Rze(n,e)}}predictOnBatch(e){Oze(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new hOe("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const e=this.feedOutputShapes[a];this.feedLossFns[a]===GLe?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){const n=AOe(e.map((e=>e.shape[0])));n.sort();const r=AOe(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new pOe(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new pOe(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!jve(n,r))throw new pOe(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=Fze(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Fze(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){const r=[BLe,HLe,jLe];for(let a=0;a<e.length;++a){const s=e[a],i=t[a],o=n[a];if(null!=i){if(i===jLe&&1===s.shape[s.shape.length-1])throw new pOe(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],a=t[n];if(null!=a&&r!==a)throw new pOe(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new pOe(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=xze(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await wze(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return yCe((()=>{const s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new fOe("Verbose mode is not implemented yet.");if(null!=a)throw new fOe("steps mode in testLoop() is not implemented yet");{const r=_ze(s,n),a=T$e(iPe(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],o=r[n][1],l=dPe(a,s,o-s),u=Aze(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(PNe(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=ANe(i[e],RNe(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=$Ne(i[e],s)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let a=r;if(vOe(e,r)>1){a+=`_${vOe(e.slice(0,n),r)}`}t.push(a)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new cLe(e),o=pLe(this.outputs,i,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],o[n]);null!=a[n]&&(e=kze(e,a[n]));const s=d_e(e);t.push(s),l=0===n?e:ANe(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=d_e(t(r[a],o[a]))}vCe(e),s.push(e)}return l=d_e(l),this.calculateLosses().forEach((e=>{l=ANe(l,e)})),l}),!0,i)].concat(s)}}makeTestFunction(){this.testFunction=e=>yCe((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});const i=new cLe(s),o=pLe(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],s=d_e(r(a[e],o[e]));n=0===e?s:ANe(n,s),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=d_e(n(a[r],o[r]));t.push(s)}return t}))}async fit(e,t){let n,r,a,s,i,o,l,u,c,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const h=null==d.batchSize?32:d.batchSize;Tze(h);const p=!1,f=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,p,h);n=f[0],r=f[1],c=f[2];let m,g=!1;if(null!=d.validationData&&d.validationData.length>0){if(g=!0,2!==d.validationData.length)throw 3===d.validationData.length?new fOe("validationData including sample weights is not supported yet."):new pOe(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${d.validationData} is invalid.`);i=d.validationData[0],o=d.validationData[1];const e=!0,t=await this.standardizeUserData(i,o,null,null,e,h);l=t[0],u=t[1],m=l.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];l=Eze(n,e,t),a=n,n=Eze(n,0,e),u=Eze(r,e,t),s=r,r=Eze(r,0,e),m=l.concat(u)}else null!=d.validationSteps&&(g=!0);const y=n.concat(r).concat(c);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let x,w;g?(this.makeTestFunction(),x=this.testFunction,w=v.slice().concat(v.map((e=>"val_"+e)))):(x=null,m=[],w=v.slice());const k=FLe(d.callbacks,d.yieldEvery);return await this.fitLoop(b,y,v,h,d.epochs,d.verbose,k,x,m,d.shuffle,w,d.initialEpoch,null,null)}finally{this.isTraining=!1,Rze(n,e),Rze(r,t),Rze(a,e),Rze(s,t),Rze(l,i),Rze(u,o),null!=c&&bCe(c)}}async fitLoop(e,t,n,r,a,s,i,o,l,u,c,d,h,p){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==h))throw new pOe("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,h,"steps_per_epoch");let g;null!=m&&(g=iPe(0,m)),null==s&&(s=1);const{callbackList:y,history:b}=PLe(i,s,a,d,m,h,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=d;v<a;++v){await y.onEpochBegin(v);const a={};if(null!=h)throw new fOe("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new fOe("batch shuffling is not implemneted yet");u&&Ove(g);const s=T$e(g),i=_ze(m,r);for(let u=0;u<i.length;++u){const c={};if(await y.onBatchBegin(u,c),yCe((()=>{const d=i[u][0],h=i[u][1],p=dPe(s,d,h-d);c.batch=u,c.size=h-d;const m=Aze(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];c[t]=r,vCe(r)}if(u===i.length-1&&f){const e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){const r=n[t],s=e[t];vCe(s),a["val_"+r]=s}}})),await y.onBatchEnd(u,c),ELe(c),this.stopTraining_)break}s.dispose()}if(await y.onEpochEnd(v,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Cze(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(const o of s){const e=await o.data();i.push(e[0])}return bCe(s),Rze(n[0],e),Rze(n[1],t),xOe(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=gCe().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-gCe().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=kOe(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>kOe(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=kOe(n[r])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[kOe(ize(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>kOe(ize(e))));{const e={};for(const t in this.metrics)e[t]=kOe(ize(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=LLe(mze(e.optimizer_config));let n,r;if("string"===typeof e.loss)n=SOe(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>SOe(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=SOe(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>SOe(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=SOe(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"===typeof e){const t=jCe(e);if(0===t.length)throw new pOe(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new pOe(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new pOe("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await ICe(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${yze}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:a}=await ICe(await this.optimizer.getWeights(),e);n.specs.push(...a),n.data=MCe([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;lze(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){lze(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Pze.className="Model",VNe(Pze);class Lze extends Pze{}Lze.className="Functional",VNe(Lze);class zze extends Pze{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:zOe("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new pOe(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof zze||e instanceof Pze;let n;if(t){if(n=e,1!==n.outputs.length)throw new pOe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new pOe("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new pOe("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new pOe("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new uLe({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new pOe(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new pOe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=lLe(this.outputs[0])}this.inboundNodes=[],new sLe({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:yOe(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(YPe(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Pze({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new hOe("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new hOe("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new hOe("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new hOe("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new pOe("Legacy serialization format not supported yet.");n=t}else Bve(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,a=t;const s=new e(a);if(!(s instanceof zze))throw new fOe(`Sequential.fromConfig called on non-Sequential input: ${s}`);for(const i of n){const e=LLe(i,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),s.add(e)}return s}set stopTraining(e){if(null==this.model)throw new pOe("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new pOe("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}zze.className="Sequential",VNe(zze);class Bze extends BNe{getConfig(){return{}}}class Wze extends Bze{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new fOe(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return pAe(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}Wze.className="elu",VNe(Wze);class Vze extends Bze{apply(e){return s$e(e)}}Vze.className="selu",VNe(Vze);class Uze extends Bze{apply(e){return Y_e(e)}}Uze.className="relu",VNe(Uze);class jze extends Bze{apply(e){return yCe((()=>m_e(6,Y_e(e))))}}jze.className="relu6",VNe(jze);class Gze extends Bze{apply(e){return e}}Gze.className="linear",VNe(Gze);class Hze extends Bze{apply(e){return TEe(e)}}Hze.className="sigmoid",VNe(Hze);class qze extends Bze{apply(e){return function(e){return yCe((()=>{const t=ANe(.5,RNe(.2,e));return WEe(t,0,1)}))}(e)}}qze.className="hardSigmoid",VNe(qze);class Kze extends Bze{apply(e){return QAe(e)}}Kze.className="softplus",VNe(Kze);class Xze extends Bze{apply(e){return function(e){return yCe((()=>$Ne(e,ANe(YNe(e),1))))}(e)}}Xze.className="softsign",VNe(Xze);class Yze extends Bze{apply(e){return AEe(e)}}Yze.className="tanh",VNe(Yze);class Qze extends Bze{apply(e){return m$e(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}Qze.className="softmax",VNe(Qze);class Jze extends Bze{apply(e){return ZAe(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}Jze.className="logSoftmax",VNe(Jze);class Zze extends Bze{apply(e){return yCe((()=>yCe((()=>{const t=Math.sqrt(2),n=RNe(.5,ANe(1,mAe($Ne(e,t))));return RNe(e,n)}))))}}Zze.className="gelu",VNe(Zze);class eBe extends Bze{apply(e){return yCe((()=>RNe(.5,RNe(e,ANe(1,AEe(RNe(DNe($Ne(2,Math.PI)),ANe(e,RNe(.044715,qNe(e,3))))))))))}}eBe.className="gelu_new",VNe(eBe);class tBe extends Bze{apply(e){return yCe((()=>RNe(e,AEe(QAe(e)))))}}tBe.className="mish",VNe(tBe);class nBe extends Bze{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return yCe((()=>RNe(TEe(RNe(e,t)),e)))}}function rBe(e){return e.getClassName()}function aBe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return TOe(e,WNe.getMap().classNameMap,t,"activation")}function sBe(e){if(null==e){const e={className:"linear",config:{}};return aBe(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},aBe(t)}return e instanceof Bze?e:aBe(e)}function iBe(e){if(null!=e&&"object"!==typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}nBe.className="swish",VNe(nBe);class oBe extends BNe{}class lBe extends oBe{constructor(e){super(),iBe(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return yCe((()=>{let t=h_e([1]);return this.hasL1&&(t=ANe(t,NAe(RNe(this.l1,YNe(e))))),this.hasL2&&(t=ANe(t,NAe(RNe(this.l2,xPe(e))))),kEe(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}lBe.className="L1L2",VNe(lBe);const uBe={l1l2:"L1L2"};function cBe(e){return COe(e)}function dBe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return TOe(e,WNe.getMap().classNameMap,t,"regularizer")}function hBe(e){if(null==e)return null;if("string"===typeof e){return dBe({className:e in uBe?uBe[e]:e,config:{}})}return e instanceof oBe?e:dBe(e)}class pBe extends oLe{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=XPe(e);let n=Y_e(e);return null!=this.maxValue&&(n=WEe(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}pBe.className="ReLU",VNe(pBe);class fBe extends oLe{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=XPe(e);return UAe(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}fBe.className="LeakyReLU",VNe(fBe);class mBe extends oLe{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=HPe(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=hBe(e.alphaRegularizer),this.alphaConstraint=NLe(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new pOe(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=YPe(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new nLe({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=XPe(e),R_e(e,this.alpha.read())}getConfig(){const e={alphaInitializer:GPe(this.alphaInitializer),alphaRegularizer:cBe(this.alphaRegularizer),alphaConstraint:ILe(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}mBe.className="PReLU",VNe(mBe);class gBe extends oLe{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new fOe(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=XPe(e);return pAe(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}gBe.className="ELU",VNe(gBe);class yBe extends oLe{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=XPe(e);return RNe(n,NNe(PAe(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}yBe.className="ThresholdedReLU",VNe(yBe);class bBe extends oLe{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Qze).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return yCe((()=>{let n=XPe(e);const r=t.mask;if(null!=r){const e=RNe(KNe(p_e(n.shape),NNe(r,n.dtype)),PNe(-1e9));n=ANe(n,e)}return this.axis instanceof Array?this.axis.length>1?_Ae(KNe(n,e_e(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function vBe(e,t,n){if("number"===typeof e)return yOe(e,t);if(e.length!==t)throw new pOe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const a=e[r];if(!nPe(a))throw new pOe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function xBe(e,t,n,r){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function wBe(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+sPe([n-t,0]);else{if("same"!==r)throw new pOe(`Unsupport padding mode: ${r}.`);e*=t}return e}function kBe(e,t){return yCe((()=>(HOe(t),"channelsFirst"===t?H$e(e,[0,2,3,1]):e)))}function SBe(e,t){return yCe((()=>(HOe(t),"channelsFirst"===t?H$e(e,[0,2,3,4,1]):e)))}function IBe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return yCe((()=>{if(null==s&&(s="channelsLast"),HOe(s),3!==e.shape.length)throw new pOe(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new pOe(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new pOe(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===s&&(e=H$e(e,[0,2,1])),"causal"===a)throw new fOe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=qEe(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=kPe(o,n)),o}))}function CBe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return yCe((()=>{if(null==s&&(s="channelsLast"),HOe(s),3!==e.rank&&4!==e.rank)throw new pOe(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new pOe(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=kBe(e,s);if("causal"===a)throw new fOe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=iRe({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=H$e(l,[0,3,1,2])),l}))}function NBe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return yCe((()=>{if(null==s&&(s="channelsLast"),HOe(s),4!==e.rank&&5!==e.rank)throw new pOe(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new pOe(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=SBe(e,s);if("causal"===a)throw new fOe("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=YEe(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=kPe(o,n)),"channelsFirst"===s&&(o=H$e(o,[0,4,1,2,3])),o}))}bBe.className="Softmax",VNe(bBe);class TBe extends oLe{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",TBe.verifyArgs(t),this.rank=e,DOe(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new fOe(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=vBe(t.kernelSize,e,"kernelSize"),this.strides=vBe(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,qOe(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,HOe(this.dataFormat),this.activation=sBe(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=HPe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=NLe(t.biasConstraint),this.biasRegularizer=hBe(t.biasRegularizer),this.activityRegularizer=hBe(t.activityRegularizer),this.dilationRate=vBe(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new pOe(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new pOe(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new pOe(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(bOe("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!ROe(e.kernelSize,"number",1,3))throw new pOe(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:rBe(this.activation),useBias:this.useBias,biasInitializer:GPe(this.biasInitializer),biasRegularizer:cBe(this.biasRegularizer),activityRegularizer:cBe(this.activityRegularizer),biasConstraint:ILe(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class EBe extends TBe{constructor(e,t){super(e,t),this.kernel=null,EBe.verifyArgs(t),this.filters=t.filters,DOe(this.filters,"filters"),this.kernelInitializer=HPe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=NLe(t.kernelConstraint),this.kernelRegularizer=hBe(t.kernelRegularizer)}build(e){e=YPe(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new pOe(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return yCe((()=>{let t;e=XPe(e);const n=null==this.bias?null:this.bias.read(),r=FOe(this.activation.getClassName());if(null!=r&&2===this.rank)t=CBe(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=IBe(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=CBe(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new fOe("convolutions greater than 3D are not implemented yet.");t=NBe(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=YPe(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){const e=xBe(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:GPe(this.kernelInitializer),kernelRegularizer:cBe(this.kernelRegularizer),kernelConstraint:ILe(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new pOe(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class ABe extends EBe{constructor(e){super(2,e),ABe.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!ROe(e.kernelSize,"number",1,2))throw new pOe(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}ABe.className="Conv2D",VNe(ABe);class _Be extends EBe{constructor(e){super(3,e),_Be.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new pOe(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}_Be.className="Conv3D",VNe(_Be);class $Be extends ABe{constructor(e){if(super(e),this.inputSpec=[new nLe({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new pOe(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=YPe(e)).length)throw new pOe("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new pOe("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new nLe({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return yCe((()=>{let t=XPe(e);if(4!==t.shape.length)throw new pOe(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let a,s;"channelsFirst"===this.dataFormat?(a=2,s=3):(a=1,s=2);const i=n[a],o=n[s],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],h=[r,wBe(i,c,l,this.padding),wBe(o,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=H$e(t,[0,2,3,1]));let p=XEe(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=H$e(p,[0,3,1,2])),null!=this.bias&&(p=kPe(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=YPe(e)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=wBe(t[r],o,s,this.padding),t[a]=wBe(t[a],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}$Be.className="Conv2DTranspose",VNe($Be);class RBe extends _Be{constructor(e){if(super(e),this.inputSpec=[new nLe({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new pOe(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=YPe(e)).length)throw new pOe("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new pOe("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new nLe({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return yCe((()=>{let t=XPe(e);if(5!==t.shape.length)throw new pOe(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let a,s,i;"channelsFirst"===this.dataFormat?(i=2,a=3,s=4):(i=1,a=2,s=3);const o=n[i],l=n[a],u=n[s],c=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,wBe(o,p,c,this.padding),wBe(l,f,d,this.padding),wBe(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=H$e(t,[0,2,3,4,1]));let y=JEe(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=H$e(y,[0,4,1,2,3])),null!==this.bias&&(y=kPe(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){const t=(e=YPe(e)).slice();let n,r,a,s;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=wBe(t[r],u,i,this.padding),t[a]=wBe(t[a],c,o,this.padding),t[s]=wBe(t[s],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}RBe.className="Conv3DTranspose",VNe(RBe);class DBe extends EBe{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new pOe("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new pOe("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new pOe(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=HPe(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=hBe(t.depthwiseRegularizer),this.depthwiseConstraint=NLe(t.depthwiseConstraint),this.pointwiseInitializer=HPe(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=hBe(t.pointwiseRegularizer),this.pointwiseConstraint=NLe(t.pointwiseConstraint)}build(e){if((e=YPe(e)).length<this.rank+2)throw new pOe(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new pOe(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new nLe({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return yCe((()=>{let t;if(e=XPe(e),1===this.rank)throw new fOe("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=H$e(e,[0,2,3,1])),t=i$e(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=kPe(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=H$e(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=GPe(this.depthwiseInitializer),e.pointwiseInitializer=GPe(this.pointwiseInitializer),e.depthwiseRegularizer=cBe(this.depthwiseRegularizer),e.pointwiseRegularizer=cBe(this.pointwiseRegularizer),e.depthwiseConstraint=ILe(this.depthwiseConstraint),e.pointwiseConstraint=ILe(this.pointwiseConstraint),e}}DBe.className="SeparableConv";class MBe extends DBe{constructor(e){super(2,e)}}MBe.className="SeparableConv2D",VNe(MBe);class FBe extends EBe{constructor(e){super(1,e),FBe.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!ROe(e.kernelSize,"number",1,1))throw new pOe(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}FBe.className="Conv1D",VNe(FBe);class OBe extends oLe{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return yCe((()=>{if(e=XPe(e),"channelsLast"===this.dataFormat){const t=pPe(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return pPe(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=pPe(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return pPe(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}OBe.className="Cropping2D",VNe(OBe);class PBe extends oLe{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,HOe(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,$Oe(WOe,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return yCe((()=>{let t=XPe(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=H$e(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?cDe.resizeNearestNeighbor(t,[e,r]):cDe.resizeBilinear(t,[e,r]);return H$e(a,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?cDe.resizeNearestNeighbor(t,[e,r]):cDe.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}PBe.className="UpSampling2D",VNe(PBe);class LBe extends TBe{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=HPe(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=NLe(e.depthwiseConstraint),this.depthwiseRegularizer=hBe(e.depthwiseRegularizer)}build(e){if((e=YPe(e)).length<4)throw new pOe(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new pOe(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return yCe((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return yCe((()=>{null==a&&(a="channelsLast"),HOe(a);let i=kBe(e,a);if(4!==e.rank)throw new pOe(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new pOe(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=sAe(i,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(i=H$e(i,[0,3,1,2])),i}))}(e=XPe(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=kPe(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=YPe(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=xBe(t,this.kernelSize[0],this.padding,this.strides[0]),s=xBe(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=GPe(this.depthwiseInitializer),e.depthwiseRegularizer=cBe(this.depthwiseRegularizer),e.depthwiseConstraint=ILe(this.depthwiseRegularizer),e}}function zBe(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new pOe("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function BBe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return yCe((()=>{const l=t.shape.length;if(l<3)throw new pOe(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(iPe(2,l));if(t=H$e(t,u),null!=s)throw new fOe("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=NNe(NNe(a,"bool"),"float32"),a.rank===l-1&&(a=$Ae(a,-1)),a=H$e(a,u)),r&&(t=J_e(t,0),null!=a&&(a=J_e(a,0)));const c=[];let d,h=n;const p=t.shape[0],f=B$e(t);let m,g;null!=a&&(m=B$e(a));for(let t=0;t<p;++t){const n=f[t],r=yCe((()=>e(n,h)));if(null==a)d=r[0],h=r[1];else{const e=yCe((()=>{const e=m[t],n=KNe(S_e(e),e);return{output:ANe(RNe(r[0],e),RNe(h[0],n)),newStates:h.map(((t,a)=>ANe(RNe(r[1][a],e),RNe(t,n))))}}));d=e.output,h=e.newStates}o&&c.push(d)}if(o){g=S$e(c,1)}return[d,g,h]}))}LBe.className="DepthwiseConv2D",VNe(LBe);class WBe extends oLe{constructor(e){let t;if(super(e),null==e.cell)throw new pOe("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new XBe({cells:e.cell}):e.cell,null==t.stateSize)throw new pOe("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new nLe({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return iPe(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){qPe(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return yCe((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new fOe("Constants support is not implemented in RNN yet.");qPe(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new nLe({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!jve(this.stateSpec.map((e=>e.shape[e.shape.length-1])),a))throw new pOe(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map((e=>new nLe({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];yCe((()=>{if(!this.stateful)throw new dOe("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new pOe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>h_e([n,e]))):this.states_=[h_e([n,this.cell.stateSize])];else if(null==e)bCe(this.states_),null!=this.keptStates&&(bCe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>h_e([n,e]))):this.states_[0]=h_e([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new pOe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):bCe(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!jve(r.shape,s))throw new pOe(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>vCe(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=zBe(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new nLe({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length);if(s[0]instanceof rLe){const n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return yCe((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let a=null==t?null:t.initialState;e=XPe(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new pOe(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=BBe(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return yCe((()=>{let t=h_e(e.shape);return t=NAe(t,[1,2]),t=cPe(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?gPe(t,[1,e]):t)):this.cell.stateSize>1?[gPe(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===WBe.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=LLe(t.cell,n);return new e(Object.assign(t,{cell:r}))}}WBe.className="RNN",VNe(WBe);class VBe extends oLe{}class UBe extends VBe{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,DOe(this.units,"units"),this.activation=sBe(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=HPe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=HPe(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=HPe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=hBe(e.kernelRegularizer),this.recurrentRegularizer=hBe(e.recurrentRegularizer),this.biasRegularizer=hBe(e.biasRegularizer),this.kernelConstraint=NLe(e.kernelConstraint),this.recurrentConstraint=NLe(e.recurrentConstraint),this.biasConstraint=NLe(e.biasConstraint),this.dropout=aPe([1,sPe([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=aPe([1,sPe([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=YPe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return yCe((()=>{if(2!==e.length)throw new pOe(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=YBe({ones:()=>S_e(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=YBe({ones:()=>S_e(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=this.recurrentDropoutMask;a=bPe(null!=s?RNe(e,s):e,this.kernel.read()),null!=this.bias&&(a=kPe(a,this.bias.read())),null!=i&&(n=RNe(n,i));let o=ANe(a,bPe(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:rBe(this.activation),useBias:this.useBias,kernelInitializer:GPe(this.kernelInitializer),recurrentInitializer:GPe(this.recurrentInitializer),biasInitializer:GPe(this.biasInitializer),kernelRegularizer:cBe(this.kernelRegularizer),recurrentRegularizer:cBe(this.recurrentRegularizer),biasRegularizer:cBe(this.biasRegularizer),activityRegularizer:cBe(this.activityRegularizer),kernelConstraint:ILe(this.kernelConstraint),recurrentConstraint:ILe(this.recurrentConstraint),biasConstraint:ILe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}UBe.className="SimpleRNNCell",VNe(UBe);class jBe extends WBe{constructor(e){e.cell=new UBe(e),super(e)}call(e,t){return yCe((()=>{null!=this.cell.dropoutMask&&(bCe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(bCe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}}jBe.className="SimpleRNN",VNe(jBe);class GBe extends VBe{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new pOe("GRUCell does not support reset_after parameter set to true.");this.units=e.units,DOe(this.units,"units"),this.activation=sBe(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=sBe(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=HPe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=HPe(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=HPe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=hBe(e.kernelRegularizer),this.recurrentRegularizer=hBe(e.recurrentRegularizer),this.biasRegularizer=hBe(e.biasRegularizer),this.kernelConstraint=NLe(e.kernelConstraint),this.recurrentConstraint=NLe(e.recurrentConstraint),this.biasConstraint=NLe(e.biasConstraint),this.dropout=aPe([1,sPe([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=aPe([1,sPe([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=YPe(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return yCe((()=>{if(2!==e.length)throw new pOe(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=YBe({ones:()=>S_e(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=YBe({ones:()=>S_e(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,s=this.recurrentDropoutMask;let i,o,l;0<this.dropout&&this.dropout<1&&(e=RNe(e,a[0]));let u=bPe(e,this.kernel.read());this.useBias&&(u=kPe(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=RNe(r,s[0]));const c=this.recurrentKernel.read(),[d,h]=v$e(c,[2*this.units,this.units],c.rank-1),p=bPe(r,d),[f,m,g]=v$e(u,3,u.rank-1),[y,b]=v$e(p,2,p.rank-1);i=this.recurrentActivation.apply(ANe(f,y)),o=this.recurrentActivation.apply(ANe(m,b));const v=bPe(RNe(o,r),h);l=this.activation.apply(ANe(g,v));const x=ANe(RNe(i,r),RNe(ANe(1,YAe(i)),l));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:rBe(this.activation),recurrentActivation:rBe(this.recurrentActivation),useBias:this.useBias,kernelInitializer:GPe(this.kernelInitializer),recurrentInitializer:GPe(this.recurrentInitializer),biasInitializer:GPe(this.biasInitializer),kernelRegularizer:cBe(this.kernelRegularizer),recurrentRegularizer:cBe(this.recurrentRegularizer),biasRegularizer:cBe(this.biasRegularizer),activityRegularizer:cBe(this.activityRegularizer),kernelConstraint:ILe(this.kernelConstraint),recurrentConstraint:ILe(this.recurrentConstraint),biasConstraint:ILe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}GBe.className="GRUCell",VNe(GBe);class HBe extends WBe{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new GBe(e),super(e)}call(e,t){return yCe((()=>{null!=this.cell.dropoutMask&&(bCe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(bCe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}HBe.className="GRU",VNe(HBe);class qBe extends VBe{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,DOe(this.units,"units"),this.activation=sBe(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=sBe(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=HPe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=HPe(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=HPe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=hBe(e.kernelRegularizer),this.recurrentRegularizer=hBe(e.recurrentRegularizer),this.biasRegularizer=hBe(e.biasRegularizer),this.kernelConstraint=NLe(e.kernelConstraint),this.recurrentConstraint=NLe(e.recurrentConstraint),this.biasConstraint=NLe(e.biasConstraint),this.dropout=aPe([1,sPe([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=aPe([1,sPe([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=YPe(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new(t=class extends TPe{apply(t,r){const a=e.apply([n]),s=(new APe).apply([n]),i=e.apply([2*n]);return mPe(mPe(a,s),i)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return yCe((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new pOe(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=YBe({ones:()=>S_e(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=YBe({ones:()=>S_e(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(e=RNe(e,s[0]));let d=bPe(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=RNe(r,i[0])),d=ANe(d,bPe(r,this.recurrentKernel.read())),this.useBias&&(d=kPe(d,this.bias.read()));const[h,p,f,m]=v$e(d,4,d.rank-1);o=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=ANe(RNe(l,a),RNe(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=RNe(c,this.activation.apply(u));return[g,g,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:rBe(this.activation),recurrentActivation:rBe(this.recurrentActivation),useBias:this.useBias,kernelInitializer:GPe(this.kernelInitializer),recurrentInitializer:GPe(this.recurrentInitializer),biasInitializer:GPe(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:cBe(this.kernelRegularizer),recurrentRegularizer:cBe(this.recurrentRegularizer),biasRegularizer:cBe(this.biasRegularizer),activityRegularizer:cBe(this.activityRegularizer),kernelConstraint:ILe(this.kernelConstraint),recurrentConstraint:ILe(this.recurrentConstraint),biasConstraint:ILe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}qBe.className="LSTMCell",VNe(qBe);class KBe extends WBe{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new qBe(e),super(e)}call(e,t){return yCe((()=>{null!=this.cell.dropoutMask&&(bCe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(bCe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}KBe.className="LSTM",VNe(KBe);class XBe extends VBe{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return yCe((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let s;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],s=0===i?[e[0]].concat(n):[s[0]].concat(n),s=o.call(s,t),a.push(s.slice(1))}n=[];for(const e of a.slice().reverse())n.push(...e);return[s[0]].concat(n)}))}build(e){let t;qPe(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{QOe(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of t.cells)r.push(LLe(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return eLe(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}tLe(t)}}function YBe(e){const{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):SPe(t(),n),o=()=>IPe(i,t,r);if(!a||a<=1)return vCe(o().clone());return Array(a).fill(void 0).map(o).map((e=>vCe(e.clone())))}XBe.className="StackedRNNCells",VNe(XBe);var QBe=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};class JBe extends WBe{constructor(e){if(e.unroll)throw new fOe("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new fOe("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new nLe({ndim:5})]}call(e,t){return yCe((()=>{if(null!=this.cell.dropoutMask&&(bCe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(bCe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new pOe("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return yCe((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=h_e([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];yCe((()=>{if(!this.stateful)throw new dOe("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new pOe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>h_e(a))):this.states_=[h_e(a)];else if(null==e)bCe(this.states_),null!=this.keptStates&&(bCe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>h_e(a))):this.states_[0]=h_e(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new pOe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):bCe(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=a;if(!jve(n.shape,r))throw new pOe(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>vCe(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=xBe(l,r[0],a,s[0],i[0]),d=xBe(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}}JBe.className="ConvRNN2D";class ZBe extends qBe{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,DOe(this.filters,"filters"),this.kernelSize=vBe(n,2,"kernelSize"),this.kernelSize.forEach((e=>DOe(e,"kernelSize"))),this.strides=vBe(r||1,2,"strides"),this.strides.forEach((e=>DOe(e,"strides"))),this.padding=a||"valid",qOe(this.padding),this.dataFormat=s||"channelsLast",HOe(this.dataFormat),this.dilationRate=vBe(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>DOe(e,"dilationRate")))}build(e){var t;e=YPe(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new pOe(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends TPe{apply(e,t){return fPe([n.apply([r]),p_e([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return yCe((()=>{if(3!==e.length)throw new pOe(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],a=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=YBe({ones:()=>S_e(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?RNe(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),d=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=YBe({ones:()=>S_e(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let p=o(a,h,0),f=o(a,h,1),m=o(a,h,2),g=o(a,h,3);const[y,b,v,x]=v$e(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?v$e(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,v,S,this.padding),d=this.inputConv(d,x,I,this.padding);const[C,N,T,E]=v$e(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,C),f=this.recurrentConv(f,N),m=this.recurrentConv(m,T),g=this.recurrentConv(g,E);const A=this.recurrentActivation.apply(ANe(l,p)),_=this.recurrentActivation.apply(ANe(u,f)),$=ANe(RNe(_,s),RNe(A,this.activation.apply(ANe(c,m)))),R=RNe(this.recurrentActivation.apply(ANe(d,g)),this.activation.apply($));return[R,R,$]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=QBe(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const a=HEe(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?kPe(a,n,this.dataFormat):a}recurrentConv(e,t){return HEe(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}ZBe.className="ConvLSTM2DCell",VNe(ZBe);class eWe extends JBe{constructor(e){const t=new ZBe(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}eWe.className="ConvLSTM2D",VNe(eWe);class tWe extends oLe{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return yCe((()=>{this.invokeCallHook(e,t);const n=XPe(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return IPe((()=>SPe(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}tWe.className="Dropout",VNe(tWe);class nWe extends tWe{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}nWe.className="SpatialDropout1D",VNe(nWe);class rWe extends oLe{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,DOe(this.units,"units"),this.activation=sBe(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=HPe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=HPe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=NLe(e.kernelConstraint),this.biasConstraint=NLe(e.biasConstraint),this.kernelRegularizer=hBe(e.kernelRegularizer),this.biasRegularizer=hBe(e.biasRegularizer),this.activityRegularizer=hBe(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=YPe(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=YPe(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return yCe((()=>{this.invokeCallHook(e,t);const n=XPe(e),r=FOe(this.activation.getClassName());let a;return null!=r?a=bPe(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=bPe(n,this.kernel.read()),null!=this.bias&&(a=kPe(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const e={units:this.units,activation:rBe(this.activation),useBias:this.useBias,kernelInitializer:GPe(this.kernelInitializer),biasInitializer:GPe(this.biasInitializer),kernelRegularizer:cBe(this.kernelRegularizer),biasRegularizer:cBe(this.biasRegularizer),activityRegularizer:cBe(this.activityRegularizer),kernelConstraint:ILe(this.kernelConstraint),biasConstraint:ILe(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}rWe.className="Dense",VNe(rWe);class aWe extends oLe{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=YPe(e);for(const t of e.slice(1))if(null==t)throw new pOe(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],rPe(e,1)]}call(e,t){return yCe((()=>{this.invokeCallHook(e,t);let n=XPe(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=H$e(n,e)}return function(e){if(e.rank<=1)throw new pOe(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],rPe(e.shape,1)];return kEe(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}aWe.className="Flatten",VNe(aWe);class sWe extends oLe{constructor(e){super(e),this.supportsMasking=!0,this.activation=sBe(e.activation)}call(e,t){return yCe((()=>{this.invokeCallHook(e,t);const n=XPe(e);return this.activation.apply(n)}))}getConfig(){const e={activation:rBe(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}sWe.className="Activation",VNe(sWe);class iWe extends oLe{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return yCe((()=>function(e,t){return yCe((()=>{if(2!==e.shape.length)throw new pOe(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return gPe(cPe(e,1),[1,t,1])}))}(e=XPe(e),this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}iWe.className="RepeatVector",VNe(iWe);class oWe extends oLe{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let a=1,s=null;for(let o=0;o<r.length;++o){const e=r[o];if(this.isUnknown(e)){if(null!==s)throw new pOe("Can only specifiy one unknown dimension.");s=o}else a*=e}const i=rPe(e);if(null!==s){if(0===a||i%a!==0)throw new pOe(n);r[s]=i/a}else if(i!==a)throw new pOe(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return yCe((()=>{this.invokeCallHook(e,t);const n=XPe(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return kEe(n,a)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}oWe.className="Reshape",VNe(oWe);class lWe extends oLe{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=iPe(1,e.dims.length+1);if(!jve(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new nLe({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=YPe(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return H$e(XPe(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}lWe.className="Permute",VNe(lWe);class uWe extends oLe{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=XPe(e);return ZTe(w_e(n,this.maskValue),-1)}call(e,t){return yCe((()=>{this.invokeCallHook(e,t);const n=XPe(e),r=ZTe(w_e(n,this.maskValue),-1,!0);return RNe(n,NNe(r,n.dtype))}))}}uWe.className="Masking",VNe(uWe);class cWe extends oLe{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(wOe(e.inputLength))}this.inputDim=e.inputDim,DOe(this.inputDim,"inputDim"),this.outputDim=e.outputDim,DOe(this.outputDim,"outputDim"),this.embeddingsInitializer=HPe(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=hBe(e.embeddingsRegularizer),this.activityRegularizer=hBe(e.activityRegularizer),this.embeddingsConstraint=NLe(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return yCe((()=>this.maskZero?(e=XPe(e),w_e(e,FNe(e))):null))}computeOutputShape(e){if(e=YPe(e),null==this.inputLength)return[...e,this.outputDim];const t=wOe(this.inputLength);if(t.length!==e.length-1)throw new pOe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new pOe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return yCe((()=>{this.invokeCallHook(e,t);let n=XPe(e);"int32"!==n.dtype&&(n=uPe(n,"int32"));const r=vPe(this.embeddings.read(),kEe(n,[n.size]));return kEe(r,YPe(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:GPe(this.embeddingsInitializer),embeddingsRegularizer:cBe(this.embeddingsRegularizer),activityRegularizer:cBe(this.activityRegularizer),embeddingsConstraint:ILe(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}cWe.className="Embedding",VNe(cWe);class dWe extends oLe{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new fOe}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new pOe("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[YPe(e)]),e.length<2)throw new pOe(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=AOe(t),t.length>1)throw new pOe(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===AOe(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return yCe((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=sPe(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=cPe(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const s of e){const e=s.rank;if(null==e){const e=s.shape,r=e[0],a=e.slice(1).concat([r]);let i=kEe(s,[r].concat(rPe(e.slice(1))));i=H$e(i,[1,0]),i=kEe(i,a),t.push(i),n=!0}else if(e>1){const r=iPe(1,e).concat([0]);t.push(H$e(s,r)),n=!0}else t.push(s)}let r=this.mergeFunction(t);const a=r.rank;if(n)if(null==a){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=kEe(H$e(kEe(r,[-1,t]),[1,0]),n)}else if(a>1){const e=[a-1].concat(iPe(0,a-1));r=H$e(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=AOe(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return yCe((()=>{if(null==t)return null;if(!Array.isArray(t))throw new pOe("`mask` should be an Array");if(!Array.isArray(e))throw new pOe("`inputs` should be an Array");if(t.length!==e.length)throw new pOe(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:$Ae(e,0))))[0];for(let e=1;e<t.length-1;++e)n=t_e(n,t[e]);return n}))}}class hWe extends dWe{constructor(e){super(e)}mergeFunction(e){return yCe((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ANe(t,e[n]);return t}))}}hWe.className="Add",VNe(hWe);class pWe extends dWe{constructor(e){super(e)}mergeFunction(e){return yCe((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=RNe(t,e[n]);return t}))}}pWe.className="Multiply",VNe(pWe);class fWe extends dWe{constructor(e){super(e)}mergeFunction(e){return yCe((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ANe(t,e[n]);return RNe(1/e.length,t)}))}}fWe.className="Average",VNe(fWe);class mWe extends dWe{constructor(e){super(e)}mergeFunction(e){return yCe((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=eTe(t,e[n]);return t}))}}mWe.className="Maximum",VNe(mWe);class gWe extends dWe{constructor(e){super(e)}mergeFunction(e){return yCe((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=m_e(t,e[n]);return t}))}}gWe.className="Minimum",VNe(gWe);class yWe extends dWe{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new pOe("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let a=!1;for(const e of n)if(jve(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new pOe("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return yCe((()=>fPe(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new pOe("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new pOe("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new pOe("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new pOe(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return yCe((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let s=0;s<e.length;++s)null==t[s]?r.push(NNe(S_e(e[s]),"bool")):t[s].rank<e[s].rank?r.push($Ae(t[s],-1)):r.push(t[s]);const a=CEe(r,this.axis);return JTe(a,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function bWe(e,t){for(;e<0;)e+=t;return e}yWe.className="Concatenate",VNe(yWe);class vWe extends dWe{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Bve(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new fOe("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new pOe(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new pOe(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>bWe(t,e[n].shape.length))):[bWe(this.axes,n.shape.length),bWe(this.axes,r.shape.length)],this.normalize&&(n=zLe(n,t[0]),r=zLe(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new fOe("batchDot is not implemented for tensors of 4D or higher rank yet");if(Bve(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),Bve(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new fOe("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);const s=n;return yCe((()=>{let n,i;if(r>a){n=r-a;const e=[];for(let t=0;t<n;++t)e.push(1);t=kEe(t,t.shape.concat(e))}else if(a>r){n=a-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=kEe(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?NAe(RNe(e,t),s[0]):NAe(RNe(H$e(e,[1,0]),t),s[1]);else{const n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;i=NEe(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=k$e(i,t)}return 1===i.shape.length&&(i=$Ae(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[bWe(this.axes,e.length),bWe(this.axes,t.length)],n}computeOutputShape(e){Bve(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new fOe("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}vWe.className="Dot",VNe(vWe);class xWe extends oLe{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return yCe((()=>{this.invokeCallHook(e,t);const n=XPe(e);return IPe((()=>ANe(yPe(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}xWe.className="GaussianNoise",VNe(xWe);class wWe extends oLe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return yCe((()=>{this.invokeCallHook(e,t);const n=XPe(e);if(this.rate>0&&this.rate<1){return IPe((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return RNe(n,yPe(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}wWe.className="GaussianDropout",VNe(wWe);class kWe extends oLe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||XPe(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return yCe((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=XPe(e),r=-1.7580993408473766;let a=LAe(G_e(n),this.rate);a=uPe(a,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-s*r*this.rate,o=ANe(RNe(t,a),RNe(ANe(a,-1),r));return ANe(RNe(o,s),i)};return IPe(r,(()=>XPe(e)),t.training||!1)}return e}))}}function SWe(e,t,n,r,a){let s,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)s=DEe(e,t,n,r,a,i);else if(3===e.rank)s=MEe(e,t,n,r,a,i);else{if(4!==e.rank)throw new fOe(`batchNormalization is not implemented for array of rank ${e.rank} yet`);s=FEe(e,t,n,r,a,i)}return s}function IWe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return jve(r.slice().sort(),iPe(0,e.rank-1))?function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return yCe((()=>{const s=b_e(e,r),i=s.mean,o=s.variance;return[SWe(e,i,o,n,t,a),i,o]}))}(e,t,n,r,a):function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return yCe((()=>{const s=b_e(e,r),i=s.mean,o=s.variance,l=[];for(const t of iPe(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=kEe(i,l),c=kEe(o,l),d=null==t?null:kEe(t,l),h=null==n?null:kEe(n,l);return[SWe(e,u,c,h,d,a),i,o]}))}(e,t,n,r,a)}kWe.className="AlphaDropout",VNe(kWe);class CWe extends oLe{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=HPe(e.betaInitializer||"zeros"),this.gammaInitializer=HPe(e.gammaInitializer||"ones"),this.movingMeanInitializer=HPe(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=HPe(e.movingVarianceInitializer||"ones"),this.betaConstraint=NLe(e.betaConstraint),this.gammaConstraint=NLe(e.gammaConstraint),this.betaRegularizer=hBe(e.betaRegularizer),this.gammaRegularizer=hBe(e.gammaRegularizer)}build(e){e=YPe(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new pOe(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new nLe({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return yCe((()=>{const n=null!=t.training&&t.training,r=XPe(e),a=r.shape,s=a.length,i=iPe(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);const l=yOe(1,s);l[o]=a[o];const u=i.slice();u.sort();const c=!jve(u,iPe(0,s).slice(0,s-1));if(!n)return(()=>{if(c){const e=kEe(this.movingMean.read(),l),t=kEe(this.movingVariance.read(),l),n=this.center?kEe(this.beta.read(),l):null,a=this.scale?kEe(this.gamma.read(),l):null;return SWe(r,e,t,n,a,this.epsilon)}return SWe(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,h,p]=IWe(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{yCe((()=>{const r=1-n,a=e.read(),s=RNe(KNe(a,t),r);e.write(KNe(a,s))}))};return(()=>{f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:GPe(this.betaInitializer),gammaInitializer:GPe(this.gammaInitializer),movingMeanInitializer:GPe(this.movingMeanInitializer),movingVarianceInitializer:GPe(this.movingVarianceInitializer),betaRegularizer:cBe(this.betaRegularizer),gammaRegularizer:cBe(this.gammaRegularizer),betaConstraint:ILe(this.betaConstraint),gammaConstraint:ILe(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}CWe.className="BatchNormalization",VNe(CWe);class NWe extends oLe{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=HPe(e.betaInitializer||"zeros"),this.gammaInitializer=HPe(e.gammaInitializer||"ones"),this.betaRegularizer=hBe(e.betaRegularizer),this.gammaRegularizer=hBe(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=YPe(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==AOe(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=XPe(e),r=n.shape,a=r.length;return yCe((()=>{let{mean:e,variance:t}=b_e(n,this.axis,!0);const s=yOe(1,a);for(const n of this.axis)s[n]=r[n];const i=e=>null!=e&&e.shape.length!==a?kEe(e,s):e;let o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null;const u=[],c=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=DAe(e,u),t=DAe(t,u),null!=o&&(o=DAe(o,c)),null!=l&&(l=DAe(l,c)),SWe(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:GPe(this.betaInitializer),gammaInitializer:GPe(this.gammaInitializer),betaRegularizer:cBe(this.betaRegularizer),gammaRegularizer:cBe(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}NWe.className="LayerNormalization",VNe(NWe);class TWe extends oLe{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new pOe(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new pOe(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new pOe(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new nLe({ndim:4})]}computeOutputShape(e){let t,n;return e=YPe(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return yCe((()=>function(e,t,n){return yCe((()=>{if(4!==e.rank)throw new pOe(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new pOe("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new pOe(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],C_e(e,r)}))}(XPe(e),this.padding,this.dataFormat)))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function EWe(e,t,n,r,a,s){return yCe((()=>{let i;HOe(a),KOe(s),qOe(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=kBe(e,a);const o="same"===r?"same":"valid";return i="max"===s?l_e(e,t,n,o):SEe(e,t,n,o),"channelsFirst"===a&&(i=H$e(i,[0,3,1,2])),i}))}function AWe(e,t,n,r,a,s){return yCe((()=>{let i;HOe(a),KOe(s),qOe(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=SBe(e,a);const o="same"===r?"same":"valid";return i="max"===s?u_e(e,t,n,o):IEe(e,t,n,o),"channelsFirst"===a&&(i=H$e(i,[0,4,1,2,3])),i}))}TWe.className="ZeroPadding2D",VNe(TWe);class _We extends oLe{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new pOe(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(DOe(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new pOe(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}DOe(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,qOe(this.padding),this.inputSpec=[new nLe({ndim:3})]}computeOutputShape(e){const t=xBe((e=YPe(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return yCe((()=>{this.invokeCallHook(e,t),e=cPe(XPe(e),2);const n=this.poolingFunction(XPe(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return k$e(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class $We extends _We{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return HOe(a),qOe(r),EWe(e,t,n,r,a,"max")}}$We.className="MaxPooling1D",VNe($We);class RWe extends _We{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return HOe(a),qOe(r),EWe(e,t,n,r,a,"avg")}}RWe.className="AveragePooling1D",VNe(RWe);class DWe extends oLe{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new pOe(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];DOe(this.poolSize,"poolSize"),DOe(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,HOe(this.dataFormat),qOe(this.padding),this.inputSpec=[new nLe({ndim:4})]}computeOutputShape(e){e=YPe(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=xBe(t,this.poolSize[0],this.padding,this.strides[0]),n=xBe(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return yCe((()=>(this.invokeCallHook(e,t),this.poolingFunction(XPe(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class MWe extends DWe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return HOe(a),qOe(r),EWe(e,t,n,r,a,"max")}}MWe.className="MaxPooling2D",VNe(MWe);class FWe extends DWe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return HOe(a),qOe(r),EWe(e,t,n,r,a,"avg")}}FWe.className="AveragePooling2D",VNe(FWe);class OWe extends oLe{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new pOe(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];DOe(this.poolSize,"poolSize"),DOe(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,HOe(this.dataFormat),qOe(this.padding),this.inputSpec=[new nLe({ndim:5})]}computeOutputShape(e){e=YPe(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=xBe(t,this.poolSize[0],this.padding,this.strides[0]),n=xBe(n,this.poolSize[1],this.padding,this.strides[1]),r=xBe(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return yCe((()=>(this.invokeCallHook(e,t),this.poolingFunction(XPe(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class PWe extends OWe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return HOe(a),qOe(r),AWe(e,t,n,r,a,"max")}}PWe.className="MaxPooling3D",VNe(PWe);class LWe extends OWe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return HOe(a),qOe(r),AWe(e,t,n,r,a,"avg")}}LWe.className="AveragePooling3D",VNe(LWe);class zWe extends oLe{constructor(e){super(e),this.inputSpec=[new nLe({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new fOe}}class BWe extends zWe{constructor(e){super(e||{})}call(e,t){return yCe((()=>{const t=XPe(e);return d_e(t,1)}))}}BWe.className="GlobalAveragePooling1D",VNe(BWe);class WWe extends zWe{constructor(e){super(e||{})}call(e,t){return yCe((()=>{const t=XPe(e);return IAe(t,1)}))}}WWe.className="GlobalMaxPooling1D",VNe(WWe);class VWe extends oLe{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,HOe(this.dataFormat),this.inputSpec=[new nLe({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new fOe}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class UWe extends VWe{call(e,t){return yCe((()=>{const t=XPe(e);return"channelsLast"===this.dataFormat?d_e(t,[1,2]):d_e(t,[2,3])}))}}UWe.className="GlobalAveragePooling2D",VNe(UWe);class jWe extends VWe{call(e,t){return yCe((()=>{const t=XPe(e);return"channelsLast"===this.dataFormat?IAe(t,[1,2]):IAe(t,[2,3])}))}}jWe.className="GlobalMaxPooling2D",VNe(jWe);class GWe extends oLe{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=LLe(t.layer,n);delete t.layer;const a={layer:r};return Object.assign(a,t),new e(a)}}class HWe extends GWe{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=YPe(e)).length<3)throw new pOe(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=YPe(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return yCe((()=>BBe(((e,n)=>[XPe(this.layer.call(e,t)),[]]),e=XPe(e),[],!1,null,null,!1,!0)[1]))}}HWe.className="TimeDistributed",VNe(HWe);class qWe extends GWe{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=LLe(n),t.goBackwards=!0!==t.goBackwards;const r={};var a;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=LLe(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,a=this.mergeMode,$Oe(jOe,"BidirectionalMergeMode",a),e.weights)throw new fOe("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),t=a[0]):t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):xOe(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=zBe(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const s=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new pOe("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);const r=n.map((e=>new nLe({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new fOe("Support for constants in Bidirectional layers is not implemented yet.");const o=s[0]instanceof rLe;for(const l of s)if(l instanceof rLe!==o)throw new pOe("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return yCe((()=>{const n=t.initialState;let r,a,s,i;if(null==n)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{const s=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:s})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=J_e(a,1)),"concat"===this.mergeMode?i=fPe([r,a]):"sum"===this.mergeMode?i=ANe(r,a):"ave"===this.mergeMode?i=RNe(.5,ANe(r,a)):"mul"===this.mergeMode?i=RNe(r,a):null==this.mergeMode&&(i=[r,a]),this.returnState?null==this.mergeMode?i.concat(s):[i].concat(s):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){QOe(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),QOe(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=LLe(t.layer);if(delete t.layer,null!=t.numConstants)throw new fOe("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}qWe.className="Bidirectional",VNe(qWe);class KWe extends oLe{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return yCe((()=>("float32"!==(e=XPe(e)).dtype&&(e=uPe(e,"float32")),ANe(RNe(e,this.scale),this.offset))))}}KWe.className="Rescaling",VNe(KWe);const{resizeBilinear:XWe,cropAndResize:YWe}=cDe;class QWe extends oLe{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return yCe((()=>{let l,u=!1;const c=[t/s,n/i,(r+t)/s,(a+n)/i],d=[];3===e.rank?(u=!0,l=S$e([e])):l=e;for(let e=0;e<l.shape[0];e++)d.push(c);const h=hCe(d,[d.length,4]),p=q_e(0,d.length,1,"int32"),f=YWe(l,h,p,[r,a],"nearest");return uPe(u?XPe(B$e(f)):f,o)}))}upsize(e,t,n,r){return yCe((()=>uPe(XWe(e,[t,n]),r)))}call(e,t){return yCe((()=>{const t=XPe(e),n=t.dtype,r=t.shape,a=r[r.length-3],s=r[r.length-2];let i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let o=0;return s!==this.width&&(o=Math.floor((s-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,a,s,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=YPe(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}QWe.className="CenterCrop",VNe(QWe);class JWe extends oLe{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=YPe(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return yCe((()=>{let n;if("int32"!==(e=XPe(e)).dtype&&(e=uPe(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new pOe(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=XPe(t.countWeights)}const r=IAe(e),a=CAe(e),s=PAe(this.numTokens,r).bufferSync().get(0),i=LAe(a,0).bufferSync().get(0);if(!s||!i)throw new pOe(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let a=XPe(e);if("int32"!==a.dtype&&(a=uPe(a,"int32")),"int"===t)return a;const s=a.shape;if(0===a.rank&&(a=$Ae(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=$Ae(a,-1)),a.rank>2)throw new pOe(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);const i=["multiHot","oneHot"].includes(t),o=a;let l;if(l=rAe(o,"undefined"!==typeof r&&"count"===t?r:[],n,i),"tfIdf"!==t)return l;if(r)return RNe(l,r);throw new pOe("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}JWe.className="CategoryEncoding",VNe(JWe);const ZWe=new Set(["bilinear","nearest"]);class eVe extends oLe{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!ZWe.has(e.interpolation))throw new pOe(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=YPe(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return yCe((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return cDe.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return cDe.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...ZWe]} are supported`)}))}}eVe.className="Resizing",VNe(eVe);class tVe{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}tVe.className="RandomSeed";class nVe extends oLe{constructor(e){super(e),this.randomGenerator=new tVe(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}nVe.className="BaseRandomLayer";const rVe=new Set(["bilinear","nearest"]);class aVe extends nVe{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new pOe(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new pOe(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new pOe(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!rVe.has(n))throw new pOe(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=YPe(e))[2];return[this.imgHeight,-1,t]}call(e,t){return yCe((()=>{const t=XPe(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=G_e([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return cDe.resizeBilinear(e,a);case"nearest":return cDe.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...rVe]} are supported`)}}))}}aVe.className="RandomWidth",VNe(aVe);var sVe,iVe;xxe().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(sVe||(sVe={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(iVe||(iVe={}));const oVe={};function lVe(e){return oVe[e]}function uVe(e,t,n,r,a){const s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){const e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return cVe(t.inputNames[o],n,r,a);if("tensors"===s.type){const s=t.inputs.slice(e,i),o=t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=s[t])||void 0===n?void 0:n.op)}));return o.map((e=>cVe(e,n,r,a)))}const l=cVe(t.inputNames[o],n,r,a),u=l.dataSync();return"number"===s.type?u[0]:uxe(l.shape,u)}const i=t.attrParams[e];return i&&i.value}function cVe(e,t,n,r){const[a,s]=fVe(e,n);if(null!=r){const e=r.getHashTableHandleByName(a);if(null!=e)return e}const i=n.currentContextIds.find((e=>!!t[pVe(a,e)]));return void 0!==i?t[pVe(a,i)][s]:void 0}function dVe(e,t,n){return t[pVe(e,n.currentContextId)]}function hVe(e,t){const[n,r,a]=fVe(e,t);return[pVe(n,t&&t.currentContextId),r,a]}function pVe(e,t){return t?`${e}-${t}`:e}function fVe(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let a;if(1===r.length)a=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;a=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,a),a}function mVe(e,t,n){let r=uVe("pad",e,t,n);if("explicit"===r){r=uVe("explicitPaddings",e,t,n);const a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function gVe(e){return e.kept?e:TNe(e)}const yVe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],bVe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],vVe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],xVe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],wVe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],kVe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],SVe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],IVe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],CVe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],NVe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],TVe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],EVe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],AVe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],_Ve=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],$Ve=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],RVe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],DVe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],MVe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],FVe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class OVe{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[i,o,l,u,c,d,h,p,f,m,g,y,b,v,x,w,k,S,I].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,r=[],a=[],s=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e)),{});let o=[];const l=[];let u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(i);d.forEach((e=>{const t=i[e];t.inputNames.forEach(((e,n)=>{const[r,,a]=hVe(e),s=i[r];if(null!=s.outputs){const e=s.outputs.indexOf(a);if(-1!==e){const a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{const t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{const[t]=hVe(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{const[t]=hVe(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:h};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=lVe(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let a;switch(n.type){case"string":a=LVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=LVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":a=KVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=KVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":a=BVe(e.attr,n.tfName,n.defaultValue||0),void 0===a&&n.tfDeprecatedName&&(a=BVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":a=qVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=qVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":a=zVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=zVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":a=YVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=YVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":a=HVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=HVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":a=XVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=XVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":a=UVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=UVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":a=jVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=jVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":a=VVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=VVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:a,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const a=[],s=[];e.signature.inputArg.forEach((e=>{const[t]=hVe(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:WVe(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,a.push(n),r[t]=n}));Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[a,,s]=hVe(e),i=r[a];if(null!=i.outputs){const e=i.outputs.indexOf(s);if(-1!==e){const r=`${a}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));const i=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=hVe(i[e.name]),a=r[t];null!=a&&(a.defaultOutput=n,s.push(a))}));const o=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:s,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function PVe(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=xxe().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function LVe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e[t];return null!=a?PVe(a.s,r):n}function zVe(e,t,n){const r=e[t];return r?r.b:n}function BVe(e,t,n){const r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"===typeof a?a:parseInt(a,10)}function WVe(e){switch("string"===typeof e&&(e=sVe[e]),e){case sVe.DT_FLOAT:case sVe.DT_HALF:return"float32";case sVe.DT_INT32:case sVe.DT_INT64:case sVe.DT_INT8:case sVe.DT_UINT8:return"int32";case sVe.DT_BOOL:return"bool";case sVe.DT_DOUBLE:return"float32";case sVe.DT_STRING:return"string";case sVe.DT_COMPLEX64:case sVe.DT_COMPLEX128:return"complex64";default:return null}}function VVe(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function UVe(e,t,n){const r=e[t];return r&&r.type?WVe(r.type):n}function jVe(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>WVe(e))):n}function GVe(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function HVe(e,t,n){const r=e[t];return r&&r.shape?GVe(r.shape):n}function qVe(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function KVe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>PVe(e,r))):n}function XVe(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>GVe(e))):n}function YVe(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class QVe{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return cVe(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return cVe(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return BVe(this.node.rawAttrs,e,t);if(null!=n.s)return LVe(this.node.rawAttrs,e,t);if(null!=n.b)return zVe(this.node.rawAttrs,e,t);if(null!=n.shape)return HVe(this.node.rawAttrs,e,t);if(null!=n.type)return UVe(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return qVe(this.node.rawAttrs,e,t);if(null!=n.list.s)return KVe(this.node.rawAttrs,e,t);if(null!=n.list.shape)return XVe(this.node.rawAttrs,e,t);if(null!=n.list.b)return YVe(this.node.rawAttrs,e,t);if(null!=n.list.type)return jVe(this.node.rawAttrs,e,t)}return t}}function JVe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){Bve(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const a=e[r],s=t[r];Bve(a<0||s<0||a===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function ZVe(e){return"number"!==typeof e&&!e.some((e=>e<0))}function eUe(e,t,n){let r=tUe(e,n);const a=!ZVe(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=tUe(e.shape,r)})),!ZVe(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function tUe(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}class nUe{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=PNe(0),vCe(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),JVe(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,vCe(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return hCe([],[0].concat(this.elementShape));const n=this.readMany(e);return JVe(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),S$e(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return hCe([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return JVe(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),CEe(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,B$e(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=0===n?0:t.size/n,s=[];yCe((()=>{t=kEe(t,[1,n,a]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],a];s[n]=kEe(EEe(t,i,o),this.elementShape)}return s}));const i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}}class rUe{get id(){return this.idTensor.id}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);JVe(t,e.shape,"TensorList shape mismatch: "),vCe(e)})),this.idTensor=PNe(0),this.maxNumElements=r,vCe(this.idTensor)}copy(){return new rUe([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);JVe(e,this.elementShape,"TensorList shape mismatch: ");const r=eUe(this.elementShape,this.tensors,e);return yCe((()=>{const e=this.tensors.map((e=>kEe(e,r)));return S$e(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=eUe(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,JVe(r.shape,e,"TensorList shape mismatch: "),kEe(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(JVe(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");vCe(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new rUe([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);JVe(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=eUe(this.elementShape,this.tensors,t);return kEe(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);JVe(this.elementShape,t.shape,"TensorList shape mismatch: "),vCe(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);JVe(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=eUe(this.elementShape,this.tensors,n);return 0===e.length?hCe([],[0].concat(r)):yCe((()=>{const t=e.map((e=>kEe(this.tensors[e],r)));return S$e(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);JVe(this.elementShape,t,"TensorList shape mismatch: ");const n=eUe(this.elementShape,this.tensors,t);return 0===this.size()?hCe([],[0].concat(n)):yCe((()=>{const e=this.tensors.map((e=>kEe(e,n)));return CEe(e,0)}))}}const aUe=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=uVe("thenBranch",e,t,n),a=uVe("elseBranch",e,t,n),s=uVe("cond",e,t,n),i=uVe("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=uVe("body",e,t,n),a=uVe("cond",e,t,n),s=uVe("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map((e=>e.id));let l=await i[0].data();i.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let u=s;for(;l[0];){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return u}case"LoopCond":return[gVe(uVe("pred",e,t,n))];case"Switch":{const r=uVe("pred",e,t,n);let a=uVe("data",e,t,n);return a.kept||(a=gVe(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==cVe(e,t,n)));if(r){return[gVe(cVe(r,t,n))]}return}case"Enter":{const r=uVe("frameName",e,t,n),a=uVe("tensor",e,t,n);return n.enterFrame(r),[gVe(a)]}case"Exit":{const r=uVe("tensor",e,t,n);return n.exitFrame(),[gVe(r)]}case"NextIteration":{const r=uVe("tensor",e,t,n);return n.nextIteration(),[gVe(r)]}case"TensorArrayV3":{const r=uVe("size",e,t,n),a=uVe("dtype",e,t,n),s=uVe("elementShape",e,t,n),i=uVe("dynamicSize",e,t,n),o=uVe("clearAfterRead",e,t,n),l=uVe("identicalElementShapes",e,t,n),u=uVe("name",e,t,n),c=new nUe(u,a,r,s,l,i,o);return n.addTensorArray(c),[c.idTensor,PNe(1)]}case"TensorArrayWriteV3":{const r=uVe("tensorArrayId",e,t,n),a=uVe("index",e,t,n),s=uVe("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{const r=uVe("tensorArrayId",e,t,n),a=uVe("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{const r=uVe("tensorArrayId",e,t,n),a=uVe("indices",e,t,n),s=uVe("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{const r=uVe("tensorArrayId",e,t,n),a=uVe("indices",e,t,n),s=uVe("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{const r=uVe("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=uVe("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{const r=uVe("tensorArrayId",e,t,n),a=uVe("tensor",e,t,n),s=uVe("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{const r=uVe("tensorArrayId",e,t,n);return[PNe(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=uVe("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{const r=uVe("tensorListId",e,t,n),a=uVe("index",e,t,n),s=uVe("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{const r=uVe("tensorListId",e,t,n),a=uVe("index",e,t,n),s=uVe("elementShape",e,t,n),i=uVe("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=uVe("indices",e,t,n),a=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);const s=new rUe([],n,e.dtype,r),i=B$e(e,0);return t.forEach(((e,t)=>{s.setItem(e,i[t])})),s}(uVe("tensor",e,t,n),r,uVe("elementShape",e,t,n),uVe("numElements",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=uVe("elementShape",e,t,n),a=uVe("elementDType",e,t,n);let s;s="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=uVe(s,e,t,n),o=function(e,t,n,r){return new rUe([],e,t,r)}(r,a,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=uVe("tensorListId",e,t,n),a=uVe("indices",e,t,n),s=uVe("elementShape",e,t,n),i=uVe("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{const r=uVe("tensorListId",e,t,n),a=uVe("elementShape",e,t,n),s=uVe("elementDType",e,t,n),i=uVe("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);JVe(e.shape.slice(1),t,"TensorList shape mismatch: ");const a=B$e(e);return new rUe(a,t,r)}(uVe("tensor",e,t,n),uVe("elementShape",e,t,n),uVe("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=uVe("tensorListId",e,t,n),a=n.getTensorList(r.id),s=uVe("dtype",e,t,n),i=uVe("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{const r=uVe("tensorListId",e,t,n),a=uVe("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{const r=uVe("tensorListId",e,t,n),a=uVe("elementShape",e,t,n),s=uVe("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{const r=uVe("tensor",e,t,n),a=uVe("elementShape",e,t,n),s=function(e,t,n){let r=0;const a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const s=tUe(e.shape.slice(1),n),i=0===r?0:e.size/r,o=yCe((()=>{const n=[];e=kEe(e,[1,r,i]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:a[r-1],0],l=[1,t[r],i];n[r]=kEe(EEe(e,o,l),s)}return e.dispose(),n})),l=new rUe([],n,e.dtype,t.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(r,uVe("lengths",e,t,n),a);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{const r=uVe("tensorListId",e,t,n);return[PNe(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=uVe("tensorListId",e,t,n),a=uVe("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function sUe(e,t,n){const[r,a]=uVe("fusedOps",e,t,n),s="biasadd"===r,i=!s,o="prelu"===a,l="fusedbatchnorm"===r,u=uVe("numArgs",e,t,n);if(s){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=uVe("strides",e,t,n),d=mVe(e,t,n),h=uVe("dataFormat",e,t,n).toUpperCase(),p=uVe("dilations",e,t,n);let[f,m]=uVe("args",e,t,n);i&&(m=f,f=void 0);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:uVe("leakyreluAlpha",e,t,n)}}function iUe(e,t,n){return{boxes:uVe("boxes",e,t,n),scores:uVe("scores",e,t,n),maxOutputSize:uVe("maxOutputSize",e,t,n),iouThreshold:uVe("iouThreshold",e,t,n),scoreThreshold:uVe("scoreThreshold",e,t,n),softNmsSigma:uVe("softNmsSigma",e,t,n)}}class oUe{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=PNe(0),this.tensorMap=new Map,vCe(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return PNe(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),yCe((()=>{const e=B$e(t),r=n.length,a=e.length;Bve(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){const r=n[t],a=e[t];vCe(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return yCe((()=>{const e=[];for(let r=0;r<n.length;r++){const a=n[r],s=this.findWithDefault(a,t);e.push(s)}return S$e(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function lUe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:yCe;const s=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(uVe("a",e,t,n),uVe("b",e,t,n))];case"AddN":return[r.addN(uVe("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(uVe("a",e,t,n),uVe("b",e,t,n))];case"Mul":return[r.mul(uVe("a",e,t,n),uVe("b",e,t,n))];case"RealDiv":case"Div":return[r.div(uVe("a",e,t,n),uVe("b",e,t,n))];case"DivNoNan":return[r.divNoNan(uVe("a",e,t,n),uVe("b",e,t,n))];case"FloorDiv":return[r.floorDiv(uVe("a",e,t,n),uVe("b",e,t,n))];case"Sub":return[r.sub(uVe("a",e,t,n),uVe("b",e,t,n))];case"Minimum":return[r.minimum(uVe("a",e,t,n),uVe("b",e,t,n))];case"Maximum":return[r.maximum(uVe("a",e,t,n),uVe("b",e,t,n))];case"Pow":return[r.pow(uVe("a",e,t,n),uVe("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(uVe("a",e,t,n),uVe("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"basic_math":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(uVe("x",e,t,n))];case"Acos":return[r.acos(uVe("x",e,t,n))];case"Acosh":return[r.acosh(uVe("x",e,t,n))];case"Asin":return[r.asin(uVe("x",e,t,n))];case"Asinh":return[r.asinh(uVe("x",e,t,n))];case"Atan":return[r.atan(uVe("x",e,t,n))];case"Atan2":return[r.atan2(uVe("x",e,t,n),uVe("y",e,t,n))];case"Atanh":return[r.atanh(uVe("x",e,t,n))];case"Ceil":return[r.ceil(uVe("x",e,t,n))];case"Complex":return[r.complex(uVe("real",e,t,n),uVe("imag",e,t,n))];case"Cos":return[r.cos(uVe("x",e,t,n))];case"Cosh":return[r.cosh(uVe("x",e,t,n))];case"Elu":return[r.elu(uVe("x",e,t,n))];case"Erf":return[r.erf(uVe("x",e,t,n))];case"Exp":return[r.exp(uVe("x",e,t,n))];case"Expm1":return[r.expm1(uVe("x",e,t,n))];case"Floor":return[r.floor(uVe("x",e,t,n))];case"Log":return[r.log(uVe("x",e,t,n))];case"Log1p":return[r.log1p(uVe("x",e,t,n))];case"Imag":return[r.imag(uVe("x",e,t,n))];case"Neg":return[r.neg(uVe("x",e,t,n))];case"Reciprocal":return[r.reciprocal(uVe("x",e,t,n))];case"Real":return[r.real(uVe("x",e,t,n))];case"Relu":return[r.relu(uVe("x",e,t,n))];case"Round":return[r.round(uVe("x",e,t,n))];case"Selu":return[r.selu(uVe("x",e,t,n))];case"Sigmoid":return[r.sigmoid(uVe("x",e,t,n))];case"Sin":return[r.sin(uVe("x",e,t,n))];case"Sign":return[r.sign(uVe("x",e,t,n))];case"Sinh":return[r.sinh(uVe("x",e,t,n))];case"Softplus":return[r.softplus(uVe("x",e,t,n))];case"Sqrt":return[r.sqrt(uVe("x",e,t,n))];case"Square":return[r.square(uVe("x",e,t,n))];case"Tanh":return[r.tanh(uVe("x",e,t,n))];case"Tan":return[r.tan(uVe("x",e,t,n))];case"ClipByValue":return[r.clipByValue(uVe("x",e,t,n),uVe("clipValueMin",e,t,n),uVe("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(uVe("x",e,t,n))];case"Rsqrt":return[r.rsqrt(cVe(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(uVe("x",e,t,n),uVe("alpha",e,t,n))];case"Prelu":return[r.prelu(uVe("x",e,t,n),uVe("alpha",e,t,n))];case"IsNan":return[r.isNaN(cVe(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(cVe(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(cVe(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"control":return aUe(e,t,n);case"convolution":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Conv1D":{const a=uVe("stride",e,t,n),s=uVe("pad",e,t,n),i=uVe("dataFormat",e,t,n).toUpperCase(),o=uVe("dilation",e,t,n);return[r.conv1d(uVe("x",e,t,n),uVe("filter",e,t,n),a,s,i,o)]}case"Conv2D":{const a=uVe("strides",e,t,n),s=mVe(e,t,n),i=uVe("dataFormat",e,t,n).toUpperCase(),o=uVe("dilations",e,t,n);return[r.conv2d(uVe("x",e,t,n),uVe("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=sUe(e,t,n);return[r.fused.conv2d({x:uVe("x",e,t,n),filter:uVe("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=sUe(e,t,n);return[r.fused.depthwiseConv2d({x:uVe("x",e,t,n),filter:uVe("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=uVe("outputShape",e,t,n),s=uVe("strides",e,t,n),i=mVe(e,t,n);return[r.conv2dTranspose(uVe("x",e,t,n),uVe("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=uVe("strides",e,t,n),s=mVe(e,t,n),i=uVe("dilations",e,t,n),o=uVe("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(uVe("input",e,t,n),uVe("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{const a=uVe("strides",e,t,n),s=uVe("pad",e,t,n),i=uVe("dataFormat",e,t,n).toUpperCase(),o=uVe("dilations",e,t,n);return[r.conv3d(uVe("x",e,t,n),uVe("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{const a=uVe("strides",e,t,n),s=uVe("pad",e,t,n),i=uVe("kernelSize",e,t,n);return[r.avgPool(uVe("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{const a=uVe("strides",e,t,n),s=uVe("pad",e,t,n),i=uVe("kernelSize",e,t,n);return[r.maxPool(uVe("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{const a=uVe("strides",e,t,n),s=uVe("pad",e,t,n),i=uVe("kernelSize",e,t,n),o=uVe("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(uVe("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,u]}case"AvgPool3D":{const a=uVe("strides",e,t,n),s=uVe("pad",e,t,n),i=uVe("kernelSize",e,t,n);return[r.avgPool3d(uVe("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{const a=uVe("strides",e,t,n),s=uVe("pad",e,t,n),i=uVe("kernelSize",e,t,n);return[r.maxPool3d(uVe("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{const a=uVe("strides",e,t,n),s=uVe("pad",e,t,n),i=uVe("dilations",e,t,n),o=a[1],l=a[2],u=i[1],c=i[2];return[r.dilation2d(uVe("x",e,t,n),uVe("filter",e,t,n),[o,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"creation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Fill":{const a=uVe("shape",e,t,n),s=uVe("dtype",e,t,n),i=uVe("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{const a=uVe("start",e,t,n),s=uVe("stop",e,t,n),i=uVe("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{const a=uVe("logits",e,t,n),s=uVe("numSamples",e,t,n),i=uVe("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{const a=uVe("indices",e,t,n),s=uVe("depth",e,t,n),i=uVe("onValue",e,t,n),o=uVe("offValue",e,t,n),l=uVe("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(uVe("shape",e,t,n),uVe("dtype",e,t,n))];case"OnesLike":return[r.onesLike(uVe("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(uVe("shape",e,t,n),uVe("dtype",e,t,n),uVe("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(uVe("shape",e,t,n),uVe("minval",e,t,n),uVe("maxval",e,t,n),uVe("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(uVe("shape",e,t,n),uVe("minval",e,t,n),uVe("maxval",e,t,n),uVe("seed",e,t,n))];case"Range":{const a=uVe("start",e,t,n),s=uVe("stop",e,t,n),i=uVe("step",e,t,n);return[r.range(a,s,i,uVe("dtype",e,t,n))]}case"TruncatedNormal":{const a=uVe("shape",e,t,n),s=uVe("mean",e,t,n),i=uVe("stdDev",e,t,n),o=uVe("seed",e,t,n);return[r.truncatedNormal(a,s,i,uVe("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(uVe("shape",e,t,n),uVe("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(uVe("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"dynamic":return async function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:C;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=iUe(e,t,n),c=await a.image.nonMaxSuppressionWithScoreAsync(r,s,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=iUe(e,t,n),u=uVe("padToMaxOutputSize",e,t,n),c=await a.image.nonMaxSuppressionPaddedAsync(r,s,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=iUe(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,s,i,o,l)]}case"Where":{const r=a.cast(uVe("condition",e,t,n),"bool"),s=[await a.whereAsync(r)];return r.dispose(),s}case"ListDiff":return a.setdiff1dAsync(uVe("x",e,t,n),uVe("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n);case"evaluation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"LowerBound":{const a=uVe("sortedSequence",e,t,n),s=uVe("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{const a=uVe("x",e,t,n),s=uVe("k",e,t,n),i=uVe("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{const a=uVe("sortedSequence",e,t,n),s=uVe("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{const a=uVe("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{const a=uVe("x",e,t,n),s=uVe("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"image":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"ResizeBilinear":{const a=uVe("images",e,t,n),s=uVe("size",e,t,n),i=uVe("alignCorners",e,t,n),o=uVe("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{const a=uVe("images",e,t,n),s=uVe("size",e,t,n),i=uVe("alignCorners",e,t,n),o=uVe("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{const a=uVe("image",e,t,n),s=uVe("boxes",e,t,n),i=uVe("boxInd",e,t,n),o=uVe("cropSize",e,t,n),l=uVe("method",e,t,n),u=uVe("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{const a=uVe("images",e,t,n),s=uVe("transforms",e,t,n),i=uVe("outputShape",e,t,n),o=uVe("fillValue",e,t,n),l=uVe("interpolation",e,t,n),u=uVe("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"graph":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const a=uVe("default",e,t,n);return[cVe(e.name,t,n)||a];case"Placeholder":return[cVe(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[gVe(uVe("x",e,t,n))];case"IdentityN":return uVe("x",e,t,n).map((e=>gVe(e)));case"Shape":return[r.tensor1d(uVe("x",e,t,n).shape,"int32")];case"ShapeN":return uVe("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(uVe("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(uVe("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const s=uVe("x",e,t,n),i=uVe("data",e,t,n),o=uVe("message",e,t,n),l=uVe("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"logical":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Equal":return[r.equal(uVe("a",e,t,n),uVe("b",e,t,n))];case"NotEqual":return[r.notEqual(uVe("a",e,t,n),uVe("b",e,t,n))];case"Greater":return[r.greater(uVe("a",e,t,n),uVe("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(uVe("a",e,t,n),uVe("b",e,t,n))];case"Less":return[r.less(uVe("a",e,t,n),uVe("b",e,t,n))];case"LessEqual":return[r.lessEqual(uVe("a",e,t,n),uVe("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(uVe("a",e,t,n),uVe("b",e,t,n))];case"LogicalNot":return[r.logicalNot(uVe("a",e,t,n))];case"LogicalOr":return[r.logicalOr(uVe("a",e,t,n),uVe("b",e,t,n))];case"Select":case"SelectV2":return[r.where(uVe("condition",e,t,n),uVe("a",e,t,n),uVe("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(uVe("a",e,t,n),uVe("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"matrices":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(uVe("a",e,t,n),uVe("b",e,t,n),uVe("transposeA",e,t,n),uVe("transposeB",e,t,n))];case"Einsum":return[r.einsum(uVe("equation",e,t,n),...uVe("tensors",e,t,n))];case"Transpose":return[r.transpose(uVe("x",e,t,n),uVe("perm",e,t,n))];case"_FusedMatMul":const[a,s]=uVe("fusedOps",e,t,n),i="biasadd"===a,o="prelu"===s,l=uVe("numArgs",e,t,n),u=uVe("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=uVe("args",e,t,n);return[r.fused.matMul({a:uVe("a",e,t,n),b:uVe("b",e,t,n),transposeA:uVe("transposeA",e,t,n),transposeB:uVe("transposeB",e,t,n),bias:c,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(uVe("a",e,t,n),uVe("numLower",e,t,n),uVe("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"normalization":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(uVe("x",e,t,n),uVe("axis",e,t,n),uVe("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(uVe("x",e,t,n),uVe("mean",e,t,n),uVe("variance",e,t,n),uVe("offset",e,t,n),uVe("scale",e,t,n),uVe("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(uVe("x",e,t,n),uVe("radius",e,t,n),uVe("bias",e,t,n),uVe("alpha",e,t,n),uVe("beta",e,t,n))];case"Softmax":return[r.softmax(uVe("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(uVe("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"ragged":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"RaggedGather":{const{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(uVe("paramsNestedSplits",e,t,n),uVe("paramsDenseValues",e,t,n),uVe("indices",e,t,n),uVe("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{const{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(uVe("starts",e,t,n),uVe("limits",e,t,n),uVe("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(uVe("shape",e,t,n),uVe("values",e,t,n),uVe("defaultValue",e,t,n),uVe("rowPartitionTensors",e,t,n),uVe("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"reduction":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Max":{const a=uVe("axis",e,t,n),s=uVe("keepDims",e,t,n);return[r.max(uVe("x",e,t,n),a,s)]}case"Mean":{const a=uVe("axis",e,t,n),s=uVe("keepDims",e,t,n);return[r.mean(uVe("x",e,t,n),a,s)]}case"Min":{const a=uVe("axis",e,t,n),s=uVe("keepDims",e,t,n);return[r.min(uVe("x",e,t,n),a,s)]}case"Sum":{const a=uVe("axis",e,t,n),s=uVe("keepDims",e,t,n);return[r.sum(uVe("x",e,t,n),a,s)]}case"All":{const a=uVe("axis",e,t,n),s=uVe("keepDims",e,t,n);return[r.all(uVe("x",e,t,n),a,s)]}case"Any":{const a=uVe("axis",e,t,n),s=uVe("keepDims",e,t,n);return[r.any(uVe("x",e,t,n),a,s)]}case"ArgMax":{const a=uVe("axis",e,t,n);return[r.argMax(uVe("x",e,t,n),a)]}case"ArgMin":{const a=uVe("axis",e,t,n);return[r.argMin(uVe("x",e,t,n),a)]}case"Prod":{const a=uVe("axis",e,t,n),s=uVe("keepDims",e,t,n);return[r.prod(uVe("x",e,t,n),a,s)]}case"Cumprod":{const a=uVe("axis",e,t,n),s=uVe("exclusive",e,t,n),i=uVe("reverse",e,t,n);return[r.cumprod(uVe("x",e,t,n),a,s,i)]}case"Cumsum":{const a=uVe("axis",e,t,n),s=uVe("exclusive",e,t,n),i=uVe("reverse",e,t,n);return[r.cumsum(uVe("x",e,t,n),a,s,i)]}case"Bincount":const a=uVe("x",e,t,n),s=uVe("weights",e,t,n),i=uVe("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{const a=uVe("x",e,t,n),s=uVe("weights",e,t,n),i=uVe("size",e,t,n),o=uVe("binaryOutput",e,t,n);return[r.denseBincount(a,s,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"slice_join":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"ConcatV2":case"Concat":{const a=uVe("n",e,t,n),s=uVe("axis",e,t,n);let i=uVe("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{const a=uVe("x",e,t,n),s=uVe("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{const a=uVe("axis",e,t,n),s=uVe("batchDims",e,t,n),i=uVe("x",e,t,n),o=uVe("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{const a=uVe("dims",e,t,n),s=[];for(let e=0;e<a.length;e++)a[e]&&s.push(e);const i=uVe("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{const a=uVe("axis",e,t,n),s=uVe("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{const a=uVe("begin",e,t,n),s=uVe("size",e,t,n);return[r.slice(uVe("x",e,t,n),a,s)]}case"StridedSlice":{const a=uVe("begin",e,t,n),s=uVe("end",e,t,n),i=uVe("strides",e,t,n),o=uVe("beginMask",e,t,n),l=uVe("endMask",e,t,n),u=uVe("ellipsisMask",e,t,n),c=uVe("newAxisMask",e,t,n),d=uVe("shrinkAxisMask",e,t,n),h=uVe("x",e,t,n);return[r.stridedSlice(h,a,s,i,o,l,u,c,d)]}case"Pack":return yCe((()=>{const a=uVe("axis",e,t,n),s=uVe("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map((e=>{const t=jve(e.shape,i);if(!t&&!jve(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,a)]}));case"Unpack":{const a=uVe("axis",e,t,n),s=uVe("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{const a=uVe("reps",e,t,n);return[r.tile(uVe("x",e,t,n),a)]}case"Split":case"SplitV":{const a=uVe("axis",e,t,n),s=uVe("numOrSizeSplits",e,t,n),i=uVe("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{const a=uVe("indices",e,t,n),s=uVe("values",e,t,n),i=uVe("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{const a=uVe("x",e,t,n),s=uVe("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{const a=uVe("sparseIndices",e,t,n),s=uVe("outputShape",e,t,n),i=uVe("sparseValues",e,t,n),o=uVe("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const a=uVe("indices",e,t,n),s=uVe("values",e,t,n),i=uVe("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"sparse":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(uVe("indices",e,t,n),uVe("values",e,t,n),uVe("denseShape",e,t,n),uVe("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{const{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(uVe("inputIndices",e,t,n),uVe("inputShape",e,t,n),uVe("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(uVe("data",e,t,n),uVe("indices",e,t,n),uVe("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(uVe("data",e,t,n),uVe("indices",e,t,n),uVe("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"spectral":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"FFT":return[r.fft(uVe("x",e,t,n))];case"IFFT":return[r.ifft(uVe("x",e,t,n))];case"RFFT":return[r.rfft(uVe("x",e,t,n))];case"IRFFT":return[r.irfft(uVe("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"string":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(uVe("input",e,t,n),uVe("pattern",e,t,n),uVe("rewrite",e,t,n),uVe("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(uVe("data",e,t,n),uVe("dataSplits",e,t,n),uVe("separator",e,t,n),uVe("nGramWidths",e,t,n),uVe("leftPad",e,t,n),uVe("rightPad",e,t,n),uVe("padWidth",e,t,n),uVe("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{const{indices:a,values:s,shape:i}=r.string.stringSplit(uVe("input",e,t,n),uVe("delimiter",e,t,n),uVe("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(uVe("input",e,t,n),uVe("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"transformation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Cast":return[r.cast(uVe("x",e,t,n),uVe("dtype",e,t,n))];case"ExpandDims":{const a=uVe("axis",e,t,n);return[r.expandDims(uVe("x",e,t,n),a)]}case"Squeeze":{const a=uVe("axis",e,t,n);return[r.squeeze(uVe("x",e,t,n),a)]}case"Reshape":return[r.reshape(uVe("x",e,t,n),uVe("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(uVe("x",e,t,n),uVe("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(uVe("x",e,t,n),uVe("padding",e,t,n),uVe("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(uVe("x",e,t,n),uVe("padding",e,t,n),uVe("constantValue",e,t,n))];case"SpaceToBatchND":{const a=uVe("blockShape",e,t,n),s=uVe("paddings",e,t,n);return[r.spaceToBatchND(uVe("x",e,t,n),a,s)]}case"BatchToSpaceND":{const a=uVe("blockShape",e,t,n),s=uVe("crops",e,t,n);return[r.batchToSpaceND(uVe("x",e,t,n),a,s)]}case"DepthToSpace":{const a=uVe("blockSize",e,t,n),s=uVe("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(uVe("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(uVe("x",e,t,n),uVe("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(uVe("s0",e,t,n),uVe("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const a=r.getHashTableHandleByName(e.name);if(null!=a)return[a];{const a=uVe("keyDType",e,t,n),s=uVe("valueDType",e,t,n),i=new oUe(a,s);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const a=uVe("tableHandle",e,t,n,r),s=uVe("keys",e,t,n),i=uVe("values",e,t,n),o=r.getHashTableById(a.id);return[await o.import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{const a=uVe("tableHandle",e,t,n,r),s=uVe("keys",e,t,n),i=uVe("defaultValue",e,t,n),o=r.getHashTableById(a.id);return[await o.find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const a=uVe("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const s=lVe(e.op);if(s&&s.customExecutor)return s.customExecutor(new QVe(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return gxe(s)?s.then((e=>[].concat(e))):[].concat(s)}class uUe{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function cUe(e,t,n,r){const a=new Set,s=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(e).map((e=>fVe(e)[0])));r=r||[];const c=new Set(r.map((e=>fVe(e.name)[0]))),d=[...t];for(;d.length>0;){const e=d.pop();(gUe(e)||yUe(e)||bUe(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&(u.has(e.name)||c.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))})):s.push(e.name)))}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function dUe(e,t){const{usedNodes:n,inputs:r}=t,a=Object.keys(r).map((e=>fVe(e)[0])).map((t=>e.nodes[t])),s=e.initNodes||[],i=e=>n.has("string"===typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const l=o([...a,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map((e=>[e.name,e]))),d={};for(const m of u){d[m.name]=d[m.name]||0;for(const e of m.children)i(e)||(d[e.name]=Number.POSITIVE_INFINITY),d[e.name]=(d[e.name]||0)+1}const h=Object.entries(d).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...h];for(;h.length>0;){const e=h.pop(),t=c.get(e);for(const n of t.children.filter(i))0===--d[n.name]&&(p.push(n.name),h.push(n.name))}const f=function(e,t){const n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),a=new Set(r);for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const s of t.children)n.has(s.name)&&!a.has(s.name)&&(a.add(s.name),r.push(s.name))}const s=e.filter((e=>a.has(e.name)));return s}(p.map((e=>c.get(e))),l);return function(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),a=e=>r.has("string"===typeof e?e:e.name),s=new Set(e.map((e=>e.name))),i=e=>s.has("string"===typeof e?e:e.name);for(const o of e){for(const e of o.children.filter(i)){if(!n.has(e.name))throw new hUe(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new hUe(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!a(o))for(const e of o.inputs){if(!n.has(e.name))throw new hUe(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new hUe(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}class hUe extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}const pUe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),fUe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),mUe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function gUe(e){return pUe.has(e.op)}function yUe(e){return fUe.has(e.op)}function bUe(e){return mUe.has(e.op)}class vUe{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new vUe(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=cUe(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){const n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}const i=dUe(this.graph,n),o=function(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>gUe(e)?n:t)),a=e=>{const n=r[t.get(e.name)];return null==n?-1:n},s=e.map(((e,t)=>e.children.map(a).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){const t=s[o];if(t===n)continue;const r=e[o],a=e[t];i.has(a.name)||i.set(a.name,[]),i.get(a.name).push(r)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return vCe(t),t}cloneTensorList(e){if(!e)return null;const t=e.map((e=>this.cloneAndKeepTensor(e)));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[fVe(e)[0]])),a=t.map((e=>fVe(e)[0])),s=new Set(a);let i=a.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=xxe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(mD){this.keepIntermediateTensors=!1,console.warn(mD.message)}const u={},c={};return yCe((()=>{const n=new uUe(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[a,s]=fVe(t,n),i=[];i[s]=e[t],r[a]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(i))}));const a=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(const e of i){if(r[e.name])continue;const t=lUe(e,r,n,this._resourceManager);if(gxe(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,a,s,o.get(e.name))}return null==this.parent&&n.dispose(a),t.map((e=>cVe(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,i){if(!gUe(t)&&!s.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if(gUe(e))continue;const t=dVe(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||a.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,a,s){function i(e){return gUe(e)||a.has(e.name)}if(!gUe(e)&&null!=s)for(const o of s){if(i(o))continue;const e=dVe(o.name,t,n);for(const t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=xxe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(mD){this.keepIntermediateTensors=!1,console.warn(mD.message)}const s=new uUe(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,s,t,n),o=t.map((e=>cVe(e,i,s))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()}))})),null==this.parent&&s.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const a=Object.keys(e),s=a.map((e=>this.graph.nodes[fVe(e)[0]])),i=n.map((e=>fVe(e)[0])),o=new Set(i);let l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:h}=cUe(e,l,this.weightMap,this._initNodes),p=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=fVe(t),a=[];a[r]=e[t],f[n]=a}));const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=this.processStack(s,p,t,f,y,g,o,m,u);await Promise.all(e)}null!=d||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter((e=>!gUe(e)&&!cVe(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,a,s,i,o,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&uVe("isConstant",e.node,r,n)&&([c]=hVe(e.node.name,n)),null==r[e.node.name]){const d=lUe(e.node,r,n,this._resourceManager);c||([c]=hVe(e.node.name,n));const h=n.currentContext;gxe(d)?u.push(d.then((u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=h,this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{const[i]=hVe(e.name,n);!a[i]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!cVe(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!cVe(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=fVe(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const e=a.attrParams.shape.value;Bve(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&Bve(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;const r={};for(const a in e){const s=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[a];null!=s?r[s.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=fVe(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=fVe(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class xUe{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const wUe="?tfjs-format=file",kUe="model.json";class SUe{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=r,null==n&&(this.loadOptions={}),this.resourceManager=new xUe}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return gxe(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await _Ce(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new vUe(OVe.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=OVe.Instance.transformGraph(e.modelInitializer);this.initializer=new vUe(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof _Ie?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof _Ie)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var a,s,i;const o=null===(i=null===(s=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===s?void 0:s[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const a=t[n[r]];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&bCe(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function IUe(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==n&&(n={}),n.fromTFHub&&"string"===typeof t&&(t=function(e){e.endsWith("/")||(e+="/");return`${e}${kUe}${wUe}`}(t));const a=new SUe(t,n,r);return await a.load(),a}function CUe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(AUe(e)){const a=Array.isArray(e)?[]:{};r.add(e);for(const s in e){const i=CUe(e[s],t,n,r);a[s]=i}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function NUe(e){return TUe(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:EUe)}function TUe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(AUe(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=e.map((e=>e[s])),i=TUe(r,t,n);a[s]=i}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function EUe(e){return null===e?null:AUe(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function AUe(e){let t=!1;if(xxe().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(551);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof _Ie)&&!(e instanceof Promise)&&!t)}function _Ue(e){return function(e,t){return CUe(e,t)}(e,$Ue)}function $Ue(e){return e instanceof _Ie?{value:e.clone(),recurse:!1}:AUe(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class RUe{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class DUe extends RUe{constructor(){super(DUe.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function MUe(e){return new LUe(e)}function FUe(e,t){return new XUe(e,t)}DUe.INITIAL_CAPACITY=32;class OUe{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new GUe(this,e)}filter(e){return new UUe(this,e)}map(e){return new jUe(this,e)}mapAsync(e){return new HUe(this,e)}serialMapAsync(e){return new HUe(this,e).serial()}flatmap(e){return new KUe(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new VUe(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:EUe;return this.rowMajorBatch(e,t).map((e=>NUe(e,n)))}concatenate(e,t){return new XUe(new PUe([this,e]),t)}take(e){return e<0||null==e?this:new WUe(this,e)}skip(e){return e<0||null==e?this:new BUe(this,e)}prefetch(e){return new QUe(this,e)}shuffle(e,t){return new JUe(this,e,t)}serial(){return new zUe(this)}}class PUe extends OUe{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:_Ue(e),done:!1}}}class LUe extends OUe{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(mD){throw mD.message=`Error thrown while iterating through a dataset: ${mD.message}`,mD}}}class zUe extends OUe{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class BUe extends OUe{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;bCe(e.value)}return this.upstream.next()}}class WUe extends OUe{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class VUe extends OUe{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class UUe extends OUe{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;bCe(e.value)}}}class jUe extends OUe{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=GIe(e.value),n=this.transform(e.value),r=GIe(n);for(const a of t)jIe(a,r)||a.dispose();return{value:n,done:!1}}}class GUe extends OUe{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(mD){if(!this.handler(mD))return{value:null,done:!0}}}}class HUe extends OUe{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=GIe(e.value),n=await this.transform(e.value),r=GIe(n);for(const a of t)jIe(a,r)||a.dispose();return{value:n,done:!1}}}class qUe extends OUe{constructor(){super(),this.outputQueue=new DUe,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class KUe extends qUe{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=GIe(e.value),n=this.transform(e.value),r=GIe(n);this.outputQueue.pushAll(n);for(const a of t)jIe(a,r)||a.dispose();return!0}}class XUe extends OUe{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var YUe;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(YUe||(YUe={}));class QUe extends OUe{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new RUe(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class JUe extends QUe{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=L_e.alea(n||uIe().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class ZUe{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return Bve(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),eje((async()=>(await n.iterator()).columnMajorBatch(e,t,tje)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,eje((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,eje((async()=>(await t.iterator()).filter((t=>yCe((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return eje((async()=>(await t.iterator()).map((t=>yCe((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return eje((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return eje((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,eje((async()=>FUe(MUe((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,eje((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,a=L_e.alea(t||uIe().toString());return eje((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,eje((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function eje(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends ZUe{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function tje(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof _Ie||pIe(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof _Ie?S$e(e):hCe(e)}(e),recurse:!1}}return{value:null,recurse:!0}}ZUe.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function nje(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Bve("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}const rje=U$e;class aje extends Mve{nextDataId(){return aje.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Dve(this,mCe())}write(e,t,n){this.firstUse&&(this.firstUse=!1,xxe().get("IS_NODE")&&OSe("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&nxe(n[0])){const a=n.map((e=>dIe(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return VDe(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>hIe(e)));return CNe(e.shape,e.dtype,n)}catch(eL){throw new Error("Failed to decode encoded string bytes into utf-8")}return CNe(e.shape,e.dtype,t)}makeOutput(e,t,n){return mCe().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=uIe();e();return{kernelMs:uIe()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){nje([e],"where");const t=this.readSync(e.dataId);return rje(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}aje.nextDataId=0;function sje(e){return(t,n,r)=>{const a=Zve(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function ije(e,t,n){return oje(e,sje(t),n)}function oje(e,t,n){return r=>{let{inputs:a,attrs:s,backend:i}=r;const{x:o}=a;nje(o,e);const l=i,u=l.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=kMe(u)}else c=u;const d=n||o.dtype,h=t(c,d,s);return l.makeTensorInfo(o.shape,d,h)}}wCe("cpu",(()=>new aje),1);const lje=ije(Swe,(e=>e>=0?e:Math.exp(e)-1)),uje={kernelName:Swe,backendName:"cpu",kernelFunc:lje};function cje(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const dje={kernelName:Bwe,backendName:"cpu",kernelFunc:cje};function hje(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;nje([a],"leakyRelu");const i=Uve(a.shape),o=n.data.get(a.dataId).values,l=Jve("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}const pje={kernelName:Hwe,backendName:"cpu",kernelFunc:hje};function fje(e){return(t,n,r,a,s)=>{const i=ZNe(t,n),o=i.length,l=oxe(i),u=Jve(s,Uve(i)),c=t.length,d=n.length,h=oxe(t),p=oxe(n),f=QNe(t,i),m=QNe(n,i);if(f.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=e(r[g%r.length],a[g%a.length]);else for(let g=0;g<u.length;++g){const t=mxe(g,o,l),n=t.slice(-c);f.forEach((e=>n[e]=0));const s=fxe(n,c,h),i=t.slice(-d);m.forEach((e=>i[e]=0));const y=fxe(i,d,p);u[g]=e(r[s],a[y])}return[u,i]}}const mje=fje(((e,t)=>e<0?t*e:e));function gje(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t;nje([r,a],"prelu");const s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=mje(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}const yje={kernelName:Tke,backendName:"cpu",kernelFunc:gje},bje=ije(Fke,(e=>Math.max(0,e))),vje={kernelName:Fke,backendName:"cpu",kernelFunc:bje},xje=ije(Wke,(e=>Math.min(Math.max(0,e),6))),wje={kernelName:Wke,backendName:"cpu",kernelFunc:xje},kje=sje((e=>1/(1+Math.exp(-e)))),Sje=ije(eSe,(e=>1/(1+Math.exp(-e)))),Ije={kernelName:eSe,backendName:"cpu",kernelFunc:Sje};function Cje(e,t,n,r,a){if("linear"===n)return cje({inputs:{x:t},backend:e});if("relu"===n)return bje({inputs:{x:t},backend:e});if("elu"===n)return lje({inputs:{x:t},backend:e});if("relu6"===n)return xje({inputs:{x:t},backend:e});if("prelu"===n)return gje({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return hje({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return Sje({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Nje(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}const Tje={kernelName:Qxe,backendName:"cpu",kernelFunc:Nje};function Eje(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return Nje({inputs:{real:Eje(e,t,"float32"),imag:Eje(e,t,"float32")},backend:e})}const r=dxe(Uve(t),n);return e.makeTensorInfo(t,n,r)}function Aje(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const _je={kernelName:Dke,backendName:"cpu",kernelFunc:Aje};function $je(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=lIe([0],n),[a,s]=fje(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Rje(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return cje({inputs:{x:a},backend:n});const e=Eje(n,a.shape,a.dtype),t=Rje({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=Nje({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=Aje({inputs:{input:a},backend:n}),t=Rje({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!exe(a.dtype,s)){const e=cje({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}const i=n.data.get(a.dataId).values,[o,l,u]=$je(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,u)}const Dje={kernelName:Kxe,backendName:"cpu",kernelFunc:Rje};function Mje(e,t,n,r){return null==n?n=>{let{inputs:a,backend:s}=n;const{a:i,b:o}=a,l=s;nje([i,o],e);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d="string"===i.dtype?kMe(u):u,h="string"===i.dtype?kMe(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:e=>{let{inputs:a,backend:s}=e;const{a:i,b:o}=a,l=s;if("complex64"===i.dtype||"complex64"===o.dtype){const e=Rje({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,s=l.data.get(r.dataId).values,u=l.data.get(a.dataId).values,c=Rje({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=l.data.get(h.dataId).values,m=l.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,s,u,f,m),v=l.makeTensorInfo(b,"float32",g),x=l.makeTensorInfo(b,"float32",y),w=Nje({inputs:{real:v,imag:x},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(x),w}{const e=l.data.get(i.dataId).values,n=l.data.get(o.dataId).values,a=r||i.dtype,[s,u]=t(i.shape,o.shape,e,n,a);return l.makeTensorInfo(u,a,s)}}}function Fje(e){return(t,n,r,a,s,i)=>{const o=ZNe(t,n),l=Uve(o),u=o.length,c=oxe(o),d=Jve("float32",l),h=Jve("float32",l),p=QNe(t,o),f=QNe(n,o),m=VDe(r,a),g=VDe(s,i),y=t.length,b=oxe(t),v=n.length,x=oxe(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=r.real,h[w]=r.imag}else for(let w=0;w<d.length;w++){const t=mxe(w,u,c),n=t.slice(-y);p.forEach((e=>n[e]=0));const r=fxe(n,y,b),a=t.slice(-v);f.forEach((e=>a[e]=0));const s=fxe(a,v,x),i=e(m[2*r],m[2*r+1],g[2*s],g[2*s+1]);d[w]=i.real,h[w]=i.imag}return[d,h,o]}}const Oje=fje(((e,t)=>e+t)),Pje=Fje(((e,t,n,r)=>({real:e+n,imag:t+r}))),Lje=Mje(Exe,Oje,Pje),zje={kernelName:Exe,backendName:"cpu",kernelFunc:Lje};function Bje(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=Uve(a.shape),o=Xve(s,i),l=Uve(o);Bve(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);const u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}const Wje={kernelName:Oke,backendName:"cpu",kernelFunc:Bje};function Vje(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;nje([a,s],"matMul");const l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Uve(f),y=Uve(m),b=ZNe(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);Bve(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));const v=o?[y,p,d]:[y,d,p],x=Bje({inputs:{x:a},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=Bje({inputs:{x:s},backend:n,attrs:{shape:v}}),k=i?x.shape[1]:x.shape[2],S=i?x.shape[2]:x.shape[1],I=o?w.shape[1]:w.shape[2],C=Math.max(g,y),N=n.data.get(x.dataId).values,T=n.data.get(w.dataId).values,E=oxe(x.shape),A=oxe(w.shape),[_,$,R]=i?[E[0],1,E[1]]:[E[0],E[1],1],[D,M,F]=o?[1,A[1],A[0]]:[A[1],1,A[0]],O=S*I,P=CNe([C,S,I],x.dtype),L=P.values,z=n.blockSize;for(let B=0;B<C;B++){const e=B%g,t=B%y;for(let n=0;n<S;n+=z){const r=Math.min(n+z,S);for(let a=0;a<I;a+=z){const s=Math.min(a+z,I);for(let i=0;i<k;i+=z){const o=Math.min(i+z,k);for(let l=n;l<r;l++)for(let n=a;n<s;n++){let r=0;for(let a=i;a<o;a++){r+=N[e*_+l*$+a*R]*T[a*D+n*M+t*F]}L[B*O+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,P.dtype,P.values)}const Uje={kernelName:Uxe,backendName:"cpu",kernelFunc:Vje};const jje={kernelName:DSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=Vje({inputs:{a:a,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=Lje({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=Cje(n,h,c,o,d),m.push(h),h=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return h}};function Gje(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const Hje={kernelName:Cxe,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;nje(t,"abs");let r=new Float32Array(Uve(t.shape));return r=Gje(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},qje=ije(Nxe,(e=>Math.acos(e))),Kje={kernelName:Nxe,backendName:"cpu",kernelFunc:qje},Xje=ije(Txe,(e=>Math.acosh(e))),Yje={kernelName:Txe,backendName:"cpu",kernelFunc:Xje};const Qje={kernelName:Axe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;nje(t,"addN");const a=r.map((e=>n.data.get(e.dataId).values)),s=CNe(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){const e=a[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function Jje(e,t,n,r,a){const s=t.length,i=Uve(t),o=oxe(t),l=oxe(a),u=Jve(n,Uve(a));for(let c=0;c<i;++c){const t=mxe(c,s,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[fxe(n,s,l)]=e[c]}return u}function Zje(e){const{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;nje(a,"transpose");const i=a.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=a.shape[s[u]];const l=Jje(r.data.get(a.dataId).values,a.shape,a.dtype,s,o);return{dataId:r.write(l,o,a.dtype),shape:o,dtype:a.dtype}}const eGe={kernelName:CSe,backendName:"cpu",kernelFunc:Zje};const tGe={kernelName:_xe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;nje(a,"all");const o=Yve(s,a.shape);let l=o;const u=wAe(l,a.shape.length);let c=a;null!=u&&(c=Zje({inputs:{x:a},backend:n,attrs:{perm:u}}),l=SAe(l.length,a.shape.length)),xAe("all",l,c.shape.length);const[d,h]=bAe(c.shape,l),p=Uve(h),f=dxe(Uve(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=Bje({inputs:{x:g},backend:n,attrs:{shape:vAe(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const nGe={kernelName:$xe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;nje(a,"any");const o=Yve(s,a.shape);let l=o;const u=wAe(l,a.shape.length);let c=a;null!=u&&(c=Zje({inputs:{x:a},backend:n,attrs:{perm:u}}),l=SAe(l.length,a.shape.length)),xAe("any",l,c.shape.length);const[d,h]=bAe(c.shape,l),p=Uve(h),f=dxe(Uve(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=Bje({inputs:{x:g},backend:n,attrs:{shape:vAe(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const rGe={kernelName:Rxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;nje(a,"argMax");let i=Yve(s,a.shape);const o=wAe(i,a.shape.length);let l=a;const u=[];null!=o&&(l=Zje({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=SAe(i.length,l.shape.length)),i=[i[0]],xAe("argMax",i,l.shape.length);const[c,d]=bAe(l.shape,i),h=dxe(Uve(c),"int32"),p=Uve(d),f=n.data.get(l.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const a=f[e+r];a>t&&(t=a,n=r)}h[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}};const aGe={kernelName:Dxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;nje(a,"argMin");let i=Yve(s,a.shape);const o=wAe(i,a.shape.length);let l=a;const u=[];null!=o&&(l=Zje({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=SAe(i.length,l.shape.length)),i=[i[0]],xAe("argMin",i,l.shape.length);const[c,d]=bAe(l.shape,i),h=dxe(Uve(c),"int32"),p=Uve(d),f=n.data.get(l.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const a=f[e+r];a<t&&(t=a,n=r)}h[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}},sGe=ije(Mxe,(e=>Math.asin(e))),iGe={kernelName:Mxe,backendName:"cpu",kernelFunc:sGe},oGe=ije(Fxe,(e=>Math.asinh(e))),lGe={kernelName:Fxe,backendName:"cpu",kernelFunc:oGe},uGe=ije(Oxe,(e=>Math.atan(e))),cGe={kernelName:Oxe,backendName:"cpu",kernelFunc:uGe},dGe=fje(((e,t)=>Math.atan2(e,t))),hGe=Mje(Lxe,dGe),pGe={kernelName:Lxe,backendName:"cpu",kernelFunc:hGe},fGe=ije(Pxe,(e=>Math.atanh(e))),mGe={kernelName:Pxe,backendName:"cpu",kernelFunc:fGe};function gGe(e,t,n,r,a,s){const i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,c=a.effectiveFilterHeight,d=a.effectiveFilterWidth,h=a.padInfo.top,p=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=CNe(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let x=0;x<a.batchSize;++x){const t=x*y,n=x*r[0];for(let m=0;m<a.inChannels;++m)for(let y=0;y<a.outHeight;++y){const x=y*i-h,w=Math.max(0,x),k=Math.min(a.inHeight,c+x),S=t+y*b;for(let t=0;t<a.outWidth;++t){const i=t*o-p,c=Math.max(0,i),h=Math.min(a.inWidth,d+i);let y=f,b=0,x=0;for(let t=w;t<k;t+=l){const a=n+t*r[1];for(let t=c;t<h;t+=u){const n=e[a+t*r[2]+m];"max"===s&&n>y?y=n:"avg"===s&&(b+=n,x++)}if(isNaN(y))break}g[S+t*v+m]="avg"===s?b/x:y}}}return m}function yGe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=CNe(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=CNe(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*o-p;let y=n;for(;y<0;)y+=u;const b=Math.min(r.inHeight,d+n);for(let o=0;o<r.outWidth;++o){const d=o*l-f;let p=d;for(;p<0;)p+=c;const v=Math.min(r.inWidth,h+d);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=u){const i=t-n;for(let n=p;n<v;n+=c){const o=n-d,l=m.get(g,t,n,e);l>x&&(x=l,w=a?s?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*h+o)}}i.set(w,g,t,o,e)}}return i}function bGe(e,t,n,r,a,s){const i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,c=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=CNe(a.outShape,n),x=v.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let C=0;C<a.batchSize;++C){const t=C*w,n=C*r[0];for(let v=0;v<a.inChannels;++v)for(let w=0;w<a.outDepth;++w){const C=w*i-m;let N=C;for(;N<0;)N+=u;const T=Math.min(a.inDepth,h+C),E=t+w*k;for(let t=0;t<a.outHeight;++t){const i=t*o-g;let h=i;for(;h<0;)h+=c;const m=Math.min(a.inHeight,p+i),w=E+t*S;for(let t=0;t<a.outWidth;++t){const i=t*l-y;let o=i;for(;o<0;)o+=d;const p=Math.min(a.inWidth,f+i),g=w+t*I;let k=b,S=0,C=0;for(let t=N;t<T;t+=u){const a=n+t*r[1];for(let t=h;t<m;t+=c){const n=a+t*r[2];for(let t=o;t<p;t+=d){const a=e[n+t*r[3]+v];if("max"===s&&a>k?k=a:"avg"===s&&(S+=a,C++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===s?S/Math.max(C,1):k}}}}return v}const vGe={kernelName:zxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;nje(a,"avgPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Bve(bEe(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=lEe(a.shape,s,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&jve(u.inShape,u.outShape))c=cje({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=oxe(a.shape),r=gGe(e,a.shape,a.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,a.dtype,r.values)}return c}};const xGe={kernelName:Wxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;nje(a,"avgPool3d");const c=uEe(a.shape,s,i,1,o,l,u),d=bGe(n.data.get(a.dataId).values,a.shape,a.dtype,oxe(a.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};const wGe={kernelName:Vxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;nje([a,s],"avgPool3DGrad");const c=uEe(s.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=x-1-c.padInfo.front,I=k-1-c.padInfo.left,C=w-1-c.padInfo.top,N=CNe(s.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(a);for(let A=0;A<c.batchSize;++A)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const a=t-S,s=n-C,i=r-I;let o=0;for(let t=0;t<x;t+=y){const n=(a+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const r=(s+t)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){const a=(i+t)/p;if(a<0||a>=c.outWidth||Math.floor(a)!==a)continue;o+=E.get(A,n,r,a,e)}}}N.set(o*T,A,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const kGe={kernelName:Bxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;nje([a,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=lEe(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=CNe(i.shape,"float32"),k=1/(p*f),S=n.data.get(a.dataId).values,I=CNe(a.shape,"float32",S);for(let C=0;C<c.batchSize;++C)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const r=t-x,a=n-v;let s=0;for(let t=0;t<y;t+=m){const n=(r+t)/d;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const r=(a+t)/h;if(r<0||r>=c.outWidth||Math.floor(r)!==r)continue;s+=I.get(C,n,r,e)}}w.set(s*k,C,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const SGe={kernelName:Fwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;Bve(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Bve(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Bve(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),nje([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,v=d.length;let x=0,w=0,k=0,S=0;for(let I=0;I<c.length;++I)m[I]=f[x++]+(c[I]-d[w++])*p[k++]/Math.sqrt(h[S++]+u),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,m)}};function IGe(e,t,n,r,a){const s=jTe(r,t,n),i=Uve(n),o=oxe(r);if(s){const n=GTe(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}const l=CNe(r,a,"string"===a?kMe(e):e),u=CNe(n,a);for(let c=0;c<u.size;++c){const e=u.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===a?SMe(u.values):u.values}function CGe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;nje(a,"slice");const[o,l]=HTe(a,s,i);RTe(a,o,l);const u=IGe(n.data.get(a.dataId).values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}const NGe={kernelName:Yke,backendName:"cpu",kernelFunc:CGe};const TGe={kernelName:jxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;nje([a],"batchToSpaceND");const o=s.reduce(((e,t)=>e*t)),l=EDe(a.shape,s,o),u=ADe(l.length,s.length),c=_De(a.shape,s,o),d=$De(i,s.length),h=RDe(c,i,s.length),p=Bje({inputs:{x:a},backend:n,attrs:{shape:l}}),f=Zje({inputs:{x:p},backend:n,attrs:{perm:u}}),m=Bje({inputs:{x:f},backend:n,attrs:{shape:c}}),g=CGe({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function EGe(e,t,n,r,a){const s=Uve(r),i=dxe(a,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=s>0?t[o]:1)}return i}function AGe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e.shape[0],s=e.shape[1],i=CNe([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){const s=e.get(o,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}const _Ge={kernelName:Gxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=EGe(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}},$Ge=fje(((e,t)=>e&t)),RGe=Mje(Hxe,$Ge),DGe={kernelName:Hxe,backendName:"cpu",kernelFunc:RGe};const MGe={kernelName:qxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=ZNe(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},FGe=sje((e=>Math.ceil(e))),OGe=oje(Xxe,FGe),PGe={kernelName:Xxe,backendName:"cpu",kernelFunc:OGe},LGe=ije(Yxe,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),zGe={kernelName:Yxe,backendName:"cpu",kernelFunc:LGe},BGe={kernelName:Jxe,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Uve(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function WGe(e,t,n,r){const a=Zve(n,Uve(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=Uve(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const s="string"===n?kMe(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]}))}return a}function VGe(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const UGe={kernelName:Vwe,backendName:"cpu",kernelFunc:VGe};function jGe(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Yve(a,t[0].shape)[0];bDe(t.map((e=>e.shape)),s);let i=vDe(t.map((e=>e.shape)),s);if(0===Uve(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Uve(e.shape)>0));if(1===o.length)return cje({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map((e=>Aje({inputs:{input:e},backend:n}))),t=o.map((e=>VGe({inputs:{input:e},backend:n}))),r=jGe({inputs:e,backend:n,attrs:{axis:s}}),a=jGe({inputs:t,backend:n,attrs:{axis:s}}),i=Nje({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}const l=o.map((e=>{const t=Uve(e.shape.slice(s));return Bje({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=vDe(l.map((e=>e.shape)),1);const c=1===l[0].shape[0],d=WGe(u,i,t[0].dtype,c),h=vDe(o.map((e=>e.shape)),s),p=n.makeTensorInfo(h,t[0].dtype,d);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const GGe={kernelName:Zxe,backendName:"cpu",kernelFunc:jGe};function HGe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;nje([a,s],"conv2d");const d=xEe(l),h=cEe(a.shape,s.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new NIe(h.outShape,a.dtype),w=oxe(a.shape),k=oxe(s.shape),S=w[0],I=v?w[1]:w[2],C=v?w[2]:1,N=v?1:w[1],T=x.strides[0],E=v?x.strides[1]:x.strides[2],A=v?x.strides[2]:1,_=v?1:x.strides[1],$=n.data.get(a.dataId).values,R=n.data.get(s.dataId).values,D=x.values;for(let M=0;M<h.batchSize;++M){const e=M*S,t=M*T;for(let n=0;n<h.outHeight;++n){const r=t+n*E,a=n*h.strideHeight-b;for(let t=0;t<p;++t){const n=a+t*m;if(n<0||n>=h.inHeight)continue;const s=t*k[0],i=e+n*I;for(let e=0;e<h.outWidth;++e){const t=r+e*A,n=e*h.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=h.inWidth)continue;const a=i+r*C;let o=s+e*k[1];for(let e=0;e<h.inChannels;++e){const n=$[a+e*N];for(let e=0;e<h.outChannels;++e)D[t+e*_]+=n*R[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,D)}const qGe={kernelName:ewe,backendName:"cpu",kernelFunc:HGe};const KGe={kernelName:twe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;nje([a,s],"conv2dBackpropFilter");const d=xEe(l),h=cEe(a.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new NIe(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=new NIe(a.shape,a.dtype,w),I=new NIe(s.shape,s.dtype,k);for(let C=0;C<m;++C){const e=Math.max(0,Math.ceil((x-C)/p)),t=Math.min(h.outHeight,(h.inHeight+x-C)/p);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(h.outWidth,(h.inWidth+v-n)/f);for(let s=0;s<h.inChannels;++s)for(let i=0;i<h.outChannels;++i){let o=0;for(let l=0;l<h.batchSize;++l)for(let u=e;u<t;++u){const e=C+u*p-x;for(let t=r;t<a;++t){const r=n+t*f-v;o+=y?S.get(l,e,r,s)*I.get(l,u,t,i):S.get(l,s,e,r)*I.get(l,i,u,t)}}b.set(o,C,n,s,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const XGe={kernelName:nwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;nje([a,s],"conv2dBackpropInput");const d=oxe(s.shape),h=oxe(a.shape);let p=xEe(u);const f=cEe(i,s.shape,o,1,l,c,!1,p),m=new NIe(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[v,x,w]=d,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:C,inHeight:N,inWidth:T,outChannels:E,outHeight:A,outWidth:_,strideHeight:$,strideWidth:R}=f;p=f.dataFormat;const D=S-1-f.padInfo.top,M=I-1-f.padInfo.left,F="channelsLast"===p,O=m.strides[0],P=F?m.strides[1]:m.strides[2],L=F?m.strides[2]:1,z=F?1:m.strides[1],B=h[0],W=F?h[1]:h[2],V=F?h[2]:1,U=F?1:h[1];for(let j=0;j<k;++j)for(let e=0;e<C;++e)for(let t=0;t<N;++t){const n=t-D,r=Math.max(0,Math.ceil(n/$)),a=Math.min(A,(S+n)/$);for(let s=0;s<T;++s){const i=s-M,o=Math.max(0,Math.ceil(i/R)),l=Math.min(_,(I+i)/R);let u=0;for(let t=r;t<a;++t){const r=t*$-n;for(let n=o;n<l;++n){const a=B*j+W*t+V*n,s=v*(S-1-r)+x*(I-1-(n*R-i))+w*e;for(let e=0;e<E;++e){u+=y[a+U*e]*b[s+e]}}}g[O*j+P*t+L*s+z*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const YGe={kernelName:rwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;nje([a,s],"conv3d");const u=dEe(a.shape,s.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new NIe(u.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=x.values,I=oxe(a.shape),C=oxe(s.shape);for(let N=0;N<u.batchSize;++N){const e=N*I[0],t=N*x.strides[0];for(let n=0;n<u.outDepth;++n){const r=t+n*x.strides[1],a=n*u.strideDepth-y;for(let t=0;t<c;++t){const n=a+t*p;if(n<0||n>=u.inDepth)continue;const s=t*C[0],i=e+n*I[1];for(let e=0;e<u.outHeight;++e){const t=r+e*x.strides[2],n=e*u.strideHeight-v;for(let e=0;e<d;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const a=s+e*C[1],o=i+r*I[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<h;++e){const t=r+e*m;if(t<0||t>=u.inWidth)continue;const s=a+e*C[2],i=o+t*u.inChannels;let l=s;for(let e=0;e<u.inChannels;++e){const t=w[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const QGe={kernelName:awe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;nje([a,s],"conv3dBackpropFilterV2");const u=oxe(a.shape),c=oxe(s.shape),d=dEe(a.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new NIe(d.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,I=n.data.get(s.dataId).values,[C,N,T,E]=c,A=n.data.get(a.dataId).values,[_,$,R,D]=u,M=d.padInfo.front,F=d.padInfo.left,O=d.padInfo.top;for(let P=0;P<m;++P){const e=Math.max(0,Math.ceil((M-P)/h)),t=Math.min(d.outDepth,(d.inDepth+M-P)/h),n=P*x;for(let r=0;r<g;++r){const a=Math.max(0,Math.ceil((O-r)/p)),s=Math.min(d.outHeight,(d.inHeight+O-r)/p),i=r*w+n;for(let n=0;n<y;++n){const o=Math.max(0,Math.ceil((F-n)/f)),l=Math.min(d.outWidth,(d.inWidth+F-n)/f),u=n*k+i;for(let i=0;i<d.inChannels;++i){const c=i*S+u;for(let u=0;u<d.outChannels;++u){let m=0;for(let c=0;c<d.batchSize;++c){const d=c*_,g=c*C;for(let c=e;c<t;++c){const e=(P+c*h-M)*$+d,t=c*N+g;for(let c=a;c<s;++c){const a=(r+c*p-O)*R+e,s=c*T+t;for(let e=o;e<l;++e){const t=e*E+s;m+=A[(n+e*f-F)*D+a+i]*I[t+u]}}}}v[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const JGe={kernelName:swe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;nje([a],"conv3dBackpropInputV2");const u=oxe(a.shape),c=oxe(s.shape),d=dEe(l,s.shape,o,1,i),h=new NIe(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(a.dataId).values,[v,x,w,k]=u,S=n.data.get(s.dataId).values,[I,C,N,T]=c,{batchSize:E,filterDepth:A,filterHeight:_,filterWidth:$,inChannels:R,inDepth:D,inHeight:M,inWidth:F,outChannels:O,outDepth:P,outHeight:L,outWidth:z,strideDepth:B,strideHeight:W,strideWidth:V}=d,U=A-1-d.padInfo.front,j=_-1-d.padInfo.top,G=$-1-d.padInfo.left;for(let H=0;H<E;++H)for(let e=0;e<R;++e)for(let t=0;t<D;++t){const n=t-U,r=Math.max(0,Math.ceil(n/B)),a=Math.min(P,(A+n)/B);for(let s=0;s<M;++s){const i=s-j,o=Math.max(0,Math.ceil(i/W)),l=Math.min(L,(_+i)/W);for(let u=0;u<F;++u){const c=u-G,d=Math.max(0,Math.ceil(c/V)),h=Math.min(z,($+c)/V);let E=0;for(let t=r;t<a;++t){const r=t*B-n;for(let n=o;n<l;++n){const a=n*W-i;for(let s=d;s<h;++s){const i=v*H+x*t+w*n+k*s,o=I*(A-1-r)+C*(_-1-a)+N*($-1-(s*V-c))+T*e;for(let e=0;e<O;++e){E+=b[i+e]*S[o+e]}}}}p[f*H+m*t+g*s+y*u+e]=E}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},ZGe=ije(iwe,(e=>Math.cos(e))),eHe={kernelName:iwe,backendName:"cpu",kernelFunc:ZGe},tHe=ije(owe,(e=>Math.cosh(e))),nHe={kernelName:owe,backendName:"cpu",kernelFunc:tHe};const rHe={kernelName:cwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=a.shape,f=s.shape[0],[m,g]=o,y=CNe([f,m,g,p],"float32"),b=n.data.get(s.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,w=oxe(a.shape),k=oxe(y.shape);for(let S=0;S<f;S++){const e=4*S,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],s=v[S];if(s>=c)continue;const i=m>1?(r-t)*(d-1)/(m-1):0,o=g>1?(a-n)*(h-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(d-1)+c*i:.5*(t+r)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}else if("bilinear"===l){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const l=g>1?n*(h-1)+e*o:.5*(n+a)*(h-1);if(l<0||l>h-1){for(let t=0;t<p;t++){const n=t+e*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const d=Math.floor(l),f=Math.ceil(l),m=l-d;for(let n=0;n<p;n++){let a=n+d*w[2]+t*w[1]+s*w[0];const o=x[a];a=n+f*w[2]+t*w[1]+s*w[0];const l=x[a];a=n+d*w[2]+r*w[1]+s*w[0];const u=x[a];a=n+f*w[2]+r*w[1]+s*w[0];const h=o+(l-o)*m,p=u+(x[a]-u)*m;a=n+e*k[2]+c*k[1]+S*k[0],y.values[a]=h+(p-h)*i}}}else for(let t=0;t<g;++t){const r=g>1?n*(h-1)+t*o:.5*(n+a)*(h-1);if(r<0||r>h-1){for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++){const n=e+i*w[2]+l*w[1]+s*w[0],r=e+t*k[2]+c*k[1]+S*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const aHe={kernelName:lwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;nje(a,"cumprod");const l=wAe([s],a.shape.length);let u=a;null!=l&&(u=Zje({inputs:{x:a},backend:n,attrs:{perm:l}}));const c=SAe(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=zIe(u.dtype,"int32"),h=cxe(Uve(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)h[t]=i?1:p[t];else{const n=m(y,e-1);h[t]=i?p[n]*h[n]:p[t]*h[n]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=Zje({inputs:{x:g},backend:n,attrs:{perm:kAe(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const sHe={kernelName:uwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;nje(a,"cumsum");const l=wAe([s],a.shape.length);let u=a;null!=l&&(u=Zje({inputs:{x:a},backend:n,attrs:{perm:l}}));const c=SAe(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=zIe(u.dtype,"int32"),h=dxe(Uve(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)h[t]=i?0:p[t];else{const n=m(y,e-1);h[t]=i?p[n]+h[n]:p[t]+h[n]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=Zje({inputs:{x:g},backend:n,attrs:{perm:kAe(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const iHe={kernelName:dwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){const e=EGe(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){const e=AGe(n.bufferSync(a),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};const oHe={kernelName:hwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;Bve("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const o=a.shape[0],l=a.shape[1],u=a.shape[2],c=a.shape[3],d=l*s,h=u*s,p=c/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*d*h*p);let g=0;for(let y=0;y<o;++y)for(let e=0;e<d;++e){const t=Math.floor(e/s),n=e%s;for(let e=0;e<h;++e){const r=Math.floor(e/s),a=(n*s+e%s)*p;for(let e=0;e<p;++e){const n=e+a+c*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,d,h,p],a.dtype,m)}};function lHe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;nje([a,s],"depthwiseConv2DNative");const c=oxe(a.shape),d=oxe(s.shape);let h=l;null==h&&(h=[1,1]),Bve(bEe(i,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`));const p=cEe(a.shape,s.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new NIe(p.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,C=k.values;for(let N=0;N<p.batchSize;++N){const e=N*c[0],t=N*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],a=n*p.strideHeight-x;for(let t=0;t<f;++t){const n=a+t*g;if(n<0||n>=p.inHeight)continue;const s=t*d[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=p.inWidth)continue;const a=s+e*d[1],o=i+r*p.inChannels;let l=t,u=a;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<w;++e)C[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const uHe={kernelName:pwe,backendName:"cpu",kernelFunc:lHe};const cHe={kernelName:fwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;nje([a,s],"depthwiseConv2dNativeBackpropFilter");const d=cEe(a.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new NIe(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,x=n.data.get(a.dataId).values,w=new NIe(a.shape,a.dtype,x),k=n.data.get(s.dataId).values,S=new NIe(s.shape,s.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((b-I)/h)),t=Math.min(d.outHeight,(d.inHeight+b-I)/h);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((y-n)/p)),a=Math.min(d.outWidth,(d.inWidth+y-n)/p);for(let s=0;s<d.outChannels;++s){const i=Math.trunc(s/v),o=s%v;let l=0;for(let u=0;u<d.batchSize;++u)for(let o=e;o<t;++o){const e=I+o*h-b;for(let t=r;t<a;++t){const r=n+t*p-y;l+=w.get(u,e,r,i)*S.get(u,o,t,s)}}g.set(l,I,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const dHe={kernelName:mwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;nje([a,s],"depthwiseConv2DNativeBackpropInput");const d=oxe(a.shape),h=oxe(s.shape),p=cEe(c,s.shape,i,o,l,u,!0),f=new NIe(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(a.dataId).values,[x,w,k]=d,S=n.data.get(s.dataId).values,[I,C,N]=h,{batchSize:T,filterHeight:E,filterWidth:A,inChannels:_,inHeight:$,inWidth:R,outChannels:D,outHeight:M,outWidth:F,strideHeight:O,strideWidth:P}=p,L=E-1-p.padInfo.top,z=A-1-p.padInfo.left,B=D/_;for(let W=0;W<T;++W)for(let e=0;e<_;++e)for(let t=0;t<$;++t){const n=t-L,r=Math.max(0,Math.ceil(n/O)),a=Math.min(M,(E+n)/O);for(let s=0;s<R;++s){const i=s-z,o=Math.max(0,Math.ceil(i/P)),l=Math.min(F,(A+i)/P);let u=0;for(let t=r;t<a;++t){const r=t*O-n;for(let n=o;n<l;++n){const a=x*W+w*t+k*n,s=I*(E-1-r)+C*(A-1-(n*P-i))+N*e;for(let t=0;t<B;++t){u+=v[a+(e*B+t)]*S[s+t]}}}m[g*W+y*t+b*s+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const hHe={kernelName:gwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=Uve(r.shape),s=n.data.get(r.dataId).values,i=CNe([a,a],r.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*a+u]=s[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},pHe={kernelName:ywe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=n,c=u.data.get(a.dataId).values,d=a.shape.length,h=u.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:C,dilationWidth:N,outShape:T}=oEe(a.shape,s.shape,i,o,"NHWC",l),E=Uve(T),A=T.length,_=Zve(a.dtype,E);for(let $=0;$<f;++$)for(let e=0;e<b;++e){const t=e*w-x.top;for(let n=0;n<v;++n){const r=n*k-x.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*C;if(n>=0&&n<m)for(let t=0;t<I;++t){const l=r+t*N;if(l>=0&&l<g){const r=fxe([$,n,l,i],d,oxe(a.shape)),u=fxe([e,t,i],p,oxe(s.shape)),f=c[r]+h[u];f>o&&(o=f)}}}_[fxe([$,e,n,i],A,oxe(T))]=o}}}return{dataId:u.write(lIe(_,a.dtype),T,a.dtype),shape:T,dtype:a.dtype}}},fHe={kernelName:vwe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=uxe(a.shape,c.data.get(a.dataId).values),h=uxe(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=oEe(a.shape,s.shape,o,l,"NHWC",u);Bve(i.rank===N.length,(()=>`Error in ${vwe}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));const T=uxe(N,c.data.get(i.dataId).values),E=hxe(s.shape,s.dtype);for(let A=0;A<p;++A)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*C;if(l>=0&&l<m){const r=d[A][n][l][a]+h[e][t][a];r>s&&(s=r,i=e,o=t)}}}E[i][o][a]+=T[A][e][n][a]}}}return{dataId:c.write(lIe(E,a.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},mHe={kernelName:bwe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=uxe(a.shape,c.data.get(a.dataId).values),h=uxe(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=oEe(a.shape,s.shape,o,l,"NHWC",u);Bve(i.rank===N.length,(()=>`Error in ${bwe}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));const T=uxe(N,c.data.get(i.dataId).values),E=hxe(a.shape,a.dtype);for(let A=0;A<p;++A)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*C;if(l>=0&&l<m){const r=d[A][n][l][a]+h[e][t][a];r>s&&(s=r,i=n,o=l)}}}E[A][i][o][a]+=T[A][e][n][a]}}}return{dataId:c.write(lIe(E,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};const gHe={kernelName:xwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null===l||void 0===l?void 0:l.alpha)||1,c=(null===o||void 0===o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=s.getContext(c,(null===o||void 0===o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);const[h,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(p*h*4);for(let v=0;v<h*p;++v){const e=[0,0,0,255*u];for(let n=0;n<f;n++){const t=m[v*f+n];if("float32"===a.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===a.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}s.width=p,s.height=h;const b=new ImageData(y,p,h);return d.putImageData(b,0,0),a}},yHe=fje(((e,t)=>e*t)),bHe=Fje(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),vHe=Mje(gke,yHe,bHe),xHe={kernelName:gke,backendName:"cpu",kernelFunc:vHe};function wHe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;let o;nje(a,"sum"),o="bool"===a.dtype?Rje({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):cje({inputs:{x:a},backend:n});const l=o.shape.length,u=Yve(s,o.shape),c=wAe(u,l);let d=u,h=o;null!=c&&(h=Zje({inputs:{x:o},backend:n,attrs:{perm:c}}),d=SAe(d.length,l)),xAe("sum",d,h.shape.length);const[p,f]=bAe(h.shape,d);let m=Eje(n,p,zIe(h.dtype,"int32"));const g=Uve(f),y=n.data.get(m.dataId).values,b=n.data.get(h.dataId).values;for(let v=0;v<y.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(i){const e=m;m=Bje({inputs:{x:m},backend:n,attrs:{shape:vAe(m.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(h),m}const kHe={kernelName:rSe,backendName:"cpu",kernelFunc:wHe};const SHe={kernelName:kwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=eMe(a,s.length);nMe(i.length,l,s);const{path:u,steps:c}=rMe(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=tMe(p,l[e]);let a;aMe(t)?a=s[e]:(a=Zje({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);jve(a.shape,i)||(a=Bje({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===h?h=a:(h=vHe({inputs:{a:a,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=wHe({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};const IHe={kernelName:Iwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:a}=t;nje([r,a],"eluGrad");const s=new Float32Array(Uve(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const e=i[l];s[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",s)}},CHe=fje(((e,t)=>e===t?1:0)),NHe=Mje(Nwe,CHe,null,"bool"),THe={kernelName:Nwe,backendName:"cpu",kernelFunc:NHe},EHe=ODe,AHe=PDe,_He=LDe,$He=zDe,RHe=BDe,DHe=WDe,MHe=ije(Cwe,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+EHe*n);return t*(1-((((DHe*r+RHe)*r+$He)*r+_He)*r+AHe)*r*Math.exp(-n*n))})),FHe={kernelName:Cwe,backendName:"cpu",kernelFunc:MHe},OHe=sje((e=>Math.exp(e))),PHe=oje(Twe,OHe,"float32"),LHe={kernelName:Twe,backendName:"cpu",kernelFunc:PHe};function zHe(e){const{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(Bve(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),Bje({inputs:{x:a},backend:n,attrs:{shape:o}})}const BHe={kernelName:Ewe,backendName:"cpu",kernelFunc:zHe},WHe=sje((e=>Math.expm1(e))),VHe=oje(Awe,WHe),UHe={kernelName:Awe,backendName:"cpu",kernelFunc:VHe},jHe=fje(((e,t)=>e/t)),GHe=Mje(wwe,jHe),HHe={kernelName:wwe,backendName:"cpu",kernelFunc:GHe},qHe=fje(((e,t)=>e-t)),KHe=Fje(((e,t,n,r)=>({real:e-n,imag:t-r}))),XHe=Mje(vSe,qHe,KHe),YHe={kernelName:vSe,backendName:"cpu",kernelFunc:XHe};function QHe(e,t,n){const r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],c=Uve(u),d=Jve("float32",c),h=Jve("float32",c);for(let g=0;g<a;g++){const e=CGe({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=CGe({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=Nje({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=JHe(a,t,n),c=VDe(i,u);for(let t=0;t<s;t++){const e=HDe(c,t);d[g*s+t]=e.real,h[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=Nje({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function JHe(e,t,n){const r=Uve(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(0===((o=r)&o-1)){const a=ZHe(s,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),s=n.makeTensorInfo([],"float32",oIe(r,"float32")),i=cje({inputs:{x:s},backend:n}),l=HHe.kernelFunc({inputs:{a:e,b:s},backend:n}),u=HHe.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return a}{const e=function(e,t,n){const r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){const o=XDe(a*r,t,n),l=HDe(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),qDe(r,s,i,a)}return r}(VDe(s,i),r,t);return UDe(e)}var o}function ZHe(e,t,n,r,a){if(1===n)return{real:e,imag:t};const s=VDe(e,t),i=n/2,o=jDe(s),l=o.real,u=o.imag,c=[l.length],d=a.makeTensorInfo(c,"float32",l),h=a.makeTensorInfo(c,"float32",u),p=Nje({inputs:{real:d,imag:h},backend:a}),f=GDe(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),v=a.makeTensorInfo(y,"float32",g),x=Nje({inputs:{real:b,imag:v},backend:a}),w=ZHe(l,u,i,r,a),k=w.real,S=w.imag,I=[k.length],C=a.makeTensorInfo(I,"float32",k),N=a.makeTensorInfo(I,"float32",S),T=Nje({inputs:{real:C,imag:N},backend:a}),E=ZHe(m,g,i,r,a),A=E.real,_=E.imag,$=[A.length],R=a.makeTensorInfo($,"float32",A),D=a.makeTensorInfo($,"float32",_),M=Nje({inputs:{real:R,imag:D},backend:a}),F=KDe(n,r),O=[F.real.length],P=a.makeTensorInfo(O,"float32",F.real),L=a.makeTensorInfo(O,"float32",F.imag),z=Nje({inputs:{real:P,imag:L},backend:a}),B=vHe({inputs:{a:z,b:M},backend:a}),W=Lje({inputs:{a:T,b:B},backend:a}),V=XHe({inputs:{a:T,b:B},backend:a}),U=Aje({inputs:{input:W},backend:a}),j=Aje({inputs:{input:V},backend:a}),G=VGe({inputs:{input:W},backend:a}),H=VGe({inputs:{input:V},backend:a}),q=jGe({inputs:[U,j],backend:a,attrs:{axis:0}}),K=jGe({inputs:[G,H],backend:a,attrs:{axis:0}}),X=a.data.get(q.dataId).values,Y=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}const eqe={kernelName:_we,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=Uve(r.shape),s=r.shape[r.shape.length-1],i=Bje({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=QHe(i,!1,n),l=Bje({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function tqe(e){const{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||axe(a),o=Zve(i,Uve(r));return function(e,t){e.fill(t)}(o,a),t.makeTensorInfo(r,i,o)}const nqe={kernelName:$we,backendName:"cpu",kernelFunc:tqe};const rqe={kernelName:Rwe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,s=r,i=Jve(a.dtype,Uve(a.shape)),[o,l,u,c]=a.shape,d=s.data.get(a.dataId).values;for(let h=0;h<o;h++){const e=h*u*l*c;for(let t=0;t<l;t++){const n=t*(u*c);for(let t=0;t<u;t++){const r=t*c;for(let a=0;a<c;a++){const s=Math.round(u-t-1),o=e+n+r+a;let l=d[o];if(s>=0&&s<u){l=d[e+n+s*c+a]}i[o]=l}}}}return{dataId:s.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},aqe=sje((e=>Math.floor(e))),sqe=oje(Dwe,aqe),iqe={kernelName:Dwe,backendName:"cpu",kernelFunc:sqe},oqe=fje(((e,t)=>Math.floor(e/t))),lqe=Mje(Mwe,oqe,null,"int32"),uqe={kernelName:Mwe,backendName:"cpu",kernelFunc:lqe};const cqe={kernelName:MSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=HGe({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=Bje({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=Lje({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=Lje({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=Bje({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=Cje(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=Cje(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};const dqe={kernelName:FSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=lHe({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;m=Lje({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=Cje(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function hqe(e,t,n,r,a,s,i,o,l){const u=CNe([r,s],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<a;t++){const s=e[c*a+t];r+=s*i[t],n.push(s)}if(r<0||r>=l/s)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<s;e++)u.values[c*s+e]=t.get(...t.indexToLoc(r*s+e))}return u}const pqe={kernelName:Pwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=Uve(r.shape),i=a.shape,o=i[i.length-1],[l,u,c,d]=DDe(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const h=hqe(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,o,c,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,h.values)}};function fqe(e,t,n){const r=CNe(n,e.dtype);for(let a=0;a<r.size;++a){const n=r.indexToLoc(a).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];const l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}const mqe={kernelName:Owe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;nje([a,s],"gatherV2");const l=Yve(i,a.shape)[0],u=n.data.get(s.dataId).values,c=a.shape[l];for(let v=0;v<u.length;++v){const e=u[v];Bve(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let d=o;null==o&&(d=0);const h=Uve(s.shape),p=wMe(a,s,l,d),f=Bje({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Bje({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=fqe(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},gqe=fje(((e,t)=>e>t?1:0)),yqe=Mje(Lwe,gqe,null,"bool"),bqe={kernelName:Lwe,backendName:"cpu",kernelFunc:yqe},vqe=fje(((e,t)=>e>=t?1:0)),xqe=Mje(zwe,vqe,null,"bool"),wqe={kernelName:zwe,backendName:"cpu",kernelFunc:xqe};const kqe={kernelName:Wwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=Uve(r.shape),s=r.shape[r.shape.length-1],i=Bje({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=QHe(i,!0,n),l=Bje({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},Sqe=ije(Uwe,(e=>Number.isFinite(e)?1:0),"bool"),Iqe={kernelName:Uwe,backendName:"cpu",kernelFunc:Sqe},Cqe=ije(jwe,(e=>Math.abs(e)===1/0?1:0),"bool"),Nqe={kernelName:jwe,backendName:"cpu",kernelFunc:Cqe},Tqe=ije(Gwe,(e=>Number.isNaN(e)?1:0),"bool"),Eqe={kernelName:Gwe,backendName:"cpu",kernelFunc:Tqe},Aqe=fje(((e,t)=>e<t?1:0)),_qe=Mje(qwe,Aqe,null,"bool"),$qe={kernelName:qwe,backendName:"cpu",kernelFunc:_qe},Rqe=fje(((e,t)=>e<=t?1:0)),Dqe=Mje(Kwe,Rqe,null,"bool"),Mqe={kernelName:Kwe,backendName:"cpu",kernelFunc:Dqe};function Fqe(e,t,n){const r=(t-e)/(n-1),a=dxe(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}const Oqe={kernelName:Xwe,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=Fqe(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},Pqe=sje((e=>Math.log(e))),Lqe=oje(Ywe,Pqe),zqe={kernelName:Ywe,backendName:"cpu",kernelFunc:Lqe},Bqe=ije(Qwe,(e=>Math.log1p(e))),Wqe={kernelName:Qwe,backendName:"cpu",kernelFunc:Bqe},Vqe=fje(((e,t)=>e&&t)),Uqe=Mje(Jwe,Vqe,null,"bool"),jqe={kernelName:Jwe,backendName:"cpu",kernelFunc:Uqe},Gqe=ije(Zwe,(e=>e?0:1),"bool"),Hqe={kernelName:Zwe,backendName:"cpu",kernelFunc:Gqe},qqe=fje(((e,t)=>e||t)),Kqe=Mje(eke,qqe,null,"bool"),Xqe={kernelName:eke,backendName:"cpu",kernelFunc:Kqe};const Yqe={kernelName:tke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;nje(a,"LRN");const u=a.shape[3],c=u-1,d=n.data.get(a.dataId).values,h=Uve(a.shape),p=new Float32Array(h);function f(e){const t=e%u;let n=e-t+Math.max(0,t-s);const r=e-t+Math.min(t+s,c);let a=0;for(;n<=r;n++){const e=d[n];a+=e*e}return a}for(let m=0;m<h;m++){const e=f(m),t=d[m]*Math.pow(i+o*e,-l);p[m]=t}return n.makeTensorInfo(a.shape,a.dtype,p)}};const Qqe={kernelName:nke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;nje(i,"LRNGrad");const d=Uve(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const e=b%h,t=b-e+Math.max(0,e-o),n=b-e+Math.min(h,e+o+1);let r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*c*f[a]*m[b]/r;b===a&&(e+=Math.pow(r,-c)),e*=p[b],g[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,g)}};function Jqe(e,t,n,r){const a=Jve(r,Uve(n));for(let s=0;s<a.length;++s){const n=s*t;let r=e[n];for(let a=0;a<t;++a){const t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[s]=r}return a}function Zqe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n;let l=a.shape;const u=l.length,c=Yve(s,l);let d=c;const h=wAe(d,u);let p=o.data.get(a.dataId).values;if(null!=h){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];p=Jje(p,l,a.dtype,h,e),d=SAe(d.length,u),l=e}nje(a,"max"),xAe("max",d,u);const[f,m]=bAe(l,d),g=Jqe(p,Uve(m),f,a.dtype),y=o.write(g,f,a.dtype);let b=f;if(i){b=vAe(f,c)}return{dataId:y,shape:b,dtype:a.dtype}}const eKe={kernelName:rke,backendName:"cpu",kernelFunc:Zqe},tKe=fje(((e,t)=>Math.max(e,t))),nKe=Mje(ake,tKe),rKe={kernelName:ake,backendName:"cpu",kernelFunc:nKe};const aKe={kernelName:ske,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;nje(a,"maxPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Bve(bEe(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=lEe(a.shape,s,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&jve(u.inShape,u.outShape))c=cje({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=oxe(a.shape),r=gGe(e,a.shape,a.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,a.dtype,r.values)}return c}};const sKe={kernelName:oke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;nje(a,"maxPool3d");const c=uEe(a.shape,s,i,1,o,l,u),d=bGe(n.data.get(a.dataId).values,a.shape,a.dtype,oxe(a.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};const iKe={kernelName:lke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;nje([a,s],"maxPool3DGrad");const c=uEe(s.shape,i,o,1,l,u),d=function(e,t){const n=CNe(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let v=b;for(;v<0;)v+=i;const x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){const u=r*a-p;let h=u;for(;h<0;)h+=o;const w=Math.min(t.inHeight,c+u);for(let a=0;a<t.outWidth;++a){const p=a*s-f;let k=p;for(;k<0;)k+=l;const S=Math.min(t.inWidth,d+p);let I=Number.NEGATIVE_INFINITY,C=-1;for(let t=v;t<x;t+=i){const n=t-b;for(let r=h;r<w;r+=o){const a=r-u;for(let s=k;s<S;s+=l){const i=s-p,o=e.get(m,t,r,s,g);o>=I&&(I=o,C=n*c*d+a*c+i)}}}n.set(C,m,y,r,a,g)}}}return n}(n.bufferSync(s),c),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=x-1-c.padInfo.left,S=v-1-c.padInfo.top,I=CNe(s.shape,"float32"),C=n.bufferSync(a);for(let N=0;N<c.batchSize;++N)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const a=t-w,s=n-S,i=r-k;let o=0;for(let t=0;t<b;t+=m){const n=(a+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){const a=(s+r)/p;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let s=0;s<x;s+=y){const l=(i+s)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=b*v*x-1-d.get(N,n,a,l,e)===t*v*x+r*x+s?1:0;if(0===u)continue;o+=C.get(N,n,a,l,e)*u}}}I.set(o,N,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const oKe={kernelName:ike,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;nje([s,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=lEe(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=CNe(h.outShape,o.dtype,yGe(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,k=v-1-h.padInfo.top,S=CNe(o.shape,"float32"),I=n.data.get(a.dataId).values,C=CNe(a.shape,"float32",I);for(let N=0;N<h.batchSize;++N)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){const r=t-k,a=n-w;let s=0;for(let t=0;t<v;t+=y){const n=(r+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){const i=(a+r)/g;if(i<0||i>=h.outWidth||Math.floor(i)!==i)continue;const o=v*x-1-f.get(N,n,i,e)===t*x+r?1:0;if(0===o)continue;s+=C.get(N,n,i,e)*o}}S.set(s,N,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const lKe={kernelName:uke,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;nje(a,"MaxPoolWithArgmax");const c=u.data.get(a.dataId).values,d=lEe(a.shape,s,i,[1,1],o),[h,p]=function(e,t,n,r,a){const s=gGe(e,0,n,oxe(t),a,"max"),i=yGe(e,t,n,a,!0,r);return[s.values,i.values]}(c,a.shape,a.dtype,l,d),f=u.write(h,d.outShape,a.dtype),m=u.write(p,d.outShape,a.dtype);return[{dataId:f,shape:d.outShape,dtype:a.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};const uKe={kernelName:cke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=Yve(s,a.shape),l=Uve(bAe(a.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const d=Rje({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});u.push(d);const h=GHe({inputs:{a:d,b:c},backend:n});u.push(h);const p=wHe({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:i}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const cKe={kernelName:dke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;nje(a,"min");const o=Yve(s,a.shape);let l=o;const u=wAe(l,a.shape.length);let c=a;null!=u&&(c=Zje({inputs:{x:a},backend:n,attrs:{perm:u}}),l=SAe(l.length,a.shape.length)),xAe("min",l,c.shape.length);const[d,h]=bAe(c.shape,l),p=Uve(h),f=dxe(Uve(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=Bje({inputs:{x:g},backend:n,attrs:{shape:vAe(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},dKe=fje(((e,t)=>Math.min(e,t))),hKe=Mje(hke,dKe),pKe={kernelName:hke,backendName:"cpu",kernelFunc:hKe};const fKe={kernelName:pke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;nje(a,"mirrorPad");const o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),c="reflect"===i?0:1,d=n.data.get(a.dataId).values,h=a.shape.length,p=oxe(a.shape),f=Uve(o),m=o.length,g=oxe(o),y=Jve(a.dtype,f);for(let b=0;b<f;b++){let e=mxe(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));const t=fxe(e,h,p);y[b]=d[t]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}},mKe=fje(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),gKe=Mje(fke,mKe),yKe={kernelName:fke,backendName:"cpu",kernelFunc:gKe};function bKe(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length;let o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Yve([o],a.shape),u=Zqe({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=vAe(u.shape,l),d=Bje({inputs:{x:u},backend:n,attrs:{shape:c}}),h=XHe({inputs:{a:a,b:d},backend:n}),p=PHe({inputs:{x:h},backend:n}),f=wHe({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=Bje({inputs:{x:f},backend:n,attrs:{shape:c}}),g=GHe({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const vKe={kernelName:iSe,backendName:"cpu",kernelFunc:bKe};const xKe={kernelName:mke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;nje(a,"multinomial");const l=o?a:bKe({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,s],p=dxe(Uve(h),"int32");for(let f=0;f<u;++f){const e=f*c,t=new Float32Array(c-1);t[0]=d[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+d[e+a];const n=L_e.alea(i.toString()),r=f*s;for(let a=0;a<s;++a){const e=n();p[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+a]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}};function wKe(e,t,n){const r=oIe(-1,n);return yHe([],t,r,e,n)}const kKe={kernelName:yke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;nje(r,"neg");const a=n.data.get(r.dataId).values,[s,i]=wKe(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}},SKe=IRe;const IKe={kernelName:vke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;nje(a,"NonMaxSuppression");const u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d}=SKe(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},CKe=CRe;const NKe={kernelName:xke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;nje(a,"NonMaxSuppressionPadded");const c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=CKe(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},TKe=NRe;const EKe={kernelName:wke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;nje(a,"NonMaxSuppressionWithScore");const c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=TKe(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},AKe=fje(((e,t)=>e!==t?1:0)),_Ke=Mje(bke,AKe,null,"bool"),$Ke={kernelName:bke,backendName:"cpu",kernelFunc:_Ke};const RKe={kernelName:Ske,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;nje(a,"oneHot");const u=Uve(a.shape),c=new Float32Array(u*i);c.fill(l);const d=n.data.get(a.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...a.shape,i],s,c)}};function DKe(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=Aje({inputs:{input:r},backend:n}),t=DKe({inputs:{x:e},backend:n}),a=VGe({inputs:{input:r},backend:n}),s=DKe({inputs:{x:a},backend:n}),i=Nje({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return tqe({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const MKe={kernelName:ASe,backendName:"cpu",kernelFunc:DKe};const FKe={kernelName:kke,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const t=Aje({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=VGe({inputs:{input:a},backend:r}),i=DKe({inputs:{x:s},backend:r}),o=Nje({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return tqe({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function OKe(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return zHe({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Wve(s,e.shape,"All tensors passed to stack must have matching shapes"),Bve(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=jGe({inputs:t.map((e=>{const t=zHe({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const PKe={kernelName:Ike,backendName:"cpu",kernelFunc:OKe};const LKe={kernelName:Cke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;nje(a,"pad");const o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,c=Uve(a.shape),d=a.shape.length,h=oxe(a.shape),p=Uve(o),f=o.length,m=oxe(o),g=Jve(a.dtype,p);0!==i&&g.fill(i);for(let y=0;y<c;y++){g[fxe(mxe(y,d,h).map(((e,t)=>e+l[t])),f,m)]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},zKe=fje(((e,t)=>Math.pow(e,t))),BKe=Mje(Nke,zKe),WKe={kernelName:Nke,backendName:"cpu",kernelFunc:BKe};function VKe(e,t,n,r){const[a,s]=bAe(e,r),i=zIe(t,"int32"),o=dxe(Uve(a),i),l=Uve(s);for(let u=0;u<o.length;++u){const e=u*l;let t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:a,outDtype:i}}const UKe={kernelName:Eke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;nje(a,"prod");const o=a.shape.length,l=Yve(s,a.shape),u=wAe(l,o);let c=l,d=a;const h=[];null!=u&&(d=Zje({inputs:{x:a},backend:n,attrs:{perm:u}}),h.push(d),c=SAe(c.length,o));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=VKe(d.shape,d.dtype,p,c);let y=m;return i&&(y=vAe(m,l)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function jKe(e,t,n,r){const a=[];let s=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){const a=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-a[r];for(let n=r;n<i;++n)o[s].push(a[n+1]+t)}r=a[r],i=a[i]}i!==r&&(a.push([r,i]),s+=i-r)}return{outSplits:o,valueSlices:a,numValues:s}}function GKe(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function HKe(e,t,n,r,a){const s=t.slice();s[0]=a;const i=Zve(n,Uve(s)),o=e.length;return function(e,t,n,r,a,s){const i=GKe(t,2)[1],o=GKe(s,2)[1];let l=0;for(const u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)a[l*o+n]=e[t*i+n];++l}}(e,t,r,0===o?0:o/t[0],i,s),[i,s]}function qKe(e,t,n,r,a,s,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const a=mxe(r,t.length,oxe(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(s,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:c,numValues:d}=jKe(s,i,e,l),h=function(e){const t=[];for(let n=0;n<e.length;++n){const r=Zve("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(u),p=HKe(n,r,a,c,d);return[h,p[0],p[1]]}const KKe={kernelName:Ake,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.data.get(e.dataId).values)),u=a.map((e=>e.shape)),c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=qKe(l,u,c,s.shape,s.dtype,d,i.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}},XKe=2147483647;function YKe(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===a.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(a[0]),u||c.push(i[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=Zve("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const t=o?e[0]:e[m],n=l?r[0]:r[m],a=u?s[0]:s[m];if(0===a)throw new Error("Requires delta != 0");let i;if(a>0&&n<t||a<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/a)),i>XKe)throw new Error(`Requires ((limit - start) / delta) <= ${XKe}`);h[m+1]=h[m]+i}const p=Zve(n,h[d]);let f=0;for(let m=0;m<d;++m){const t=h[m+1]-h[m];let n=o?e[0]:e[m];const r=u?s[0]:s[m];for(let e=0;e<t;++e)p[f++]=n,n+=r}return[h,p]}const QKe={kernelName:_ke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=YKe(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var JKe=xDe;class ZKe{constructor(e,t,n,r,a,s,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=kDe(u),this.raggedRank=SDe(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===JKe.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===JKe.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case JKe.VALUE_ROWIDS:return ZKe.getMaxWidthValueRowID(t);case JKe.ROW_SPLITS:return ZKe.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${JKe[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){const t=e[s];t!==r&&(r=t,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return tXe(e,n)}calculateOutputSize(e){const t=this.valuesShape;IDe(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=wDe(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let a=1;a<=this.raggedRank;++a)r[a]<0&&(r[a]=this.getMaxWidth(a));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),a=[];let s=0;for(let i=0;i<r;++i,s+=t)a.push(s);for(let i=r;i<e;++i)a.push(-1);return Bve(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){const a=e.length,s=[];for(let i=0;i<a-1;++i){const a=e[i+1]-e[i];let o=Math.min(r,a),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)s.push(l),l+=n;for(let e=0;e<a-o;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){const a=e.length,s=[];if(0===a)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let u=1;u<a;++u){const a=e[u];if(a===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}s.push(l)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){const a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case JKe.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case JKe.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${JKe[s]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case JKe.FIRST_DIM_SIZE:return e[0];case JKe.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case JKe.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${JKe[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];const r=tXe(t,!1),a=Zve(this.valuesDType,Uve(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){s=this.calculateOutputIndex(e-1,s,n[e],t[e])}this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;const a=this.values,s=n;let i=r.slice();i=i.slice(e+1);const o=Uve(i),l=t.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const e=this.defaultValueShape;yCe((()=>{const t=kEe(u,e),n=zEe(t,i);u=n.dataSync()}))}let c=0,d=0,h=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==h){if(d<h){const e=a.subarray(c*o);eXe(s.subarray(d*o),e,(h-d)*o)}if(p>=l){const t=n.length;e=Math.floor(t/o)}if(e>h)if(1===this.defaultValue.length)s.subarray(h*o,e*o).fill(this.defaultValue[0]),h=e;else for(;e>h;){eXe(s.slice(h*o),u,o),++h}e<0?(c=p+1,d=h):(c=p,d=h,h=d+1)}else++h}}}function eXe(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function tXe(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function nXe(e,t,n,r,a,s,i,o,l,u){return new ZKe(e,t,n,r,a,s,i,o,l,u).compute()}const rXe={kernelName:$ke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,h=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=nXe(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}};function aXe(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return dxe(0,r);const a=dxe(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+n;return a}const sXe={kernelName:Rke,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=aXe(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}},iXe=ije(Mke,(e=>1/e)),oXe={kernelName:Mke,backendName:"cpu",kernelFunc:iXe};const lXe={kernelName:zke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;nje(a,"resizeBilinear");const l=oxe(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(Uve([d,u,c,f])),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<d;k++)for(let e=0;e<u;e++){let t;t=i?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(h-1,Math.ceil(t)),s=k*l[0]+n*l[1],o=k*l[0]+a*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(p-1,Math.ceil(t)),c=s+n*l[2],d=o+n*l[2],h=s+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[d+e],s=t+(m[h+e]-t)*a,i=s+(n+(m[y+e]-n)*a-s)*r;g[v++]=i}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}};const uXe={kernelName:Bke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;nje([s,a],"resizeBilinearGrad");const o=oxe(a.shape),[l,u,c,d]=a.shape,[,h,p]=s.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(s.dataId).values;let x=0;for(let w=0;w<l;w++){const e=w*o[0];for(let t=0;t<h;t++){const n=t*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=e+r*o[1],i=e+a*o[1],l=n-r,h=1-l;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),a=t-n,u=1-a,p=s+n*o[2],m=s+r*o[2],g=i+n*o[2],y=i+r*o[2],w=h*u,k=h*a,S=l*u,I=l*a;for(let e=0;e<d;e++){const t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*I}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}};const cXe={kernelName:Pke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;nje(a,"resizeNearestNeighbor");const l=oxe(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(d*u*c*f),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let k=0;k<d;k++){const e=k*l[0];for(let t=0;t<u;t++){const n=i?v*(t+.5):v*t;let r=Math.min(h-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const a=e+r*l[1];for(let e=0;e<c;e++){const t=i?x*(e+.5):x*e;let n=Math.min(p-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=a+n*l[2];for(let e=0;e<f;e++){const t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([d,u,c,f],a.dtype,g)}};const dXe={kernelName:Lke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;nje([s,a],"resizeNearestNeighborGrad");const o=oxe(a.shape),l=oxe(s.shape),[u,c,d,h]=a.shape,[,p,f]=s.shape,m=new Float32Array(u*c*d*h),g=n.data.get(s.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let C=0;C<u;C++){const e=C*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*w),a=Math.floor(r-S/2);for(let s=0;s<d;s++){const r=n+s*o[2],u=Math.floor(s*k),y=Math.floor(u-I/2);for(let n=0;n<h;n++){let o=0;for(let r=0;r<S;r++){const u=r+a;if(u<0||u>=p)continue;const h=e+u*l[1],m=u*v;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){const t=e+y;if(t<0||t>=f)continue;const r=h+t*l[2],a=t*x;s===Math.min(d-1,i?Math.round(a):Math.floor(a))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}};const hXe={kernelName:Vke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;nje(a,"reverse");const i=a.shape.length,o=Yve(s,a.shape);if(0===i)return cje({inputs:{x:a},backend:n});const l=new NIe(a.shape,a.dtype),u=n.bufferSync(a);for(let c=0;c<l.size;c++){const e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},pXe={kernelName:RSe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=Jve(a.dtype,Uve(a.shape)),[c,d,h,p]=a.shape,[f,m]=TDe(o,d,h),g=Math.sin(s),y=Math.cos(s),b=l.data.get(a.dataId).values;for(let v=0;v<c;v++){const e=v*h*d*p;for(let t=0;t<d;t++){const n=t*(h*p);for(let r=0;r<h;r++){const a=r*p;for(let s=0;s<p;s++){const o=[c,t,r,s],l=o[2],v=o[1];let x=(l-f)*y-(v-m)*g,w=(l-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=i;if("number"!==typeof i&&(k=3===s?255:i[s]),x>=0&&x<h&&w>=0&&w<d){k=b[e+w*(h*p)+x*p+s]}u[e+n+a+s]=k}}}}return{dataId:l.write(u,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},fXe=ije(Uke,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),mXe={kernelName:Uke,backendName:"cpu",kernelFunc:fXe},gXe=sje((e=>1/Math.sqrt(e))),yXe=oje(jke,gXe),bXe={kernelName:jke,backendName:"cpu",kernelFunc:yXe};function vXe(e,t,n,r,a,s,i,o,l,u){const c=[r/a,a],d=e.values,h=t.values;if(0===r)return CNe(n,t.dtype);const p=l instanceof NIe?l:CNe(c,t.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<s;f++){const e=[];let s=0;for(let t=0;t<i;t++){const n=d[f*i+t];e.push(n),s+=n*o[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?p.values[s*a+n]+=h[f*a+n]:p.values[s*a+n]=0===t.rank?h[0]:h[f*a+n]}return p}const xXe={kernelName:Gke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=M$e(0,a,i),h=vXe(n.bufferSync(a),n.bufferSync(s),i,d,u,l,o,c,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function wXe(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function kXe(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}const SXe={kernelName:qke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=function(e,t,n,r,a,s){const i=Zve("int32",n*a);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?wXe(n,t[e+l]):kXe(n,t[e+l])}return i}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",o)}};const IXe={kernelName:Kke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;nje([r,a,s],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=zIe(a.dtype,s.dtype),d=dxe(Uve(a.shape),c);let h=0;const p=0===i||i>1||1===a.shape.length?1:Uve(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(a.shape,c,d)}},CXe=MDe,NXe=FDe,TXe=ije(Xke,(e=>e>=0?NXe*e:CXe*(Math.exp(e)-1))),EXe={kernelName:Xke,backendName:"cpu",kernelFunc:TXe},AXe=ije(Zke,(e=>e<0?-1:e>0?1:0)),_Xe={kernelName:Zke,backendName:"cpu",kernelFunc:AXe},$Xe=ije(Qke,(e=>Math.sin(e))),RXe={kernelName:Qke,backendName:"cpu",kernelFunc:$Xe},DXe=ije(Jke,(e=>Math.sinh(e))),MXe={kernelName:Jke,backendName:"cpu",kernelFunc:DXe},FXe=Math.log(1.1920928955078125e-7)+2,OXe=ije(tSe,(e=>{const t=e>-FXe,n=e<FXe,r=Math.exp(e);let a;return a=n?r:t?e:Math.log(1+r),a})),PXe={kernelName:tSe,backendName:"cpu",kernelFunc:OXe};const LXe={kernelName:aSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;nje([a],"spaceToBatchND");const o=Uve(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);const u=LKe.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=EDe(u.shape,s,o,!1),d=ADe(c.length,s.length,!1),h=_De(u.shape,s,o,!1),p=Bje({inputs:{x:u},backend:n,attrs:{shape:c}}),f=Zje({inputs:{x:p},backend:n,attrs:{perm:d}}),m=Bje({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function zXe(e,t,n,r,a,s,i){const o=t[0],l=s[0],u=new Array(l),c=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(oMe(o));return[Zve(n,0),[0,d],Zve(a,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<o;++g){const t=e[g*d];if(t<0)throw new Error(lMe(g,t));if(t>=l)throw new Error(uMe(g,t,l));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<l;++g){const e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,d],n,u,c]}{const t=f[l-1],s=Zve(n,t*d),h=Zve(a,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){const t=e[n*d],a=p[t],i=(0===t?0:f[t-1])+a;p[t]++;for(let r=0;r<d;++r)s[i*d+r]=e[n*d+r];h[i]=r[n],c[n]=i}for(let e=0;e<l;++e){if(0===p[e]){const t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;h[t]=i}}return[s,[t,d],h,u,c]}}const BXe={kernelName:oSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=zXe(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function WXe(e,t,n,r,a){const s=Uve(r),i=t[0],o=a.length,l=[];let u=1,c=-1;for(let m=0;m<o;++m){const e=a[m];if(-1===e){if(-1!==c)throw new Error(cMe(c,m));c=m,l.push(1)}else{if(e<0)throw new Error(dMe(m,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(s/u);if(u*e!==s)throw new Error(pMe(r,l));l[c]=e}if(Uve(l)!==s)throw new Error(fMe(r,l));const d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=Zve(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],l]}const VXe={kernelName:lSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,d]=WXe(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};function UXe(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?a[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=c;const h=Zve(n,d.reduce(((e,t)=>e*t),1));if(0===o)return c>0&&h.fill(i),[h,d];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=a[p];for(;;){let t=0;if(f<o){if(t=a[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(yMe(g,c));g>m&&h.fill(i,m*u,g*u);for(let n=p;n<f;++n){const t=r[n];if(t<0||t>=l[0])throw new Error(bMe(n,r[n],l[0]));for(let n=0;n<u;n++)h[g*u+n]+=e[t*u+n]}if(s)for(let e=0;e<u;e++)h[g*u+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>o)break}return m<c&&h.fill(i,m*u,c*u),[h,d]}const jXe={kernelName:uSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=UXe(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const GXe={kernelName:cSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=UXe(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const HXe={kernelName:dSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=M$e(0,a,o),p=!1,f=n.bufferSync(a);let m;switch(s.dtype){case"bool":m=vXe(f,n.bufferSync(s),o,h,c,u,l,d,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":m=vXe(f,n.bufferSync(s),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"int32":m=vXe(f,n.bufferSync(s),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"string":m=vXe(f,n.bufferSync(s),o,h,c,u,l,d,hIe(n.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}};const qXe={kernelName:sSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Yve(i,a.shape)[0],l=iMe(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{const t=[...c];t[o]=e;const r=CGe({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},KXe=sje((e=>Math.sqrt(e))),XXe=ije(nSe,(e=>Math.sqrt(e))),YXe={kernelName:nSe,backendName:"cpu",kernelFunc:XXe},QXe={kernelName:pSe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:r}=t,a=n;nje(r,"square");const s=a.data.get(r.dataId).values,i=new Float32Array(s.length);for(let o=0;o<s.length;++o){const e=s[o];i[o]=e*e}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},JXe=fje(((e,t)=>{const n=e-t;return n*n})),ZXe=Mje(hSe,JXe),eYe={kernelName:hSe,backendName:"cpu",kernelFunc:ZXe},tYe=sje(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),nYe=oje(fSe,tYe),rYe={kernelName:fSe,backendName:"cpu",kernelFunc:nYe},aYe=ije(_Se,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),sYe={kernelName:_Se,backendName:"cpu",kernelFunc:aYe};function iYe(e,t,n,r){const a=CNe(e,t.dtype);for(let s=0;s<a.size;s++){const e=a.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}const oYe={kernelName:mSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;nje(a,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=qTe(a.shape,s,i,o,l,u,c,d,h);let w;if(m)w=Bje({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){Bve(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=MTe(b,v,x),t=CGe({inputs:{x:a},backend:n,attrs:{begin:b,size:e}});w=Bje({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=iYe(p,n.bufferSync(a),x,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class lYe{constructor(e,t,n,r,a,s){this.separator=dIe(e),this.nGramWidths=t,this.leftPad=dIe(n),this.rightPad=dIe(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){const o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),c=s-(l+u),d=t+(l>0?0:i-o);let h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length;h+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(h);const p=n[r+i];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const a=r-1,s=Zve("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[e,s]}s[0]=0;for(let o=1;o<=a;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[o]=s[o-1]+n}const i=new Array(s[a]);for(let o=0;o<a;++o){const n=t[o];let r=s[o];if(this.nGramWidths.forEach((a=>{const s=t[o+1]-t[o],l=this.getNumNGrams(s,a);this.createNGrams(e,n,i,r,l,a),r+=l})),this.preserveShort&&r===s[o]){const a=t[o+1]-t[o];if(0===a)continue;const s=a+2*this.padWidth,l=1;this.createNGrams(e,n,i,r,l,s)}}return[i,s]}}function uYe(e,t,n,r,a,s,i,o){return new lYe(n,r,a,s,i,o).compute(e,t)}const cYe={kernelName:gSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=uYe(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};function dYe(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const a=t[0];let s=e.indexOf(a);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||r.push(t),s=(e=e.subarray(s+1)).indexOf(a)}return void(n&&0===e.length||r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(a,s);n&&0===t.length||r.push(t),a=s+1}}function hYe(e,t,n){const r=e.length,a=[];let s=0,i=0;const o=new Array(r);for(let h=0;h<r;++h){const r=a.length;dYe(e[h],t,n,a);const l=a.length-r;o[h]=l,s+=l,i=Math.max(i,l)}const l=Zve("int32",2*s),u=new Array(s),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let e=0;e<o[h];++e)l[2*d]=h,l[2*d+1]=e,u[d]=a[d],++d;return[l,u,c]}const pYe={kernelName:ySe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=hYe(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function fYe(e,t){const n=Zve("int32",e.length);for(let r=0;r<e.length;++r)n[r]=iIe(e[r]).modulo(t).getLowBitsUnsigned();return n}const mYe={kernelName:bSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=fYe(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",i)}},gYe=ije(xSe,(e=>Math.tan(e))),yYe={kernelName:xSe,backendName:"cpu",kernelFunc:gYe},bYe=ije(wSe,(e=>Math.tanh(e)));const vYe={kernelName:Hke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=M$e(0,a,r.shape),d=n.bufferSync(a),h=n.bufferSync(s),p=n.bufferSync(r),f=vXe(d,h,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function xYe(e,t){const n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];const r=CNe(n,e.dtype);for(let a=0;a<r.values.length;++a){const t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const s=e.locToIndex(n);r.values[a]=e.values[s]}return r}const wYe={kernelName:kSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;nje(a,"tile");const i=xYe(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},kYe=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function SYe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){const a=r-n+1,s=t-n+1,i=Math.log(a),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(a-o)/a)*Math.sign(s-a/2);SYe(e,t,Math.max(n,Math.floor(t-s*o/a+l)),Math.min(r,Math.floor(t+(a-s)*o/a+l)))}const a=e[t];let s=n,i=r;for(zve(e,n,t),kYe(e[r],a)>0&&zve(e,n,r);s<i;){for(zve(e,s,i),s++,i--;kYe(e[s],a)<0;)s+=1;for(;kYe(e[i],a)>0;)i-=1}0===kYe(e[n],a)?zve(e,n,i):(i+=1,zve(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function IYe(e,t,n,r,a){const s=t[t.length-1],[i,o]=[e.length/s,s],l=Jve(n,i*r),u=Jve("int32",i*r);for(let d=0;d<i;d++){const t=d*o,n=e.subarray(t,t+o);let s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(SYe(s,r),s=s.slice(0,r)),a&&s.sort(kYe);const i=d*r,c=l.subarray(i,i+r),h=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=s[e].value,h[e]=s[e].index}const c=t.slice();return c[c.length-1]=r,[CNe(c,n,l),CNe(c,"int32",u)]}const CYe={kernelName:SSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;nje(a,"topk");const o=n.data.get(a.dataId).values,[l,u]=IYe(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};const NYe={kernelName:ISe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=[c,f,m,p],y=oxe(a.shape),b=y[0],v=y[1],x=y[2],w=oxe(g),k=w[0],S=w[1],I=w[2],C=Jve(a.dtype,Uve(g));C.fill(l);const N=r.data.get(a.dataId).values,T=r.data.get(s.dataId).values;for(let E=0;E<c;++E){const e=1===s.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let a;const s=e[6]*n+e[7]*t+1;if(0===s)continue;const u=(e[0]*n+e[1]*t+e[2])/s,c=(e[3]*n+e[4]*t+e[5])/s,p=TYe(u,h,o),f=TYe(c,d,o);switch(i){case"nearest":a=AYe(N,d,h,b,v,x,E,f,p,r,l);break;case"bilinear":a=_Ye(N,d,h,b,v,x,E,f,p,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}C[E*k+t*S+n*I+r]=a}return r.makeTensorInfo(g,a.dtype,C)}return{dataId:r.write(C,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function TYe(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Pve(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return Pve(0,n,t-1)}(e,t);case"nearest":return function(e,t){return Pve(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function EYe(e,t,n,r,a,s,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*a+l*s+u]:c}function AYe(e,t,n,r,a,s,i,o,l,u,c){return EYe(e,t,n,r,a,s,i,Math.round(o),Math.round(l),u,c)}function _Ye(e,t,n,r,a,s,i,o,l,u,c){const d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1;return(p-o)*((f-l)*EYe(e,t,n,r,a,s,i,d,h,u,c)+(l-h)*EYe(e,t,n,r,a,s,i,d,f,u,c))+(o-d)*((f-l)*EYe(e,t,n,r,a,s,i,p,h,u,c)+(l-h)*EYe(e,t,n,r,a,s,i,p,f,u,c))}function $Ye(e,t,n,r){const a=Yve(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];const i=new Map,o=new Int32Array(n[a]),l=new NIe(s,r,e),u=[],c=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(l.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,u.push(f)}}const d=s.slice();d[1]=i.size;const h=new NIe(d,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)h.set(l.get(n,e,r),n,t,r)}));const p=n.slice();return p[a]=d[1],{outputValues:h.values,outputShape:p,indices:o}}const RYe={kernelName:NSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;nje(s,"unique");const i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=$Ye(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const DYe={kernelName:TSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const i=a.shape.length,o=a.shape[s],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==s&&(l[u++]=a.shape[p]);const c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;const h=new Array(o);for(let p=0;p<h.length;p++){c[s]=p;const e=CGe({inputs:{x:a},backend:n,attrs:{begin:c,size:d}});h[p]=Bje({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return h}};const MYe={kernelName:ESe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;nje(a,"unsortedSegmentSum");const o=[],l=[],u=a.shape.length-s.shape.length;let c=s;for(let h=0;h<u;++h){const e=zHe({inputs:{input:c},backend:n,attrs:{dim:h+1}});c=e,l.push(e)}for(let h=0;h<i;++h){const e=oIe(h,"int32"),t=n.makeTensorInfo([],"int32",e),r=NHe({inputs:{a:t,b:c},backend:n}),s=Rje({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=vHe({inputs:{a:s,b:a},backend:n}),u=wHe({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(s),l.push(i),l.push(u)}const d=OKe({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},FYe=[jje,Hje,Kje,Yje,zje,Qje,tGe,nGe,rGe,aGe,iGe,lGe,cGe,pGe,mGe,vGe,xGe,wGe,kGe,Uje,SGe,TGe,_Ge,DGe,MGe,Dje,PGe,zGe,Tje,BGe,GGe,qGe,KGe,XGe,YGe,QGe,JGe,eHe,nHe,rHe,aHe,sHe,iHe,oHe,uHe,cHe,dHe,hHe,pHe,fHe,mHe,gHe,SHe,uje,IHe,THe,FHe,LHe,BHe,UHe,eqe,nqe,rqe,iqe,uqe,cqe,dqe,pqe,mqe,bqe,wqe,dje,kqe,UGe,Iqe,Nqe,Eqe,pje,$qe,Mqe,Oqe,zqe,Wqe,jqe,Hqe,Xqe,Yqe,Qqe,eKe,rKe,aKe,sKe,iKe,oKe,lKe,uKe,cKe,pKe,fKe,yKe,xKe,xHe,kKe,IKe,NKe,EKe,$Ke,RKe,FKe,PKe,LKe,WKe,yje,UKe,KKe,QKe,rXe,sXe,_je,HHe,oXe,vje,wje,Wje,lXe,uXe,cXe,dXe,hXe,pXe,mXe,bXe,xXe,SXe,IXe,EXe,Ije,_Xe,RXe,MXe,NGe,vKe,PXe,LXe,BXe,VXe,jXe,GXe,HXe,qXe,YXe,QXe,eYe,rYe,sYe,oYe,cYe,pYe,mYe,YHe,kHe,yYe,{kernelName:wSe,backendName:"cpu",kernelFunc:bYe},vYe,wYe,CYe,NYe,eGe,RYe,DYe,MYe,MKe];for(const n of FYe)USe(n);const OYe={},PYe={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function LYe(e,t){if(!(e in OYe)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(xxe().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete OYe[e]}),!1),xxe().getBool("SOFTWARE_WEBGL_ENABLED")&&(PYe.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",PYe)||n.getContext("experimental-webgl",PYe);return n.getContext("webgl2",PYe)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;OYe[e]=n}const n=OYe[e];return null==n||n.isContextLost()?(delete OYe[e],LYe(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),OYe[e])}var zYe,BYe,WYe;function VYe(e,t){return[t,e]}function UYe(e){const t=Uve(e);return Hve(Math.ceil(t/4))}function jYe(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function GYe(e,t){const n=e;let r,a,s,i,o,l,u,c,d,h;return 2===xxe().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function HYe(e,t){const n=t();return xxe().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(zYe||(zYe={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(BYe||(BYe={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(WYe||(WYe={}));function qYe(e){return!!(xxe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function KYe(e,t){return rQe(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const XYe=/ERROR: [0-9]+:([0-9]+):/g;function YYe(e,t){const n=XYe.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map(((e,t)=>qve((t+1).toString(),s)+e));let o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${qve(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function QYe(e,t){if(HYe(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function JYe(e,t,n,r,a,s,i){const o=e.getAttribLocation(t,n);return-1!==o&&(HYe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),HYe(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i))),HYe(e,(()=>e.enableVertexAttribArray(o))),!0)}function ZYe(e,t,n,r){HYe(e,(()=>function(e,t,n){aQe(e,n),HYe(e,(()=>e.activeTexture(e.TEXTURE0+n))),HYe(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),HYe(e,(()=>e.uniform1i(n,r)))}function eQe(e,t,n){HYe(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),HYe(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function tQe(e,t){HYe(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),HYe(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function nQe(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function rQe(e,t,n){const r=HYe(e,(()=>t()));if(null==r)throw new Error(n);return r}function aQe(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function sQe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Uve(e.slice(0,e.length-t))}function iQe(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function oQe(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[sQe(e),...iQe(e)]),t}function lQe(e){return e%2===0}function uQe(e,t){if(jve(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(lQe(n)&&lQe(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&lQe(e[0])&&lQe(t[0])}let cQe,dQe;function hQe(e,t){return null!=e.getExtension(t)}function pQe(e){try{if(null!=LYe(e))return!0}catch(mD){return console.log("Error when getting WebGL context: ",mD),!1}return!1}function fQe(e){if(0===e)return!1;const t=LYe(e);if(1!==e){if(hQe(t,"EXT_color_buffer_float"))return mQe(t);const e="EXT_color_buffer_half_float";if(hQe(t,e)){const n=t.getExtension(e);return function(e,t){const n=GYe(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const a=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}(t,n)}return!1}if(!hQe(t,"OES_texture_float"))return!1;if(!hQe(t,"WEBGL_color_buffer_float"))return!1;return mQe(t)}function mQe(e){const t=GYe(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function gQe(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Bve("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const yQe=xxe();function bQe(){let e,t,n,r,a,s,i,o,l,u;return 2===xxe().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=xxe().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function vQe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=oxe(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${t}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function xQe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=oxe(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / outShapeStrides[${a}]`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function wQe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${r[a]}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}function kQe(e){const t=oxe(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}yQe.registerFlag("HAS_WEBGL",(()=>yQe.getNumber("WEBGL_VERSION")>0)),yQe.registerFlag("WEBGL_VERSION",(()=>pQe(2)?2:pQe(1)?1:0)),yQe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),yQe.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===yQe.get("WEBGL_VERSION"))),yQe.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),yQe.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),yQe.registerFlag("WEBGL_PACK",(()=>yQe.getBool("HAS_WEBGL"))),yQe.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>yQe.getBool("WEBGL_PACK"))),yQe.registerFlag("WEBGL_PACK_CLIP",(()=>yQe.getBool("WEBGL_PACK"))),yQe.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>yQe.getBool("WEBGL_PACK"))),yQe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>yQe.getBool("WEBGL_PACK"))),yQe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>yQe.getBool("WEBGL_PACK"))),yQe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>yQe.getBool("WEBGL_PACK"))),yQe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>yQe.getBool("WEBGL_PACK"))),yQe.registerFlag("WEBGL_PACK_REDUCE",(()=>yQe.getBool("WEBGL_PACK"))),yQe.registerFlag("WEBGL_LAZILY_UNPACK",(()=>yQe.getBool("WEBGL_PACK"))),yQe.registerFlag("WEBGL_CONV_IM2COL",(()=>yQe.getBool("WEBGL_PACK"))),yQe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>yQe.getBool("WEBGL_PACK"))),yQe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==cQe){const t=LYe(e);cQe=t.getParameter(t.MAX_TEXTURE_SIZE)}return cQe}(yQe.getNumber("WEBGL_VERSION")))),yQe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==dQe){const t=LYe(e);dQe=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,dQe)}(yQe.getNumber("WEBGL_VERSION")))),yQe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=yQe.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=LYe(e);return t=hQe(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:hQe(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),yQe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>yQe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!eCe())),yQe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=LYe(e);if(1===e){if(!hQe(t,"OES_texture_float"))return!1}else if(!hQe(t,"EXT_color_buffer_float"))return!1;return mQe(t)}(yQe.getNumber("WEBGL_VERSION")))),yQe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!yQe.getBool("WEBGL_FORCE_F16_TEXTURES")&&yQe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),yQe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>fQe(yQe.getNumber("WEBGL_VERSION")))),yQe.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=yQe.getNumber("WEBGL_VERSION"))&&null!=LYe(e).fenceSync;var e})),yQe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>yQe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),yQe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),yQe.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>eCe()?1:-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),yQe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),yQe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),yQe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),yQe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),yQe.registerFlag("WEBGL_EXP_CONV",(()=>!1)),yQe.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>yQe.getBool("IS_TEST"))),yQe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),yQe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),yQe.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),yQe.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const SQe="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:IQe}=s;function CQe(e,t,n){const r=[];if(e.forEach((e=>{const t=Uve(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=OQe(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const a=r.join("\n"),s=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?TQe(e,r):NQe(e,r);const s=e.shapeInfo.logicalShape,i=t.logicalShape;s.length<=i.length&&(a+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=IQe(e.shapeInfo.logicalShape,t.logicalShape),l=FQe(i),u=i-s;let c;const d=["x","y","z","w","u","v"];c=0===s?"":i<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${d[e+u]} = 0;`)).join("\n");let h="";h=i<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+u]}`)).join(", ");let p="return outputValue;";const f=1===Uve(e.shapeInfo.logicalShape),m=Uve(t.logicalShape),g=1===m;if(1!==s||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=s-2,t=s-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${a}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&jve(i,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=FQe(l),c=IQe(e.shapeInfo.logicalShape,t.logicalShape),d=l-o;let h;const p=["x","y","z","w","u","v"];h=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+d]} = 0;`)).join("\n");let f="";f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+d]}`)).join(", ");return`\n    float ${a}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${f});\n    }\n  `}(e,t));return a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,o=bQe(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,d=function(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${EQe}\n    ${AQe}\n    ${_Qe}\n  `;return t}(o);t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return RQe();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(jve(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const a=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2);let i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function(e,t,n){switch(e.length){case 0:return RQe();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(jve(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${xQe(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=vQe(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${xQe(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=vQe(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=vQe(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=vQe(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(d+=$Qe);return[d,l,c,a,u,s,n.userCode].join("\n")}function NQe(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=DQe(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${MQe(e)}\n      }\n    `;const a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=DQe(n);if(1===i)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===s)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&jve(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=s[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=Qve(n),l=i;if(l.length<n.length){const n=["row","col"];return`\n      ${NQe(PQe(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${LQe(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${MQe(e)}\n      }\n    `;const u=s[0],c=s[1],d=DQe(r);if(1===c)return t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===u)return t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Qve(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${NQe(PQe(e,u),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${LQe(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${MQe(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=DQe(r);if(t)return`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=Qve(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${NQe(PQe(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${LQe(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${MQe(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===s&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=DQe(r);if(t)return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=Qve(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${NQe(PQe(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${LQe(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${a})) +\n          depth3;\n        ${MQe(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=DQe(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=Qve(t);if(a.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${NQe(PQe(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${LQe(t,s)});\n      }\n    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${MQe(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=DQe(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function TQe(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=bQe();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=bQe();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=bQe();if(null!=s&&jve(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=[1,2],s=["b","row","col"];return`\n        ${TQe(PQe(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${LQe(s,r)});\n        }\n      `}const o=bQe();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=bQe();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;const s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(s[i-1]/2);let h=d*Math.ceil(s[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=s[i-m-1],f=`b${m} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const EQe="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",AQe="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",_Qe="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$Qe="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function RQe(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function DQe(e){return`offset${e}`}function MQe(e){const t=e.name,n=Uve(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function FQe(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function OQe(e,t,n){const{newShape:r,keptDims:a}=Qve(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!jve(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function PQe(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function LQe(e,t){return t.map((t=>e[t])).join(", ")}function zQe(e,t,n,r){const a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=CQe(a,i,t),l=function(e,t){const n=rQe(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(HYe(e,(()=>e.shaderSource(n,t))),HYe(e,(()=>e.compileShader(n))),xxe().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw YYe(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),u=e.createProgram(l);return xxe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},BQe(e,t,u)))}function BQe(e,t,n){const r=[],a=[];let s,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===xxe().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const d of t.variableNames){const a={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${d}Shape`,c),a.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),r.push(a)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const d of t.customUniforms)a.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function WQe(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,a=t[n],s=a.shape;if(!jve(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;const i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!jve(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function VQe(e){return xxe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class UQe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=zYe.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=bQe();this.outputShape=e,this.enableShapeUniforms=VQe(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?xQe(["r","c","d"],e):vQe(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class jQe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=zYe.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=bQe();this.outputShape=e,this.enableShapeUniforms=VQe(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?xQe(["r","c","d"],e):vQe(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class GQe{constructor(e){this.variableNames=["A"],this.outTexUsage=BYe.DOWNLOAD;const t=bQe();this.outputShape=e,this.userCode=`\n      ${SQe}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class HQe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=BYe.DOWNLOAD;const t=bQe();this.outputShape=e,this.userCode=`\n      ${SQe}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const qQe={R:0,G:1,B:2,A:3};class KQe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=bQe();this.outputShape=e,this.enableShapeUniforms=VQe(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){const e=n[i];s+=`\n          if(offset == ${i}) {\n            result = values[${qQe[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kQe(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${s}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class XQe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=bQe();this.outputShape=e,this.enableShapeUniforms=VQe(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){const a=2*s+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kQe(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}}function YQe(e){const t=bQe();return function(e,t){const n=rQe(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(HYe(e,(()=>e.shaderSource(n,t))),HYe(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function QQe(e){return function(e,t){const n=rQe(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return HYe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),HYe(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function JQe(e){return function(e,t){const n=rQe(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return HYe(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),HYe(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function ZQe(e,t,n,r,a,s){!function(e,t){const n=xxe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return rQe(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return HYe(e,(()=>e.bindTexture(o,i))),HYe(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),HYe(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),HYe(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),HYe(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===xxe().getNumber("WEBGL_VERSION")?HYe(e,(()=>e.texImage2D(o,0,r,t,n,0,a,s,null))):HYe(e,(()=>e.texStorage2D(o,1,r,t,n))),HYe(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function eJe(e){return e.internalFormatFloat}function tJe(e){return e.internalFormatHalfFloat}function nJe(e){return e.downloadTextureFormat}function rJe(e){return e.internalFormatPackedFloat}function aJe(e){return e.internalFormatPackedHalfFloat}function sJe(e,t,n,r,a,s,i,o){const l=e,u=new Float32Array(function(e,t){const[n,r]=jYe(e,t);return n*r*4}(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}class iJe{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=xxe().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){OYe[e]=t}(t,e)):this.gl=LYe(t),e=this.gl,2===xxe().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>HYe(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>HYe(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>HYe(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>HYe(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>HYe(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>HYe(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>HYe(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>HYe(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===xxe().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=KYe(this.gl,e),hQe(this.gl,t))this.textureHalfFloatExtension=KYe(this.gl,t);else if(xxe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),hQe(this.gl,r))this.colorBufferHalfFloatExtension=KYe(this.gl,r);else if(xxe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",hQe(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!hQe(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=QQe(this.gl),this.indexBuffer=JQe(this.gl),this.framebuffer=function(e){return rQe(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=GYe(this.gl,this.textureHalfFloatExtension)}get debug(){return xxe().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;HYe(e,(()=>e.finish())),HYe(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),HYe(e,(()=>e.deleteFramebuffer(this.framebuffer))),HYe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),HYe(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),HYe(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=VYe(t,n);return ZQe(e,a,s,eJe(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=VYe(t,n);return ZQe(e,a,s,tJe(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=VYe(t,n);return ZQe(e,a,s,nJe(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){HYe(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===xxe().getNumber("WEBGL_VERSION")?HYe(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):HYe(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===xxe().getNumber("WEBGL_VERSION")?HYe(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):HYe(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),HYe(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,a,s){let i,o,l;HYe(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===xxe().getNumber("WEBGL_VERSION")?HYe(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):HYe(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),HYe(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=jYe(t,n);return ZQe(e,a,s,aJe(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=jYe(t,n);return ZQe(e,a,s,rJe(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(tQe(this.gl,this.framebuffer),this.outputTexture=null),HYe(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[a,s]=VYe(t,n),i=new Uint8Array(t*n*4);return HYe(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return sJe(this.gl,e,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();HYe(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const a=16*t*n;return HYe(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ))),HYe(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),HYe(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(xxe().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return HYe(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=YQe(t));const n=function(e){return rQe(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);HYe(t,(()=>t.attachShader(n,this.vertexShader))),HYe(t,(()=>t.attachShader(n,e))),function(e,t){if(HYe(e,(()=>e.linkProgram(t))),!xxe().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&QYe(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;HYe(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){HYe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),JYe(e,t,"clipSpacePos",n,3,20,0)&&JYe(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(HYe(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&QYe(this.gl,this.program),HYe(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return rQe(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),HYe(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),ZYe(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=jYe(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&QYe(this.gl,this.program),nQe(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}HYe(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),HYe(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=KYe(this.gl,2===xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Kve((()=>this.disposed||this.isQueryAvailable(e,xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in xxe().platform&&(n=xxe().platform.setTimeoutCustom.bind(xxe().platform)),Kve((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),eQe(this.gl,e,this.framebuffer),this.debug&&nQe(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(eQe(this.gl,this.outputTexture,this.framebuffer),this.debug&&nQe(this.gl)):tQe(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;eQe(r,e,this.framebuffer),this.debug&&nQe(r),this.outputTexture=e,HYe(r,(()=>r.viewport(0,0,t,n))),HYe(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),HYe(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:oJe,XI:lJe,Nk:uJe,f6:cJe,ct:dJe,YG:hJe,hH:pJe,z3:fJe,sG:mJe,uM:gJe,vS:yJe,qB:bJe,GG:vJe,rq:xJe,lg:wJe,WR:kJe,cu:SJe,GE:IJe,px:CJe,jC:NJe,He:TJe,hE:EJe,BF:AJe,Dk:_Je,cl:$Je,_B:RJe,ub:DJe,_f:MJe,Ku:FJe,qy:OJe,Zy:PJe,bu:LJe,zv:zJe,dH:BJe,HS:WJe,yH:VJe,l3:UJe,z9:jJe,x6:GJe,_m:HJe,eW:qJe,GK:KJe,SP:XJe,yr:YJe,dl:QJe,Dw:JJe,xT:ZJe,_X:eZe,wz:tZe}=N;function nZe(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function rZe(e,t){return 1===t?[e]:nZe(e,t)}class aZe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=VQe(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=rZe("rc",this.rank),t=FQe(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class sZe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=VQe(this.outputShape.length);let n="";for(let s=0;s<4;s++){let e="thisRC = rc;";s%2===1&&(e+="thisRC.z += 1;"),s>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}var r,a;this.userCode=`\n      ${r=t,a=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${a?wQe(["r","c","d"],"inputShape"):vQe(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kQe(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class iZe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=lZe(t,n),a=uZe(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const s=oZe(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}let i;return r===WYe.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===WYe.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===WYe.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===WYe.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===WYe.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const a=lZe(n,r),s=uZe(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);const i=oZe(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=xxe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[s],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function oZe(e,t,n,r,a){const s=function(e,t){switch(e){case WYe.PACKED_2X2_FLOAT32:return rJe(t);case WYe.PACKED_2X2_FLOAT16:return aJe(t);case WYe.UNPACKED_FLOAT32:return eJe(t);case WYe.UNPACKED_FLOAT16:return tJe(t);case WYe.PACKED_4X1_UNSIGNED_BYTE:return nJe(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(a){const[t,n]=jYe(e[0],e[1]);i=t*n}else{const[t,n]=VYe(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,s);return i*o}function lZe(e,t){if(e===BYe.UPLOAD)return WYe.PACKED_2X2_FLOAT32;if(e===BYe.RENDER||null==e)return function(e){return xxe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?WYe.PACKED_2X2_FLOAT32:WYe.UNPACKED_FLOAT32:e?WYe.PACKED_2X2_FLOAT16:WYe.UNPACKED_FLOAT16}(t);if(e===BYe.DOWNLOAD||e===BYe.PIXELS)return WYe.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function uZe(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class cZe{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=VQe(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const dZe="if (isnan(x)) return x;",hZe="return x;",pZe="return abs(x);";const fZe="return (x >= 0.0) ? x : (exp(x) - 1.0);",mZe=dZe+"\n  return (x < 0.0) ? 0.0 : x;\n",gZe=dZe+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",yZe="return x;",bZe="return 1.0 / (1.0 + exp(-1.0 * x));",vZe="return x;",xZe="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",wZe="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",kZe="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",SZe="return 1.0 / (1.0 + exp(-1.0 * x));";class IZe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=VQe(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class CZe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=VQe(this.outputShape.length);const t=e.length,n=rZe("rc",t),r=FQe(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const NZe=U$e,TZe={};const EZe=xxe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class AZe extends Mve{nextDataId(){return AZe.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!xxe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof iJe)t=e;else{const n=LYe(xxe().getNumber("WEBGL_VERSION"),e);t=new iJe(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=LYe(xxe().getNumber("WEBGL_VERSION"));t=new iJe(e),this.binaryCache=((n=xxe().getNumber("WEBGL_VERSION"))in TZe||(TZe[n]={}),TZe[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new iZe(this.gpgpu),this.numMBBeforeWarning=null==xxe().global.screen?1024:xxe().global.screen.height*xxe().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Dve(this,mCe())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,s){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];const l=oQe(t),u=new KQe(l,!1,s),c=this.runWebGLProgram(u,[i],n,[[r,a]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((xxe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||xxe().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:BYe.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if(xxe().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:BYe.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new IZe(i,yZe):new cZe(i,yZe);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=uIe()),"complex64"===r){c=VDe(this.readSync(a.real.dataId),this.readSync(a.imag.dataId))}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=uIe()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=a){let t;t=o?new IZe(r,yZe):new cZe(r,yZe);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(xxe().getBool("DEBUG")&&!xxe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===xxe().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==s&&xxe().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...UYe(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);u=VDe(e[0],e[1])}else if(null==c)u=this.getValuesFromTexture(e);else{const e=Uve(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;HYe(e,(()=>e.deleteBuffer(c)))}const d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&mCe().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new IZe(a,yZe):new cZe(a,yZe);const r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=mCe().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>hIe(e)));return CNe(e.shape,e.dtype,n)}catch(eL){throw new Error("Failed to decode encoded string bytes into utf-8")}return CNe(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!qYe(n)){if(xxe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=Uve(t);if(xxe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...UYe(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}const s=xxe().getBool("WEBGL_PACK")&&!0===r,i=s?oQe(t):t,o=s?new HQe(i):new GQe(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=fIe(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=fIe(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(a);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:uIe(),endMs:null}}endTimer(e){return xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=uIe(),e)}async getQueryTime(e){if(xxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:EZe;return xxe().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Uve(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){OSe("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return NZe(e.shape,t)}packedUnaryOp(e,t,n){const r=new IZe(e.shape,t),a=this.compileAndRun(r,[e],n);return mCe().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=BJe(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(xxe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,pZe,e.dtype);const t=new cZe(e.shape,pZe),n=this.compileAndRun(t,[e]);return mCe().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&nxe(n[0])){const a=n.map((e=>dIe(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return mCe().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new CZe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new aZe(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[sQe(e.shape),...iQe(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[sQe(t),...iQe(t)],s=new sZe(a,n),i=[n],o=this.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){Bve(Uve(a)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=oQe(a);let o;o=r?new jQe(i):new UQe(i);const l=[null!=t?t:UYe(i)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(o,[{shape:i,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0;const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===zYe.DENSE){const t=null!=s?s:UYe(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Uve(i.shape))return o.values=Jve(i.dtype,0),i;const l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Uve(t.shape)<=xxe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!uQe(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},d=function(e,t,n){let r="";t.concat(n).forEach((t=>{const a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=OQe(e.packedInputs,t.shape,s);let u="",c="",d="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=oxe(o);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const h=t.shape.length,p=2===o.length&&jve(t.shape,s),f=1===Uve(t.shape),m=QNe(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&jve(s,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${h}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${d}_${y}_${a}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));const a=e.userCode;let s=e.constructor.name;return s+="_"+r+"_"+a+`${xxe().getNumber("WEBGL_VERSION")}`,s}(e,u,c),h=this.getAndSaveBinary(d,(()=>zQe(this.gpgpu,e,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),xxe().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(WQe(t.inShapeInfos,n),WQe([t.outShapeInfo],[r]));const s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===xxe().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const r=n[l],{uniform:a,offset:s,shape:i,texShape:o}=t.variablesLocations[l];if(i){const{uniformShape:n}=OQe(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=a)if(r.isUniform)if(Uve(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=r.texData.slice&&null!=s&&e.gl.uniform1i(s,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,l)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=oxe(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){const n=t.program.customUniforms[l],r=t.customUniformLocations[l],s=a[l];if("float"===n.type)e.gl.uniform1fv(r,s);else if("vec2"===n.type)e.gl.uniform2fv(r,s);else if("vec3"===n.type)e.gl.uniform3fv(r,s);else if("vec4"===n.type)e.gl.uniform4fv(r,s);else if("int"===n.type)e.gl.uniform1iv(r,s);else if("ivec2"===n.type)e.gl.uniform2iv(r,s);else if("ivec3"===n.type)e.gl.uniform3iv(r,s);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,s)}}e.executeProgram()}(this.gpgpu,h,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=xxe().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=uIe();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!xxe().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!xxe().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=yCe((()=>{if(!xxe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=xxe().getBool("DEBUG");xxe().set("DEBUG",!1);const t=this.abs(PNe(1e-8)).dataSync()[0];if(xxe().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;const l=null!=this.activeTimers;let u;l&&(u=uIe());let c=t.texShape;if(null==c&&(c=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=xxe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=xxe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&xxe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?Lve(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=Qve(e);e=t.newShape}let a=Uve(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);const i=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){const t=sQe(e);let n=2,r=2;e.length&&([n,r]=iQe(e)),a=t*(n/2)*(r/2),s=Hve(a).map((e=>2*e))}else s=Hve(a);return s}(n,o),t.texShape=c),null!=a){const e=oQe(n);let s,i=c[1],d=c[0];const h=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!o&&h||([i,d]=jYe(c[0],c[1])),s=o?new XQe(e,h):new KQe(e,h);const p=h?[d,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=h?BYe.PIXELS:BYe.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,a);const g=[[d,i]],y=!0,b=this.runWebGLProgram(s,[f],r,g,y),v=this.texData.get(b.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,xxe().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=uIe()-u)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*txe(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await yDe(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw YYe(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=BQe(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:a,width:s,channels:i}=e,o=mCe().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=o.writeTexture(r,t,n,a,s,i);return mCe().makeTensorFromDataId(l,t,n,o)}}AZe.nextDataId=0;tCe()&&wCe("webgl",(()=>new AZe),2);const _Ze="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class $Ze{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=ZNe(t,n),this.enableShapeUniforms=VQe(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const RZe="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class DZe{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ZNe(t,n);const a=this.outputShape.length;this.enableShapeUniforms=VQe(a);let s="";if(r)if(0===a||1===Uve(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(s=`\n          ${FQe(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=rZe("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function MZe(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const FZe={kernelName:Bwe,backendName:"webgl",kernelFunc:MZe};function OZe(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=MZe({inputs:{x:r},backend:n}),l=MZe({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}const PZe={kernelName:Qxe,backendName:"webgl",kernelFunc:OZe},LZe="return (a < 0.) ? b * a : a;",zZe="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const BZe={kernelName:Hwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",oIe(s,"float32")),o=xxe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new DZe(zZe,a.shape,i.shape):new $Ze(LZe,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},WZe="return (a < 0.) ? b * a : a;",VZe="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const UZe={kernelName:Tke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=xxe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new DZe(VZe,r.shape,a.shape):new $Ze(WZe,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},jZe="if (isnan(x)) return x;";function GZe(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=e;return e=>{let{inputs:s,backend:i}=e;const{x:o}=s,l=i,u=a||o.dtype;if(l.shouldExecuteOnCPU([o])&&null!=r){const e=l.texData.get(o.dataId),t=r(e.values,u);return l.makeTensorInfo(o.shape,u,t)}let c;return c=xxe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new IZe(o.shape,n):new cZe(o.shape,t),l.runWebGLProgram(c,[o],u)}}function HZe(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:s,dtype:i}=e;return e=>{let{inputs:o,backend:l}=e;const{a:u,b:c}=o,d=l;if(a&&"complex64"===u.dtype){const e=d.texData.get(u.dataId),n=d.texData.get(c.dataId),[r,a]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,a={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:r.dataId,dtype:r.dtype,shape:c.shape},i=new $Ze(t,u.shape,c.shape);return d.runWebGLProgram(i,[a,s],zIe(n.dtype,r.dtype))})),s=OZe({inputs:{real:r,imag:a},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(a),s}const h=i||zIe(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=s){const e=d.texData.get(u.dataId).values,t=d.texData.get(c.dataId).values,n="string"===u.dtype?kMe(e):e,r="string"===u.dtype?kMe(t):t,[a,i]=s(u.shape,c.shape,n,r,h),o=d.makeTensorInfo(i,h);return d.texData.get(o.dataId).values=a,o}let p;return p=xxe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new DZe(n,u.shape,c.shape,r):new $Ze(t,u.shape,c.shape),d.runWebGLProgram(p,[u,c],h)}}function qZe(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?vZe:hZe;if("relu"===e)return t?wZe:mZe;if("elu"===e)return t?xZe:fZe;if("relu6"===e)return t?kZe:gZe;if("prelu"===e)return t?VZe:WZe;if("leakyrelu"===e)return t?zZe:LZe;if("sigmoid"===e)return t?SZe:bZe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class KZe{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=VQe(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const XZe={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class YZe{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ZNe(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const QZe="return a * b;";function JZe(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=zIe(r.dtype,a.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),s=new YZe(XZe.REAL,r.shape,a.shape),i=new YZe(XZe.IMAG,r.shape,a.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:a.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:a.shape}],l=n.runWebGLProgram(s,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=OZe({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,a])){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),[i,o]=AJe(r.shape,a.shape,e.values,t.values,s),l=n.makeTensorInfo(o,s);return n.texData.get(l.dataId).values=i,l}let i;return i=xxe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new DZe(QZe,r.shape,a.shape):new $Ze(QZe,r.shape,a.shape),n.runWebGLProgram(i,[r,a],s)}const ZZe={kernelName:gke,backendName:"webgl",kernelFunc:JZe};function e0e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=Uve(a.shape),l=Xve(s,o),u=Uve(l);Bve(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=i.texData.get(a.dataId);return!c.isPacked||uQe(a.shape,l)||null!==c.texture&&uQe(c.shape,l)?(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){const r=[sQe(e.shape),...iQe(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[sQe(t),...iQe(t)],i=new sZe(s,r),o=[r],l=n.runWebGLProgram(i,[a],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(a,l,i)}const t0e={kernelName:Oke,backendName:"webgl",kernelFunc:e0e};class n0e{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${Gve(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class r0e{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}}function a0e(e,t,n,r){const a=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=NDe(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let s=e;for(let i=0;i<a.length;i++){const{inSize:o,windowSize:l,outSize:u}=a[i];let c,d;c="mean"===n?0===i?new n0e({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new n0e({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new r0e({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=s,s=r.runWebGLProgram(c,[s],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return s}class s0e{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;const r=FQe(this.rank),a=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}class i0e{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=FQe(this.rank),a=nZe("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];const i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function o0e(e,t,n){const r=xxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new i0e(e.shape,t):new s0e(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function l0e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return function(e,t,n,r){const a=t,s=e.shape.length,i=Yve(a,e.shape);let o=i;const l=wAe(o,s),u=null!=l;let c=e;u&&(c=o0e(e,l,r),o=SAe(o.length,s)),xAe("sum",o,s);const[d,h]=bAe(c.shape,o);let p=d;n&&(p=vAe(d,i));const f=Uve(h),m=e0e({inputs:{x:c},attrs:{shape:[Uve(e.shape)/f,f]},backend:r}),g=a0e(m,BIe(e.dtype),"sum",r),y=e0e({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),y}(a,s,i,n)}const u0e={kernelName:rSe,backendName:"webgl",kernelFunc:l0e};function c0e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,i=n,o=a.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=a.shape[s[c]];let u;if(i.shouldExecuteOnCPU([a])){const e=i.texData.get(a.dataId).values,t=eZe(e,a.shape,a.dtype,s,l);u=i.makeTensorInfo(l,a.dtype);i.texData.get(u.dataId).values=t}else u=o0e(a,s,i);return u}const d0e={kernelName:CSe,backendName:"webgl",kernelFunc:c0e},h0e=1e3;function p0e(e){let{a:t,b:n,transposeA:r,transposeB:a,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e;const c=t.shape.length,d=n.shape.length,h=r?t.shape[c-2]:t.shape[c-1],p=a?n.shape[d-1]:n.shape[d-2],f=r?t.shape[c-1]:t.shape[c-2],m=a?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=Uve(g),v=Uve(y),x=ZNe(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);Bve(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${a} must match.`));const w=r?[b,h,f]:[b,f,h],k=a?[v,m,p]:[v,p,m],S=e0e({inputs:{x:t},backend:s,attrs:{shape:w}}),I=e0e({inputs:{x:n},backend:s,attrs:{shape:k}}),C=[S,I],N=Math.max(b,v),T=r?S.shape[1]:S.shape[2],E=null!=i,A=null!=o,_="leakyrelu"===u,$=null!=u?qZe(u,!0):null;let R;if((1===f||1===m)&&T>h0e&&!1===(E||A||_||null!=$)){let e=S,t=I;r&&(e=c0e({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),C.push(e)),a&&(t=c0e({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),C.push(t));const n=1===m;let i=e;1!==m&&(i=e0e({inputs:{x:e},backend:s,attrs:{shape:[N,T,1]}}),C.push(i));const o=1===m?2:1;let l=t;n&&(l=e0e({inputs:{x:t},backend:s,attrs:{shape:[N,1,T]}}),C.push(l));const u=JZe({inputs:{a:i,b:l},backend:s});R=l0e({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),C.push(u)}else{const e=zIe(t.dtype,n.dtype),u=new KZe(w,k,[N,f,m],r,a,E,$,A,_),c=[S,I];if(null!=i&&c.push(i),A&&c.push(o),_){const e=s.makeTensorInfo([],"float32",oIe(l,"float32"));c.push(e),C.push(e)}R=s.runWebGLProgram(u,c,e)}const D=e0e({inputs:{x:R},backend:s,attrs:{shape:x}});C.push(R);for(const M of C)s.disposeIntermediateTensorInfo(M);return D}const f0e={kernelName:DSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return p0e({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},m0e="return abs(x);";const g0e={kernelName:Cxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=BJe(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let a;return a=xxe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new IZe(r.shape,m0e):new cZe(r.shape,m0e),n.runWebGLProgram(a,[r],r.dtype)}},y0e=GZe({opSnippet:dZe+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),b0e={kernelName:Nxe,backendName:"webgl",kernelFunc:y0e},v0e=GZe({opSnippet:dZe+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),x0e={kernelName:Txe,backendName:"webgl",kernelFunc:v0e},w0e="return a + b;",k0e=HZe({opSnippet:w0e,packedOpSnippet:w0e,supportsComplex:!0,cpuKernelImpl:oJe}),S0e={kernelName:Exe,backendName:"webgl",kernelFunc:k0e};class I0e{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class C0e{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const N0e={kernelName:Axe,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,a=n;if(1===a.length)return MZe({inputs:{x:a[0]},backend:r});if(a.length>xxe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),s=e({inputs:a.slice(t),backend:r});return e({inputs:[n,s],backend:r})}const s=a.map((e=>e.dtype)).reduce(((e,t)=>zIe(e,t))),i=a.map((e=>e.shape)),o=xxe().getBool("WEBGL_PACK")?new C0e(a[0].shape,i):new I0e(a[0].shape,i);return r.runWebGLProgram(o,a,s)}};const T0e={kernelName:_xe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Yve(s,a.shape);let u=l;const c=wAe(u,o);let d=a;null!=c&&(d=c0e({inputs:{x:a},backend:n,attrs:{perm:c}}),u=SAe(u.length,o)),xAe("all",u,o);const[h,p]=bAe(d.shape,u),f=e0e({inputs:{x:d},backend:n,attrs:{shape:[-1,Uve(p)]}}),m=a0e(f,f.dtype,"all",n);let g;if(i){g=e0e({inputs:{x:m},backend:n,attrs:{shape:vAe(h,l)}})}else g=e0e({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};const E0e={kernelName:$xe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Yve(s,a.shape);let u=l;const c=wAe(u,o);let d=a;null!=c&&(d=c0e({inputs:{x:a},backend:n,attrs:{perm:c}}),u=SAe(u.length,o)),xAe("any",u,o);const[h,p]=bAe(d.shape,u),f=e0e({inputs:{x:d},backend:n,attrs:{shape:[-1,Uve(p)]}}),m=a0e(f,f.dtype,"any",n);let g;if(i){g=e0e({inputs:{x:m},backend:n,attrs:{shape:vAe(h,l)}})}else g=e0e({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};class A0e{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class _0e{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Bve(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,l=FQe(o),u=rZe("coords",o);let c,d;if(1===s){d=o+1;const e=FQe(d);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else d=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),m=rZe("sourceLocR",d-1).concat("inIdx.r"),g=rZe("sourceLocG",d-1).concat("inIdx.g"),y=rZe("sourceLocB",d-1).concat("inIdx.b"),b=rZe("sourceLocA",d-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function $0e(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);const i=NDe(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new A0e(o,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=$0e(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function R0e(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const a=null!=r?r.shape:t.shape,s=NDe(a[a.length-1]),i=new _0e(a,s,n,null==r),o=null==r?[t]:[t,r],l=e.runWebGLProgram(i,o,"int32");if(l.shape.length===t.shape.length){const r=R0e(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function D0e(e,t,n,r){const a=[n];if(xAe("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!xxe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId);let i=t;null!==s&&s.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,l]=bAe(i.shape,a),u=Uve(l),c=e0e({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);const d=$0e(e,c,r);n.push(d);const h=e0e({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return R0e(e,t,r)}const M0e={kernelName:Rxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let i=Yve(s,a.shape);const o=wAe(i,a.shape.length);let l=a;const u=[];null!=o&&(l=c0e({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=SAe(i.length,l.shape.length)),xAe("argMax",[i[0]],l.shape.length);const c=D0e(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};const F0e={kernelName:Dxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let i=Yve(s,a.shape);const o=wAe(i,a.shape.length);let l=a;const u=[];null!=o&&(l=c0e({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=SAe(i.length,l.shape.length)),xAe("argMin",[i[0]],l.shape.length);const c=D0e(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},O0e=GZe({opSnippet:dZe+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),P0e={kernelName:Mxe,backendName:"webgl",kernelFunc:O0e},L0e=GZe({opSnippet:dZe+"return log(x + sqrt(x * x + 1.0));"}),z0e={kernelName:Fxe,backendName:"webgl",kernelFunc:L0e},B0e=GZe({opSnippet:dZe+"\n  return atan(x);\n"}),W0e={kernelName:Oxe,backendName:"webgl",kernelFunc:B0e},V0e=HZe({opSnippet:_Ze+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+RZe+"\n  return result;\n"}),U0e={kernelName:Lxe,backendName:"webgl",kernelFunc:V0e},j0e=GZe({opSnippet:dZe+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),G0e={kernelName:Pxe,backendName:"webgl",kernelFunc:j0e};class H0e{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");const v=4*Math.floor(s/4),x=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class q0e{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(s/4),k=s%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}}const K0e={kernelName:zxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;gQe(a,"avgPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Bve(bEe(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=lEe(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&jve(u.inShape,u.outShape))return MZe({inputs:{x:a},backend:n});const c=new H0e(u,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}};const X0e={kernelName:Wxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=uEe(a.shape,s,i,[1,1,1],o,l,u),d=new q0e(c,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}};class Y0e{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Q0e{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const J0e={kernelName:Vxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=uEe(i.shape,o,l,[1,1,1],u,c),h=new Q0e(d);return n.runWebGLProgram(h,[a],i.dtype)}};const Z0e={kernelName:Bxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;gQe([a,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=lEe(i.shape,o,l,1,u),d=new Y0e(c);return n.runWebGLProgram(d,[a],i.dtype)}};const e1e={kernelName:Uxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;return p0e({a:a,b:s,transposeA:i,transposeB:o,backend:n})}};class t1e{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],ZNe(e,t),ZNe(e,n);let i="0.0";null!=r&&(ZNe(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(ZNe(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class n1e{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ZNe(e,t),ZNe(e,n);let i="vec4(0.0)";null!=r&&(ZNe(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(ZNe(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const r1e={kernelName:Fwe,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,mean:s,variance:i,offset:o,scale:l}=t;Bve(s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Bve(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Bve(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=[a,s,i];let d=null;null!=o&&(d=o.shape,c.push(o));let h=null;null!=l&&(h=l.shape,c.push(l));const p=xxe().getBool("WEBGL_PACK_NORMALIZATION")?new n1e(a.shape,s.shape,i.shape,d,h,u):new t1e(a.shape,s.shape,i.shape,d,h,u);return n.runWebGLProgram(p,c,c[0].dtype)}};class a1e{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=FQe(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return s1e.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${s1e[t]} = start[${t}] + coords.${s1e[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const s1e=["x","y","z","w","u","v"];class i1e{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=FQe(this.rank),n=rZe("coords",this.rank),r=rZe("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function o1e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=HTe(a,s,i);if(RTe(a,o,l),0===Uve(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.texData.get(a.dataId),t=WJe(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}const{isPacked:u}=n.texData.get(a.dataId),c=jTe(a.shape,o,l);if(u||!c){const e=xxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new i1e(l):new a1e(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){const a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=GTe(t,oxe(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}(a,o,l,n)}const l1e={kernelName:Yke,backendName:"webgl",kernelFunc:o1e},u1e={kernelName:jxe,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;Bve(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((e,t)=>e*t)),l=EDe(a.shape,s,o),u=ADe(l.length,s.length),c=_De(a.shape,s,o),d=$De(i,s.length),h=RDe(c,i,s.length),p=[],f=e0e({inputs:{x:a},backend:n,attrs:{shape:l}}),m=c0e({inputs:{x:f},backend:n,attrs:{perm:u}}),g=e0e({inputs:{x:m},backend:n,attrs:{shape:c}}),y=o1e({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const c1e={kernelName:Gxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=lJe(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}};const d1e={kernelName:Hxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=xxe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=xxe().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(a.dataId).values,[s,i]=cJe(r.shape,a.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=s,o}let o;return o=s?new DZe("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,a.shape,!1):new $Ze("\n  return float(int(a.r) & int(b.r));\n",r.shape,a.shape),n.runWebGLProgram(o,[r,a],r.dtype)}};const h1e={kernelName:qxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=ZNe(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},p1e=HZe({opSnippet:"return float(a != b);",cpuKernelImpl:$Je,dtype:"bool"}),f1e={kernelName:bke,backendName:"webgl",kernelFunc:p1e};function m1e(e){const{inputs:t,backend:n}=e,{input:r}=t;return MZe({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const g1e={kernelName:Dke,backendName:"webgl",kernelFunc:m1e},y1e="return float(int(x));";const b1e={kernelName:Kxe,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:i}=a;if("complex64"===i){if("complex64"===s.dtype)return MZe({inputs:{x:s},backend:r});const t=h_e(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=OZe({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){const t=m1e({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!exe(s.dtype,i)){const e=MZe({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([s])){const e=r.texData.get(s.dataId).values,[t,n,a]=dJe(e,s.shape,s.dtype,i);return r.makeTensorInfo(t,n,a)}if("int32"===i)return function(e,t){const n=new cZe(e.shape,y1e),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",Jve("bool",1)),t=p1e({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},v1e="return ceil(x);",x1e=GZe({opSnippet:v1e,packedOpSnippet:v1e,cpuKernelImpl:hJe}),w1e={kernelName:Xxe,backendName:"webgl",kernelFunc:x1e};class k1e{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class S1e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const I1e={kernelName:Yxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r;let o;o=xxe().getBool("WEBGL_PACK_CLIP")?new S1e(a.shape):new k1e(a.shape);const l=[[s],[i]];return n.runWebGLProgram(o,[a],a.dtype,l)}};class C1e{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function N1e(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const T1e={kernelName:Jxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new C1e(r.shape),i=[N1e(r,a.complexTensorInfos.real),N1e(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}};class E1e{constructor(e){this.outputShape=[],this.outputShape=vDe(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){const e=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${e}));`)}const r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class A1e{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=vDe(e,t);const n=this.outputShape,r=n.length,a=FQe(r),s=rZe("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const l=i[t],u=i.slice(-2),c=i.join();let d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){const e=o[f-1];d+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${_1e(i,l,e)}),\n            vec2(${_1e(u,l,e)}));\n        }`}const h=o.length,p=o[o.length-1];d+=`\n        return getChannel(\n          getT${h}(${_1e(i,l,p)}),\n          vec2(${_1e(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function _1e(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function $1e(e){const{inputs:t,backend:n}=e,{input:r}=t;return MZe({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const R1e={kernelName:Vwe,backendName:"webgl",kernelFunc:$1e};function D1e(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>m1e({inputs:{input:e},backend:n}))),a=e.map((e=>$1e({inputs:{input:e},backend:n}))),s=D1e(r,t,n),i=D1e(a,t,n),o=OZe({inputs:{real:s,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const r=Uve(e.shape.slice(t));return e0e({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=vDe(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=pJe(s,i,r,o),u=vDe(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const s=e.filter((e=>Uve(e.shape)>0)),i=xxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const t=i?new cZe(e[0].shape,yZe):new IZe(e[0].shape,yZe);return n.runWebGLProgram(t,e,r)}const o=xxe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){const e=[];for(let a=0;a<s.length;a+=o){const r=s.slice(a,a+o);e.push(D1e(r,t,n))}const r=D1e(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new A1e(s.map((e=>e.shape)),t);return n.runWebGLProgram(e,s,r)}const{tensors2D:l,outShape:u}=function(e,t,n){const r=vDe(e.map((e=>e.shape)),t),a=e.map((e=>e0e({inputs:{x:e},attrs:{shape:[-1,Uve(e.shape.slice(t))]},backend:n})));return{tensors2D:a,outShape:r}}(s,t,n),c=new E1e(l.map((e=>e.shape))),d=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const h=e0e({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function M1e(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Yve(a,t[0].shape)[0];bDe(t.map((e=>e.shape)),s);const i=vDe(t.map((e=>e.shape)),s);if(0===Uve(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Uve(e.shape)>0));return 1===o.length?MZe({inputs:{x:o[0]},backend:n}):D1e(o,s,n)}const F1e={kernelName:Zxe,backendName:"webgl",kernelFunc:M1e};class O1e{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}}class P1e{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class L1e{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=VQe(this.outputShape.length);const s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)d+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){const t=2*m;if(d+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,d+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){const e=s%2===0?Lve(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,d+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):d+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(d+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(d+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(d+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class z1e{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=VQe(this.outputShape.length);const{dataFormat:n}=t,r=bQe(),a="channelsLast"===n,s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function B1e(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function W1e(e){let{x:t,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const u=t.shape,c=a.texData.get(t.dataId),d=r.inChannels,h=u[0]*u[1]*u[2],p=r.outChannels,f="channelsLast"===r.dataFormat,m=!1;let g;const y=[];if(null!=i){const e=B1e(i.shape,f);null!=e&&(i=e0e({inputs:{x:i},backend:a,attrs:{shape:e}}),y.push(i))}if(null!=s){const e=B1e(s.shape,f);null!=e&&(s=e0e({inputs:{x:s},backend:a,attrs:{shape:e}}),y.push(s))}if(!((1===h||1===p)&&d>h0e)&&c.isPacked&&f&&null!=c.texture&&u[2]%2!==0&&jve(c.shape.slice(-3),u.slice(-3))){const e=u[0]*u[1]*(u[2]+1),d={dataId:t.dataId,shape:[1,e,r.inChannels],dtype:t.dtype},h=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,Bve(uQe(c.shape,d.shape),(()=>`packed reshape ${c.shape} to ${d.shape} isn't free`));const p=e0e({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}});y.push(p);const f=p0e({a:d,b:p,backend:a,transposeA:false,transposeB:m,bias:s,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),b=a.texData.get(f.dataId);Bve(b.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=h,b.shape=r.outShape,g=MZe({inputs:{x:f},backend:a}),g.shape=r.outShape,y.push(f)}else{const e=r.outHeight*r.outWidth,u=e0e({inputs:{x:t},backend:a,attrs:{shape:f?[r.batchSize,e,r.inChannels]:[r.batchSize,r.inChannels,e]}}),c=e0e({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}}),d=p0e({a:f?u:c,b:f?c:u,transposeA:!f,transposeB:m,backend:a,bias:s,activation:l,preluActivationWeights:i,leakyreluAlpha:o});g=e0e({inputs:{x:d},backend:a,attrs:{shape:r.outShape}}),y.push(u),y.push(c),y.push(d)}for(const b of y)a.disposeIntermediateTensorInfo(b);return g}function V1e(e){let{x:t,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const{filterWidth:u,filterHeight:c,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=u*c*d,y=p*h,b=[r.batchSize,g,y],v=[];if(null!=i){const e=B1e(i.shape,m);null!=e&&(i=e0e({inputs:{x:i},backend:a,attrs:{shape:e}}),v.push(i))}if(null!=s){const e=B1e(s.shape,m);null!=e&&(s=e0e({inputs:{x:s},backend:a,attrs:{shape:e}}),v.push(s))}const x=e0e({inputs:{x:n},backend:a,attrs:{shape:[1,g,Uve(n.shape)/g]}});v.push(x);const w=new z1e(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(w,[t],"float32",k),I=e0e({inputs:{x:S},backend:a,attrs:{shape:b}});v.push(S),v.push(I);const C=null!=s,N=null!=i,T="leakyrelu"===l,E=l?qZe(l,!0):null,A=new KZe(m?I.shape:x.shape,m?x.shape:I.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,C,E,N,T),_=m?[I,x]:[x,I];if(s&&_.push(s),N&&_.push(i),T){const e=a.makeTensorInfo([],"float32",oIe(o,"float32"));_.push(e),v.push(e)}const $=a.runWebGLProgram(A,_,"float32"),R=e0e({inputs:{x:$},backend:a,attrs:{shape:r.outShape}});v.push($);for(const D of v)a.disposeIntermediateTensorInfo(D);return R}const U1e={kernelName:ewe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=xEe(l),h=cEe(a.shape,s.shape,i,u,o,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&xxe().getBool("WEBGL_EXP_CONV")){const e=new L1e(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[a,s],"float32",t)}else if(xxe().getBool("WEBGL_CONV_IM2COL"))p=V1e({x:a,filter:s,convInfo:h,backend:n});else{const e=new O1e(h);p=n.runWebGLProgram(e,[a,s],"float32")}else p=W1e({x:a,filter:s,convInfo:h,backend:n});const f=e0e({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class j1e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class G1e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class H1e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class q1e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const K1e={kernelName:twe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=xEe(l),h=cEe(a.shape,c,i,1,o,u,!1,d),p=new j1e(h);return n.runWebGLProgram(p,[a,s],"float32")}};class X1e{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=VQe(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const Y1e={kernelName:nwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=xEe(u),h=cEe(i,s.shape,o,1,l,c,!1,d);if(xxe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new X1e(h);return n.runWebGLProgram(t,[a,s],"float32",e)}{const e=new G1e(h);return n.runWebGLProgram(e,[a,s],"float32")}}};const Q1e={kernelName:rwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=dEe(a.shape,s.shape,i,l,o),c=new P1e(u);return n.runWebGLProgram(c,[a,s],"float32")}};const J1e={kernelName:awe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=dEe(a.shape,l,i,1,o),c=new H1e(u);return n.runWebGLProgram(c,[a,s],"float32")}};const Z1e={kernelName:swe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=dEe(l,s.shape,o,1,i),c=new q1e(u);return n.runWebGLProgram(c,[a,s],"float32")}},e2e=GZe({opSnippet:jZe+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${RZe}\n  return result;\n`}),t2e={kernelName:iwe,backendName:"webgl",kernelFunc:e2e},n2e=GZe({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),r2e={kernelName:owe,backendName:"webgl",kernelFunc:n2e};class a2e{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];const h="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,x]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const s2e={kernelName:cwe,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new a2e(a.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[a,s,i],"float32")}};var i2e;!function(e){e.Prod="*",e.Sum="+"}(i2e||(i2e={}));class o2e{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,s=this.op===i2e.Prod?"1.0":"0.0",i=n?s:`getX(${l2e(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${FQe(a)} coords = getOutputCoords();\n        int end = ${u2e(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${u2e(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${l2e(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function l2e(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function u2e(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function c2e(e,t,n,r,a,s){const i=t.shape.length,o=wAe([r],i);let l=t;null!=o&&(l=c0e({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=SAe(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=MZe({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const t=new o2e(e,l.shape,!1,s),r=[[h]],a=d;d=n.runWebGLProgram(t,[d],d.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){const t=new o2e(e,l.shape,a,s),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=c0e({inputs:{x:d},backend:n,attrs:{perm:kAe(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}const d2e={kernelName:lwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return c2e(i2e.Prod,a,n,s,i,o)}};const h2e={kernelName:uwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return c2e(i2e.Sum,a,n,s,i,o)}};const p2e={kernelName:dwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){const e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=lJe(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){const e=n.bufferSync(a),t=n.bufferSync(s),r=uJe(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};class f2e{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const m2e={kernelName:hwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,c=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d=new f2e("NHWC"===i?[o,l,u,c]:[o,c,l,u],s,i);return n.runWebGLProgram(d,[a],a.dtype)}};class g2e{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=VQe(this.outputShape.length);const s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class y2e{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=VQe(this.outputShape.length);const s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)h+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){const e=2*g;if(h+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,h+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=i%2===0?Lve(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,h+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):h+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(h+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(h+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(h+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const b2e={kernelName:pwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),Bve(bEe(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=cEe(a.shape,s.shape,i,c,o,u,!0);let h;h=xxe().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new y2e(d):new g2e(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[a,s],"float32",p)}};class v2e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class x2e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const w2e={kernelName:fwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=cEe(a.shape,c,i,o,l,u,!0),h=new v2e(d);return n.runWebGLProgram(h,[a,s],"float32")}};const k2e={kernelName:mwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=cEe(c,s.shape,i,o,l,u,!0),h=new x2e(d);return n.runWebGLProgram(h,[a,s],"float32")}};class S2e{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const I2e={kernelName:gwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=Uve(r.shape),i=e0e({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new S2e(s),l=n.runWebGLProgram(o,[i],i.dtype),u=e0e({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}};class C2e{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const N2e={kernelName:ywe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=oEe(a.shape,s.shape,i,o,"NHWC",l);let c;const d=new C2e(u);c=n.runWebGLProgram(d,[a,s],"float32");const h=e0e({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}};const T2e={kernelName:kwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=eMe(a,s.length);nMe(i.length,l,s);const{path:u,steps:c}=rMe(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=tMe(p,l[e]);let a;aMe(t)?a=s[e]:(a=c0e({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);jve(a.shape,i)||(a=e0e({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===h?h=a:(h=JZe({inputs:{a:a,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=l0e({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},E2e=GZe({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),A2e={kernelName:Swe,backendName:"webgl",kernelFunc:E2e},_2e={kernelName:Iwe,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=xxe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new DZe("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new $Ze("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},$2e=HZe({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:fJe}),R2e={kernelName:Nwe,backendName:"webgl",kernelFunc:$2e},D2e=GZe({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${ODe};\n  float a1 = ${PDe};\n  float a2 = ${LDe};\n  float a3 = ${zDe};\n  float a4 = ${BDe};\n  float a5 = ${WDe};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),M2e={kernelName:Cwe,backendName:"webgl",kernelFunc:D2e},F2e=GZe({opSnippet:jZe+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:mJe,dtype:"float32"}),O2e={kernelName:Twe,backendName:"webgl",kernelFunc:F2e};function P2e(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(Bve(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),e0e({inputs:{x:s},backend:r,attrs:{shape:o}})}const L2e={kernelName:Ewe,backendName:"webgl",kernelFunc:P2e},z2e="return exp(x) - 1.0;",B2e=GZe({opSnippet:z2e,packedOpSnippet:z2e,cpuKernelImpl:gJe}),W2e={kernelName:Awe,backendName:"webgl",kernelFunc:B2e};class V2e{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function U2e(e,t,n){const r=n.texData.get(e.dataId),a=Uve(e.shape),s=e.shape[e.shape.length-1],i=e0e({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),o=i.shape,l=new V2e("real",o,t),u=new V2e("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(l,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),p=OZe({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=e0e({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const j2e={kernelName:_we,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return U2e(r,!1,n)}};class G2e{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function H2e(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||axe(a),"string"===s){const e=Zve(s,Uve(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{const e=new G2e(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}const q2e={kernelName:$we,backendName:"webgl",kernelFunc:H2e};class K2e{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const X2e={kernelName:Rwe,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:r}=t,a=n,s=new K2e(r.shape);return a.runWebGLProgram(s,[r],r.dtype)}},Y2e="return floor(x);",Q2e=GZe({opSnippet:Y2e,packedOpSnippet:Y2e,cpuKernelImpl:yJe}),J2e={kernelName:Dwe,backendName:"webgl",kernelFunc:Q2e},Z2e=HZe({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),e3e={kernelName:Mwe,backendName:"webgl",kernelFunc:Z2e};class t3e{constructor(e){this.variableNames=["A"];const t=bQe(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class n3e{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=bQe(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const r3e={kernelName:$Se,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:s}=r,i="undefined"!==typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],c=[u,l],d=[u,l,s];if(o||i){const e=xxe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=a3e&&e===s3e||(s3e=e,a3e=document.createElement("canvas").getContext("2d",{willReadFrequently:s3e})),a3e.canvas.width=l,a3e.canvas.height=u,a3e.drawImage(a,0,0,l,u),a=a3e.canvas}const h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=BYe.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);const p=xxe().getBool("WEBGL_PACK")?new n3e(d):new t3e(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let a3e,s3e=xxe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const i3e={kernelName:MSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=xEe(c),g=cEe(a.shape,s.shape,l,d,u,h,!1,m);let y;const b=[],v=null!=i,x=null!=o,w="leakyrelu"===p,k=()=>{const e=[a,s],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=e0e({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(i,c)),x&&e.push(t(o,c)),w){const t=n.makeTensorInfo([],"float32",oIe(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&xxe().getBool("WEBGL_EXP_CONV")){const e=p?qZe(p,!0):null,t=new L1e(g,v,e,x,w),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],a=k();y=n.runWebGLProgram(t,a,"float32",r)}else if(xxe().getBool("WEBGL_CONV_IM2COL"))y=V1e({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?qZe(p,!1):null,t=new O1e(g,v,e,x,w),r=k();y=n.runWebGLProgram(t,r,"float32")}else y=W1e({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=e0e({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const o3e={kernelName:FSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),Bve(bEe(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=cEe(a.shape,s.shape,l,m,u,d,!0),y=xxe().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=h?qZe(h,y):null,v=[a,s],x=null!=i,w=null!=o,k="leakyrelu"===h;if(x&&v.push(i),w&&v.push(o),k){const e=n.makeTensorInfo([],"float32",oIe(p,"float32"));v.push(e),f.push(e)}let S;S=y?new y2e(g,x,b,w,k):new g2e(g,x,b,w,k);const I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],C=n.runWebGLProgram(S,v,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),C}};class l3e{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=FQe(n.length);let s="\n    int index;";for(let i=0;i<this.sliceDim;i++)s+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const u3e={kernelName:Pwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=Uve(r.shape),[l,u,c,d]=DDe(r,a),h=e0e({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),p=e0e({inputs:{x:r},backend:n,attrs:{shape:[Uve(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),s=bJe(e,t,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}const f=new l3e(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=e0e({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class c3e{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=FQe(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function d3e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=Yve(i,a.shape)[0];if(xxe().get("DEBUG")){const e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){const r=e[n];Bve(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const u=wMe(a,s,l,o),c=Uve(s.shape),d=[],h=e0e({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=e0e({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),r=vJe(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new c3e(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const y=e0e({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const h3e={kernelName:Owe,backendName:"webgl",kernelFunc:d3e},p3e=HZe({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:xJe,dtype:"bool"}),f3e={kernelName:Lwe,backendName:"webgl",kernelFunc:p3e},m3e=HZe({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:wJe}),g3e={kernelName:zwe,backendName:"webgl",kernelFunc:m3e};const y3e={kernelName:Wwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return U2e(r,!0,n)}},b3e=GZe({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),v3e={kernelName:Uwe,backendName:"webgl",kernelFunc:b3e},x3e=GZe({opSnippet:"return float(isinf(x));",dtype:"bool"}),w3e={kernelName:jwe,backendName:"webgl",kernelFunc:x3e},k3e=GZe({opSnippet:"return float(isnan(x));",dtype:"bool"}),S3e={kernelName:Gwe,backendName:"webgl",kernelFunc:k3e},I3e=HZe({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:kJe,dtype:"bool"}),C3e={kernelName:qwe,backendName:"webgl",kernelFunc:I3e},N3e=HZe({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:SJe,dtype:"bool"}),T3e={kernelName:Kwe,backendName:"webgl",kernelFunc:N3e};const E3e={kernelName:Xwe,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=IJe(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},A3e=GZe({opSnippet:jZe+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:CJe}),_3e={kernelName:Ywe,backendName:"webgl",kernelFunc:A3e},$3e=GZe({opSnippet:jZe+"\n  return log(1.0 + x);\n"}),R3e={kernelName:Qwe,backendName:"webgl",kernelFunc:$3e},D3e=HZe({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),M3e={kernelName:Jwe,backendName:"webgl",kernelFunc:D3e},F3e=GZe({opSnippet:"return float(!(x >= 1.0));"}),O3e={kernelName:Zwe,backendName:"webgl",kernelFunc:F3e},P3e=HZe({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),L3e={kernelName:eke,backendName:"webgl",kernelFunc:P3e};class z3e{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];const s=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class B3e{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const W3e={kernelName:tke,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=xxe().getBool("WEBGL_PACK_NORMALIZATION")?new B3e(a.shape,s,i,o,l):new z3e(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)}};class V3e{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const U3e={kernelName:nke,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new V3e(a.shape,o,l,u,c);return n.runWebGLProgram(d,[a,s,i],a.dtype)}};function j3e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=Yve(s,a.shape);let u=l;const c=wAe(u,o),d=null!=c,h=n.shouldExecuteOnCPU([a]);let p=a;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=a.shape[c[n]];const r=eZe(e,a.shape,a.dtype,c,t);p=n.makeTensorInfo(t,a.dtype);n.texData.get(p.dataId).values=r}else p=o0e(a,c,n);u=SAe(u.length,o)}xAe("max",u,o);const[f,m]=bAe(p.shape,u);let g,y=f;if(i&&(y=vAe(f,l)),h){const e=n.texData.get(p.dataId).values,t=NJe(e,Uve(m),y,a.dtype);g=n.makeTensorInfo(y,a.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const a=Uve(t),s=e0e({inputs:{x:e},attrs:{shape:[Uve(e.shape)/a,a]},backend:r}),i=a0e(s,e.dtype,"max",r),o=e0e({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(p,m,y,n);return d&&n.disposeIntermediateTensorInfo(p),g}const G3e={kernelName:rke,backendName:"webgl",kernelFunc:j3e},H3e=HZe({opSnippet:_Ze+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+RZe+"\n  return result;\n",cpuKernelImpl:TJe}),q3e={kernelName:ake,backendName:"webgl",kernelFunc:H3e};const K3e={kernelName:ske,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;gQe(a,"maxPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Bve(bEe(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=lEe(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&jve(u.inShape,u.outShape))return MZe({inputs:{x:a},backend:n});const c=new H0e(u,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}};const X3e={kernelName:oke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=uEe(a.shape,s,i,[1,1,1],o,u,l),d=new q0e(c,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}};class Y3e{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Q3e{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const J3e={kernelName:lke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=uEe(i.shape,o,l,[1,1,1],u,c),h=new q0e(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new Q3e(d),m=n.runWebGLProgram(f,[a,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};const Z3e={kernelName:ike,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;gQe([s,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=lEe(o.shape,l,u,1,c,d),p=new H0e(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new Y3e(h),g=n.runWebGLProgram(m,[a,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const e4e={kernelName:uke,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;Bve(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));const c=[1,1];Bve(bEe(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=lEe(a.shape,s,i,c,o),[h,p]=function(e,t,n,r){let a=new H0e(n,"max",!1);const s=r.runWebGLProgram(a,[e],"float32");return a=new H0e(n,"max",!0,!0,t),[s,r.runWebGLProgram(a,[e],"float32")]}(a,l,d,u);return[h,p]}};const t4e={kernelName:cke,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{keepDims:s,axis:i}=n,o=r,l=a.shape.length,u=Yve(i,a.shape);let c=u;const d=wAe(c,l),h=null!=d,p=o.shouldExecuteOnCPU([a]),f=[];let m=a;if(h){if(p){const e=o.texData.get(m.dataId).values,t=new Array(l);for(let r=0;r<t.length;r++)t[r]=a.shape[d[r]];const n=eZe(e,a.shape,a.dtype,d,t);m=o.makeTensorInfo(t,a.dtype);o.texData.get(m.dataId).values=n}else m=o0e(a,d,o);f.push(m),c=SAe(c.length,l)}xAe("sum",c,l);const[g,y]=bAe(m.shape,c);let b=g;s&&(b=vAe(g,u));const v=function(e,t,n,r){const a=Uve(t),s=e0e({inputs:{x:e},attrs:{shape:[Uve(e.shape)/a,a]},backend:r}),i=a0e(s,"float32","mean",r),o=e0e({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(m,y,b,o);for(const x of f)o.disposeIntermediateTensorInfo(x);return v}};const n4e={kernelName:dke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Yve(s,a.shape);let u=l;const c=wAe(u,o);let d=a;null!=c&&(d=c0e({inputs:{x:a},backend:n,attrs:{perm:c}}),u=SAe(u.length,a.shape.length)),xAe("min",u,o);const[h,p]=bAe(d.shape,u),f=e0e({inputs:{x:d},backend:n,attrs:{shape:[-1,Uve(p)]}}),m=a0e(f,f.dtype,"min",n);let g;if(i){g=e0e({inputs:{x:m},backend:n,attrs:{shape:vAe(h,l)}})}else g=e0e({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},r4e=HZe({opSnippet:_Ze+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+RZe+"\n  return result;\n",cpuKernelImpl:EJe}),a4e={kernelName:hke,backendName:"webgl",kernelFunc:r4e};class s4e{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=FQe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class i4e{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=FQe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=rZe("rc",r),l=rZe("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1;let h="";if(1===r){const e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const o4e={kernelName:pke,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a}=t,{paddings:s,mode:i}=r,o=xxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new i4e(a.shape,s,i):new s4e(a.shape,s,i);return n.runWebGLProgram(o,[a],a.dtype)}},l4e=HZe({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+RZe+"\n  return result;\n"}),u4e={kernelName:fke,backendName:"webgl",kernelFunc:l4e};class c4e{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const d4e=HZe({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),h4e={kernelName:wwe,backendName:"webgl",kernelFunc:d4e},p4e="return a - b;",f4e=HZe({opSnippet:p4e,packedOpSnippet:p4e,supportsComplex:!0,cpuKernelImpl:QJe}),m4e={kernelName:vSe,backendName:"webgl",kernelFunc:f4e};function g4e(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=Yve([s],a.shape),o=j3e({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=vAe(o.shape,i),u=e0e({inputs:{x:o},backend:n,attrs:{shape:l}}),c=f4e({inputs:{a:a,b:u},backend:n}),d=F2e({inputs:{x:c},backend:n}),h=l0e({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=e0e({inputs:{x:h},backend:n,attrs:{shape:l}}),f=d4e({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const y4e={kernelName:iSe,backendName:"webgl",kernelFunc:g4e};const b4e={kernelName:mke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:g4e({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new c4e(u,c,s),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}},v4e=dZe+"\n  return -x;\n";const x4e={kernelName:yke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,a]=_Je(e.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,t)}let a;return a=xxe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new IZe(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new cZe(r.shape,v4e),n.runWebGLProgram(a,[r],r.dtype)}},w4e=IRe;const k4e={kernelName:vke,backendName:"webgl",kernelFunc:function(e){OSe("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=w4e(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},S4e=CRe;const I4e={kernelName:xke,backendName:"webgl",kernelFunc:function(e){OSe("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:p}=S4e(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},C4e=NRe;const N4e={kernelName:wke,backendName:"webgl",kernelFunc:function(e){OSe("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=C4e(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class T4e{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const E4e={kernelName:Ske,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=Uve(a.shape),c=new T4e(u,i,o,l),d=e0e({inputs:{x:a},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],s);n.disposeIntermediateTensorInfo(d);const p=e0e({inputs:{x:h},backend:n,attrs:{shape:[...a.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function A4e(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=m1e({inputs:{input:r},backend:n}),t=A4e({inputs:{x:e},backend:n}),a=$1e({inputs:{input:r},backend:n}),s=A4e({inputs:{x:a},backend:n}),i=OZe({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return H2e({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const _4e={kernelName:ASe,backendName:"webgl",kernelFunc:A4e};const $4e={kernelName:kke,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const t=m1e({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=$1e({inputs:{input:a},backend:r}),i=A4e({inputs:{x:s},backend:r}),o=OZe({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return H2e({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};const R4e={kernelName:Ike,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return P2e({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Wve(s,e.shape,"All tensors passed to stack must have matching shapes"),Bve(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=M1e({inputs:t.map((e=>{const t=P2e({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class D4e{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=FQe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class M4e{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=FQe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=rZe("rc",r),l=rZe("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${d[f]}\n        if (${h}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const F4e=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===Uve(a.shape)){const e=s.map(((e,t)=>e[0]+a.shape[t]+e[1]));return H2e({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}const o=xxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new M4e(a.shape,s,i):new D4e(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},O4e={kernelName:Cke,backendName:"webgl",kernelFunc:F4e},P4e=HZe({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+RZe+"\n  return result;\n"}),L4e={kernelName:Nke,backendName:"webgl",kernelFunc:P4e};const z4e={kernelName:Eke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=[],u=Yve(s,a.shape);let c=u;const d=wAe(c,o);let h,p=a;if(null!=d&&(p=c0e({inputs:{x:a},backend:n,attrs:{perm:d}}),c=SAe(c.length,o),l.push(p)),xAe("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:a}=RJe(p.shape,p.dtype,e,c);h=n.makeTensorInfo(r,a,t)}else{const[e,t]=bAe(p.shape,c),r=Uve(t),s=e0e({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=a0e(s,BIe(a.dtype),"prod",n);h=e0e({inputs:{x:i},backend:n,attrs:{shape:e}}),l.push(s),l.push(i)}if(i){l.push(h);const e=vAe(h.shape,u);h=e0e({inputs:{x:h},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const B4e={kernelName:Ake,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.readSync(e.dataId))),u=a.map((e=>e.shape)),c=n.readSync(s.dataId),d=n.readSync(i.dataId),[h,p,f]=DJe(l,u,c,s.shape,s.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};const W4e={kernelName:_ke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=MJe(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};const V4e={kernelName:$ke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),d=n.readSync(i.dataId),h=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=FJe(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}},U4e=e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=OJe(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},j4e={kernelName:Rke,backendName:"webgl",kernelFunc:U4e},G4e=GZe({opSnippet:"return 1.0 / x;"}),H4e={kernelName:Mke,backendName:"webgl",kernelFunc:G4e},q4e=GZe({opSnippet:dZe+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),K4e={kernelName:Fke,backendName:"webgl",kernelFunc:q4e},X4e=GZe({opSnippet:dZe+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Y4e={kernelName:Wke,backendName:"webgl",kernelFunc:X4e};class Q4e{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class J4e{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const Z4e={kernelName:zke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=xxe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new J4e(a.shape,l,u,s,i):new Q4e(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],"float32")}};class e5e{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const t5e={kernelName:Bke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new e5e(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};class n5e{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class r5e{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const a5e={kernelName:Pke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=xxe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new r5e(a.shape,l,u,s,i):new n5e(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],a.dtype)}};class s5e{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const i5e={kernelName:Lke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new s5e(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};class o5e{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=FQe(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class l5e{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=rZe("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=FQe(n);function o(n){const r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const u5e={kernelName:Vke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=Yve(s,a.shape);if(0===i)return MZe({inputs:{x:a},backend:n});const l=xxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new l5e(a.shape,o):new o5e(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}};class c5e{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let a="";a="number"===typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const d5e={kernelName:RSe,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=new c5e(a.shape,i),[c,d]=TDe(o,a.shape[1],a.shape[2]),h=[[c,d,Math.sin(s),Math.cos(s)]];return l.runWebGLProgram(u,[a],a.dtype,h)}},h5e=GZe({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),p5e={kernelName:Uke,backendName:"webgl",kernelFunc:h5e},f5e=GZe({opSnippet:"return inversesqrt(x);",cpuKernelImpl:PJe}),m5e={kernelName:jke,backendName:"webgl",kernelFunc:f5e};class g5e{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const o=FQe(a.length),l=FQe(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}}class y5e{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const o=FQe(a.length),l=FQe(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${g};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}}const b5e={kernelName:Gke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=M$e(0,a,i),h=[d/u,u];if(0===d)return n.makeTensorInfo(i,a.dtype);const p=e0e({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=e0e({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=xxe().getBool("WEBGL_PACK")?new y5e(l,o,p.shape.length,f.shape.length,c,h):new g5e(l,o,p.shape.length,f.shape.length,c,h);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=e0e({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class v5e{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===xxe().getNumber("WEBGL_VERSION")?"while (left < right) {":a,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const x5e={kernelName:qke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new v5e(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}};class w5e{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}const s=FQe(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}const k5e={kernelName:Kke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new w5e(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],zIe(a.dtype,s.dtype))}},S5e=GZe({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${MDe};\n  float scale = ${FDe};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),I5e={kernelName:Xke,backendName:"webgl",kernelFunc:S5e},C5e=GZe({opSnippet:jZe+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:zJe}),N5e={kernelName:eSe,backendName:"webgl",kernelFunc:C5e},T5e=GZe({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),E5e={kernelName:Zke,backendName:"webgl",kernelFunc:T5e},A5e=GZe({opSnippet:jZe+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${RZe}\n  return result;\n`}),_5e={kernelName:Qke,backendName:"webgl",kernelFunc:A5e},$5e=GZe({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),R5e={kernelName:Jke,backendName:"webgl",kernelFunc:$5e},D5e=GZe({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),M5e={kernelName:tSe,backendName:"webgl",kernelFunc:D5e},F5e={kernelName:aSe,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;Bve(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);const u=[],c=F4e({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=EDe(c.shape,s,o,!1),h=ADe(d.length,s.length,!1),p=_De(c.shape,s,o,!1),f=e0e({inputs:{x:c},backend:n,attrs:{shape:d}}),m=c0e({inputs:{x:f},backend:n,attrs:{perm:h}}),g=e0e({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const O5e={kernelName:oSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=VJe(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};const P5e={kernelName:lSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,d]=UJe(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};const L5e={kernelName:uSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=jJe(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const z5e={kernelName:cSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=jJe(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const B5e={kernelName:dSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=M$e(0,a,o),p=!1;if("string"===s.dtype){const e=n.bufferSync(a),t=n.bufferSync(s),r=hIe(n.readSync(i.dataId)[0]),f=LJe(e,t,o,h,c,u,l,d,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new g5e(u,l,a.shape.length,s.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=e0e({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};const W5e={kernelName:sSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Yve(i,a.shape)[0],l=iMe(a,s,o),u=a.shape.length,c=new Array(u).fill(0),d=a.shape.slice();return l.map((e=>{const t=[...d];t[o]=e;const r=o1e({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},V5e="return sqrt(x);",U5e=GZe({opSnippet:V5e,packedOpSnippet:V5e,cpuKernelImpl:GJe}),j5e={kernelName:nSe,backendName:"webgl",kernelFunc:U5e},G5e={kernelName:pSe,backendName:"webgl",kernelFunc:GZe({opSnippet:"return x * x;"})},H5e="return (a - b) * (a - b);",q5e=HZe({opSnippet:H5e,packedOpSnippet:H5e}),K5e={kernelName:hSe,backendName:"webgl",kernelFunc:q5e};const X5e={kernelName:fSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");const s=kMe(n.readSync(a.dataId)),i=HJe(s,"string",r);return n.makeTensorInfo(a.shape,"string",i)}};const Y5e={kernelName:_Se,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,s=dZe+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,i=new cZe(a.shape,s);return r.runWebGLProgram(i,[a],a.dtype)}};class Q5e{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=FQe(n.length),s=FQe(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const J5e={kernelName:mSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=qTe(a.shape,s,i,o,l,u,c,d,h);let w;if(m)w=e0e({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){Bve(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=MTe(b,v,x),t=o1e({inputs:{x:a},backend:n,attrs:{begin:b,size:e}});w=e0e({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=CNe(a.shape,a.dtype,e),r=qJe(p,t,x,b);w=n.makeTensorInfo(f,a.dtype,r.values)}else{const e=new Q5e(b,x,p);w=n.runWebGLProgram(e,[a],a.dtype)}}const k=e0e({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const Z5e={kernelName:gSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=KJe(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};const e6e={kernelName:ySe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=XJe(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const t6e={kernelName:bSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(s.dataId),o=YJe(i,a);return n.makeTensorInfo(s.shape,"int32",o)}},n6e=GZe({opSnippet:"return tan(x);"}),r6e={kernelName:xSe,backendName:"webgl",kernelFunc:n6e},a6e=GZe({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),s6e={kernelName:wSe,backendName:"webgl",kernelFunc:a6e};const i6e={kernelName:Hke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=M$e(0,s,a.shape),h=[d/u,u];if(0===d)return n.makeTensorInfo(a.shape,s.dtype);const p=e0e({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=e0e({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=e0e({inputs:{x:a},backend:n,attrs:{shape:h}}),g=new g5e(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=e0e({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class o6e{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;const r=FQe(this.rank),a=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}function l6e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>hIe(e))):e,r=CNe(a.shape,a.dtype,t),i=JJe(r,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new o6e(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}const u6e={kernelName:kSe,backendName:"webgl",kernelFunc:l6e};class c6e{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class d6e{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function h6e(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function p6e(e){let t=1;for(;t<e;)t*=2;return t}const f6e={kernelName:SSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=xxe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=xxe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([a])||c<o||s>l){const e=n.readSync(a.dataId),[t,r]=ZJe(e,u,a.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[a,H2e({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(a.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(a):a,f=Uve(u)/c,m=e0e({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&h6e(n,p);const g=p6e(s),y=p6e(c);let b=null;const v=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{const a=v(),s=new c6e(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(s,a,"int32",i),h6e(n,o)};for(let C=1;C<g;C*=2){const e=2*C;for(let t=C;t>=1;t/=2)x(e,t,[f,y])}for(let C=y;C>g;C/=2){const e=v(),t=new d6e([f,C/2]),r=[[c],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(t,e,"int32",r),h6e(n,a);const s=g/2,i=2*s;for(let n=s;n>=1;n/=2)x(i,n,b.shape)}let w=b;b=o1e({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),h6e(n,w);let k=d3e({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});h6e(n,m);const S=u.slice(0,-1);S.push(s),w=b,b=e0e({inputs:{x:b},attrs:{shape:S},backend:n}),h6e(n,w);const I=k;return k=e0e({inputs:{x:k},attrs:{shape:S},backend:n}),h6e(n,I),[k,b]}};class m6e{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const g6e={kernelName:ISe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=new m6e(d,h,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[a,s],"float32")}};const y6e={kernelName:NSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;gQe(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=tZe(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const b6e={kernelName:TSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==s&&(u[c++]=i.shape[m]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[s]=1;const f=new Array(l);for(let m=0;m<f.length;m++){h[s]=m;const e=o1e({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),t=e0e({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class v6e{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const x6e={kernelName:ESe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[];let u=0;const c=wAe([u],o);let d=a;null!=c&&(d=c0e({inputs:{x:a},backend:n,attrs:{perm:c}}),l.push(d),u=SAe(1,o)[0]);const h=xMe(d.shape,u,i),p=Uve([d.shape[u]]),f=e0e({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=BIe(a.dtype),g=(e,t,r,a,s)=>{const i=e.shape[0],o=e.shape[1],u=vMe(o,s),c=new v6e({windowSize:u,inSize:o,batchSize:i,numSegments:s},t),d=n.compileAndRun(c,[e,r],a);if(l.push(d),d.shape[1]===s)return d;const h=U4e({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=l6e({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});l.push(h),l.push(p);return g(d,t,p,a,s)},y=e0e({inputs:{x:g(f,"unsortedSegmentSum",s,m,i)},backend:n,attrs:{shape:h}});let b=y;if(null!=c){l.push(y);const e=kAe(c);b=c0e({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},w6e=[f0e,g0e,b0e,x0e,S0e,N0e,T0e,E0e,M0e,F0e,P0e,z0e,W0e,U0e,G0e,K0e,X0e,J0e,Z0e,e1e,r1e,u1e,c1e,d1e,h1e,b1e,w1e,I1e,PZe,T1e,F1e,U1e,K1e,Y1e,Q1e,J1e,Z1e,t2e,r2e,s2e,d2e,h2e,p2e,m2e,b2e,w2e,k2e,I2e,N2e,T2e,A2e,_2e,R2e,M2e,O2e,L2e,W2e,j2e,q2e,X2e,J2e,e3e,r3e,i3e,o3e,u3e,h3e,f3e,g3e,FZe,y3e,R1e,v3e,w3e,S3e,BZe,C3e,T3e,E3e,_3e,R3e,M3e,O3e,L3e,W3e,U3e,G3e,q3e,K3e,X3e,J3e,Z3e,e4e,t4e,n4e,a4e,o4e,u4e,b4e,ZZe,x4e,k4e,I4e,N4e,f1e,E4e,$4e,R4e,O4e,L4e,UZe,z4e,B4e,W4e,V4e,j4e,g1e,h4e,H4e,K4e,Y4e,t0e,Z4e,t5e,a5e,i5e,u5e,d5e,p5e,m5e,b5e,x5e,k5e,I5e,N5e,E5e,_5e,R5e,l1e,y4e,M5e,F5e,O5e,P5e,L5e,z5e,B5e,W5e,j5e,G5e,K5e,X5e,Y5e,J5e,Z5e,e6e,t6e,m4e,u0e,r6e,s6e,i6e,u6e,f6e,g6e,d0e,y6e,b6e,x6e,_4e];for(const n of w6e)USe(n);function k6e(e,t,n,r){return new(n||(n=Promise))((function(a,s){function i(e){try{l(r.next(e))}catch(e){s(e)}}function o(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?a(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))}function S6e(e,t){var n,r,a,s,i={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function o(o){return function(l){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;s&&(s=0,o[0]&&(i=0)),i;)try{if(n=1,r&&(a=2&o[0]?r.return:o[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,o[1])).done)return a;switch(r=0,a&&(o=[2&o[0],a.value]),o[0]){case 0:case 1:a=o;break;case 4:return i.label++,{value:o[1],done:!1};case 5:i.label++,r=o[1],o=[0];continue;case 7:o=i.ops.pop(),i.trys.pop();continue;default:if(!((a=(a=i.trys).length>0&&a[a.length-1])||6!==o[0]&&2!==o[0])){i=0;continue}if(3===o[0]&&(!a||o[1]>a[0]&&o[1]<a[3])){i.label=o[1];break}if(6===o[0]&&i.label<a[1]){i.label=a[1],a=o;break}if(a&&i.label<a[2]){i.label=a[2],i.ops.push(o);break}a[2]&&i.ops.pop(),i.trys.pop();continue}o=t.call(e,i)}catch(e){o=[6,e],r=0}finally{n=a=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,l])}}}function I6e(e,t,n){if(n||2===arguments.length)for(var r,a=0,s=t.length;a<s;a++)!r&&a in t||(r||(r=Array.prototype.slice.call(t,0,a)),r[a]=t[a]);return e.concat(r||Array.prototype.slice.call(t))}function C6e(e){return[Math.abs(e.endPoint[0]-e.startPoint[0]),Math.abs(e.endPoint[1]-e.startPoint[1])]}function N6e(e){return[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])/2,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])/2]}function T6e(e,t){void 0===t&&(t=1.5);var n=N6e(e),r=C6e(e),a=[t*r[0]/2,t*r[1]/2];return{startPoint:[n[0]-a[0],n[1]-a[1]],endPoint:[n[0]+a[0],n[1]+a[1]],palmLandmarks:e.palmLandmarks}}function E6e(e){var t=N6e(e),n=C6e(e),r=Math.max.apply(Math,n)/2;return{startPoint:[t[0]-r,t[1]-r],endPoint:[t[0]+r,t[1]+r],palmLandmarks:e.palmLandmarks}}function A6e(e,t){var n=[e.endPoint[0]-e.startPoint[0],e.endPoint[1]-e.startPoint[1]],r=[n[0]*t[0],n[1]*t[1]];return{startPoint:[e.startPoint[0]+r[0],e.startPoint[1]+r[1]],endPoint:[e.endPoint[0]+r[0],e.endPoint[1]+r[1]],palmLandmarks:e.palmLandmarks}}"function"==typeof SuppressedError&&SuppressedError;var _6e=function(){function e(e,t,n,r,a,s){this.model=e,this.width=t,this.height=n,this.iouThreshold=a,this.scoreThreshold=s,this.anchors=r.map((function(e){return[e.x_center,e.y_center]})),this.anchorsTensor=E$e(this.anchors),this.inputSizeTensor=T$e([t,n]),this.doubleInputSizeTensor=T$e([2*t,2*n])}return e.prototype.normalizeBoxes=function(e){var t=this;return yCe((function(){var n=EEe(e,[0,0],[-1,2]),r=EEe(e,[0,2],[-1,2]),a=ANe($Ne(n,t.inputSizeTensor),t.anchorsTensor),s=$Ne(r,t.doubleInputSizeTensor),i=RNe(KNe(a,s),t.inputSizeTensor),o=RNe(ANe(a,s),t.inputSizeTensor);return UEe([i,o],1)}))},e.prototype.normalizeLandmarks=function(e,t){var n=this;return yCe((function(){var r=ANe($Ne(kEe(e,[-1,7,2]),n.inputSizeTensor),n.anchors[t]);return RNe(r,n.inputSizeTensor)}))},e.prototype.getBoundingBoxes=function(e){return k6e(this,void 0,void 0,(function(){var t,n,r,a,s,i,o,l,u,c,d,h,p,f,m,g=this;return S6e(this,(function(y){switch(y.label){case 0:return t=yCe((function(){return RNe(KNe(e,.5),2)})),"webgl"===xCe()?(r=xxe().get("WEBGL_PACK_DEPTHWISECONV"),xxe().set("WEBGL_PACK_DEPTHWISECONV",!0),n=this.model.predict(t),xxe().set("WEBGL_PACK_DEPTHWISECONV",r)):n=this.model.predict(t),a=k$e(n),s=yCe((function(){return k$e(TEe(EEe(a,[0,0],[-1,1])))})),i=EEe(a,[0,1],[-1,4]),o=this.normalizeBoxes(i),l=console.warn,console.warn=function(){},u=cDe.nonMaxSuppression(o,s,1,this.iouThreshold,this.scoreThreshold),console.warn=l,[4,u.array()];case 1:return c=y.sent(),d=[t,n,u,a,o,i,s],0===c.length?(d.forEach((function(e){return e.dispose()})),[2,null]):(h=c[0],p=EEe(o,[h,0],[1,-1]),f=EEe(a,[h,5],[1,14]),m=yCe((function(){return kEe(g.normalizeLandmarks(f,h),[-1,2])})),d.push(f),d.forEach((function(e){return e.dispose()})),[2,{boxes:p,palmLandmarks:m}])}}))}))},e.prototype.estimateHandBounds=function(e){return k6e(this,void 0,void 0,(function(){var t,n,r,a,s,i,o,l,u=this;return S6e(this,(function(c){switch(c.label){case 0:return t=e.shape[1],n=e.shape[2],r=yCe((function(){return $Ne(cDe.resizeBilinear(e,[u.width,u.height]),255)})),[4,this.getBoundingBoxes(r)];case 1:return null===(a=c.sent())?(r.dispose(),[2,null]):(s=a.boxes.arraySync(),i=s[0].slice(0,2),o=s[0].slice(2,4),l=a.palmLandmarks.arraySync(),r.dispose(),a.boxes.dispose(),a.palmLandmarks.dispose(),[2,(d={startPoint:i,endPoint:o,palmLandmarks:l},h=[n/this.width,t/this.height],{startPoint:[d.startPoint[0]*h[0],d.startPoint[1]*h[1]],endPoint:[d.endPoint[0]*h[0],d.endPoint[1]*h[1]],palmLandmarks:d.palmLandmarks.map((function(e){return[e[0]*h[0],e[1]*h[1]]}))})])}var d,h}))}))},e}(),$6e={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]};var R6e=function(e,t){return[[1,0,e],[0,1,t],[0,0,1]]};function D6e(e,t){for(var n=0,r=0;r<e.length;r++)n+=e[r]*t[r];return n}function M6e(e,t){for(var n=[],r=0;r<e.length;r++)n.push(e[r][t]);return n}function F6e(e,t){for(var n=[],r=e.length,a=0;a<r;a++){n.push([]);for(var s=0;s<r;s++)n[a].push(D6e(e[a],M6e(t,s)))}return n}function O6e(e,t){var n=Math.cos(e),r=Math.sin(e),a=[[n,-r,0],[r,n,0],[0,0,1]],s=F6e(R6e(t[0],t[1]),a);return F6e(s,R6e(-t[0],-t[1]))}function P6e(e,t){return[D6e(e,t[0]),D6e(e,t[1])]}var L6e=[0,-.4],z6e=[0,-.1],B6e=[0,5,9,13,17,1,2],W6e=function(){function e(e,t,n,r,a,s){this.boundingBoxDetector=e,this.meshDetector=t,this.meshWidth=n,this.meshHeight=r,this.maxContinuousChecks=a,this.detectionConfidence=s,this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.maxHandsNumber=1}return e.prototype.getBoxForPalmLandmarks=function(e,t){var n=e.map((function(e){return P6e(I6e(I6e([],e,!0),[1],!1),t)}));return T6e(E6e(A6e(this.calculateLandmarksBoundingBox(n),L6e)),3)},e.prototype.getBoxForHandLandmarks=function(e){for(var t=T6e(E6e(A6e(this.calculateLandmarksBoundingBox(e),z6e)),1.65),n=[],r=0;r<B6e.length;r++)n.push(e[B6e[r]].slice(0,2));return t.palmLandmarks=n,t},e.prototype.transformRawCoords=function(e,t,n,r){var a,s,i,o,l=this,u=C6e(t),c=[u[0]/this.meshWidth,u[1]/this.meshHeight],d=e.map((function(e){return[c[0]*(e[0]-l.meshWidth/2),c[1]*(e[1]-l.meshHeight/2),e[2]]})),h=O6e(n,[0,0]),p=d.map((function(e){return I6e(I6e([],P6e(e,h),!0),[e[2]],!1)})),f=(s=[[(a=r)[0][0],a[1][0]],[a[0][1],a[1][1]]],i=[a[0][2],a[1][2]],o=[-D6e(s[0],i),-D6e(s[1],i)],[s[0].concat(o[0]),s[1].concat(o[1]),[0,0,1]]),m=I6e(I6e([],N6e(t),!0),[1],!1),g=[D6e(m,f[0]),D6e(m,f[1])];return p.map((function(e){return[e[0]+g[0],e[1]+g[1],e[2]]}))},e.prototype.estimateHand=function(e){return k6e(this,void 0,void 0,(function(){var t,n,r,a,s,i,o,l,u,c,d,h,p,f,m,g,y,b,v,x;return S6e(this,(function(w){switch(w.label){case 0:return!0!==(t=this.shouldUpdateRegionsOfInterest())?[3,2]:[4,this.boundingBoxDetector.estimateHandBounds(e)];case 1:return null===(n=w.sent())?(e.dispose(),this.regionsOfInterest=[],[2,null]):(this.updateRegionsOfInterest(n,!0),this.runsWithoutHandDetector=0,[3,3]);case 2:this.runsWithoutHandDetector++,w.label=3;case 3:return r=this.regionsOfInterest[0],a=function(e,t){var n;return(n=Math.PI/2-Math.atan2(-(t[1]-e[1]),t[0]-e[0]))-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}(r.palmLandmarks[0],r.palmLandmarks[2]),s=N6e(r),i=[s[0]/e.shape[2],s[1]/e.shape[1]],o=cDe.rotateWithOffset(e,a,0,i),l=O6e(-a,s),u=!0===t?this.getBoxForPalmLandmarks(r.palmLandmarks,l):r,c=function(e,t,n){var r=t.shape[1],a=t.shape[2],s=[[e.startPoint[1]/r,e.startPoint[0]/a,e.endPoint[1]/r,e.endPoint[0]/a]];return cDe.cropAndResize(t,s,[0],n)}(u,o,[this.meshWidth,this.meshHeight]),d=$Ne(c,255),c.dispose(),o.dispose(),"webgl"===xCe()?(p=xxe().get("WEBGL_PACK_DEPTHWISECONV"),xxe().set("WEBGL_PACK_DEPTHWISECONV",!0),h=this.meshDetector.predict(d),xxe().set("WEBGL_PACK_DEPTHWISECONV",p)):h=this.meshDetector.predict(d),f=h[0],m=h[1],d.dispose(),g=f.dataSync()[0],f.dispose(),g<this.detectionConfidence?(m.dispose(),this.regionsOfInterest=[],[2,null]):(y=kEe(m,[-1,3]),b=y.arraySync(),m.dispose(),y.dispose(),v=this.transformRawCoords(b,u,a,l),x=this.getBoxForHandLandmarks(v),this.updateRegionsOfInterest(x,!1),[2,{landmarks:v,handInViewConfidence:g,boundingBox:{topLeft:x.startPoint,bottomRight:x.endPoint}}])}}))}))},e.prototype.calculateLandmarksBoundingBox=function(e){var t=e.map((function(e){return e[0]})),n=e.map((function(e){return e[1]}));return{startPoint:[Math.min.apply(Math,t),Math.min.apply(Math,n)],endPoint:[Math.max.apply(Math,t),Math.max.apply(Math,n)]}},e.prototype.updateRegionsOfInterest=function(e,t){if(t)this.regionsOfInterest=[e];else{var n=this.regionsOfInterest[0],r=0;if(null!=n&&null!=n.startPoint){var a=e.startPoint,s=a[0],i=a[1],o=e.endPoint,l=o[0],u=o[1],c=n.startPoint,d=c[0],h=c[1],p=n.endPoint,f=p[0],m=p[1],g=Math.max(s,d),y=Math.max(i,h),b=(Math.min(l,f)-g)*(Math.min(u,m)-y);r=b/((l-s)*(u-i)+(f-d)*(m-i)-b)}this.regionsOfInterest[0]=r>.8?n:e}},e.prototype.shouldUpdateRegionsOfInterest=function(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks},e}();function V6e(){return k6e(this,void 0,void 0,(function(){return S6e(this,(function(e){return[2,IUe("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1",{fromTFHub:!0})]}))}))}function U6e(){return k6e(this,void 0,void 0,(function(){return S6e(this,(function(e){return[2,IUe("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1",{fromTFHub:!0})]}))}))}function j6e(){return k6e(this,void 0,void 0,(function(){return S6e(this,(function(e){return[2,cIe("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then((function(e){return e.json()}))]}))}))}var G6e=function(){function e(e){this.pipeline=e}return e.getAnnotations=function(){return $6e},e.prototype.estimateHands=function(e,t){return void 0===t&&(t=!1),k6e(this,void 0,void 0,(function(){var n,r,a,s,i,o,l,u,c;return S6e(this,(function(d){switch(d.label){case 0:return n=function(e){return e instanceof _Ie?[e.shape[0],e.shape[1]]:[e.height,e.width]}(e),r=n[1],a=yCe((function(){return e instanceof _Ie||(e=ATe(e)),$Ae(NNe(e,"float32"))})),[4,this.pipeline.estimateHand(a)];case 1:if(s=d.sent(),a.dispose(),null===s)return[2,[]];for(i=s,!0===t&&(i=function(e,t){var n=e.handInViewConfidence,r=e.landmarks,a=e.boundingBox;return{handInViewConfidence:n,landmarks:r.map((function(e){return[t-1-e[0],e[1],e[2]]})),boundingBox:{topLeft:[t-1-a.topLeft[0],a.topLeft[1]],bottomRight:[t-1-a.bottomRight[0],a.bottomRight[1]]}}}(s,r)),o={},l=0,u=Object.keys($6e);l<u.length;l++)c=u[l],o[c]=$6e[c].map((function(e){return i.landmarks[e]}));return[2,[{handInViewConfidence:i.handInViewConfidence,boundingBox:i.boundingBox,landmarks:i.landmarks,annotations:o}]]}}))}))},e}();const H6e={thumb:[0,1,2,3,4],indexFinger:[0,5,6,7,8],middleFinger:[0,9,10,11,12],ringFinger:[0,13,14,15,16],littleFinger:[0,17,18,19,20]};var q6e=n(757);const K6e=q6e.Finger.Thumb,X6e=q6e.Finger.Index,Y6e=q6e.Finger.Middle,Q6e=q6e.Finger.Ring,J6e=q6e.Finger.Pinky,Z6e=q6e.FingerCurl.NoCurl,e8e=q6e.FingerCurl.FullCurl,t8e=q6e.FingerCurl.HalfCurl,n8e=q6e.FingerDirection.VerticalUpRight,r8e=q6e.FingerDirection.VerticalUp,a8e=q6e.FingerDirection.VerticalDown,s8e=q6e.FingerDirection.DiagonalUpRight,i8e=q6e.FingerDirection.DiagonalDownRight,o8e=q6e.FingerDirection.DiagonalUpLeft,l8e=q6e.FingerDirection.HorizontalRight,u8e=q6e.FingerDirection.HorizontalLeft,c8e=new q6e.GestureDescription("A");c8e.addCurl(K6e,Z6e,1),c8e.addDirection(X6e,n8e,.7),c8e.addCurl(X6e,e8e,1),c8e.addDirection(X6e,a8e,.7),c8e.addCurl(Y6e,e8e,1),c8e.addDirection(Y6e,r8e,.7),c8e.addCurl(Q6e,e8e,1),c8e.addDirection(Q6e,r8e,.7),c8e.addCurl(J6e,e8e,1),c8e.addDirection(J6e,r8e,.7);const d8e=new q6e.GestureDescription("B");d8e.addCurl(K6e,t8e,1),d8e.addDirection(X6e,o8e,.7),d8e.addDirection(X6e,s8e,.7),d8e.addCurl(X6e,Z6e,1),d8e.addDirection(X6e,r8e,.7),d8e.addCurl(Y6e,Z6e,1),d8e.addDirection(Y6e,r8e,.7),d8e.addCurl(Q6e,Z6e,1),d8e.addDirection(Q6e,r8e,.7),d8e.addCurl(J6e,Z6e,1),d8e.addDirection(J6e,r8e,.7);const h8e=new q6e.GestureDescription("C");h8e.addCurl(K6e,Z6e,1),h8e.addDirection(X6e,s8e,.7),h8e.addCurl(X6e,Z6e,1),h8e.addDirection(X6e,s8e,.7),h8e.addCurl(Y6e,t8e,1),h8e.addDirection(Y6e,s8e,.7),h8e.addCurl(Q6e,t8e,1),h8e.addDirection(Q6e,s8e,.7),h8e.addCurl(J6e,t8e,1),h8e.addDirection(J6e,s8e,.7);const p8e=new q6e.GestureDescription("D");p8e.addCurl(K6e,t8e,1),p8e.addDirection(X6e,r8e,.7),p8e.addCurl(X6e,Z6e,1),p8e.addDirection(X6e,r8e,.7),p8e.addCurl(Y6e,e8e,1),p8e.addDirection(Y6e,r8e,.7),p8e.addCurl(Q6e,e8e,1),p8e.addDirection(Q6e,r8e,.7),p8e.addCurl(J6e,e8e,1),p8e.addDirection(J6e,r8e,.7);const f8e=new q6e.GestureDescription("E");f8e.addCurl(K6e,t8e,1),f8e.addDirection(X6e,r8e,.7),f8e.addCurl(X6e,e8e,1),f8e.addDirection(X6e,r8e,.7),f8e.addCurl(Y6e,e8e,1),f8e.addDirection(Y6e,r8e,.7),f8e.addCurl(Q6e,e8e,1),f8e.addDirection(Q6e,r8e,.7),f8e.addCurl(J6e,e8e,1),f8e.addDirection(J6e,r8e,.7);const m8e=new q6e.GestureDescription("F");m8e.addCurl(K6e,t8e,1),m8e.addDirection(X6e,s8e,.7),m8e.addCurl(X6e,e8e,1),m8e.addDirection(X6e,s8e,.7),m8e.addCurl(Y6e,Z6e,1),m8e.addDirection(Y6e,r8e,.7),m8e.addCurl(Q6e,Z6e,1),m8e.addDirection(Q6e,r8e,.7),m8e.addCurl(J6e,Z6e,1),m8e.addDirection(J6e,r8e,.7);const g8e=new q6e.GestureDescription("G");g8e.addCurl(K6e,Z6e,1),g8e.addDirection(X6e,s8e,.7),g8e.addCurl(X6e,Z6e,1),g8e.addDirection(X6e,l8e,.7),g8e.addCurl(Y6e,e8e,1),g8e.addDirection(Y6e,s8e,.7),g8e.addCurl(Q6e,e8e,1),g8e.addDirection(Q6e,l8e,.7),g8e.addCurl(J6e,e8e,1),g8e.addDirection(J6e,l8e,.7);const y8e=new q6e.GestureDescription("H");y8e.addCurl(K6e,Z6e,1),y8e.addDirection(X6e,l8e,.7),y8e.addCurl(X6e,Z6e,1),y8e.addDirection(X6e,l8e,.7),y8e.addCurl(Y6e,Z6e,1),y8e.addDirection(Y6e,l8e,.7),y8e.addCurl(Q6e,e8e,1),y8e.addDirection(Q6e,l8e,.7),y8e.addCurl(J6e,e8e,1),y8e.addDirection(J6e,l8e,.7);const b8e=new q6e.GestureDescription("I");b8e.addCurl(K6e,t8e,1),b8e.addDirection(X6e,o8e,.7),b8e.addCurl(X6e,e8e,1),b8e.addDirection(X6e,r8e,.7),b8e.addCurl(Y6e,e8e,1),b8e.addDirection(Y6e,r8e,.7),b8e.addCurl(Q6e,e8e,1),b8e.addDirection(Q6e,r8e,.7),b8e.addCurl(J6e,Z6e,1),b8e.addDirection(J6e,r8e,.7);const v8e=new q6e.GestureDescription("J");v8e.addCurl(K6e,Z6e,1),v8e.addDirection(X6e,s8e,.7),v8e.addCurl(X6e,e8e,1),v8e.addDirection(X6e,s8e,.7),v8e.addCurl(Y6e,e8e,1),v8e.addDirection(Y6e,s8e,.7),v8e.addCurl(Q6e,e8e,1),v8e.addDirection(Q6e,l8e,.7),v8e.addCurl(J6e,Z6e,1),v8e.addDirection(J6e,l8e,.7);const x8e=new q6e.GestureDescription("K");x8e.addCurl(K6e,Z6e,1),x8e.addDirection(X6e,o8e,.7),x8e.addCurl(X6e,Z6e,1),x8e.addDirection(X6e,s8e,.7),x8e.addCurl(Y6e,Z6e,1),x8e.addDirection(Y6e,r8e,.7),x8e.addCurl(Q6e,e8e,1),x8e.addDirection(Q6e,r8e,.7),x8e.addCurl(J6e,e8e,1),x8e.addDirection(J6e,r8e,.7);const w8e=new q6e.GestureDescription("L");w8e.addCurl(K6e,Z6e,1),w8e.addDirection(X6e,s8e,.7),w8e.addCurl(X6e,Z6e,1),w8e.addDirection(X6e,r8e,.7),w8e.addCurl(Y6e,e8e,1),w8e.addDirection(Y6e,r8e,.7),w8e.addCurl(Q6e,e8e,1),w8e.addDirection(Q6e,r8e,.7),w8e.addCurl(J6e,e8e,1),w8e.addDirection(J6e,r8e,.7);const k8e=new q6e.GestureDescription("M");k8e.addCurl(K6e,t8e,1),k8e.addDirection(X6e,o8e,.7),k8e.addCurl(X6e,e8e,1),k8e.addDirection(X6e,s8e,.7),k8e.addCurl(Y6e,e8e,1),k8e.addDirection(Y6e,r8e,.7),k8e.addCurl(Q6e,e8e,1),k8e.addDirection(Q6e,r8e,.7),k8e.addCurl(J6e,e8e,1),k8e.addDirection(J6e,r8e,.7);const S8e=new q6e.GestureDescription("N");S8e.addCurl(K6e,t8e,1),S8e.addDirection(X6e,o8e,.7),S8e.addCurl(X6e,e8e,1),S8e.addDirection(X6e,s8e,.7),S8e.addCurl(Y6e,e8e,1),S8e.addDirection(Y6e,r8e,.7),S8e.addCurl(Q6e,e8e,1),S8e.addDirection(Q6e,r8e,.7),S8e.addCurl(J6e,e8e,1),S8e.addDirection(J6e,o8e,.7);const I8e=new q6e.GestureDescription("O");I8e.addCurl(K6e,Z6e,1),I8e.addDirection(X6e,s8e,.7),I8e.addCurl(X6e,t8e,1),I8e.addDirection(X6e,s8e,.7),I8e.addCurl(Y6e,t8e,1),I8e.addDirection(Y6e,s8e,.7),I8e.addCurl(Q6e,e8e,1),I8e.addDirection(Q6e,s8e,.7),I8e.addCurl(J6e,e8e,1),I8e.addDirection(J6e,s8e,.7);const C8e=new q6e.GestureDescription("P");C8e.addCurl(K6e,Z6e,1),C8e.addDirection(X6e,l8e,.7),C8e.addCurl(X6e,Z6e,1),C8e.addDirection(X6e,l8e,.7),C8e.addCurl(Y6e,t8e,1),C8e.addDirection(Y6e,i8e,.7),C8e.addCurl(Q6e,e8e,1),C8e.addDirection(Q6e,i8e,.7),C8e.addCurl(J6e,e8e,1),C8e.addDirection(J6e,i8e,.7);const N8e=new q6e.GestureDescription("Q");N8e.addCurl(K6e,Z6e,1),N8e.addDirection(X6e,i8e,.7),N8e.addCurl(X6e,t8e,1),N8e.addDirection(X6e,l8e,.7),N8e.addCurl(Y6e,e8e,1),N8e.addDirection(Y6e,l8e,.7),N8e.addCurl(Q6e,e8e,1),N8e.addDirection(Q6e,i8e,.7),N8e.addCurl(J6e,e8e,1),N8e.addDirection(J6e,i8e,.7);const T8e=new q6e.GestureDescription("R");T8e.addCurl(K6e,t8e,1),T8e.addDirection(X6e,o8e,.7),T8e.addCurl(X6e,Z6e,1),T8e.addDirection(X6e,r8e,.7),T8e.addCurl(Y6e,Z6e,1),T8e.addDirection(Y6e,r8e,.7),T8e.addCurl(Q6e,e8e,1),T8e.addDirection(Q6e,r8e,.7),T8e.addCurl(J6e,e8e,1),T8e.addDirection(J6e,r8e,.7);const E8e=new q6e.GestureDescription("S");E8e.addCurl(K6e,t8e,1),E8e.addDirection(X6e,r8e,.7),E8e.addCurl(X6e,e8e,1),E8e.addDirection(X6e,s8e,.7),E8e.addCurl(Y6e,e8e,1),E8e.addDirection(Y6e,r8e,.7),E8e.addCurl(Q6e,e8e,1),E8e.addDirection(Q6e,r8e,.7),E8e.addCurl(J6e,e8e,1),E8e.addDirection(J6e,o8e,.7);const A8e=new q6e.GestureDescription("T");A8e.addCurl(K6e,Z6e,1),A8e.addDirection(X6e,r8e,.7),A8e.addCurl(X6e,e8e,1),A8e.addDirection(X6e,s8e,.7),A8e.addCurl(Y6e,e8e,1),A8e.addDirection(Y6e,r8e,.7),A8e.addCurl(Q6e,e8e,1),A8e.addDirection(Q6e,r8e,.7),A8e.addCurl(J6e,e8e,1),A8e.addDirection(J6e,o8e,.7);const _8e=new q6e.GestureDescription("U");_8e.addCurl(K6e,t8e,1),_8e.addDirection(X6e,o8e,.7),_8e.addCurl(X6e,Z6e,1),_8e.addDirection(X6e,r8e,.7),_8e.addCurl(Y6e,Z6e,1),_8e.addDirection(Y6e,r8e,.7),_8e.addCurl(Q6e,e8e,1),_8e.addDirection(Q6e,r8e,.7),_8e.addCurl(J6e,e8e,1),_8e.addDirection(J6e,o8e,.7);const $8e=new q6e.GestureDescription("V");$8e.addCurl(K6e,t8e,1),$8e.addDirection(X6e,o8e,.7),$8e.addCurl(X6e,Z6e,1),$8e.addDirection(X6e,s8e,.7),$8e.addCurl(Y6e,Z6e,1),$8e.addDirection(Y6e,r8e,.7),$8e.addCurl(Q6e,e8e,1),$8e.addDirection(Q6e,r8e,.7),$8e.addCurl(J6e,e8e,1),$8e.addDirection(J6e,o8e,.7);const R8e=new q6e.GestureDescription("W");R8e.addCurl(K6e,t8e,1),R8e.addDirection(X6e,o8e,.7),R8e.addCurl(X6e,Z6e,1),R8e.addDirection(X6e,s8e,.7),R8e.addCurl(Y6e,Z6e,1),R8e.addDirection(Y6e,r8e,.7),R8e.addCurl(Q6e,Z6e,1),R8e.addDirection(Q6e,o8e,.7),R8e.addCurl(J6e,e8e,1),R8e.addDirection(J6e,o8e,.7);const D8e=new q6e.GestureDescription("X");D8e.addCurl(K6e,t8e,1),D8e.addDirection(X6e,r8e,.7),D8e.addCurl(X6e,t8e,1),D8e.addDirection(X6e,r8e,.7),D8e.addCurl(Y6e,e8e,1),D8e.addDirection(Y6e,r8e,.7),D8e.addCurl(Q6e,e8e,1),D8e.addDirection(Q6e,r8e,.7),D8e.addCurl(J6e,e8e,1),D8e.addDirection(J6e,r8e,.7);const M8e=new q6e.GestureDescription("Y");M8e.addCurl(K6e,Z6e,1),M8e.addDirection(X6e,s8e,.7),M8e.addCurl(X6e,e8e,1),M8e.addDirection(X6e,r8e,.7),M8e.addCurl(Y6e,e8e,1),M8e.addDirection(Y6e,r8e,.7),M8e.addCurl(Q6e,Z6e,1),M8e.addDirection(Q6e,r8e,.7),M8e.addCurl(J6e,Z6e,1),M8e.addDirection(J6e,o8e,.7);const F8e=new q6e.GestureDescription("Z");F8e.addCurl(K6e,Z6e,.8),F8e.addDirection(X6e,u8e,.7),F8e.addCurl(X6e,Z6e,1),F8e.addDirection(X6e,o8e,.7),F8e.addCurl(Y6e,e8e,1),F8e.addDirection(Y6e,u8e,.7),F8e.addCurl(Q6e,e8e,1),F8e.addDirection(Q6e,u8e,.7),F8e.addCurl(J6e,e8e,1),F8e.addDirection(J6e,u8e,.7);const O8e={a_ASL:c8e,b_ASL:d8e,c_ASL:h8e,d_ASL:p8e,e_ASL:f8e,f_ASL:m8e,g_ASL:g8e,h_ASL:y8e,i_ASL:b8e,j_ASL:v8e,k_ASL:x8e,l_ASL:w8e,m_ASL:k8e,n_ASL:S8e,o_ASL:I8e,p_ASL:C8e,q_ASL:N8e,r_ASL:T8e,s_ASL:E8e,t_ASL:A8e,u_ASL:_8e,v_ASL:$8e,w_ASL:R8e,x_ASL:D8e,y_ASL:M8e,z_ASL:F8e};var P8e=n(1136);const L8e=T.createContext();function z8e(e){return(0,yr.Ay)("MuiGrid",e)}const B8e=["auto",!0,1,2,3,4,5,6,7,8,9,10,11,12],W8e=(0,gr.A)("MuiGrid",["root","container","item","zeroMinWidth",...[0,1,2,3,4,5,6,7,8,9,10].map((e=>`spacing-xs-${e}`)),...["column-reverse","column","row-reverse","row"].map((e=>`direction-xs-${e}`)),...["nowrap","wrap-reverse","wrap"].map((e=>`wrap-xs-${e}`)),...B8e.map((e=>`grid-xs-${e}`)),...B8e.map((e=>`grid-sm-${e}`)),...B8e.map((e=>`grid-md-${e}`)),...B8e.map((e=>`grid-lg-${e}`)),...B8e.map((e=>`grid-xl-${e}`))]);function V8e(e){let{breakpoints:t,values:n}=e,r="";Object.keys(n).forEach((e=>{""===r&&0!==n[e]&&(r=e)}));const a=Object.keys(t).sort(((e,n)=>t[e]-t[n]));return a.slice(0,a.indexOf(r))}const U8e=(0,Gn.Ay)("div",{name:"MuiGrid",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e,{container:r,direction:a,item:s,spacing:i,wrap:o,zeroMinWidth:l,breakpoints:u}=n;let c=[];r&&(c=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!e||e<=0)return[];if("string"===typeof e&&!Number.isNaN(Number(e))||"number"===typeof e)return[n[`spacing-xs-${String(e)}`]];const r=[];return t.forEach((t=>{const a=e[t];Number(a)>0&&r.push(n[`spacing-${t}-${String(a)}`])})),r}(i,u,t));const d=[];return u.forEach((e=>{const r=n[e];r&&d.push(t[`grid-${e}-${String(r)}`])})),[t.root,r&&t.container,s&&t.item,l&&t.zeroMinWidth,...c,"row"!==a&&t[`direction-xs-${String(a)}`],"wrap"!==o&&t[`wrap-xs-${String(o)}`],...d]}})((e=>{let{ownerState:t}=e;return{boxSizing:"border-box",...t.container&&{display:"flex",flexWrap:"wrap",width:"100%"},...t.item&&{margin:0},...t.zeroMinWidth&&{minWidth:0},..."wrap"!==t.wrap&&{flexWrap:t.wrap}}}),(function(e){let{theme:t,ownerState:n}=e;const r=(0,P8e.kW)({values:n.direction,breakpoints:t.breakpoints.values});return(0,P8e.NI)({theme:t},r,(e=>{const t={flexDirection:e};return e.startsWith("column")&&(t[`& > .${W8e.item}`]={maxWidth:"none"}),t}))}),(function(e){let{theme:t,ownerState:n}=e;const{container:r,rowSpacing:a}=n;let s={};if(r&&0!==a){const e=(0,P8e.kW)({values:a,breakpoints:t.breakpoints.values});let n;"object"===typeof e&&(n=V8e({breakpoints:t.breakpoints.values,values:e})),s=(0,P8e.NI)({theme:t},e,((e,r)=>{const a=t.spacing(e);return"0px"!==a?{marginTop:t.spacing(-e),[`& > .${W8e.item}`]:{paddingTop:a}}:n?.includes(r)?{}:{marginTop:0,[`& > .${W8e.item}`]:{paddingTop:0}}}))}return s}),(function(e){let{theme:t,ownerState:n}=e;const{container:r,columnSpacing:a}=n;let s={};if(r&&0!==a){const e=(0,P8e.kW)({values:a,breakpoints:t.breakpoints.values});let n;"object"===typeof e&&(n=V8e({breakpoints:t.breakpoints.values,values:e})),s=(0,P8e.NI)({theme:t},e,((e,r)=>{const a=t.spacing(e);if("0px"!==a){return{width:`calc(100% + ${a})`,marginLeft:t.spacing(-e),[`& > .${W8e.item}`]:{paddingLeft:a}}}return n?.includes(r)?{}:{width:"100%",marginLeft:0,[`& > .${W8e.item}`]:{paddingLeft:0}}}))}return s}),(function(e){let t,{theme:n,ownerState:r}=e;return n.breakpoints.keys.reduce(((e,a)=>{let s={};if(r[a]&&(t=r[a]),!t)return e;if(!0===t)s={flexBasis:0,flexGrow:1,maxWidth:"100%"};else if("auto"===t)s={flexBasis:"auto",flexGrow:0,flexShrink:0,maxWidth:"none",width:"auto"};else{const i=(0,P8e.kW)({values:r.columns,breakpoints:n.breakpoints.values}),o="object"===typeof i?i[a]:i;if(void 0===o||null===o)return e;const l=Math.round(t/o*1e8)/1e6+"%";let u={};if(r.container&&r.item&&0!==r.columnSpacing){const e=n.spacing(r.columnSpacing);if("0px"!==e){const t=`calc(${l} + ${e})`;u={flexBasis:t,maxWidth:t}}}s={flexBasis:l,flexGrow:0,maxWidth:l,...u}}return 0===n.breakpoints.values[a]?Object.assign(e,s):e[n.breakpoints.up(a)]=s,e}),{})}));const j8e=e=>{const{classes:t,container:n,direction:r,item:a,spacing:s,wrap:i,zeroMinWidth:o,breakpoints:l}=e;let u=[];n&&(u=function(e,t){if(!e||e<=0)return[];if("string"===typeof e&&!Number.isNaN(Number(e))||"number"===typeof e)return[`spacing-xs-${String(e)}`];const n=[];return t.forEach((t=>{const r=e[t];if(Number(r)>0){const e=`spacing-${t}-${String(r)}`;n.push(e)}})),n}(s,l));const c=[];l.forEach((t=>{const n=e[t];n&&c.push(`grid-${t}-${String(n)}`)}));const d={root:["root",n&&"container",a&&"item",o&&"zeroMinWidth",...u,"row"!==r&&`direction-xs-${String(r)}`,"wrap"!==i&&`wrap-xs-${String(i)}`,...c]};return(0,Vn.A)(d,z8e,t)},G8e=T.forwardRef((function(e,t){const n=So({props:e,name:"MuiGrid"}),{breakpoints:r}=Zn(),a=sr(n),{className:s,columns:i,columnSpacing:o,component:l="div",container:u=!1,direction:c="row",item:d=!1,rowSpacing:h,spacing:p=0,wrap:f="wrap",zeroMinWidth:m=!1,...g}=a,y=h||p,b=o||p,v=T.useContext(L8e),x=u?i||12:v,w={},k={...g};r.keys.forEach((e=>{null!=g[e]&&(w[e]=g[e],delete k[e])}));const S={...a,columns:x,container:u,direction:c,item:d,rowSpacing:y,columnSpacing:b,wrap:f,zeroMinWidth:m,spacing:p,...w,breakpoints:r.keys},I=j8e(S);return(0,hr.jsx)(L8e.Provider,{value:x,children:(0,hr.jsx)(U8e,{ownerState:S,className:(0,Bn.A)(I.root,s),as:l,ref:t,...k})})}));const H8e=G8e,q8e="ABCDEFGHIJKLMNOPQRSTUVWXYZ";var K8e;K8e="webgl",QIe.setBackend(K8e);const X8e=(()=>{const e=Math.floor(26*Math.random());return q8e[e]})(),Y8e=e=>{let{userData:t,userId:n}=e;const r=ee(),a=(0,T.useRef)(null),s=(0,T.useRef)(null),[i,o]=(0,T.useState)("block"),[l,u]=(0,T.useState)(!1),[c,d]=(0,T.useState)(60),h=(0,T.useRef)(null),p=vn(),f=`<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; color: #333333;">\n  <h1 style="color: #0066cc; text-align: center;">Authentication Instructions</h1>\n  <p style="font-size: 16px; line-height: 1.5;">Dear User,</p>\n  <p style="font-size: 16px; line-height: 1.5;">To authenticate yourself, please follow these steps:</p>\n  <ol style="font-size: 16px; line-height: 1.5;">\n    <li>Position yourself in front of your camera.</li>\n    <li>Ensure your background is clear and no other person is in the frame.</li>\n    <li>Make the hand sign for the letter ${X8e} in American Sign Language, as shown in the image below.</li>\n    <li>Make sure both your face and hand sign are clearly visible in the camera frame.</li>\n  </ol>\n  <h2 style="color: #0066cc; text-align: center;">Hand Sign for Letter ${X8e}</h2>\n  <img src=${`https://firebasestorage.googleapis.com/v0/b/auth-tfjs.appspot.com/o/HandSign%20Image%2F${X8e}.jpg?alt=media&token=d891e715-d5ab-49ee-8c4c-d14c25d7fb7a`} alt="Hand sign for letter ${X8e} in American Sign Language" style="display: block; max-width: 100%; height: auto; margin: 20px auto; border: 2px solid #0066cc;">\n  <p style="font-size: 16px; line-height: 1.5; font-weight: bold;">Important Notes:</p>\n  <ul style="font-size: 16px; line-height: 1.5;">\n    <li>Ensure good lighting for clear visibility.</li>\n    <li>Hold the hand sign steady for a few seconds.</li>\n    <li>If you have any difficulties, please contact our support team.</li>\n  </ul>\n  <p style="font-size: 16px; line-height: 1.5;">Thank you for your cooperation in maintaining the security of your account.</p>\n  <p style="font-size: 16px; line-height: 1.5;">Best regards,<br>Your Authentication Team</p>\n</div>`,m=()=>{d(60),h.current=setInterval((()=>{d((e=>e<=1?(clearInterval(h.current),r(wt()),p("/authenticated?username=invalid"),0):e-1))}),1e3)},g=async()=>{await(async(e,t,n,r)=>{try{await dv(Ab(mv,"mail"),{to:[e],message:{subject:`Instructions: You have to draw ${n} in American Sign Language`,html:t}}),console.log("Image uploaded and email sent successfully"),r()}catch(a){console.error("Error uploading image or sending email: ",a)}})(t.email,f,X8e,m);const e=await function(e){var t=void 0===e?{}:e,n=t.maxContinuousChecks,r=void 0===n?1/0:n,a=t.detectionConfidence,s=void 0===a?.8:a,i=t.iouThreshold,o=void 0===i?.3:i,l=t.scoreThreshold,u=void 0===l?.5:l;return k6e(this,void 0,void 0,(function(){var e,t,n,a,i,l;return S6e(this,(function(c){switch(c.label){case 0:return[4,Promise.all([j6e(),V6e(),U6e()])];case 1:return e=c.sent(),t=e[0],n=e[1],a=e[2],i=new _6e(n,256,256,t,o,u),l=new W6e(i,a,256,256,r,s),[2,new G6e(l)]}}))}))}();h.current=setInterval((()=>{y(e,X8e)}),170)},y=async(e,i)=>{const{current:c}=a,{video:d}=c||{};if(l||!d||4!==d.readyState)return;const f=d.videoWidth,m=d.videoHeight;c.video.width=f,c.video.height=m,s.current.width=f,s.current.height=m;const g=await e.estimateHands(d),y=await Xbe(d,new kbe).withFaceLandmarks().withFaceDescriptors();if(g.length>0){var b;const e="ABCDEFGHIJKLMNOPQRSTUVWXYZ".toLowerCase().split("").map((e=>O8e[`${e}_ASL`])),a=new q6e.GestureEstimator([q6e.Gestures.ThumbsUpGesture,...e]),s=await a.estimate(g[0].landmarks,6.5);if((null===(b=s.gestures.reduce(((e,t)=>t.score>e.score?t:e),s.gestures[0]))||void 0===b?void 0:b.name)===i){clearInterval(h.current),h.current=null,u(!0),o("none");const e=await(async(e,t,n,r)=>{const a=document.createElement("canvas");a.width=e,a.height=t,a.getContext("2d").drawImage(n,0,0,e,t);const s=a.toDataURL("image/png"),i=new Image;return i.src=s,new Promise((e=>{i.onload=async()=>{const t=[...Array(5)].map(((e,t)=>new Cge(r.name,[new Float32Array(r.descriptors[t])])));let n=!1;const a=new Ybe(t);(await Xbe(i,new kbe).withFaceLandmarks().withFaceDescriptors()).forEach((e=>{const{descriptor:t}=e,s=a.findBestMatch(t);n=!!s.label&&r.name})),e(n)}}))})(f,m,d,t);return e?(r(xt({name:t.name,email:t.email,dateOfBirth:t.DOB,userId:n})),p(`/authenticated?username=${e}`)):p("/authenticated?username=invalid")}}if(y.length>0){s.current.innerHTML=Kge(d);const e={width:f,height:m};!function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{width:r,height:a}=n?Hge(t):t;e.width=r,e.height=a}(s.current,e);const t=Qbe(y,e);s&&s.current&&Xme.drawDetections(s.current,t);new Xme.DrawBox(y[0].detection.box,{label:"Face Detected"}).draw(s.current)}const v=s.current.getContext("2d");((e,t)=>{e.length>0&&e.forEach((e=>{const n=e.landmarks;Object.keys(H6e).forEach((e=>{const r=H6e[e];r.slice(0,-1).forEach(((e,a)=>{const s=r[a],i=r[a+1];t.beginPath(),t.moveTo(n[s][0],n[s][1]),t.lineTo(n[i][0],n[i][1]),t.strokeStyle="#FF4500",t.lineWidth=2,t.stroke()}))})),n.forEach((e=>{let[n,r]=e;t.beginPath(),t.arc(n,r,5,0,3*Math.PI),t.fillStyle="#32CD32",t.fill()}))}))})(g,v),v.clearRect(0,0,s.width,s.height)};return(0,T.useEffect)((()=>((async()=>{try{g()}catch(e){console.error("Error during model loading or inference:",e)}})(),()=>clearInterval(h.current))),[]),(0,hr.jsx)(Br,{padding:1,sx:{display:"flex",alignItems:"center",justifyContent:"center",height:"100dvh"},children:(0,hr.jsxs)(H8e,{container:!0,spacing:2,alignItems:"center",justifyContent:"center",children:[(0,hr.jsxs)(H8e,{item:!0,xs:12,md:9,lg:8,children:[(0,hr.jsx)(Br,{display:"flex",justifyContent:"center",position:"relative",sx:{width:"100%"},children:(0,hr.jsxs)(Br,{sx:{position:"relative",width:"100%",maxWidth:"600px"},children:[(0,hr.jsx)(cT(),{id:"webcam",ref:a,style:{width:"100%",height:"auto",borderRadius:"10px",objectFit:"cover"}}),(0,hr.jsx)("canvas",{id:"gesture-canvas",ref:s,style:{display:i,position:"absolute",top:0,left:0,width:"100%",height:"100%",borderRadius:"10px"}})]})}),(0,hr.jsxs)(Ir,{variant:"h5",align:"center",sx:{marginTop:2},children:["Time Remaining: ",c," seconds"]})]}),(0,hr.jsx)(H8e,{item:!0,xs:12,md:3,lg:2,children:(0,hr.jsx)(Br,{display:"flex",flexDirection:"column",justifyContent:"flex-start",children:(0,hr.jsxs)(Gr,{elevation:3,sx:{padding:"20px",marginBottom:"20px"},children:[(0,hr.jsx)(Ir,{variant:"h6",align:"center",children:"Kindly Check your email for Instructions on performing Hand Signs"}),(0,hr.jsx)(Ir,{variant:"body1",align:"center",sx:{marginTop:"10px"},children:"Ensure your background is clear and no other person is present in the frame."})]})})})]})})},Q8e=()=>{const[e,t]=(0,T.useState)(""),[n,r]=(0,T.useState)(null),[a,s]=(0,T.useState)(""),[i,o]=(0,T.useState)(!1),[l,u]=(0,T.useState)(!1),[c,d]=(0,T.useState)(!1),h=()=>{u(!1)};return c?(0,hr.jsx)(Y8e,{userData:n,userId:e}):(0,hr.jsxs)(Bl,{maxWidth:"sm",sx:{mt:10},children:[(0,hr.jsxs)(Br,{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",sx:{padding:4,boxShadow:"0px 0px 20px rgba(0, 0, 0, 0.1)",borderRadius:3,backgroundColor:"#ffffff",transition:"box-shadow 0.3s ease","&:hover":{boxShadow:"0px 0px 30px rgba(0, 0, 0, 0.15)"}},children:[(0,hr.jsx)(Ir,{variant:"h4",gutterBottom:!0,sx:{color:"#1976d2",fontWeight:"bold"},children:"Enter Your User ID"}),(0,hr.jsx)(Mo,{label:"User ID",variant:"outlined",fullWidth:!0,error:!!a,helperText:a,value:e,onChange:e=>t(e.target.value),sx:{marginBottom:3}}),(0,hr.jsx)(hl,{variant:"contained",color:"primary",onClick:async()=>{if(!e)return void s("User ID is required.");if(/^[a-zA-Z0-9]+$/.test(e)){s(""),o(!0);try{const n=await gv(e);if(console.log("userDocSnap",n.data()),void 0!==n.data()){var t;const e=null!==(t=n.data())&&void 0!==t?t:{},a=((e,t)=>Ave().AES.decrypt(e,t.name+t.DOB).toString(Ave().enc.Utf8))(e.email,e),s=(e=>Object.keys(e).filter((e=>e.startsWith("descriptors_"))).map((t=>JSON.parse(Ave().AES.decrypt(e[t],e.name+e.DOB).toString(Ave().enc.Utf8)))))(e);r({...e,email:a,descriptors:s}),setTimeout((()=>{d(!0)}),1500)}else s("No such User ID exists.")}catch(a){s("Something went wrong! Please try again.")}finally{u(!0),o(!1)}}else s("User ID must be alphanumeric.")},sx:{backgroundColor:"#1976d2","&:hover":{backgroundColor:"#1565c0"},width:"100%",padding:"10px 0",fontSize:"16px",display:"flex",alignItems:"center",justifyContent:"center"},disabled:i,children:i?(0,hr.jsx)(uve,{size:24}):"Submit"})]}),(0,hr.jsx)(Tve,{open:l,autoHideDuration:3e3,onClose:h,anchorOrigin:{vertical:"top",horizontal:"right"},children:(0,hr.jsx)(_l,{onClose:h,severity:a.length?"error":"success",sx:{width:"100%"},children:a.length?a:"You are successfully Logged In!"})})]})};function J8e(){return(0,T.useEffect)((()=>{(async()=>{await(async()=>{try{await Promise.all([Abe.ssdMobilenetv1.loadFromUri("/models"),Abe.tinyFaceDetector.loadFromUri("/models"),Abe.faceLandmark68Net.loadFromUri("/models"),Abe.faceRecognitionNet.loadFromUri("/models")]),console.log("Face Models are loaded!!!")}catch(e){console.error("Error loading models:",e)}})()})()}),[]),(0,hr.jsx)(Pn,{children:(0,hr.jsxs)(Mn,{children:[(0,hr.jsx)(Rn,{path:"/",element:(0,hr.jsx)(Rve,{})}),(0,hr.jsx)(Rn,{path:"/login",element:(0,hr.jsx)(Q8e,{})}),(0,hr.jsx)(Rn,{path:"/loggedUser",element:(0,hr.jsx)(Rl,{})}),(0,hr.jsx)(Rn,{path:"/authenticated",element:(0,hr.jsx)(bv,{})})]})})}A.render((0,hr.jsx)(Y,{store:St,children:(0,hr.jsx)(J8e,{})}),document.getElementById("root"))})()})();
//# sourceMappingURL=main.779bc6c7.js.map